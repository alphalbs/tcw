{"version":3,"file":"public/javascripts/vendor.js.map","sources":["public/javascripts/vendor.js","bower_components/jquery/jquery.js","bower_components/lodash/dist/lodash.compat.js","bower_components/backbone/backbone.js","bower_components/chaplin/chaplin.js","bower_components/console-polyfill/index.js","bower_components/phaser/phaser.js"],"names":[],"mappings":"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","sourcesContent":["","/*!\n * jQuery JavaScript Library v2.0.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:30Z\n */\n(function( window, undefined ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\"use strict\";\nvar\n\t// A central reference to the root jQuery(document)\n\trootjQuery,\n\n\t// The deferred used on DOM ready\n\treadyList,\n\n\t// Support: IE9\n\t// For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n\tcore_strundefined = typeof undefined,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tlocation = window.location,\n\tdocument = window.document,\n\tdocElem = document.documentElement,\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$,\n\n\t// [[Class]] -> type pairs\n\tclass2type = {},\n\n\t// List of deleted data cache ids, so we can reuse them\n\tcore_deletedIds = [],\n\n\tcore_version = \"2.0.3\",\n\n\t// Save a reference to some core methods\n\tcore_concat = core_deletedIds.concat,\n\tcore_push = core_deletedIds.push,\n\tcore_slice = core_deletedIds.slice,\n\tcore_indexOf = core_deletedIds.indexOf,\n\tcore_toString = class2type.toString,\n\tcore_hasOwn = class2type.hasOwnProperty,\n\tcore_trim = core_version.trim,\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\treturn new jQuery.fn.init( selector, context, rootjQuery );\n\t},\n\n\t// Used for matching numbers\n\tcore_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\n\t// Used for splitting on whitespace\n\tcore_rnotwhite = /\\S+/g,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\t// Match a standalone tag\n\trsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t},\n\n\t// The ready event handler and self cleanup method\n\tcompleted = function() {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\twindow.removeEventListener( \"load\", completed, false );\n\t\tjQuery.ready();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: core_version,\n\n\tconstructor: jQuery,\n\tinit: function( selector, context, rootjQuery ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn rootjQuery.ready( selector );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t},\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn core_slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num == null ?\n\n\t\t\t// Return a 'clean' array\n\t\t\tthis.toArray() :\n\n\t\t\t// Return just the object\n\t\t\t( num < 0 ? this[ this.length + num ] : this[ num ] );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tready: function( fn ) {\n\t\t// Add the callback\n\t\tjQuery.ready.promise().done( fn );\n\n\t\treturn this;\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( core_slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: core_push,\n\tsort: [].sort,\n\tsplice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\tnoConflict: function( deep ) {\n\t\tif ( window.$ === jQuery ) {\n\t\t\twindow.$ = _$;\n\t\t}\n\n\t\tif ( deep && window.jQuery === jQuery ) {\n\t\t\twindow.jQuery = _jQuery;\n\t\t}\n\n\t\treturn jQuery;\n\t},\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.trigger ) {\n\t\t\tjQuery( document ).trigger(\"ready\").off(\"ready\");\n\t\t}\n\t},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\treturn !isNaN( parseFloat(obj) ) && isFinite( obj );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn String( obj );\n\t\t}\n\t\t// Support: Safari <= 5.1 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ core_toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: Firefox <20\n\t\t// The try/catch suppresses exceptions thrown when attempting to access\n\t\t// the \"constructor\" property of certain host objects, ie. |window.location|\n\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n\t\ttry {\n\t\t\tif ( obj.constructor &&\n\t\t\t\t\t!core_hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\t// data: string of html\n\t// context (optional): If specified, the fragment will be created in this context, defaults to document\n\t// keepScripts (optional): If true, will include scripts passed in the html string\n\tparseHTML: function( data, context, keepScripts ) {\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( typeof context === \"boolean\" ) {\n\t\t\tkeepScripts = context;\n\t\t\tcontext = false;\n\t\t}\n\t\tcontext = context || document;\n\n\t\tvar parsed = rsingleTag.exec( data ),\n\t\t\tscripts = !keepScripts && [];\n\n\t\t// Single tag\n\t\tif ( parsed ) {\n\t\t\treturn [ context.createElement( parsed[1] ) ];\n\t\t}\n\n\t\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\t\tif ( scripts ) {\n\t\t\tjQuery( scripts ).remove();\n\t\t}\n\n\t\treturn jQuery.merge( [], parsed.childNodes );\n\t},\n\n\tparseJSON: JSON.parse,\n\n\t// Cross-browser xml parsing\n\tparseXML: function( data ) {\n\t\tvar xml, tmp;\n\t\tif ( !data || typeof data !== \"string\" ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Support: IE9\n\t\ttry {\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data , \"text/xml\" );\n\t\t} catch ( e ) {\n\t\t\txml = undefined;\n\t\t}\n\n\t\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\t\tjQuery.error( \"Invalid XML: \" + data );\n\t\t}\n\t\treturn xml;\n\t},\n\n\tnoop: function() {},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\ttrim: function( text ) {\n\t\treturn text == null ? \"\" : core_trim.call( text );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcore_push.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : core_indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar l = second.length,\n\t\t\ti = first.length,\n\t\t\tj = 0;\n\n\t\tif ( typeof l === \"number\" ) {\n\t\t\tfor ( ; j < l; j++ ) {\n\t\t\t\tfirst[ i++ ] = second[ j ];\n\t\t\t}\n\t\t} else {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, inv ) {\n\t\tvar retVal,\n\t\t\tret = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length;\n\t\tinv = !!inv;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tretVal = !!callback( elems[ i ], i );\n\t\t\tif ( inv !== retVal ) {\n\t\t\t\tret.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret[ ret.length ] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn core_concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = core_slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\t// Multifunctional method to get and set values of a collection\n\t// The value/s can optionally be executed if it's a function\n\taccess: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\t\tvar i = 0,\n\t\t\tlength = elems.length,\n\t\t\tbulk = key == null;\n\n\t\t// Sets many values\n\t\tif ( jQuery.type( key ) === \"object\" ) {\n\t\t\tchainable = true;\n\t\t\tfor ( i in key ) {\n\t\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t\t}\n\n\t\t// Sets one value\n\t\t} else if ( value !== undefined ) {\n\t\t\tchainable = true;\n\n\t\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\t\traw = true;\n\t\t\t}\n\n\t\t\tif ( bulk ) {\n\t\t\t\t// Bulk operations run against the entire set\n\t\t\t\tif ( raw ) {\n\t\t\t\t\tfn.call( elems, value );\n\t\t\t\t\tfn = null;\n\n\t\t\t\t// ...except when executing function values\n\t\t\t\t} else {\n\t\t\t\t\tbulk = fn;\n\t\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( fn ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chainable ?\n\t\t\telems :\n\n\t\t\t// Gets\n\t\t\tbulk ?\n\t\t\t\tfn.call( elems ) :\n\t\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n\t},\n\n\tnow: Date.now,\n\n\t// A method for quickly swapping in/out CSS properties to get correct calculations.\n\t// Note: this method belongs to the css module but it's needed here for the support module.\n\t// If support gets modularized, this method should be moved back to the css module.\n\tswap: function( elem, options, callback, args ) {\n\t\tvar ret, name,\n\t\t\told = {};\n\n\t\t// Remember the old values, and insert the new ones\n\t\tfor ( name in options ) {\n\t\t\told[ name ] = elem.style[ name ];\n\t\t\telem.style[ name ] = options[ name ];\n\t\t}\n\n\t\tret = callback.apply( elem, args || [] );\n\n\t\t// Revert the old values\n\t\tfor ( name in options ) {\n\t\t\telem.style[ name ] = old[ name ];\n\t\t}\n\n\t\treturn ret;\n\t}\n});\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || type !== \"function\" &&\n\t\t( length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n/*!\n * Sizzle CSS Selector Engine v1.9.4-pre\n * http://sizzlejs.com/\n *\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-06-03\n */\n(function( window, undefined ) {\n\nvar i,\n\tsupport,\n\tcachedruns,\n\tExpr,\n\tgetText,\n\tisXML,\n\tcompile,\n\toutermostContext,\n\tsortInput,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + -(new Date()),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\thasDuplicate = false,\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tstrundefined = typeof undefined,\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf if we can't use a native one\n\tindexOf = arr.indexOf || function( elem ) {\n\t\tvar i = 0,\n\t\t\tlen = this.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( this[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n\t\t\"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n\t// Prefer arguments quoted,\n\t//   then not containing pseudos/brackets,\n\t//   then attribute selectors/non-parenthetical expressions,\n\t//   then anything else\n\t// These preferences are here to reduce the number of selectors\n\t//   needing tokenize in the PSEUDO preFilter\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trsibling = new RegExp( whitespace + \"*[+~]\" ),\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\t// BMP codepoint\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\n\tif ( !selector || typeof selector !== \"string\" ) {\n\t\treturn results;\n\t}\n\n\tif ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n\t\treturn [];\n\t}\n\n\tif ( documentIsHTML && !seed ) {\n\n\t\t// Shortcuts\n\t\tif ( (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType === 9 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && context.parentNode || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key += \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect xml\n * @param {Element|Object} elem An element or a document\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar doc = node ? node.ownerDocument || node : preferredDoc,\n\t\tparent = doc.defaultView;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\n\t// Support tests\n\tdocumentIsHTML = !isXML( doc );\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent.attachEvent && parent !== parent.top ) {\n\t\tparent.attachEvent( \"onbeforeunload\", function() {\n\t\t\tsetDocument();\n\t\t});\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Check if getElementsByClassName can be trusted\n\tsupport.getElementsByClassName = assert(function( div ) {\n\t\tdiv.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n\t\t// Support: Safari<4\n\t\t// Catch class over-caching\n\t\tdiv.firstChild.className = \"i\";\n\t\t// Support: Opera<10\n\t\t// Catch gEBCN failure to find non-leading classes\n\t\treturn div.getElementsByClassName(\"i\").length === 2;\n\t});\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [m] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== strundefined ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\t\t\t}\n\t\t} :\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdiv.innerHTML = \"<select><option selected=''></option></select>\";\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\n\t\t\t// Support: Opera 10-12/IE8\n\t\t\t// ^= $= *= and empty values\n\t\t\t// Should not select anything\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type attribute is restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"t\", \"\" );\n\n\t\t\tif ( div.querySelectorAll(\"[t^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = docElem.compareDocumentPosition ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );\n\n\t\tif ( compare ) {\n\t\t\t// Disconnected nodes\n\t\t\tif ( compare & 1 ||\n\t\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif ( a === doc || contains(preferredDoc, a) ) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif ( b === doc || contains(preferredDoc, b) ) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\n\t\t\t\t// Maintain original order\n\t\t\t\treturn sortInput ?\n\t\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t\t0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t}\n\n\t\t// Not directly comparable, sort on existence of method\n\t\treturn a.compareDocumentPosition ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\t} else if ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch(e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val === undefined ?\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull :\n\t\tval;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\tfor ( ; (node = elem[i]); i++ ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (see #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[5] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] && match[4] !== undefined ) {\n\t\t\t\tmatch[2] = match[4];\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf.call( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n\t\t\t//   not comment, processing instructions, or others\n\t\t\t// Thanks to Diego Perini for the nodeName shortcut\n\t\t\t//   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\t// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n\t\t\t// use getAttribute instead to test this case\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\nfunction tokenize( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( tokens = [] );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar data, cache, outerCache,\n\t\t\t\tdirkey = dirruns + \" \" + doneName;\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n\t\t\t\t\t\t\tif ( (data = cache[1]) === true || data === cachedruns ) {\n\t\t\t\t\t\t\t\treturn data === true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcache = outerCache[ dir ] = [ dirkey ];\n\t\t\t\t\t\t\tcache[1] = matcher( elem, context, xml ) || cachedruns;\n\t\t\t\t\t\t\tif ( cache[1] === true ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf.call( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\treturn ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\t// A counter to specify which element is currently being matched\n\tvar matcherCachedRuns = 0,\n\t\tbySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, expandContext ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tsetMatched = [],\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\toutermost = expandContext != null,\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t\tcachedruns = matcherCachedRuns;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t\tcachedruns = ++matcherCachedRuns;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !group ) {\n\t\t\tgroup = tokenize( selector );\n\t\t}\n\t\ti = group.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( group[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\t}\n\treturn cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tmatch = tokenize( selector );\n\n\tif ( !seed ) {\n\t\t// Try to minimize operations if there is only one group\n\t\tif ( match.length === 1 ) {\n\n\t\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\t\ttokens = match[0] = match[0].slice( 0 );\n\t\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\t\tif ( !context ) {\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t\t}\n\n\t\t\t// Fetch a seed set for right-to-left matching\n\t\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\ttoken = tokens[i];\n\n\t\t\t\t// Abort if we hit a combinator\n\t\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif ( (seed = find(\n\t\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\t\trsibling.test( tokens[0].type ) && context.parentNode || context\n\t\t\t\t\t)) ) {\n\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\tcompile( selector, match )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector )\n\t);\n\treturn results;\n}\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn (val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\telem[ name ] === true ? name.toLowerCase() : null;\n\t\t}\n\t});\n}\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n})( window );\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\njQuery.support = (function( support ) {\n\tvar input = document.createElement(\"input\"),\n\t\tfragment = document.createDocumentFragment(),\n\t\tdiv = document.createElement(\"div\"),\n\t\tselect = document.createElement(\"select\"),\n\t\topt = select.appendChild( document.createElement(\"option\") );\n\n\t// Finish early in limited environments\n\tif ( !input.type ) {\n\t\treturn support;\n\t}\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Must access the parent to make an option select properly\n\t// Support: IE9, IE10\n\tsupport.optSelected = opt.selected;\n\n\t// Will be defined later\n\tsupport.reliableMarginRight = true;\n\tsupport.boxSizingReliable = true;\n\tsupport.pixelPosition = false;\n\n\t// Make sure checked status is properly cloned\n\t// Support: IE9, IE10\n\tinput.checked = true;\n\tsupport.noCloneChecked = input.cloneNode( true ).checked;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Check if an input maintains its value after becoming a radio\n\t// Support: IE9, IE10\n\tinput = document.createElement(\"input\");\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tinput.setAttribute( \"checked\", \"t\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tfragment.appendChild( input );\n\n\t// Support: Safari 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: Firefox, Chrome, Safari\n\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\tsupport.focusinBubbles = \"onfocusin\" in window;\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t// Run tests that need a body at doc ready\n\tjQuery(function() {\n\t\tvar container, marginDiv,\n\t\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\t\tdivReset = \"padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box\",\n\t\t\tbody = document.getElementsByTagName(\"body\")[ 0 ];\n\n\t\tif ( !body ) {\n\t\t\t// Return for frameset docs that don't have a body\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer = document.createElement(\"div\");\n\t\tcontainer.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\n\t\t// Check box-sizing and margin behavior.\n\t\tbody.appendChild( container ).appendChild( div );\n\t\tdiv.innerHTML = \"\";\n\t\t// Support: Firefox, Android 2.3 (Prefixed box-sizing versions).\n\t\tdiv.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%\";\n\n\t\t// Workaround failing boxSizing test due to offsetWidth returning wrong value\n\t\t// with some non-1 values of body zoom, ticket #13543\n\t\tjQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {\n\t\t\tsupport.boxSizing = div.offsetWidth === 4;\n\t\t});\n\n\t\t// Use window.getComputedStyle because jsdom on node.js will break without it.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tsupport.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tsupport.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tmarginDiv = div.appendChild( document.createElement(\"div\") );\n\t\t\tmarginDiv.style.cssText = div.style.cssText = divReset;\n\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\tsupport.reliableMarginRight =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n\t\t}\n\n\t\tbody.removeChild( container );\n\t});\n\n\treturn support;\n})( {} );\n\n/*\n\tImplementation Summary\n\n\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n\t2. Improve the module's maintainability by reducing the storage\n\t\tpaths to a single mechanism.\n\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n*/\nvar data_user, data_priv,\n\trbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction Data() {\n\t// Support: Android < 4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Math.random();\n}\n\nData.uid = 1;\n\nData.accepts = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType ?\n\t\towner.nodeType === 1 || owner.nodeType === 9 : true;\n};\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android < 4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( core_rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\n\n// These may be used throughout the jQuery core codebase\ndata_user = new Data();\ndata_priv = new Data();\n\n\njQuery.extend({\n\tacceptData: Data.accepts,\n\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar attrs, name,\n\t\t\telem = this[ 0 ],\n\t\t\ti = 0,\n\t\t\tdata = null;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\tattrs = elem.attributes;\n\t\t\t\t\tfor ( ; i < attrs.length; i++ ) {\n\t\t\t\t\t\tname = attrs[ i ].name;\n\n\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? JSON.parse( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\t// Based off of the plugin by Clint Helfers, with permission.\n\t// http://blindsignals.com/index.php/2009/07/jquery-delay/\n\tdelay: function( time, type ) {\n\t\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\t\ttype = type || \"fx\";\n\n\t\treturn this.queue( type, function( next, hooks ) {\n\t\t\tvar timeout = setTimeout( next, time );\n\t\t\thooks.stop = function() {\n\t\t\t\tclearTimeout( timeout );\n\t\t\t};\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar nodeHook, boolHook,\n\trclass = /[\\t\\r\\n\\f]/g,\n\trreturn = /\\r/g,\n\trfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t},\n\n\tprop: function( name, value ) {\n\t\treturn jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t},\n\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = jQuery.trim( cur );\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telem.className = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( core_rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === core_strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t},\n\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map(val, function ( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// attributes.value is undefined in Blackberry 4.7 but\n\t\t\t\t// uses .value. See #6932\n\t\t\t\tvar val = elem.attributes.value;\n\t\t\t\treturn !val || val.specified ? elem.value : elem.text;\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t},\n\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === core_strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( core_rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;\n\n\tjQuery.expr.attrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar fn = jQuery.expr.attrHandle[ name ],\n\t\t\tret = isXML ?\n\t\t\t\tundefined :\n\t\t\t\t/* jshint eqeqeq: false */\n\t\t\t\t// Temporarily disable this handler to check existence\n\t\t\t\t(jQuery.expr.attrHandle[ name ] = undefined) !=\n\t\t\t\t\tgetter( elem, name, isXML ) ?\n\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\n\t\t// Restore handler\n\t\tjQuery.expr.attrHandle[ name ] = fn;\n\n\t\treturn ret;\n\t};\n});\n\n// Support: IE9+\n// Selectedness for an option in an optgroup can be inaccurate\nif ( !jQuery.support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !jQuery.support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\nvar rkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = core_hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = core_slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome < 28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = ( src.defaultPrevented ||\n\t\t\tsrc.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Create \"bubbling\" focus and blur events\n// Support: Firefox, Chrome, Safari\nif ( !jQuery.support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler while someone wants focusin/focusout\n\t\tvar attaches = 0,\n\t\t\thandler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tif ( attaches++ === 0 ) {\n\t\t\t\t\tdocument.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tif ( --attaches === 0 ) {\n\t\t\t\t\tdocument.removeEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\nvar isSimple = /^.[^:#\\[\\.,]*$/,\n\trparentsprev = /^(?:parents|prev(?:Until|All))/,\n\trneedsContext = jQuery.expr.match.needsContext,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tret = [],\n\t\t\tself = this,\n\t\t\tlen = self.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = ( rneedsContext.test( selectors ) || typeof selectors !== \"string\" ) ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tcur = matched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn core_indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn core_indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\tvar set = typeof selector === \"string\" ?\n\t\t\t\tjQuery( selector, context ) :\n\t\t\t\tjQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n\t\t\tall = jQuery.merge( this.get(), set );\n\n\t\treturn this.pushStack( jQuery.unique(all) );\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\n\njQuery.extend({\n\tfilter: function( expr, elems, not ) {\n\t\tvar elem = elems[ 0 ];\n\n\t\tif ( not ) {\n\t\t\texpr = \":not(\" + expr + \")\";\n\t\t}\n\n\t\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\t\treturn elem.nodeType === 1;\n\t\t\t}));\n\t},\n\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( isSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( core_indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\nvar rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\tmanipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE 9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE 9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[ 0 ] && this[ 0 ].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\t// keepData is for internal use only--do not document\n\tremove: function( selector, keepData ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function () {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn jQuery.access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar\n\t\t\t// Snapshot the DOM in case .domManip sweeps something relevant into its fragment\n\t\t\targs = jQuery.map( this, function( elem ) {\n\t\t\t\treturn [ elem.nextSibling, elem.parentNode ];\n\t\t\t}),\n\t\t\ti = 0;\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\tvar next = args[ i++ ],\n\t\t\t\tparent = args[ i++ ];\n\n\t\t\tif ( parent ) {\n\t\t\t\t// Don't use the snapshot next if it has moved (#13810)\n\t\t\t\tif ( next && next.parentNode !== parent ) {\n\t\t\t\t\tnext = this.nextSibling;\n\t\t\t\t}\n\t\t\t\tjQuery( this ).remove();\n\t\t\t\tparent.insertBefore( elem, next );\n\t\t\t}\n\t\t// Allow new content to include elements from the context set\n\t\t}, true );\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn i ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback, allowIntersection ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = core_concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback, allowIntersection );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Hope ajax is available...\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because core_push.apply(_, arraylike) throws\n\t\t\tcore_push.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Support: IE >= 9\n\t\t// Fix Cloning issues\n\t\tif ( !jQuery.support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) && !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\ti = 0,\n\t\t\tl = elems.length,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [];\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [\"\", \"\"] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t// jQuery.merge because core_push.apply(_, arraylike) throws\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Fixes #12346\n\t\t\t\t\t// Support: Webkit, IE\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, events, type, key, j,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( Data.accepts( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tevents = Object.keys( data.events || {} );\n\t\t\t\t\tif ( events.length ) {\n\t\t\t\t\t\tfor ( j = 0; (type = events[j]) !== undefined; j++ ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t},\n\n\t_evalUrl: function( url ) {\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: \"GET\",\n\t\t\tdataType: \"script\",\n\t\t\tasync: false,\n\t\t\tglobal: false,\n\t\t\t\"throws\": true\n\t\t});\n\t}\n});\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar l = elems.length,\n\t\ti = 0;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Support: IE >= 9\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\nvar curCSS, iframe,\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trmargin = /^margin/,\n\trnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n\trnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\n\telemdisplay = { BODY: \"block\" },\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: 0,\n\t\tfontWeight: 400\n\t},\n\n\tcssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction isHidden( elem, el ) {\n\t// isHidden might be called from jQuery#filter function;\n\t// in that case, element will be second argument\n\telem = el || elem;\n\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n}\n\n// NOTE: we've included the \"window\" in window.getComputedStyle\n// because jsdom on node.js will break without it.\nfunction getStyles( elem ) {\n\treturn window.getComputedStyle( elem, null );\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\n\t\t\tif ( !values[ index ] ) {\n\t\t\t\thidden = isHidden( elem );\n\n\t\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn jQuery.access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that NaN and null values aren't set. See: #7116\n\t\t\tif ( value == null || type === \"number\" && isNaN( value ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\ncurCSS = function( elem, name, _computed ) {\n\tvar width, minWidth, maxWidth,\n\t\tcomputed = _computed || getStyles( elem ),\n\n\t\t// Support: IE9\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n\t\tstyle = elem.style;\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: Safari 5.1\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\n// Try to determine the default display value of an element\nfunction css_defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = ( iframe ||\n\t\t\t\tjQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\n\t\t\t\t.css( \"cssText\", \"display:block !important\" )\n\t\t\t).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n\t\t\tdoc.write(\"<!doctype html><html><body>\");\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\n\n// Called ONLY from within css_defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\t\tdisplay = jQuery.css( elem[0], \"display\" );\n\telem.remove();\n\treturn display;\n}\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\njQuery(function() {\n\t// Support: Android 2.3\n\tif ( !jQuery.support.reliableMarginRight ) {\n\t\tjQuery.cssHooks.marginRight = {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// Support: Android 2.3\n\t\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n\t// getComputedStyle returns percent when specified for top/left/bottom/right\n\t// rather than make the css module depend on the offset module, we just check for it here\n\tif ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n\t\tjQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\t\t\tjQuery.cssHooks[ prop ] = {\n\t\t\t\tget: function( elem, computed ) {\n\t\t\t\t\tif ( computed ) {\n\t\t\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\t\t\tcomputed;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.hidden = function( elem ) {\n\t\t// Support: Opera <= 12.12\n\t\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\t\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n\t};\n\n\tjQuery.expr.filters.visible = function( elem ) {\n\t\treturn !jQuery.expr.filters.hidden( elem );\n\t};\n}\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function(){\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function(){\n\t\t\tvar type = this.type;\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !manipulation_rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ){\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ){\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\tajax_nonce = jQuery.now(),\n\n\tajax_rquery = /\\?/,\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t// Keep a copy of the old load method\n\t_load = jQuery.fn.load,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = url.slice( off );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\n\tjQuery.fn[ type ] = function( fn ){\n\t\treturn this.on( type, fn );\n\t};\n});\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\tfireGlobals = s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrSupported = jQuery.ajaxSettings.xhr(),\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\t// Support: IE9\n\t// We need to keep track of outbound xhr and abort them manually\n\t// because IE is not smart enough to do it all by itself\n\txhrId = 0,\n\txhrCallbacks = {};\n\nif ( window.ActiveXObject ) {\n\tjQuery( window ).on( \"unload\", function() {\n\t\tfor( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t\txhrCallbacks = undefined;\n\t});\n}\n\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\njQuery.support.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( jQuery.support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i, id,\n\t\t\t\t\txhr = options.xhr();\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file protocol always yields status 0, assume 404\n\t\t\t\t\t\t\t\t\txhr.status || 404,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// #11426: When requesting binary data, IE9 will throw an exception\n\t\t\t\t\t\t\t\t\t// on any attempt to access responseText\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[( id = xhrId++ )] = callback(\"abort\");\n\t\t\t\t// Do send the request\n\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\nvar fxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t}]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tif ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n\t\t\t\tjQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth? 1 : 0;\n\tfor( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p*Math.PI ) / 2;\n\t}\n};\n\njQuery.timers = [];\njQuery.fx = Tween.prototype.init;\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tif ( timer() && jQuery.timers.push( timer ) ) {\n\t\tjQuery.fx.start();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n\tjQuery.expr.filters.animated = function( elem ) {\n\t\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\t\treturn elem === fn.elem;\n\t\t}).length;\n\t};\n}\njQuery.fn.offset = function( options ) {\n\tif ( arguments.length ) {\n\t\treturn options === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function( i ) {\n\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t});\n\t}\n\n\tvar docElem, win,\n\t\telem = this[ 0 ],\n\t\tbox = { top: 0, left: 0 },\n\t\tdoc = elem && elem.ownerDocument;\n\n\tif ( !doc ) {\n\t\treturn;\n\t}\n\n\tdocElem = doc.documentElement;\n\n\t// Make sure it's not a disconnected DOM node\n\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\treturn box;\n\t}\n\n\t// If we don't have gBCR, just use 0,0 rather than error\n\t// BlackBerry 5, iOS 3 (original iPhone)\n\tif ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n\t\tbox = elem.getBoundingClientRect();\n\t}\n\twin = getWindow( doc );\n\treturn {\n\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t};\n};\n\njQuery.offset = {\n\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && ( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\n\njQuery.fn.extend({\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// We assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn jQuery.access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn jQuery.access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n// Limit scope pollution from any deprecated API\n// (function() {\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n// })();\nif ( typeof module === \"object\" && module && typeof module.exports === \"object\" ) {\n\t// Expose jQuery as module.exports in loaders that implement the Node\n\t// module pattern (including browserify). Do not create the global, since\n\t// the user will be storing it themselves locally, and globals are frowned\n\t// upon in the Node module world.\n\tmodule.exports = jQuery;\n} else {\n\t// Register as a named AMD module, since jQuery can be concatenated with other\n\t// files that may use define, but not via a proper concatenation script that\n\t// understands anonymous AMD modules. A named AMD is safest and most robust\n\t// way to register. Lowercase jquery is used because AMD module names are\n\t// derived from file names, and jQuery is normally delivered in a lowercase\n\t// file name. Do this after creating the global so that if an AMD module wants\n\t// to call noConflict to hide this version of jQuery, it will work.\n\tif ( typeof define === \"function\" && define.amd ) {\n\t\tdefine( \"jquery\", [], function () { return jQuery; } );\n\t}\n}\n\n// If there is a window object, that at least has a document property,\n// define jQuery and $ identifiers\nif ( typeof window === \"object\" && typeof window.document === \"object\" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n})( window );\n","/**\n * @license\n * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>\n * Build: `lodash -o ./dist/lodash.compat.js`\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre ES5 environments */\n  var undefined;\n\n  /** Used to pool arrays and objects used internally */\n  var arrayPool = [],\n      objectPool = [];\n\n  /** Used to generate unique IDs */\n  var idCounter = 0;\n\n  /** Used internally to indicate various things */\n  var indicatorObject = {};\n\n  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */\n  var keyPrefix = +new Date + '';\n\n  /** Used as the size when optimizations are enabled for large arrays */\n  var largeArraySize = 75;\n\n  /** Used as the max size of the `arrayPool` and `objectPool` */\n  var maxPoolSize = 40;\n\n  /** Used to detect and test whitespace */\n  var whitespace = (\n    // whitespace\n    ' \\t\\x0B\\f\\xA0\\ufeff' +\n\n    // line terminators\n    '\\n\\r\\u2028\\u2029' +\n\n    // unicode category \"Zs\" space separators\n    '\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000'\n  );\n\n  /** Used to match empty string literals in compiled template source */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /**\n   * Used to match ES6 template delimiters\n   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match regexp flags from their coerced string values */\n  var reFlags = /\\w*$/;\n\n  /** Used to detected named functions */\n  var reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n  /** Used to match \"interpolate\" template delimiters */\n  var reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match leading whitespace and zeros to be removed */\n  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');\n\n  /** Used to ensure capturing order of template delimiters */\n  var reNoMatch = /($^)/;\n\n  /** Used to detect functions containing a `this` reference */\n  var reThis = /\\bthis\\b/;\n\n  /** Used to match unescaped characters in compiled string literals */\n  var reUnescapedString = /['\\n\\r\\t\\u2028\\u2029\\\\]/g;\n\n  /** Used to assign default `context` object properties */\n  var contextProps = [\n    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',\n    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',\n    'parseInt', 'setTimeout'\n  ];\n\n  /** Used to fix the JScript [[DontEnum]] bug */\n  var shadowedProps = [\n    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',\n    'toLocaleString', 'toString', 'valueOf'\n  ];\n\n  /** Used to make template sourceURLs easier to identify */\n  var templateCounter = 0;\n\n  /** `Object#toString` result shortcuts */\n  var argsClass = '[object Arguments]',\n      arrayClass = '[object Array]',\n      boolClass = '[object Boolean]',\n      dateClass = '[object Date]',\n      errorClass = '[object Error]',\n      funcClass = '[object Function]',\n      numberClass = '[object Number]',\n      objectClass = '[object Object]',\n      regexpClass = '[object RegExp]',\n      stringClass = '[object String]';\n\n  /** Used to identify object classifications that `_.clone` supports */\n  var cloneableClasses = {};\n  cloneableClasses[funcClass] = false;\n  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =\n  cloneableClasses[boolClass] = cloneableClasses[dateClass] =\n  cloneableClasses[numberClass] = cloneableClasses[objectClass] =\n  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;\n\n  /** Used as an internal `_.debounce` options object */\n  var debounceOptions = {\n    'leading': false,\n    'maxWait': 0,\n    'trailing': false\n  };\n\n  /** Used as the property descriptor for `__bindData__` */\n  var descriptor = {\n    'configurable': false,\n    'enumerable': false,\n    'value': null,\n    'writable': false\n  };\n\n  /** Used as the data object for `iteratorTemplate` */\n  var iteratorData = {\n    'args': '',\n    'array': null,\n    'bottom': '',\n    'firstArg': '',\n    'init': '',\n    'keys': null,\n    'loop': '',\n    'shadowedProps': null,\n    'support': null,\n    'top': '',\n    'useHas': false\n  };\n\n  /** Used to determine if values are of the language type Object */\n  var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\t': 't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Used as a reference to the global object */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Detect free variable `exports` */\n  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module` */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports` */\n  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */\n  var freeGlobal = objectTypes[typeof global] && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * The base implementation of `_.indexOf` without support for binary searches\n   * or `fromIndex` constraints.\n   *\n   * @private\n   * @param {Array} array The array to search.\n   * @param {*} value The value to search for.\n   * @param {number} [fromIndex=0] The index to search from.\n   * @returns {number} Returns the index of the matched value or `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    var index = (fromIndex || 0) - 1,\n        length = array ? array.length : 0;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * An implementation of `_.contains` for cache objects that mimics the return\n   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.\n   *\n   * @private\n   * @param {Object} cache The cache object to inspect.\n   * @param {*} value The value to search for.\n   * @returns {number} Returns `0` if `value` is found, else `-1`.\n   */\n  function cacheIndexOf(cache, value) {\n    var type = typeof value;\n    cache = cache.cache;\n\n    if (type == 'boolean' || value == null) {\n      return cache[value] ? 0 : -1;\n    }\n    if (type != 'number' && type != 'string') {\n      type = 'object';\n    }\n    var key = type == 'number' ? value : keyPrefix + value;\n    cache = (cache = cache[type]) && cache[key];\n\n    return type == 'object'\n      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)\n      : (cache ? 0 : -1);\n  }\n\n  /**\n   * Adds a given value to the corresponding cache object.\n   *\n   * @private\n   * @param {*} value The value to add to the cache.\n   */\n  function cachePush(value) {\n    var cache = this.cache,\n        type = typeof value;\n\n    if (type == 'boolean' || value == null) {\n      cache[value] = true;\n    } else {\n      if (type != 'number' && type != 'string') {\n        type = 'object';\n      }\n      var key = type == 'number' ? value : keyPrefix + value,\n          typeCache = cache[type] || (cache[type] = {});\n\n      if (type == 'object') {\n        (typeCache[key] || (typeCache[key] = [])).push(value);\n      } else {\n        typeCache[key] = true;\n      }\n    }\n  }\n\n  /**\n   * Used by `_.max` and `_.min` as the default callback when a given\n   * collection is a string value.\n   *\n   * @private\n   * @param {string} value The character to inspect.\n   * @returns {number} Returns the code unit of given character.\n   */\n  function charAtCallback(value) {\n    return value.charCodeAt(0);\n  }\n\n  /**\n   * Used by `sortBy` to compare transformed `collection` elements, stable sorting\n   * them in ascending order.\n   *\n   * @private\n   * @param {Object} a The object to compare to `b`.\n   * @param {Object} b The object to compare to `a`.\n   * @returns {number} Returns the sort order indicator of `1` or `-1`.\n   */\n  function compareAscending(a, b) {\n    var ac = a.criteria,\n        bc = b.criteria,\n        index = -1,\n        length = ac.length;\n\n    while (++index < length) {\n      var value = ac[index],\n          other = bc[index];\n\n      if (value !== other) {\n        if (value > other || typeof value == 'undefined') {\n          return 1;\n        }\n        if (value < other || typeof other == 'undefined') {\n          return -1;\n        }\n      }\n    }\n    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n    // that causes it, under certain circumstances, to return the same value for\n    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247\n    //\n    // This also ensures a stable sort in V8 and other engines.\n    // See http://code.google.com/p/v8/issues/detail?id=90\n    return a.index - b.index;\n  }\n\n  /**\n   * Creates a cache object to optimize linear searches of large arrays.\n   *\n   * @private\n   * @param {Array} [array=[]] The array to search.\n   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.\n   */\n  function createCache(array) {\n    var index = -1,\n        length = array.length,\n        first = array[0],\n        mid = array[(length / 2) | 0],\n        last = array[length - 1];\n\n    if (first && typeof first == 'object' &&\n        mid && typeof mid == 'object' && last && typeof last == 'object') {\n      return false;\n    }\n    var cache = getObject();\n    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;\n\n    var result = getObject();\n    result.array = array;\n    result.cache = cache;\n    result.push = cachePush;\n\n    while (++index < length) {\n      result.push(array[index]);\n    }\n    return result;\n  }\n\n  /**\n   * Used by `template` to escape characters for inclusion in compiled\n   * string literals.\n   *\n   * @private\n   * @param {string} match The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(match) {\n    return '\\\\' + stringEscapes[match];\n  }\n\n  /**\n   * Gets an array from the array pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Array} The array from the pool.\n   */\n  function getArray() {\n    return arrayPool.pop() || [];\n  }\n\n  /**\n   * Gets an object from the object pool or creates a new one if the pool is empty.\n   *\n   * @private\n   * @returns {Object} The object from the pool.\n   */\n  function getObject() {\n    return objectPool.pop() || {\n      'array': null,\n      'cache': null,\n      'criteria': null,\n      'false': false,\n      'index': 0,\n      'null': false,\n      'number': null,\n      'object': null,\n      'push': null,\n      'string': null,\n      'true': false,\n      'undefined': false,\n      'value': null\n    };\n  }\n\n  /**\n   * Checks if `value` is a DOM node in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.\n   */\n  function isNode(value) {\n    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`\n    // methods that are `typeof` \"string\" and still can coerce nodes to strings\n    return typeof value.toString != 'function' && typeof (value + '') == 'string';\n  }\n\n  /**\n   * Releases the given array back to the array pool.\n   *\n   * @private\n   * @param {Array} [array] The array to release.\n   */\n  function releaseArray(array) {\n    array.length = 0;\n    if (arrayPool.length < maxPoolSize) {\n      arrayPool.push(array);\n    }\n  }\n\n  /**\n   * Releases the given object back to the object pool.\n   *\n   * @private\n   * @param {Object} [object] The object to release.\n   */\n  function releaseObject(object) {\n    var cache = object.cache;\n    if (cache) {\n      releaseObject(cache);\n    }\n    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;\n    if (objectPool.length < maxPoolSize) {\n      objectPool.push(object);\n    }\n  }\n\n  /**\n   * Slices the `collection` from the `start` index up to, but not including,\n   * the `end` index.\n   *\n   * Note: This function is used instead of `Array#slice` to support node lists\n   * in IE < 9 and to ensure dense arrays are returned.\n   *\n   * @private\n   * @param {Array|Object|string} collection The collection to slice.\n   * @param {number} start The start index.\n   * @param {number} end The end index.\n   * @returns {Array} Returns the new array.\n   */\n  function slice(array, start, end) {\n    start || (start = 0);\n    if (typeof end == 'undefined') {\n      end = array ? array.length : 0;\n    }\n    var index = -1,\n        length = end - start || 0,\n        result = Array(length < 0 ? 0 : length);\n\n    while (++index < length) {\n      result[index] = array[start + index];\n    }\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new `lodash` function using the given context object.\n   *\n   * @static\n   * @memberOf _\n   * @category Utilities\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns the `lodash` function.\n   */\n  function runInContext(context) {\n    // Avoid issues with some ES3 environments that attempt to use values, named\n    // after built-in constructors like `Object`, for the creation of literals.\n    // ES5 clears this up by stating that literals must use built-in constructors.\n    // See http://es5.github.io/#x11.1.5.\n    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;\n\n    /** Native constructor references */\n    var Array = context.Array,\n        Boolean = context.Boolean,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Number = context.Number,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /**\n     * Used for `Array` method references.\n     *\n     * Normally `Array.prototype` would suffice, however, using an array literal\n     * avoids issues in Narwhal.\n     */\n    var arrayRef = [];\n\n    /** Used for native method references */\n    var errorProto = Error.prototype,\n        objectProto = Object.prototype,\n        stringProto = String.prototype;\n\n    /** Used to restore the original `_` reference in `noConflict` */\n    var oldDash = context._;\n\n    /** Used to resolve the internal [[Class]] of values */\n    var toString = objectProto.toString;\n\n    /** Used to detect if a method is native */\n    var reNative = RegExp('^' +\n      String(toString)\n        .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n        .replace(/toString| for [^\\]]+/g, '.*?') + '$'\n    );\n\n    /** Native method shortcuts */\n    var ceil = Math.ceil,\n        clearTimeout = context.clearTimeout,\n        floor = Math.floor,\n        fnToString = Function.prototype.toString,\n        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,\n        hasOwnProperty = objectProto.hasOwnProperty,\n        push = arrayRef.push,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        setTimeout = context.setTimeout,\n        splice = arrayRef.splice,\n        unshift = arrayRef.unshift;\n\n    /** Used to set meta data on functions */\n    var defineProperty = (function() {\n      // IE 8 only accepts DOM elements\n      try {\n        var o = {},\n            func = isNative(func = Object.defineProperty) && func,\n            result = func(o, o, o) && func;\n      } catch(e) { }\n      return result;\n    }());\n\n    /* Native method shortcuts for methods with the same name as other `lodash` methods */\n    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,\n        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,\n        nativeIsFinite = context.isFinite,\n        nativeIsNaN = context.isNaN,\n        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random;\n\n    /** Used to lookup a built-in constructor by [[Class]] */\n    var ctorByClass = {};\n    ctorByClass[arrayClass] = Array;\n    ctorByClass[boolClass] = Boolean;\n    ctorByClass[dateClass] = Date;\n    ctorByClass[funcClass] = Function;\n    ctorByClass[objectClass] = Object;\n    ctorByClass[numberClass] = Number;\n    ctorByClass[regexpClass] = RegExp;\n    ctorByClass[stringClass] = String;\n\n    /** Used to avoid iterating non-enumerable properties in IE < 9 */\n    var nonEnumProps = {};\n    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };\n    nonEnumProps[boolClass] = nonEnumProps[stringClass] = { 'constructor': true, 'toString': true, 'valueOf': true };\n    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = { 'constructor': true, 'toString': true };\n    nonEnumProps[objectClass] = { 'constructor': true };\n\n    (function() {\n      var length = shadowedProps.length;\n      while (length--) {\n        var key = shadowedProps[length];\n        for (var className in nonEnumProps) {\n          if (hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], key)) {\n            nonEnumProps[className][key] = false;\n          }\n        }\n      }\n    }());\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps the given value to enable intuitive\n     * method chaining.\n     *\n     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:\n     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,\n     * and `unshift`\n     *\n     * Chaining is supported in custom builds as long as the `value` method is\n     * implicitly or explicitly included in the build.\n     *\n     * The chainable wrapper functions are:\n     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,\n     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,\n     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,\n     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,\n     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,\n     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,\n     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,\n     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,\n     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,\n     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,\n     * and `zip`\n     *\n     * The non-chainable wrapper functions are:\n     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,\n     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,\n     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,\n     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,\n     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,\n     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,\n     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,\n     * `template`, `unescape`, `uniqueId`, and `value`\n     *\n     * The wrapper functions `first` and `last` return wrapped values when `n` is\n     * provided, otherwise they return unwrapped values.\n     *\n     * Explicit chaining can be enabled by using the `_.chain` method.\n     *\n     * @name _\n     * @constructor\n     * @category Chaining\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns a `lodash` instance.\n     * @example\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // returns an unwrapped value\n     * wrapped.reduce(function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * // returns a wrapped value\n     * var squares = wrapped.map(function(num) {\n     *   return num * num;\n     * });\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n       ? value\n       : new lodashWrapper(value);\n    }\n\n    /**\n     * A fast path for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @param {boolean} chainAll A flag to enable chaining for all methods\n     * @returns {Object} Returns a `lodash` instance.\n     */\n    function lodashWrapper(value, chainAll) {\n      this.__chain__ = !!chainAll;\n      this.__wrapped__ = value;\n    }\n    // ensure `new lodashWrapper` is an instance of `lodash`\n    lodashWrapper.prototype = lodash.prototype;\n\n    /**\n     * An object used to flag environments features.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    var support = lodash.support = {};\n\n    (function() {\n      var ctor = function() { this.x = 1; },\n          object = { '0': 1, 'length': 1 },\n          props = [];\n\n      ctor.prototype = { 'valueOf': 1, 'y': 1 };\n      for (var key in new ctor) { props.push(key); }\n      for (key in arguments) { }\n\n      /**\n       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.argsClass = toString.call(arguments) == argsClass;\n\n      /**\n       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.argsObject = arguments.constructor == Object && !(arguments instanceof Array);\n\n      /**\n       * Detect if `name` or `message` properties of `Error.prototype` are\n       * enumerable by default. (IE < 9, Safari < 5.1)\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');\n\n      /**\n       * Detect if `prototype` properties are enumerable by default.\n       *\n       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1\n       * (if the prototype or a property on the prototype has been set)\n       * incorrectly sets a function's `prototype` property [[Enumerable]]\n       * value to `true`.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');\n\n      /**\n       * Detect if functions can be decompiled by `Function#toString`\n       * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);\n\n      /**\n       * Detect if `Function#name` is supported (all but IE).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.funcNames = typeof Function.name == 'string';\n\n      /**\n       * Detect if `arguments` object indexes are non-enumerable\n       * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.nonEnumArgs = key != 0;\n\n      /**\n       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.\n       *\n       * In IE < 9 an objects own properties, shadowing non-enumerable ones, are\n       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.nonEnumShadows = !/valueOf/.test(props);\n\n      /**\n       * Detect if own properties are iterated after inherited properties (all but IE < 9).\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.ownLast = props[0] != 'x';\n\n      /**\n       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.\n       *\n       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`\n       * and `splice()` functions that fail to remove the last element, `value[0]`,\n       * of array-like objects even though the `length` property is set to `0`.\n       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`\n       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);\n\n      /**\n       * Detect lack of support for accessing string characters by index.\n       *\n       * IE < 8 can't access characters by index and IE 8 can only access\n       * characters by index on string literals.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';\n\n      /**\n       * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)\n       * and that the JS engine errors when attempting to coerce an object to\n       * a string without a `toString` function.\n       *\n       * @memberOf _.support\n       * @type boolean\n       */\n      try {\n        support.nodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));\n      } catch(e) {\n        support.nodeClass = true;\n      }\n    }(1));\n\n    /**\n     * By default, the template delimiters used by Lo-Dash are similar to those in\n     * embedded Ruby (ERB). Change the following template settings to use alternative\n     * delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type Object\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'escape': /<%-([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'evaluate': /<%([\\s\\S]+?)%>/g,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type RegExp\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type string\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type Object\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type Function\n         */\n        '_': lodash\n      }\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The template used to create iterator functions.\n     *\n     * @private\n     * @param {Object} data The data object used to populate the text.\n     * @returns {string} Returns the interpolated text.\n     */\n    var iteratorTemplate = function(obj) {\n\n      var __p = 'var index, iterable = ' +\n      (obj.firstArg) +\n      ', result = ' +\n      (obj.init) +\n      ';\\nif (!iterable) return result;\\n' +\n      (obj.top) +\n      ';';\n       if (obj.array) {\n      __p += '\\nvar length = iterable.length; index = -1;\\nif (' +\n      (obj.array) +\n      ') {  ';\n       if (support.unindexedChars) {\n      __p += '\\n  if (isString(iterable)) {\\n    iterable = iterable.split(\\'\\')\\n  }  ';\n       }\n      __p += '\\n  while (++index < length) {\\n    ' +\n      (obj.loop) +\n      ';\\n  }\\n}\\nelse {  ';\n       } else if (support.nonEnumArgs) {\n      __p += '\\n  var length = iterable.length; index = -1;\\n  if (length && isArguments(iterable)) {\\n    while (++index < length) {\\n      index += \\'\\';\\n      ' +\n      (obj.loop) +\n      ';\\n    }\\n  } else {  ';\n       }\n\n       if (support.enumPrototypes) {\n      __p += '\\n  var skipProto = typeof iterable == \\'function\\';\\n  ';\n       }\n\n       if (support.enumErrorProps) {\n      __p += '\\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\\n  ';\n       }\n\n          var conditions = [];    if (support.enumPrototypes) { conditions.push('!(skipProto && index == \"prototype\")'); }    if (support.enumErrorProps)  { conditions.push('!(skipErrorProps && (index == \"message\" || index == \"name\"))'); }\n\n       if (obj.useHas && obj.keys) {\n      __p += '\\n  var ownIndex = -1,\\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\\n      length = ownProps ? ownProps.length : 0;\\n\\n  while (++ownIndex < length) {\\n    index = ownProps[ownIndex];\\n';\n          if (conditions.length) {\n      __p += '    if (' +\n      (conditions.join(' && ')) +\n      ') {\\n  ';\n       }\n      __p +=\n      (obj.loop) +\n      ';    ';\n       if (conditions.length) {\n      __p += '\\n    }';\n       }\n      __p += '\\n  }  ';\n       } else {\n      __p += '\\n  for (index in iterable) {\\n';\n          if (obj.useHas) { conditions.push(\"hasOwnProperty.call(iterable, index)\"); }    if (conditions.length) {\n      __p += '    if (' +\n      (conditions.join(' && ')) +\n      ') {\\n  ';\n       }\n      __p +=\n      (obj.loop) +\n      ';    ';\n       if (conditions.length) {\n      __p += '\\n    }';\n       }\n      __p += '\\n  }    ';\n       if (support.nonEnumShadows) {\n      __p += '\\n\\n  if (iterable !== objectProto) {\\n    var ctor = iterable.constructor,\\n        isProto = iterable === (ctor && ctor.prototype),\\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\\n        nonEnum = nonEnumProps[className];\\n      ';\n       for (k = 0; k < 7; k++) {\n      __p += '\\n    index = \\'' +\n      (obj.shadowedProps[k]) +\n      '\\';\\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';\n              if (!obj.useHas) {\n      __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';\n       }\n      __p += ') {\\n      ' +\n      (obj.loop) +\n      ';\\n    }      ';\n       }\n      __p += '\\n  }    ';\n       }\n\n       }\n\n       if (obj.array || support.nonEnumArgs) {\n      __p += '\\n}';\n       }\n      __p +=\n      (obj.bottom) +\n      ';\\nreturn result';\n\n      return __p\n    };\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The base implementation of `_.bind` that creates the bound function and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new bound function.\n     */\n    function baseBind(bindData) {\n      var func = bindData[0],\n          partialArgs = bindData[2],\n          thisArg = bindData[4];\n\n      function bound() {\n        // `Function#bind` spec\n        // http://es5.github.io/#x15.3.4.5\n        if (partialArgs) {\n          // avoid `arguments` object deoptimizations by using `slice` instead\n          // of `Array.prototype.slice.call` and not assigning `arguments` to a\n          // variable as a ternary expression\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        // mimic the constructor's `return` behavior\n        // http://es5.github.io/#x13.2.2\n        if (this instanceof bound) {\n          // ensure `new bound` is an instance of `func`\n          var thisBinding = baseCreate(func.prototype),\n              result = func.apply(thisBinding, args || arguments);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisArg, args || arguments);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.clone` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates clones with source counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, isDeep, callback, stackA, stackB) {\n      if (callback) {\n        var result = callback(value);\n        if (typeof result != 'undefined') {\n          return result;\n        }\n      }\n      // inspect [[Class]]\n      var isObj = isObject(value);\n      if (isObj) {\n        var className = toString.call(value);\n        if (!cloneableClasses[className] || (!support.nodeClass && isNode(value))) {\n          return value;\n        }\n        var ctor = ctorByClass[className];\n        switch (className) {\n          case boolClass:\n          case dateClass:\n            return new ctor(+value);\n\n          case numberClass:\n          case stringClass:\n            return new ctor(value);\n\n          case regexpClass:\n            result = ctor(value.source, reFlags.exec(value));\n            result.lastIndex = value.lastIndex;\n            return result;\n        }\n      } else {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isDeep) {\n        // check for circular references and return corresponding clone\n        var initedStack = !stackA;\n        stackA || (stackA = getArray());\n        stackB || (stackB = getArray());\n\n        var length = stackA.length;\n        while (length--) {\n          if (stackA[length] == value) {\n            return stackB[length];\n          }\n        }\n        result = isArr ? ctor(value.length) : {};\n      }\n      else {\n        result = isArr ? slice(value) : assign({}, value);\n      }\n      // add array properties assigned by `RegExp#exec`\n      if (isArr) {\n        if (hasOwnProperty.call(value, 'index')) {\n          result.index = value.index;\n        }\n        if (hasOwnProperty.call(value, 'input')) {\n          result.input = value.input;\n        }\n      }\n      // exit for shallow clone\n      if (!isDeep) {\n        return result;\n      }\n      // add the source value to the stack of traversed objects\n      // and associate it with its clone\n      stackA.push(value);\n      stackB.push(result);\n\n      // recursively populate clone (susceptible to call stack limits)\n      (isArr ? baseEach : forOwn)(value, function(objValue, key) {\n        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);\n      });\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    function baseCreate(prototype, properties) {\n      return isObject(prototype) ? nativeCreate(prototype) : {};\n    }\n    // fallback for browsers without `Object.create`\n    if (!nativeCreate) {\n      baseCreate = (function() {\n        function Object() {}\n        return function(prototype) {\n          if (isObject(prototype)) {\n            Object.prototype = prototype;\n            var result = new Object;\n            Object.prototype = null;\n          }\n          return result || context.Object();\n        };\n      }());\n    }\n\n    /**\n     * The base implementation of `_.createCallback` without support for creating\n     * \"_.pluck\" or \"_.where\" style callbacks.\n     *\n     * @private\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     */\n    function baseCreateCallback(func, thisArg, argCount) {\n      if (typeof func != 'function') {\n        return identity;\n      }\n      // exit early for no `thisArg` or already bound by `Function#bind`\n      if (typeof thisArg == 'undefined' || !('prototype' in func)) {\n        return func;\n      }\n      var bindData = func.__bindData__;\n      if (typeof bindData == 'undefined') {\n        if (support.funcNames) {\n          bindData = !func.name;\n        }\n        bindData = bindData || !support.funcDecomp;\n        if (!bindData) {\n          var source = fnToString.call(func);\n          if (!support.funcNames) {\n            bindData = !reFuncName.test(source);\n          }\n          if (!bindData) {\n            // checks if `func` references the `this` keyword and stores the result\n            bindData = reThis.test(source);\n            setBindData(func, bindData);\n          }\n        }\n      }\n      // exit early if there are no `this` references or `func` is bound\n      if (bindData === false || (bindData !== true && bindData[1] & 1)) {\n        return func;\n      }\n      switch (argCount) {\n        case 1: return function(value) {\n          return func.call(thisArg, value);\n        };\n        case 2: return function(a, b) {\n          return func.call(thisArg, a, b);\n        };\n        case 3: return function(value, index, collection) {\n          return func.call(thisArg, value, index, collection);\n        };\n        case 4: return function(accumulator, value, index, collection) {\n          return func.call(thisArg, accumulator, value, index, collection);\n        };\n      }\n      return bind(func, thisArg);\n    }\n\n    /**\n     * The base implementation of `createWrapper` that creates the wrapper and\n     * sets its meta data.\n     *\n     * @private\n     * @param {Array} bindData The bind data array.\n     * @returns {Function} Returns the new function.\n     */\n    function baseCreateWrapper(bindData) {\n      var func = bindData[0],\n          bitmask = bindData[1],\n          partialArgs = bindData[2],\n          partialRightArgs = bindData[3],\n          thisArg = bindData[4],\n          arity = bindData[5];\n\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          key = func;\n\n      function bound() {\n        var thisBinding = isBind ? thisArg : this;\n        if (partialArgs) {\n          var args = slice(partialArgs);\n          push.apply(args, arguments);\n        }\n        if (partialRightArgs || isCurry) {\n          args || (args = slice(arguments));\n          if (partialRightArgs) {\n            push.apply(args, partialRightArgs);\n          }\n          if (isCurry && args.length < arity) {\n            bitmask |= 16 & ~32;\n            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);\n          }\n        }\n        args || (args = arguments);\n        if (isBindKey) {\n          func = thisBinding[key];\n        }\n        if (this instanceof bound) {\n          thisBinding = baseCreate(func.prototype);\n          var result = func.apply(thisBinding, args);\n          return isObject(result) ? result : thisBinding;\n        }\n        return func.apply(thisBinding, args);\n      }\n      setBindData(bound, bindData);\n      return bound;\n    }\n\n    /**\n     * The base implementation of `_.difference` that accepts a single array\n     * of values to exclude.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {Array} [values] The array of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     */\n    function baseDifference(array, values) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          isLarge = length >= largeArraySize && indexOf === baseIndexOf,\n          result = [];\n\n      if (isLarge) {\n        var cache = createCache(values);\n        if (cache) {\n          indexOf = cacheIndexOf;\n          values = cache;\n        } else {\n          isLarge = false;\n        }\n      }\n      while (++index < length) {\n        var value = array[index];\n        if (indexOf(values, value) < 0) {\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseObject(values);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` without support for callback\n     * shorthands or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.\n     * @param {number} [fromIndex=0] The index to start from.\n     * @returns {Array} Returns a new flattened array.\n     */\n    function baseFlatten(array, isShallow, isStrict, fromIndex) {\n      var index = (fromIndex || 0) - 1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n\n        if (value && typeof value == 'object' && typeof value.length == 'number'\n            && (isArray(value) || isArguments(value))) {\n          // recursively flatten arrays (susceptible to call stack limits)\n          if (!isShallow) {\n            value = baseFlatten(value, isShallow, isStrict);\n          }\n          var valIndex = -1,\n              valLength = value.length,\n              resIndex = result.length;\n\n          result.length += valLength;\n          while (++valIndex < valLength) {\n            result[resIndex++] = value[valIndex];\n          }\n        } else if (!isStrict) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.isEqual`, without support for `thisArg` binding,\n     * that allows partial \"_.where\" style comparisons.\n     *\n     * @private\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.\n     * @param {Array} [stackA=[]] Tracks traversed `a` objects.\n     * @param {Array} [stackB=[]] Tracks traversed `b` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {\n      // used to indicate that when comparing objects, `a` has at least the properties of `b`\n      if (callback) {\n        var result = callback(a, b);\n        if (typeof result != 'undefined') {\n          return !!result;\n        }\n      }\n      // exit early for identical values\n      if (a === b) {\n        // treat `+0` vs. `-0` as not equal\n        return a !== 0 || (1 / a == 1 / b);\n      }\n      var type = typeof a,\n          otherType = typeof b;\n\n      // exit early for unlike primitive values\n      if (a === a &&\n          !(a && objectTypes[type]) &&\n          !(b && objectTypes[otherType])) {\n        return false;\n      }\n      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior\n      // http://es5.github.io/#x15.3.4.4\n      if (a == null || b == null) {\n        return a === b;\n      }\n      // compare [[Class]] names\n      var className = toString.call(a),\n          otherClass = toString.call(b);\n\n      if (className == argsClass) {\n        className = objectClass;\n      }\n      if (otherClass == argsClass) {\n        otherClass = objectClass;\n      }\n      if (className != otherClass) {\n        return false;\n      }\n      switch (className) {\n        case boolClass:\n        case dateClass:\n          // coerce dates and booleans to numbers, dates to milliseconds and booleans\n          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal\n          return +a == +b;\n\n        case numberClass:\n          // treat `NaN` vs. `NaN` as equal\n          return (a != +a)\n            ? b != +b\n            // but treat `+0` vs. `-0` as not equal\n            : (a == 0 ? (1 / a == 1 / b) : a == +b);\n\n        case regexpClass:\n        case stringClass:\n          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)\n          // treat string primitives and their corresponding object instances as equal\n          return a == String(b);\n      }\n      var isArr = className == arrayClass;\n      if (!isArr) {\n        // unwrap any `lodash` wrapped values\n        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),\n            bWrapped = hasOwnProperty.call(b, '__wrapped__');\n\n        if (aWrapped || bWrapped) {\n          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);\n        }\n        // exit for functions and DOM nodes\n        if (className != objectClass || (!support.nodeClass && (isNode(a) || isNode(b)))) {\n          return false;\n        }\n        // in older versions of Opera, `arguments` objects have `Array` constructors\n        var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor,\n            ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;\n\n        // non `Object` object instances with different constructors are not equal\n        if (ctorA != ctorB &&\n              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&\n              ('constructor' in a && 'constructor' in b)\n            ) {\n          return false;\n        }\n      }\n      // assume cyclic structures are equal\n      // the algorithm for detecting cyclic structures is adapted from ES 5.1\n      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)\n      var initedStack = !stackA;\n      stackA || (stackA = getArray());\n      stackB || (stackB = getArray());\n\n      var length = stackA.length;\n      while (length--) {\n        if (stackA[length] == a) {\n          return stackB[length] == b;\n        }\n      }\n      var size = 0;\n      result = true;\n\n      // add `a` and `b` to the stack of traversed objects\n      stackA.push(a);\n      stackB.push(b);\n\n      // recursively compare objects and arrays (susceptible to call stack limits)\n      if (isArr) {\n        // compare lengths to determine if a deep comparison is necessary\n        length = a.length;\n        size = b.length;\n        result = size == length;\n\n        if (result || isWhere) {\n          // deep compare the contents, ignoring non-numeric properties\n          while (size--) {\n            var index = length,\n                value = b[size];\n\n            if (isWhere) {\n              while (index--) {\n                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {\n                  break;\n                }\n              }\n            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {\n              break;\n            }\n          }\n        }\n      }\n      else {\n        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`\n        // which, in this case, is more costly\n        forIn(b, function(value, key, b) {\n          if (hasOwnProperty.call(b, key)) {\n            // count the number of properties.\n            size++;\n            // deep compare each property value.\n            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));\n          }\n        });\n\n        if (result && !isWhere) {\n          // ensure both objects have the same number of properties\n          forIn(a, function(value, key, a) {\n            if (hasOwnProperty.call(a, key)) {\n              // `size` will be `-1` if `a` has more properties than `b`\n              return (result = --size > -1);\n            }\n          });\n        }\n      }\n      stackA.pop();\n      stackB.pop();\n\n      if (initedStack) {\n        releaseArray(stackA);\n        releaseArray(stackB);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.merge` without argument juggling or support\n     * for `thisArg` binding.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {Array} [stackA=[]] Tracks traversed source objects.\n     * @param {Array} [stackB=[]] Associates values with source counterparts.\n     */\n    function baseMerge(object, source, callback, stackA, stackB) {\n      (isArray(source) ? forEach : forOwn)(source, function(source, key) {\n        var found,\n            isArr,\n            result = source,\n            value = object[key];\n\n        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {\n          // avoid merging previously merged cyclic sources\n          var stackLength = stackA.length;\n          while (stackLength--) {\n            if ((found = stackA[stackLength] == source)) {\n              value = stackB[stackLength];\n              break;\n            }\n          }\n          if (!found) {\n            var isShallow;\n            if (callback) {\n              result = callback(value, source);\n              if ((isShallow = typeof result != 'undefined')) {\n                value = result;\n              }\n            }\n            if (!isShallow) {\n              value = isArr\n                ? (isArray(value) ? value : [])\n                : (isPlainObject(value) ? value : {});\n            }\n            // add `source` and associated `value` to the stack of traversed objects\n            stackA.push(source);\n            stackB.push(value);\n\n            // recursively merge objects and arrays (susceptible to call stack limits)\n            if (!isShallow) {\n              baseMerge(value, source, callback, stackA, stackB);\n            }\n          }\n        }\n        else {\n          if (callback) {\n            result = callback(value, source);\n            if (typeof result == 'undefined') {\n              result = source;\n            }\n          }\n          if (typeof result != 'undefined') {\n            value = result;\n          }\n        }\n        object[key] = value;\n      });\n    }\n\n    /**\n     * The base implementation of `_.random` without argument juggling or support\n     * for returning floating-point numbers.\n     *\n     * @private\n     * @param {number} min The minimum possible value.\n     * @param {number} max The maximum possible value.\n     * @returns {number} Returns a random number.\n     */\n    function baseRandom(min, max) {\n      return min + floor(nativeRandom() * (max - min + 1));\n    }\n\n    /**\n     * The base implementation of `_.uniq` without support for callback shorthands\n     * or `thisArg` binding.\n     *\n     * @private\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function} [callback] The function called per iteration.\n     * @returns {Array} Returns a duplicate-value-free array.\n     */\n    function baseUniq(array, isSorted, callback) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = array ? array.length : 0,\n          result = [];\n\n      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,\n          seen = (callback || isLarge) ? getArray() : result;\n\n      if (isLarge) {\n        var cache = createCache(seen);\n        indexOf = cacheIndexOf;\n        seen = cache;\n      }\n      while (++index < length) {\n        var value = array[index],\n            computed = callback ? callback(value, index, array) : value;\n\n        if (isSorted\n              ? !index || seen[seen.length - 1] !== computed\n              : indexOf(seen, computed) < 0\n            ) {\n          if (callback || isLarge) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      if (isLarge) {\n        releaseArray(seen.array);\n        releaseObject(seen);\n      } else if (callback) {\n        releaseArray(seen);\n      }\n      return result;\n    }\n\n    /**\n     * Creates a function that aggregates a collection, creating an object composed\n     * of keys generated from the results of running each element of the collection\n     * through a callback. The given `setter` function sets the keys and values\n     * of the composed object.\n     *\n     * @private\n     * @param {Function} setter The setter function.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter) {\n      return function(collection, callback, thisArg) {\n        var result = {};\n        callback = lodash.createCallback(callback, thisArg, 3);\n\n        if (isArray(collection)) {\n          var index = -1,\n              length = collection.length;\n\n          while (++index < length) {\n            var value = collection[index];\n            setter(result, value, callback(value, index, collection), collection);\n          }\n        } else {\n          baseEach(collection, function(value, key, collection) {\n            setter(result, value, callback(value, key, collection), collection);\n          });\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, either curries or invokes `func`\n     * with an optional `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to reference.\n     * @param {number} bitmask The bitmask of method flags to compose.\n     *  The bitmask may be composed of the following flags:\n     *  1 - `_.bind`\n     *  2 - `_.bindKey`\n     *  4 - `_.curry`\n     *  8 - `_.curry` (bound)\n     *  16 - `_.partial`\n     *  32 - `_.partialRight`\n     * @param {Array} [partialArgs] An array of arguments to prepend to those\n     *  provided to the new function.\n     * @param {Array} [partialRightArgs] An array of arguments to append to those\n     *  provided to the new function.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new function.\n     */\n    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {\n      var isBind = bitmask & 1,\n          isBindKey = bitmask & 2,\n          isCurry = bitmask & 4,\n          isCurryBound = bitmask & 8,\n          isPartial = bitmask & 16,\n          isPartialRight = bitmask & 32;\n\n      if (!isBindKey && !isFunction(func)) {\n        throw new TypeError;\n      }\n      if (isPartial && !partialArgs.length) {\n        bitmask &= ~16;\n        isPartial = partialArgs = false;\n      }\n      if (isPartialRight && !partialRightArgs.length) {\n        bitmask &= ~32;\n        isPartialRight = partialRightArgs = false;\n      }\n      var bindData = func && func.__bindData__;\n      if (bindData && bindData !== true) {\n        // clone `bindData`\n        bindData = slice(bindData);\n        if (bindData[2]) {\n          bindData[2] = slice(bindData[2]);\n        }\n        if (bindData[3]) {\n          bindData[3] = slice(bindData[3]);\n        }\n        // set `thisBinding` is not previously bound\n        if (isBind && !(bindData[1] & 1)) {\n          bindData[4] = thisArg;\n        }\n        // set if previously bound but not currently (subsequent curried functions)\n        if (!isBind && bindData[1] & 1) {\n          bitmask |= 8;\n        }\n        // set curried arity if not yet set\n        if (isCurry && !(bindData[1] & 4)) {\n          bindData[5] = arity;\n        }\n        // append partial left arguments\n        if (isPartial) {\n          push.apply(bindData[2] || (bindData[2] = []), partialArgs);\n        }\n        // append partial right arguments\n        if (isPartialRight) {\n          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);\n        }\n        // merge flags\n        bindData[1] |= bitmask;\n        return createWrapper.apply(null, bindData);\n      }\n      // fast path for `_.bind`\n      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;\n      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);\n    }\n\n    /**\n     * Creates compiled iteration functions.\n     *\n     * @private\n     * @param {...Object} [options] The compile options object(s).\n     * @param {string} [options.array] Code to determine if the iterable is an array or array-like.\n     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.\n     * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.\n     * @param {string} [options.args] A comma separated string of iteration function arguments.\n     * @param {string} [options.top] Code to execute before the iteration branches.\n     * @param {string} [options.loop] Code to execute in the object loop.\n     * @param {string} [options.bottom] Code to execute after the iteration branches.\n     * @returns {Function} Returns the compiled function.\n     */\n    function createIterator() {\n      // data properties\n      iteratorData.shadowedProps = shadowedProps;\n\n      // iterator options\n      iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';\n      iteratorData.init = 'iterable';\n      iteratorData.useHas = true;\n\n      // merge options into a template data object\n      for (var object, index = 0; object = arguments[index]; index++) {\n        for (var key in object) {\n          iteratorData[key] = object[key];\n        }\n      }\n      var args = iteratorData.args;\n      iteratorData.firstArg = /^[^,]+/.exec(args)[0];\n\n      // create the function factory\n      var factory = Function(\n          'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' +\n          'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' +\n          'objectTypes, nonEnumProps, stringClass, stringProto, toString',\n        'return function(' + args + ') {\\n' + iteratorTemplate(iteratorData) + '\\n}'\n      );\n\n      // return the compiled function\n      return factory(\n        baseCreateCallback, errorClass, errorProto, hasOwnProperty,\n        indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto,\n        objectTypes, nonEnumProps, stringClass, stringProto, toString\n      );\n    }\n\n    /**\n     * Used by `escape` to convert characters to HTML entities.\n     *\n     * @private\n     * @param {string} match The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    function escapeHtmlChar(match) {\n      return htmlEscapes[match];\n    }\n\n    /**\n     * Gets the appropriate \"indexOf\" function. If the `_.indexOf` method is\n     * customized, this method returns the custom method, otherwise it returns\n     * the `baseIndexOf` function.\n     *\n     * @private\n     * @returns {Function} Returns the \"indexOf\" function.\n     */\n    function getIndexOf() {\n      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a native function.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.\n     */\n    function isNative(value) {\n      return typeof value == 'function' && reNative.test(value);\n    }\n\n    /**\n     * Sets `this` binding data on a given function.\n     *\n     * @private\n     * @param {Function} func The function to set data on.\n     * @param {Array} value The data array to set.\n     */\n    var setBindData = !defineProperty ? noop : function(func, value) {\n      descriptor.value = value;\n      defineProperty(func, '__bindData__', descriptor);\n    };\n\n    /**\n     * A fallback implementation of `isPlainObject` which checks if a given value\n     * is an object created by the `Object` constructor, assuming objects created\n     * by the `Object` constructor have no inherited enumerable properties and that\n     * there are no `Object.prototype` extensions.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     */\n    function shimIsPlainObject(value) {\n      var ctor,\n          result;\n\n      // avoid non Object objects, `arguments` objects, and DOM elements\n      if (!(value && toString.call(value) == objectClass) ||\n          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor)) ||\n          (!support.argsClass && isArguments(value)) ||\n          (!support.nodeClass && isNode(value))) {\n        return false;\n      }\n      // IE < 9 iterates inherited properties before own properties. If the first\n      // iterated property is an object's own property then there are no inherited\n      // enumerable properties.\n      if (support.ownLast) {\n        forIn(value, function(value, key, object) {\n          result = hasOwnProperty.call(object, key);\n          return false;\n        });\n        return result !== false;\n      }\n      // In most environments an object's own properties are iterated before\n      // its inherited properties. If the last iterated property is an object's\n      // own property then there are no inherited enumerable properties.\n      forIn(value, function(value, key) {\n        result = key;\n      });\n      return typeof result == 'undefined' || hasOwnProperty.call(value, result);\n    }\n\n    /**\n     * Used by `unescape` to convert HTML entities to characters.\n     *\n     * @private\n     * @param {string} match The matched character to unescape.\n     * @returns {string} Returns the unescaped character.\n     */\n    function unescapeHtmlChar(match) {\n      return htmlUnescapes[match];\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Checks if `value` is an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.\n     * @example\n     *\n     * (function() { return _.isArguments(arguments); })(1, 2, 3);\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    function isArguments(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == argsClass || false;\n    }\n    // fallback for browsers that can't detect `arguments` objects by [[Class]]\n    if (!support.argsClass) {\n      isArguments = function(value) {\n        return value && typeof value == 'object' && typeof value.length == 'number' &&\n          hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee') || false;\n      };\n    }\n\n    /**\n     * Checks if `value` is an array.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.\n     * @example\n     *\n     * (function() { return _.isArray(arguments); })();\n     * // => false\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     */\n    var isArray = nativeIsArray || function(value) {\n      return value && typeof value == 'object' && typeof value.length == 'number' &&\n        toString.call(value) == arrayClass || false;\n    };\n\n    /**\n     * A fallback implementation of `Object.keys` which produces an array of the\n     * given object's own enumerable property names.\n     *\n     * @private\n     * @type Function\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     */\n    var shimKeys = createIterator({\n      'args': 'object',\n      'init': '[]',\n      'top': 'if (!(objectTypes[typeof object])) return result',\n      'loop': 'result.push(index)'\n    });\n\n    /**\n     * Creates an array composed of the own enumerable property names of an object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names.\n     * @example\n     *\n     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)\n     */\n    var keys = !nativeKeys ? shimKeys : function(object) {\n      if (!isObject(object)) {\n        return [];\n      }\n      if ((support.enumPrototypes && typeof object == 'function') ||\n          (support.nonEnumArgs && object.length && isArguments(object))) {\n        return shimKeys(object);\n      }\n      return nativeKeys(object);\n    };\n\n    /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */\n    var eachIteratorOptions = {\n      'args': 'collection, callback, thisArg',\n      'top': \"callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)\",\n      'array': \"typeof length == 'number'\",\n      'keys': keys,\n      'loop': 'if (callback(iterable[index], index, collection) === false) return result'\n    };\n\n    /** Reusable iterator options for `assign` and `defaults` */\n    var defaultsIteratorOptions = {\n      'args': 'object, source, guard',\n      'top':\n        'var args = arguments,\\n' +\n        '    argsIndex = 0,\\n' +\n        \"    argsLength = typeof guard == 'number' ? 2 : args.length;\\n\" +\n        'while (++argsIndex < argsLength) {\\n' +\n        '  iterable = args[argsIndex];\\n' +\n        '  if (iterable && objectTypes[typeof iterable]) {',\n      'keys': keys,\n      'loop': \"if (typeof result[index] == 'undefined') result[index] = iterable[index]\",\n      'bottom': '  }\\n}'\n    };\n\n    /** Reusable iterator options for `forIn` and `forOwn` */\n    var forOwnIteratorOptions = {\n      'top': 'if (!objectTypes[typeof iterable]) return result;\\n' + eachIteratorOptions.top,\n      'array': false\n    };\n\n    /**\n     * Used to convert characters to HTML entities:\n     *\n     * Though the `>` character is escaped for symmetry, characters like `>` and `/`\n     * don't require escaping in HTML and have no special meaning unless they're part\n     * of a tag or an unquoted attribute value.\n     * http://mathiasbynens.be/notes/ambiguous-ampersands (under \"semi-related fun fact\")\n     */\n    var htmlEscapes = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#39;'\n    };\n\n    /** Used to convert HTML entities to characters */\n    var htmlUnescapes = invert(htmlEscapes);\n\n    /** Used to match HTML entities and HTML characters */\n    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),\n        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');\n\n    /**\n     * A function compiled to iterate `arguments` objects, arrays, objects, and\n     * strings consistenly across environments, executing the callback for each\n     * element in the collection. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index|key, collection). Callbacks may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @type Function\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     */\n    var baseEach = createIterator(eachIteratorOptions);\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object. Subsequent sources will overwrite property assignments of previous\n     * sources. If a callback is provided it will be executed to produce the\n     * assigned values. The callback is bound to `thisArg` and invoked with two\n     * arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @alias extend\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize assigning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });\n     * // => { 'name': 'fred', 'employer': 'slate' }\n     *\n     * var defaults = _.partialRight(_.assign, function(a, b) {\n     *   return typeof a == 'undefined' ? b : a;\n     * });\n     *\n     * var object = { 'name': 'barney' };\n     * defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var assign = createIterator(defaultsIteratorOptions, {\n      'top':\n        defaultsIteratorOptions.top.replace(';',\n          ';\\n' +\n          \"if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\\n\" +\n          '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\\n' +\n          \"} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\\n\" +\n          '  callback = args[--argsLength];\\n' +\n          '}'\n        ),\n      'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'\n    });\n\n    /**\n     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also\n     * be cloned, otherwise they will be assigned by reference. If a callback\n     * is provided it will be executed to produce the cloned values. If the\n     * callback returns `undefined` cloning will be handled by the method instead.\n     * The callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to clone.\n     * @param {boolean} [isDeep=false] Specify a deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var shallow = _.clone(characters);\n     * shallow[0] === characters[0];\n     * // => true\n     *\n     * var deep = _.clone(characters, true);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * _.mixin({\n     *   'clone': _.partialRight(_.clone, function(value) {\n     *     return _.isElement(value) ? value.cloneNode(false) : undefined;\n     *   })\n     * });\n     *\n     * var clone = _.clone(document.body);\n     * clone.childNodes.length;\n     * // => 0\n     */\n    function clone(value, isDeep, callback, thisArg) {\n      // allows working with \"Collections\" methods without using their `index`\n      // and `collection` arguments for `isDeep` and `callback`\n      if (typeof isDeep != 'boolean' && isDeep != null) {\n        thisArg = callback;\n        callback = isDeep;\n        isDeep = false;\n      }\n      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates a deep clone of `value`. If a callback is provided it will be\n     * executed to produce the cloned values. If the callback returns `undefined`\n     * cloning will be handled by the method instead. The callback is bound to\n     * `thisArg` and invoked with one argument; (value).\n     *\n     * Note: This method is loosely based on the structured clone algorithm. Functions\n     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and\n     * objects created by constructors other than `Object` are cloned to plain `Object` objects.\n     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to deep clone.\n     * @param {Function} [callback] The function to customize cloning values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the deep cloned value.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * var deep = _.cloneDeep(characters);\n     * deep[0] === characters[0];\n     * // => false\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'node': element\n     * };\n     *\n     * var clone = _.cloneDeep(view, function(value) {\n     *   return _.isElement(value) ? value.cloneNode(true) : undefined;\n     * });\n     *\n     * clone.node == view.node;\n     * // => false\n     */\n    function cloneDeep(value, callback, thisArg) {\n      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));\n    }\n\n    /**\n     * Creates an object that inherits from the given `prototype` object. If a\n     * `properties` object is provided its own enumerable properties are assigned\n     * to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties ? assign(result, properties) : result;\n    }\n\n    /**\n     * Assigns own enumerable properties of source object(s) to the destination\n     * object for all destination properties that resolve to `undefined`. Once a\n     * property is set, additional defaults of the same property will be ignored.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param- {Object} [guard] Allows working with `_.reduce` without using its\n     *  `key` and `object` arguments as sources.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var object = { 'name': 'barney' };\n     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });\n     * // => { 'name': 'barney', 'employer': 'slate' }\n     */\n    var defaults = createIterator(defaultsIteratorOptions);\n\n    /**\n     * This method is like `_.findIndex` except that it returns the key of the\n     * first element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': false },\n     *   'fred': {    'age': 40, 'blocked': true },\n     *   'pebbles': { 'age': 1,  'blocked': false }\n     * };\n     *\n     * _.findKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => 'barney' (property order is not guaranteed across environments)\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findKey(characters, { 'age': 1 });\n     * // => 'pebbles'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findKey(characters, 'blocked');\n     * // => 'fred'\n     */\n    function findKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwn(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to search.\n     * @param {Function|Object|string} [callback=identity] The function called per\n     *  iteration. If a property name or object is provided it will be used to\n     *  create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {string|undefined} Returns the key of the found element, else `undefined`.\n     * @example\n     *\n     * var characters = {\n     *   'barney': {  'age': 36, 'blocked': true },\n     *   'fred': {    'age': 40, 'blocked': false },\n     *   'pebbles': { 'age': 1,  'blocked': true }\n     * };\n     *\n     * _.findLastKey(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => returns `pebbles`, assuming `_.findKey` returns `barney`\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastKey(characters, { 'age': 40 });\n     * // => 'fred'\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastKey(characters, 'blocked');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forOwnRight(object, function(value, key, object) {\n        if (callback(value, key, object)) {\n          result = key;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over own and inherited enumerable properties of an object,\n     * executing the callback for each property. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, key, object). Callbacks may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forIn(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)\n     */\n    var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {\n      'useHas': false\n    });\n\n    /**\n     * This method is like `_.forIn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * Shape.prototype.move = function(x, y) {\n     *   this.x += x;\n     *   this.y += y;\n     * };\n     *\n     * _.forInRight(new Shape, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'\n     */\n    function forInRight(object, callback, thisArg) {\n      var pairs = [];\n\n      forIn(object, function(value, key) {\n        pairs.push(key, value);\n      });\n\n      var length = pairs.length;\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(pairs[length--], pairs[length], object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Iterates over own enumerable properties of an object, executing the callback\n     * for each property. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, key, object). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)\n     */\n    var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over elements\n     * of a `collection` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {\n     *   console.log(key);\n     * });\n     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'\n     */\n    function forOwnRight(object, callback, thisArg) {\n      var props = keys(object),\n          length = props.length;\n\n      callback = baseCreateCallback(callback, thisArg, 3);\n      while (length--) {\n        var key = props[length];\n        if (callback(object[key], key, object) === false) {\n          break;\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Creates a sorted array of property names of all enumerable properties,\n     * own and inherited, of `object` that have function values.\n     *\n     * @static\n     * @memberOf _\n     * @alias methods\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property names that have function values.\n     * @example\n     *\n     * _.functions(_);\n     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]\n     */\n    function functions(object) {\n      var result = [];\n      forIn(object, function(value, key) {\n        if (isFunction(value)) {\n          result.push(key);\n        }\n      });\n      return result.sort();\n    }\n\n    /**\n     * Checks if the specified property name exists as a direct property of `object`,\n     * instead of an inherited property.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to check.\n     * @returns {boolean} Returns `true` if key is a direct property, else `false`.\n     * @example\n     *\n     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');\n     * // => true\n     */\n    function has(object, key) {\n      return object ? hasOwnProperty.call(object, key) : false;\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of the given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the created inverted object.\n     * @example\n     *\n     * _.invert({ 'first': 'fred', 'second': 'barney' });\n     * // => { 'fred': 'first', 'barney': 'second' }\n     */\n    function invert(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = {};\n\n      while (++index < length) {\n        var key = props[index];\n        result[object[key]] = key;\n      }\n      return result;\n    }\n\n    /**\n     * Checks if `value` is a boolean value.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.\n     * @example\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        value && typeof value == 'object' && toString.call(value) == boolClass || false;\n    }\n\n    /**\n     * Checks if `value` is a date.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     */\n    function isDate(value) {\n      return value && typeof value == 'object' && toString.call(value) == dateClass || false;\n    }\n\n    /**\n     * Checks if `value` is a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     */\n    function isElement(value) {\n      return value && value.nodeType === 1 || false;\n    }\n\n    /**\n     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a\n     * length of `0` and objects with no own enumerable properties are considered\n     * \"empty\".\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object|string} value The value to inspect.\n     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({});\n     * // => true\n     *\n     * _.isEmpty('');\n     * // => true\n     */\n    function isEmpty(value) {\n      var result = true;\n      if (!value) {\n        return result;\n      }\n      var className = toString.call(value),\n          length = value.length;\n\n      if ((className == arrayClass || className == stringClass ||\n          (support.argsClass ? className == argsClass : isArguments(value))) ||\n          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {\n        return !length;\n      }\n      forOwn(value, function() {\n        return (result = false);\n      });\n      return result;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent to each other. If a callback is provided it will be executed\n     * to compare values. If the callback returns `undefined` comparisons will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (a, b).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} a The value to compare.\n     * @param {*} b The other value to compare.\n     * @param {Function} [callback] The function to customize comparing values.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var copy = { 'name': 'fred' };\n     *\n     * object == copy;\n     * // => false\n     *\n     * _.isEqual(object, copy);\n     * // => true\n     *\n     * var words = ['hello', 'goodbye'];\n     * var otherWords = ['hi', 'goodbye'];\n     *\n     * _.isEqual(words, otherWords, function(a, b) {\n     *   var reGreet = /^(?:hello|hi)$/i,\n     *       aGreet = _.isString(a) && reGreet.test(a),\n     *       bGreet = _.isString(b) && reGreet.test(b);\n     *\n     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;\n     * });\n     * // => true\n     */\n    function isEqual(a, b, callback, thisArg) {\n      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));\n    }\n\n    /**\n     * Checks if `value` is, or can be coerced to, a finite number.\n     *\n     * Note: This is not the same as native `isFinite` which will return true for\n     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.\n     * @example\n     *\n     * _.isFinite(-101);\n     * // => true\n     *\n     * _.isFinite('10');\n     * // => true\n     *\n     * _.isFinite(true);\n     * // => false\n     *\n     * _.isFinite('');\n     * // => false\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     */\n    function isFinite(value) {\n      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));\n    }\n\n    /**\n     * Checks if `value` is a function.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     */\n    function isFunction(value) {\n      return typeof value == 'function';\n    }\n    // fallback for older versions of Chrome and Safari\n    if (isFunction(/x/)) {\n      isFunction = function(value) {\n        return typeof value == 'function' && toString.call(value) == funcClass;\n      };\n    }\n\n    /**\n     * Checks if `value` is the language type of Object.\n     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(1);\n     * // => false\n     */\n    function isObject(value) {\n      // check if the value is the ECMAScript language type of Object\n      // http://es5.github.io/#x8\n      // and avoid a V8 bug\n      // http://code.google.com/p/v8/issues/detail?id=2291\n      return !!(value && objectTypes[typeof value]);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * Note: This is not the same as native `isNaN` which will return `true` for\n     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // `NaN` as a primitive is the only value that is not equal to itself\n      // (perform the [[Class]] check first to avoid errors with some host objects in IE)\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(undefined);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is a number.\n     *\n     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(8.4 * 5);\n     * // => true\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        value && typeof value == 'object' && toString.call(value) == numberClass || false;\n    }\n\n    /**\n     * Checks if `value` is an object created by the `Object` constructor.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * _.isPlainObject(new Shape);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     */\n    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {\n      if (!(value && toString.call(value) == objectClass) || (!support.argsClass && isArguments(value))) {\n        return false;\n      }\n      var valueOf = value.valueOf,\n          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);\n\n      return objProto\n        ? (value == objProto || getPrototypeOf(value) == objProto)\n        : shimIsPlainObject(value);\n    };\n\n    /**\n     * Checks if `value` is a regular expression.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.\n     * @example\n     *\n     * _.isRegExp(/fred/);\n     * // => true\n     */\n    function isRegExp(value) {\n      return value && objectTypes[typeof value] && toString.call(value) == regexpClass || false;\n    }\n\n    /**\n     * Checks if `value` is a string.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('fred');\n     * // => true\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        value && typeof value == 'object' && toString.call(value) == stringClass || false;\n    }\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     */\n    function isUndefined(value) {\n      return typeof value == 'undefined';\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated by\n     * running each own enumerable property of `object` through the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new object with values of the results of each `callback` execution.\n     * @example\n     *\n     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     *\n     * var characters = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.mapValues(characters, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 }\n     */\n    function mapValues(object, callback, thisArg) {\n      var result = {};\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      forOwn(object, function(value, key, object) {\n        result[key] = callback(value, key, object);\n      });\n      return result;\n    }\n\n    /**\n     * Recursively merges own enumerable properties of the source object(s), that\n     * don't resolve to `undefined` into the destination object. Subsequent sources\n     * will overwrite property assignments of previous sources. If a callback is\n     * provided it will be executed to produce the merged values of the destination\n     * and source properties. If the callback returns `undefined` merging will\n     * be handled by the method instead. The callback is bound to `thisArg` and\n     * invoked with two arguments; (objectValue, sourceValue).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The destination object.\n     * @param {...Object} [source] The source objects.\n     * @param {Function} [callback] The function to customize merging properties.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the destination object.\n     * @example\n     *\n     * var names = {\n     *   'characters': [\n     *     { 'name': 'barney' },\n     *     { 'name': 'fred' }\n     *   ]\n     * };\n     *\n     * var ages = {\n     *   'characters': [\n     *     { 'age': 36 },\n     *     { 'age': 40 }\n     *   ]\n     * };\n     *\n     * _.merge(names, ages);\n     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n     *\n     * var food = {\n     *   'fruits': ['apple'],\n     *   'vegetables': ['beet']\n     * };\n     *\n     * var otherFood = {\n     *   'fruits': ['banana'],\n     *   'vegetables': ['carrot']\n     * };\n     *\n     * _.merge(food, otherFood, function(a, b) {\n     *   return _.isArray(a) ? a.concat(b) : undefined;\n     * });\n     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }\n     */\n    function merge(object) {\n      var args = arguments,\n          length = 2;\n\n      if (!isObject(object)) {\n        return object;\n      }\n      // allows working with `_.reduce` and `_.reduceRight` without using\n      // their `index` and `collection` arguments\n      if (typeof args[2] != 'number') {\n        length = args.length;\n      }\n      if (length > 3 && typeof args[length - 2] == 'function') {\n        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);\n      } else if (length > 2 && typeof args[length - 1] == 'function') {\n        callback = args[--length];\n      }\n      var sources = slice(arguments, 1, length),\n          index = -1,\n          stackA = getArray(),\n          stackB = getArray();\n\n      while (++index < length) {\n        baseMerge(object, sources[index], callback, stackA, stackB);\n      }\n      releaseArray(stackA);\n      releaseArray(stackB);\n      return object;\n    }\n\n    /**\n     * Creates a shallow clone of `object` excluding the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` omitting the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The properties to omit or the\n     *  function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object without the omitted properties.\n     * @example\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');\n     * // => { 'name': 'fred' }\n     *\n     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {\n     *   return typeof value == 'number';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function omit(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var props = [];\n        forIn(object, function(value, key) {\n          props.push(key);\n        });\n        props = baseDifference(props, baseFlatten(arguments, true, false, 1));\n\n        var index = -1,\n            length = props.length;\n\n        while (++index < length) {\n          var key = props[index];\n          result[key] = object[key];\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (!callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates a two dimensional array of an object's key-value pairs,\n     * i.e. `[[key1, value1], [key2, value2]]`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns new array of key-value pairs.\n     * @example\n     *\n     * _.pairs({ 'barney': 36, 'fred': 40 });\n     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)\n     */\n    function pairs(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        var key = props[index];\n        result[index] = [key, object[key]];\n      }\n      return result;\n    }\n\n    /**\n     * Creates a shallow clone of `object` composed of the specified properties.\n     * Property names may be specified as individual arguments or as arrays of\n     * property names. If a callback is provided it will be executed for each\n     * property of `object` picking the properties the callback returns truey\n     * for. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The source object.\n     * @param {Function|...string|string[]} [callback] The function called per\n     *  iteration or property names to pick, specified as individual property\n     *  names or arrays of property names.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns an object composed of the picked properties.\n     * @example\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');\n     * // => { 'name': 'fred' }\n     *\n     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {\n     *   return key.charAt(0) != '_';\n     * });\n     * // => { 'name': 'fred' }\n     */\n    function pick(object, callback, thisArg) {\n      var result = {};\n      if (typeof callback != 'function') {\n        var index = -1,\n            props = baseFlatten(arguments, true, false, 1),\n            length = isObject(object) ? props.length : 0;\n\n        while (++index < length) {\n          var key = props[index];\n          if (key in object) {\n            result[key] = object[key];\n          }\n        }\n      } else {\n        callback = lodash.createCallback(callback, thisArg, 3);\n        forIn(object, function(value, key, object) {\n          if (callback(value, key, object)) {\n            result[key] = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * An alternative to `_.reduce` this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable properties through a callback, with each callback execution\n     * potentially mutating the `accumulator` object. The callback is bound to\n     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).\n     * Callbacks may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Array|Object} object The object to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {\n     *   num *= num;\n     *   if (num % 2) {\n     *     return result.push(num) < 3;\n     *   }\n     * });\n     * // => [1, 9, 25]\n     *\n     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     * });\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function transform(object, callback, accumulator, thisArg) {\n      var isArr = isArray(object);\n      if (accumulator == null) {\n        if (isArr) {\n          accumulator = [];\n        } else {\n          var ctor = object && object.constructor,\n              proto = ctor && ctor.prototype;\n\n          accumulator = baseCreate(proto);\n        }\n      }\n      if (callback) {\n        callback = lodash.createCallback(callback, thisArg, 4);\n        (isArr ? baseEach : forOwn)(object, function(value, index, object) {\n          return callback(accumulator, value, index, object);\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * Creates an array composed of the own enumerable property values of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @category Objects\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns an array of property values.\n     * @example\n     *\n     * _.values({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => [1, 2, 3] (property order is not guaranteed across environments)\n     */\n    function values(object) {\n      var index = -1,\n          props = keys(object),\n          length = props.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = object[props[index]];\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements from the specified indexes, or keys, of the\n     * `collection`. Indexes may be specified as individual arguments or as arrays\n     * of indexes.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`\n     *   to retrieve, specified as individual indexes or arrays of indexes.\n     * @returns {Array} Returns a new array of elements corresponding to the\n     *  provided indexes.\n     * @example\n     *\n     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);\n     * // => ['a', 'c', 'e']\n     *\n     * _.at(['fred', 'barney', 'pebbles'], 0, 2);\n     * // => ['fred', 'pebbles']\n     */\n    function at(collection) {\n      var args = arguments,\n          index = -1,\n          props = baseFlatten(args, true, false, 1),\n          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,\n          result = Array(length);\n\n      if (support.unindexedChars && isString(collection)) {\n        collection = collection.split('');\n      }\n      while(++index < length) {\n        result[index] = collection[props[index]];\n      }\n      return result;\n    }\n\n    /**\n     * Checks if a given value is present in a collection using strict equality\n     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the\n     * offset from the end of the collection.\n     *\n     * @static\n     * @memberOf _\n     * @alias include\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {*} target The value to check for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.\n     * @example\n     *\n     * _.contains([1, 2, 3], 1);\n     * // => true\n     *\n     * _.contains([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');\n     * // => true\n     *\n     * _.contains('pebbles', 'eb');\n     * // => true\n     */\n    function contains(collection, target, fromIndex) {\n      var index = -1,\n          indexOf = getIndexOf(),\n          length = collection ? collection.length : 0,\n          result = false;\n\n      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;\n      if (isArray(collection)) {\n        result = indexOf(collection, target, fromIndex) > -1;\n      } else if (typeof length == 'number') {\n        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;\n      } else {\n        baseEach(collection, function(value) {\n          if (++index >= fromIndex) {\n            return !(result = value === target);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` through the callback. The corresponding value\n     * of each key is the number of times the key was returned by the callback.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': 1, '6': 2 }\n     *\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);\n    });\n\n    /**\n     * Checks if the given callback returns truey value for **all** elements of\n     * a collection. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias all\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if all elements passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes']);\n     * // => false\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.every(characters, 'age');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.every(characters, { 'age': 36 });\n     * // => false\n     */\n    function every(collection, callback, thisArg) {\n      var result = true;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          if (!(result = !!callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          return (result = !!callback(value, index, collection));\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning an array of all elements\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias select\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that passed the callback check.\n     * @example\n     *\n     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [2, 4, 6]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.filter(characters, 'blocked');\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.filter(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     */\n    function filter(collection, callback, thisArg) {\n      var result = [];\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result.push(value);\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, returning the first element that\n     * the callback returns truey for. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias detect, findWhere\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.find(characters, function(chr) {\n     *   return chr.age < 40;\n     * });\n     * // => { 'name': 'barney', 'age': 36, 'blocked': false }\n     *\n     * // using \"_.where\" callback shorthand\n     * _.find(characters, { 'age': 1 });\n     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.find(characters, 'blocked');\n     * // => { 'name': 'fred', 'age': 40, 'blocked': true }\n     */\n    function find(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (callback(value, index, collection)) {\n            return value;\n          }\n        }\n      } else {\n        var result;\n        baseEach(collection, function(value, index, collection) {\n          if (callback(value, index, collection)) {\n            result = value;\n            return false;\n          }\n        });\n        return result;\n      }\n    }\n\n    /**\n     * This method is like `_.find` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the found element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(num) {\n     *   return num % 2 == 1;\n     * });\n     * // => 3\n     */\n    function findLast(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      forEachRight(collection, function(value, index, collection) {\n        if (callback(value, index, collection)) {\n          result = value;\n          return false;\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Iterates over elements of a collection, executing the callback for each\n     * element. The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection). Callbacks may exit iteration early by\n     * explicitly returning `false`.\n     *\n     * Note: As with other \"Collections\" methods, objects with a `length` property\n     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`\n     * may be used for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @alias each\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');\n     * // => logs each number and returns '1,2,3'\n     *\n     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });\n     * // => logs each number and returns the object (property order is not guaranteed across environments)\n     */\n    function forEach(collection, callback, thisArg) {\n      if (callback && typeof thisArg == 'undefined' && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          if (callback(collection[index], index, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        baseEach(collection, callback, thisArg);\n      }\n      return collection;\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias eachRight\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array|Object|string} Returns `collection`.\n     * @example\n     *\n     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');\n     * // => logs each number from right to left and returns '3,2,1'\n     */\n    function forEachRight(collection, callback, thisArg) {\n      var iterable = collection,\n          length = collection ? collection.length : 0;\n\n      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);\n      if (isArray(collection)) {\n        while (length--) {\n          if (callback(collection[length], length, collection) === false) {\n            break;\n          }\n        }\n      } else {\n        if (typeof length != 'number') {\n          var props = keys(collection);\n          length = props.length;\n        } else if (support.unindexedChars && isString(collection)) {\n          iterable = collection.split('');\n        }\n        baseEach(collection, function(value, key, collection) {\n          key = props ? props[--length] : --length;\n          return callback(iterable[key], key, collection);\n        });\n      }\n      return collection;\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of a collection through the callback. The corresponding value\n     * of each key is an array of the elements responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);\n     * // => { '4': [4.2], '6': [6.1, 6.4] }\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of the collection through the given callback. The corresponding\n     * value of each key is the last element responsible for generating the key.\n     * The callback is bound to `thisArg` and invoked with three arguments;\n     * (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var keys = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.indexBy(keys, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     */\n    var indexBy = createAggregator(function(result, value, key) {\n      result[key] = value;\n    });\n\n    /**\n     * Invokes the method named by `methodName` on each element in the `collection`\n     * returning an array of the results of each invoked method. Additional arguments\n     * will be provided to each invoked method. If `methodName` is a function it\n     * will be invoked for, and `this` bound to, each element in the `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|string} methodName The name of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [arg] Arguments to invoke the method with.\n     * @returns {Array} Returns a new array of the results of each invoked method.\n     * @example\n     *\n     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invoke([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    function invoke(collection, methodName) {\n      var args = slice(arguments, 2),\n          index = -1,\n          isFunc = typeof methodName == 'function',\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an array of values by running each element in the collection\n     * through the callback. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias collect\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of the results of each `callback` execution.\n     * @example\n     *\n     * _.map([1, 2, 3], function(num) { return num * 3; });\n     * // => [3, 6, 9]\n     *\n     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });\n     * // => [3, 6, 9] (property order is not guaranteed across environments)\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, callback, thisArg) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      if (isArray(collection)) {\n        while (++index < length) {\n          result[index] = callback(collection[index], index, collection);\n        }\n      } else {\n        baseEach(collection, function(value, key, collection) {\n          result[++index] = callback(value, key, collection);\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the maximum value of a collection. If the collection is empty or\n     * falsey `-Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.max(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'fred', 'age': 40 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.max(characters, 'age');\n     * // => { 'name': 'fred', 'age': 40 };\n     */\n    function max(collection, callback, thisArg) {\n      var computed = -Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value > result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        baseEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current > computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the minimum value of a collection. If the collection is empty or\n     * falsey `Infinity` is returned. If a callback is provided it will be executed\n     * for each value in the collection to generate the criterion by which the value\n     * is ranked. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.min(characters, function(chr) { return chr.age; });\n     * // => { 'name': 'barney', 'age': 36 };\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.min(characters, 'age');\n     * // => { 'name': 'barney', 'age': 36 };\n     */\n    function min(collection, callback, thisArg) {\n      var computed = Infinity,\n          result = computed;\n\n      // allows working with functions like `_.map` without using\n      // their `index` argument as a callback\n      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {\n        callback = null;\n      }\n      if (callback == null && isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          var value = collection[index];\n          if (value < result) {\n            result = value;\n          }\n        }\n      } else {\n        callback = (callback == null && isString(collection))\n          ? charAtCallback\n          : lodash.createCallback(callback, thisArg, 3);\n\n        baseEach(collection, function(value, index, collection) {\n          var current = callback(value, index, collection);\n          if (current < computed) {\n            computed = current;\n            result = value;\n          }\n        });\n      }\n      return result;\n    }\n\n    /**\n     * Retrieves the value of a specified property from all elements in the collection.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {string} property The name of the property to pluck.\n     * @returns {Array} Returns a new array of property values.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * _.pluck(characters, 'name');\n     * // => ['barney', 'fred']\n     */\n    var pluck = map;\n\n    /**\n     * Reduces a collection to a value which is the accumulated result of running\n     * each element in the collection through the callback, where each successive\n     * callback execution consumes the return value of the previous execution. If\n     * `accumulator` is not provided the first element of the collection will be\n     * used as the initial `accumulator` value. The callback is bound to `thisArg`\n     * and invoked with four arguments; (accumulator, value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @alias foldl, inject\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var sum = _.reduce([1, 2, 3], function(sum, num) {\n     *   return sum + num;\n     * });\n     * // => 6\n     *\n     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {\n     *   result[key] = num * 3;\n     *   return result;\n     * }, {});\n     * // => { 'a': 3, 'b': 6, 'c': 9 }\n     */\n    function reduce(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        if (noaccum) {\n          accumulator = collection[++index];\n        }\n        while (++index < length) {\n          accumulator = callback(accumulator, collection[index], index, collection);\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          accumulator = noaccum\n            ? (noaccum = false, value)\n            : callback(accumulator, value, index, collection)\n        });\n      }\n      return accumulator;\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @alias foldr\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function} [callback=identity] The function called per iteration.\n     * @param {*} [accumulator] Initial value of the accumulator.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * var list = [[0, 1], [2, 3], [4, 5]];\n     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, callback, accumulator, thisArg) {\n      var noaccum = arguments.length < 3;\n      callback = lodash.createCallback(callback, thisArg, 4);\n      forEachRight(collection, function(value, index, collection) {\n        accumulator = noaccum\n          ? (noaccum = false, value)\n          : callback(accumulator, value, index, collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The opposite of `_.filter` this method returns the elements of a\n     * collection that the callback does **not** return truey for.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of elements that failed the callback check.\n     * @example\n     *\n     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });\n     * // => [1, 3, 5]\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.reject(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.reject(characters, { 'age': 36 });\n     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]\n     */\n    function reject(collection, callback, thisArg) {\n      callback = lodash.createCallback(callback, thisArg, 3);\n      return filter(collection, function(value, index, collection) {\n        return !callback(value, index, collection);\n      });\n    }\n\n    /**\n     * Retrieves a random element or `n` random elements from a collection.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to sample.\n     * @param {number} [n] The number of elements to sample.\n     * @param- {Object} [guard] Allows working with functions like `_.map`\n     *  without using their `index` arguments as `n`.\n     * @returns {Array} Returns the random sample(s) of `collection`.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     *\n     * _.sample([1, 2, 3, 4], 2);\n     * // => [3, 1]\n     */\n    function sample(collection, n, guard) {\n      if (collection && typeof collection.length != 'number') {\n        collection = values(collection);\n      } else if (support.unindexedChars && isString(collection)) {\n        collection = collection.split('');\n      }\n      if (n == null || guard) {\n        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;\n      }\n      var result = shuffle(collection);\n      result.length = nativeMin(nativeMax(0, n), result.length);\n      return result;\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the Fisher-Yates\n     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to shuffle.\n     * @returns {Array} Returns a new shuffled collection.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4, 5, 6]);\n     * // => [4, 1, 6, 3, 5, 2]\n     */\n    function shuffle(collection) {\n      var index = -1,\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      forEach(collection, function(value) {\n        var rand = baseRandom(0, ++index);\n        result[index] = result[rand];\n        result[rand] = value;\n      });\n      return result;\n    }\n\n    /**\n     * Gets the size of the `collection` by returning `collection.length` for arrays\n     * and array-like objects or the number of own enumerable properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns `collection.length` or number of own enumerable properties.\n     * @example\n     *\n     * _.size([1, 2]);\n     * // => 2\n     *\n     * _.size({ 'one': 1, 'two': 2, 'three': 3 });\n     * // => 3\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      var length = collection ? collection.length : 0;\n      return typeof length == 'number' ? length : keys(collection).length;\n    }\n\n    /**\n     * Checks if the callback returns a truey value for **any** element of a\n     * collection. The function returns as soon as it finds a passing value and\n     * does not iterate over the entire collection. The callback is bound to\n     * `thisArg` and invoked with three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias any\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {boolean} Returns `true` if any element passed the callback check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'blocked': false },\n     *   { 'name': 'fred',   'age': 40, 'blocked': true }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.some(characters, 'blocked');\n     * // => true\n     *\n     * // using \"_.where\" callback shorthand\n     * _.some(characters, { 'age': 1 });\n     * // => false\n     */\n    function some(collection, callback, thisArg) {\n      var result;\n      callback = lodash.createCallback(callback, thisArg, 3);\n\n      if (isArray(collection)) {\n        var index = -1,\n            length = collection.length;\n\n        while (++index < length) {\n          if ((result = callback(collection[index], index, collection))) {\n            break;\n          }\n        }\n      } else {\n        baseEach(collection, function(value, index, collection) {\n          return !(result = callback(value, index, collection));\n        });\n      }\n      return !!result;\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection through the callback. This method\n     * performs a stable sort, that is, it will preserve the original sort order\n     * of equal elements. The callback is bound to `thisArg` and invoked with\n     * three arguments; (value, index|key, collection).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an array of property names is provided for `callback` the collection\n     * will be sorted by each property value.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Array|Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of sorted elements.\n     * @example\n     *\n     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });\n     * // => [3, 1, 2]\n     *\n     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);\n     * // => [3, 1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'barney',  'age': 26 },\n     *   { 'name': 'fred',    'age': 30 }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.map(_.sortBy(characters, 'age'), _.values);\n     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]\n     *\n     * // sorting by multiple properties\n     * _.map(_.sortBy(characters, ['name', 'age']), _.values);\n     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]\n     */\n    function sortBy(collection, callback, thisArg) {\n      var index = -1,\n          isArr = isArray(callback),\n          length = collection ? collection.length : 0,\n          result = Array(typeof length == 'number' ? length : 0);\n\n      if (!isArr) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      forEach(collection, function(value, key, collection) {\n        var object = result[++index] = getObject();\n        if (isArr) {\n          object.criteria = map(callback, function(key) { return value[key]; });\n        } else {\n          (object.criteria = getArray())[0] = callback(value, key, collection);\n        }\n        object.index = index;\n        object.value = value;\n      });\n\n      length = result.length;\n      result.sort(compareAscending);\n      while (length--) {\n        var object = result[length];\n        result[length] = object.value;\n        if (!isArr) {\n          releaseArray(object.criteria);\n        }\n        releaseObject(object);\n      }\n      return result;\n    }\n\n    /**\n     * Converts the `collection` to an array.\n     *\n     * @static\n     * @memberOf _\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to convert.\n     * @returns {Array} Returns the new converted array.\n     * @example\n     *\n     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);\n     * // => [2, 3, 4]\n     */\n    function toArray(collection) {\n      if (collection && typeof collection.length == 'number') {\n        return (support.unindexedChars && isString(collection))\n          ? collection.split('')\n          : slice(collection);\n      }\n      return values(collection);\n    }\n\n    /**\n     * Performs a deep comparison of each element in a `collection` to the given\n     * `properties` object, returning an array of all elements that have equivalent\n     * property values.\n     *\n     * @static\n     * @memberOf _\n     * @type Function\n     * @category Collections\n     * @param {Array|Object|string} collection The collection to iterate over.\n     * @param {Object} props The object of property values to filter by.\n     * @returns {Array} Returns a new array of elements that have the given properties.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * _.where(characters, { 'age': 36 });\n     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]\n     *\n     * _.where(characters, { 'pets': ['dino'] });\n     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]\n     */\n    var where = filter;\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are all falsey.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array excluding all values of the provided arrays using strict\n     * equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {...Array} [values] The arrays of values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);\n     * // => [1, 3, 4]\n     */\n    function difference(array) {\n      return baseDifference(array, baseFlatten(arguments, true, true, 1));\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element that passes the callback check, instead of the element itself.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': false },\n     *   { 'name': 'fred',    'age': 40, 'blocked': true },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }\n     * ];\n     *\n     * _.findIndex(characters, function(chr) {\n     *   return chr.age < 20;\n     * });\n     * // => 2\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findIndex(characters, 'blocked');\n     * // => 1\n     */\n    function findIndex(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        if (callback(array[index], index, array)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of a `collection` from right to left.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36, 'blocked': true },\n     *   { 'name': 'fred',    'age': 40, 'blocked': false },\n     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }\n     * ];\n     *\n     * _.findLastIndex(characters, function(chr) {\n     *   return chr.age > 30;\n     * });\n     * // => 1\n     *\n     * // using \"_.where\" callback shorthand\n     * _.findLastIndex(characters, { 'age': 36 });\n     * // => 0\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.findLastIndex(characters, 'blocked');\n     * // => 2\n     */\n    function findLastIndex(array, callback, thisArg) {\n      var length = array ? array.length : 0;\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (length--) {\n        if (callback(array[length], length, array)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Gets the first element or first `n` elements of an array. If a callback\n     * is provided elements at the beginning of the array are returned as long\n     * as the callback returns truey. The callback is bound to `thisArg` and\n     * invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias head, take\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the first element(s) of `array`.\n     * @example\n     *\n     * _.first([1, 2, 3]);\n     * // => 1\n     *\n     * _.first([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.first([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [1, 2]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.first(characters, 'blocked');\n     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function first(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = -1;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[0] : undefined;\n        }\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, n), length));\n    }\n\n    /**\n     * Flattens a nested array (the nesting can be to any depth). If `isShallow`\n     * is truey, the array will only be flattened a single level. If a callback\n     * is provided each element of the array is passed through the callback before\n     * flattening. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to flatten.\n     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2], [3, [[4]]]]);\n     * // => [1, 2, 3, 4];\n     *\n     * _.flatten([1, [2], [3, [[4]]]], true);\n     * // => [1, 2, 3, [[4]]];\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },\n     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.flatten(characters, 'pets');\n     * // => ['hoppy', 'baby puss', 'dino']\n     */\n    function flatten(array, isShallow, callback, thisArg) {\n      // juggle arguments\n      if (typeof isShallow != 'boolean' && isShallow != null) {\n        thisArg = callback;\n        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;\n        isShallow = false;\n      }\n      if (callback != null) {\n        array = map(array, callback, thisArg);\n      }\n      return baseFlatten(array, isShallow);\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found using\n     * strict equality for comparisons, i.e. `===`. If the array is already sorted\n     * providing `true` for `fromIndex` will run a faster binary search.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {boolean|number} [fromIndex=0] The index to search from or `true`\n     *  to perform a binary search on a sorted array.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 1\n     *\n     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 4\n     *\n     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);\n     * // => 2\n     */\n    function indexOf(array, value, fromIndex) {\n      if (typeof fromIndex == 'number') {\n        var length = array ? array.length : 0;\n        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);\n      } else if (fromIndex) {\n        var index = sortedIndex(array, value);\n        return array[index] === value ? index : -1;\n      }\n      return baseIndexOf(array, value, fromIndex);\n    }\n\n    /**\n     * Gets all but the last element or last `n` elements of an array. If a\n     * callback is provided elements at the end of the array are excluded from\n     * the result as long as the callback returns truey. The callback is bound\n     * to `thisArg` and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.initial([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.initial([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [1]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.initial(characters, 'blocked');\n     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]\n     *\n     * // using \"_.where\" callback shorthand\n     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');\n     * // => ['barney', 'fred']\n     */\n    function initial(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : callback || n;\n      }\n      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));\n    }\n\n    /**\n     * Creates an array of unique values present in all provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of shared values.\n     * @example\n     *\n     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2]\n     */\n    function intersection() {\n      var args = [],\n          argsIndex = -1,\n          argsLength = arguments.length,\n          caches = getArray(),\n          indexOf = getIndexOf(),\n          trustIndexOf = indexOf === baseIndexOf,\n          seen = getArray();\n\n      while (++argsIndex < argsLength) {\n        var value = arguments[argsIndex];\n        if (isArray(value) || isArguments(value)) {\n          args.push(value);\n          caches.push(trustIndexOf && value.length >= largeArraySize &&\n            createCache(argsIndex ? args[argsIndex] : seen));\n        }\n      }\n      var array = args[0],\n          index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      outer:\n      while (++index < length) {\n        var cache = caches[0];\n        value = array[index];\n\n        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {\n          argsIndex = argsLength;\n          (cache || seen).push(value);\n          while (--argsIndex) {\n            cache = caches[argsIndex];\n            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n      }\n      while (argsLength--) {\n        cache = caches[argsLength];\n        if (cache) {\n          releaseObject(cache);\n        }\n      }\n      releaseArray(caches);\n      releaseArray(seen);\n      return result;\n    }\n\n    /**\n     * Gets the last element or last `n` elements of an array. If a callback is\n     * provided elements at the end of the array are returned as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback] The function called\n     *  per element or the number of elements to return. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {*} Returns the last element(s) of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     *\n     * _.last([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.last([1, 2, 3], function(num) {\n     *   return num > 1;\n     * });\n     * // => [2, 3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.last(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.last(characters, { 'employer': 'na' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function last(array, callback, thisArg) {\n      var n = 0,\n          length = array ? array.length : 0;\n\n      if (typeof callback != 'number' && callback != null) {\n        var index = length;\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (index-- && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = callback;\n        if (n == null || thisArg) {\n          return array ? array[length - 1] : undefined;\n        }\n      }\n      return slice(array, nativeMax(0, length - n));\n    }\n\n    /**\n     * Gets the index at which the last occurrence of `value` is found using strict\n     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used\n     * as the offset from the end of the collection.\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to search.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value or `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);\n     * // => 4\n     *\n     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var index = array ? array.length : 0;\n      if (typeof fromIndex == 'number') {\n        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;\n      }\n      while (index--) {\n        if (array[index] === value) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Removes all provided values from the given array using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {...*} [value] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3, 1, 2, 3];\n     * _.pull(array, 2, 3);\n     * console.log(array);\n     * // => [1, 1]\n     */\n    function pull(array) {\n      var args = arguments,\n          argsIndex = 0,\n          argsLength = args.length,\n          length = array ? array.length : 0;\n\n      while (++argsIndex < argsLength) {\n        var index = -1,\n            value = args[argsIndex];\n        while (++index < length) {\n          if (array[index] === value) {\n            splice.call(array, index--, 1);\n            length--;\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to but not including `end`. If `start` is less than `stop` a\n     * zero-length range is created unless a negative `step` is specified.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns a new range array.\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    function range(start, end, step) {\n      start = +start || 0;\n      step = typeof step == 'number' ? step : (+step || 1);\n\n      if (end == null) {\n        end = start;\n        start = 0;\n      }\n      // use `Array(length)` so engines like Chakra and V8 avoid slower modes\n      // http://youtu.be/XAqIpGU8ZZk#t=17m25s\n      var index = -1,\n          length = nativeMax(0, ceil((end - start) / (step || 1))),\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * Removes all elements from an array that the callback returns truey for\n     * and returns an array of removed elements. The callback is bound to `thisArg`\n     * and invoked with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to modify.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4, 5, 6];\n     * var evens = _.remove(array, function(num) { return num % 2 == 0; });\n     *\n     * console.log(array);\n     * // => [1, 3, 5]\n     *\n     * console.log(evens);\n     * // => [2, 4, 6]\n     */\n    function remove(array, callback, thisArg) {\n      var index = -1,\n          length = array ? array.length : 0,\n          result = [];\n\n      callback = lodash.createCallback(callback, thisArg, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (callback(value, index, array)) {\n          result.push(value);\n          splice.call(array, index--, 1);\n          length--;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The opposite of `_.initial` this method gets all but the first element or\n     * first `n` elements of an array. If a callback function is provided elements\n     * at the beginning of the array are excluded from the result as long as the\n     * callback returns truey. The callback is bound to `thisArg` and invoked\n     * with three arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias drop, tail\n     * @category Arrays\n     * @param {Array} array The array to query.\n     * @param {Function|Object|number|string} [callback=1] The function called\n     *  per element or the number of elements to exclude. If a property name or\n     *  object is provided it will be used to create a \"_.pluck\" or \"_.where\"\n     *  style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a slice of `array`.\n     * @example\n     *\n     * _.rest([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.rest([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.rest([1, 2, 3], function(num) {\n     *   return num < 3;\n     * });\n     * // => [3]\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },\n     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },\n     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }\n     * ];\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.pluck(_.rest(characters, 'blocked'), 'name');\n     * // => ['fred', 'pebbles']\n     *\n     * // using \"_.where\" callback shorthand\n     * _.rest(characters, { 'employer': 'slate' });\n     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]\n     */\n    function rest(array, callback, thisArg) {\n      if (typeof callback != 'number' && callback != null) {\n        var n = 0,\n            index = -1,\n            length = array ? array.length : 0;\n\n        callback = lodash.createCallback(callback, thisArg, 3);\n        while (++index < length && callback(array[index], index, array)) {\n          n++;\n        }\n      } else {\n        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);\n      }\n      return slice(array, n);\n    }\n\n    /**\n     * Uses a binary search to determine the smallest index at which a value\n     * should be inserted into a given sorted array in order to maintain the sort\n     * order of the array. If a callback is provided it will be executed for\n     * `value` and each element of `array` to compute their sort ranking. The\n     * callback is bound to `thisArg` and invoked with one argument; (value).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([20, 30, 50], 40);\n     * // => 2\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');\n     * // => 2\n     *\n     * var dict = {\n     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }\n     * };\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return dict.wordToNumber[word];\n     * });\n     * // => 2\n     *\n     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {\n     *   return this.wordToNumber[word];\n     * }, dict);\n     * // => 2\n     */\n    function sortedIndex(array, value, callback, thisArg) {\n      var low = 0,\n          high = array ? array.length : low;\n\n      // explicitly reference `identity` for better inlining in Firefox\n      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;\n      value = callback(value);\n\n      while (low < high) {\n        var mid = (low + high) >>> 1;\n        (callback(array[mid]) < value)\n          ? low = mid + 1\n          : high = mid;\n      }\n      return low;\n    }\n\n    /**\n     * Creates an array of unique values, in order, of the provided arrays using\n     * strict equality for comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of combined values.\n     * @example\n     *\n     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);\n     * // => [1, 2, 3, 5, 4]\n     */\n    function union() {\n      return baseUniq(baseFlatten(arguments, true, true));\n    }\n\n    /**\n     * Creates a duplicate-value-free version of an array using strict equality\n     * for comparisons, i.e. `===`. If the array is sorted, providing\n     * `true` for `isSorted` will use a faster algorithm. If a callback is provided\n     * each element of `array` is passed through the callback before uniqueness\n     * is computed. The callback is bound to `thisArg` and invoked with three\n     * arguments; (value, index, array).\n     *\n     * If a property name is provided for `callback` the created \"_.pluck\" style\n     * callback will return the property value of the given element.\n     *\n     * If an object is provided for `callback` the created \"_.where\" style callback\n     * will return `true` for elements that have the properties of the given object,\n     * else `false`.\n     *\n     * @static\n     * @memberOf _\n     * @alias unique\n     * @category Arrays\n     * @param {Array} array The array to process.\n     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.\n     * @param {Function|Object|string} [callback=identity] The function called\n     *  per iteration. If a property name or object is provided it will be used\n     *  to create a \"_.pluck\" or \"_.where\" style callback, respectively.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns a duplicate-value-free array.\n     * @example\n     *\n     * _.uniq([1, 2, 1, 3, 1]);\n     * // => [1, 2, 3]\n     *\n     * _.uniq([1, 1, 2, 2, 3], true);\n     * // => [1, 2, 3]\n     *\n     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });\n     * // => ['A', 'b', 'C']\n     *\n     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);\n     * // => [1, 2.5, 3]\n     *\n     * // using \"_.pluck\" callback shorthand\n     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniq(array, isSorted, callback, thisArg) {\n      // juggle arguments\n      if (typeof isSorted != 'boolean' && isSorted != null) {\n        thisArg = callback;\n        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;\n        isSorted = false;\n      }\n      if (callback != null) {\n        callback = lodash.createCallback(callback, thisArg, 3);\n      }\n      return baseUniq(array, isSorted, callback);\n    }\n\n    /**\n     * Creates an array excluding all provided values using strict equality for\n     * comparisons, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {Array} array The array to filter.\n     * @param {...*} [value] The values to exclude.\n     * @returns {Array} Returns a new array of filtered values.\n     * @example\n     *\n     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);\n     * // => [2, 3, 4]\n     */\n    function without(array) {\n      return baseDifference(array, slice(arguments, 1));\n    }\n\n    /**\n     * Creates an array that is the symmetric difference of the provided arrays.\n     * See http://en.wikipedia.org/wiki/Symmetric_difference.\n     *\n     * @static\n     * @memberOf _\n     * @category Arrays\n     * @param {...Array} [array] The arrays to inspect.\n     * @returns {Array} Returns an array of values.\n     * @example\n     *\n     * _.xor([1, 2, 3], [5, 2, 1, 4]);\n     * // => [3, 5, 4]\n     *\n     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);\n     * // => [1, 4, 5]\n     */\n    function xor() {\n      var index = -1,\n          length = arguments.length;\n\n      while (++index < length) {\n        var array = arguments[index];\n        if (isArray(array) || isArguments(array)) {\n          var result = result\n            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))\n            : array;\n        }\n      }\n      return result || [];\n    }\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the first\n     * elements of the given arrays, the second of which contains the second\n     * elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @alias unzip\n     * @category Arrays\n     * @param {...Array} [array] Arrays to process.\n     * @returns {Array} Returns a new array of grouped elements.\n     * @example\n     *\n     * _.zip(['fred', 'barney'], [30, 40], [true, false]);\n     * // => [['fred', 30, true], ['barney', 40, false]]\n     */\n    function zip() {\n      var array = arguments.length > 1 ? arguments : arguments[0],\n          index = -1,\n          length = array ? max(pluck(array, 'length')) : 0,\n          result = Array(length < 0 ? 0 : length);\n\n      while (++index < length) {\n        result[index] = pluck(array, index);\n      }\n      return result;\n    }\n\n    /**\n     * Creates an object composed from arrays of `keys` and `values`. Provide\n     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`\n     * or two arrays, one of `keys` and one of corresponding `values`.\n     *\n     * @static\n     * @memberOf _\n     * @alias object\n     * @category Arrays\n     * @param {Array} keys The array of keys.\n     * @param {Array} [values=[]] The array of values.\n     * @returns {Object} Returns an object composed of the given keys and\n     *  corresponding values.\n     * @example\n     *\n     * _.zipObject(['fred', 'barney'], [30, 40]);\n     * // => { 'fred': 30, 'barney': 40 }\n     */\n    function zipObject(keys, values) {\n      var index = -1,\n          length = keys ? keys.length : 0,\n          result = {};\n\n      if (!values && length && !isArray(keys[0])) {\n        values = [];\n      }\n      while (++index < length) {\n        var key = keys[index];\n        if (values) {\n          result[key] = values[index];\n        } else if (key) {\n          result[key[0]] = key[1];\n        }\n      }\n      return result;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that executes `func`, with  the `this` binding and\n     * arguments of the created function, only after being called `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {number} n The number of times the function must be called before\n     *  `func` is executed.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('Done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => logs 'Done saving!', after all saves have completed\n     */\n    function after(n, func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with the `this`\n     * binding of `thisArg` and prepends any additional `bind` arguments to those\n     * provided to the bound function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to bind.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var func = function(greeting) {\n     *   return greeting + ' ' + this.name;\n     * };\n     *\n     * func = _.bind(func, { 'name': 'fred' }, 'hi');\n     * func();\n     * // => 'hi fred'\n     */\n    function bind(func, thisArg) {\n      return arguments.length > 2\n        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)\n        : createWrapper(func, 1, null, null, thisArg);\n    }\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method. Method names may be specified as individual arguments or as arrays\n     * of method names. If no method names are provided all the function properties\n     * of `object` will be bound.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...string} [methodName] The object method names to\n     *  bind, specified as individual method names or arrays of method names.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'onClick': function() { console.log('clicked ' + this.label); }\n     * };\n     *\n     * _.bindAll(view);\n     * jQuery('#docs').on('click', view.onClick);\n     * // => logs 'clicked docs', when the button is clicked\n     */\n    function bindAll(object) {\n      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),\n          index = -1,\n          length = funcs.length;\n\n      while (++index < length) {\n        var key = funcs[index];\n        object[key] = createWrapper(object[key], 1, null, null, object);\n      }\n      return object;\n    }\n\n    /**\n     * Creates a function that, when called, invokes the method at `object[key]`\n     * and prepends any additional `bindKey` arguments to those provided to the bound\n     * function. This method differs from `_.bind` by allowing bound functions to\n     * reference methods that will be redefined or don't yet exist.\n     * See http://michaux.ca/articles/lazy-function-definition-pattern.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Object} object The object the method belongs to.\n     * @param {string} key The key of the method.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'name': 'fred',\n     *   'greet': function(greeting) {\n     *     return greeting + ' ' + this.name;\n     *   }\n     * };\n     *\n     * var func = _.bindKey(object, 'greet', 'hi');\n     * func();\n     * // => 'hi fred'\n     *\n     * object.greet = function(greeting) {\n     *   return greeting + 'ya ' + this.name + '!';\n     * };\n     *\n     * func();\n     * // => 'hiya fred!'\n     */\n    function bindKey(object, key) {\n      return arguments.length > 2\n        ? createWrapper(key, 19, slice(arguments, 2), null, object)\n        : createWrapper(key, 3, null, null, object);\n    }\n\n    /**\n     * Creates a function that is the composition of the provided functions,\n     * where each function consumes the return value of the function that follows.\n     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.\n     * Each function is executed with the `this` binding of the composed function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {...Function} [func] Functions to compose.\n     * @returns {Function} Returns the new composed function.\n     * @example\n     *\n     * var realNameMap = {\n     *   'pebbles': 'penelope'\n     * };\n     *\n     * var format = function(name) {\n     *   name = realNameMap[name.toLowerCase()] || name;\n     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();\n     * };\n     *\n     * var greet = function(formatted) {\n     *   return 'Hiya ' + formatted + '!';\n     * };\n     *\n     * var welcome = _.compose(greet, format);\n     * welcome('pebbles');\n     * // => 'Hiya Penelope!'\n     */\n    function compose() {\n      var funcs = arguments,\n          length = funcs.length;\n\n      while (length--) {\n        if (!isFunction(funcs[length])) {\n          throw new TypeError;\n        }\n      }\n      return function() {\n        var args = arguments,\n            length = funcs.length;\n\n        while (length--) {\n          args = [funcs[length].apply(this, args)];\n        }\n        return args[0];\n      };\n    }\n\n    /**\n     * Creates a function which accepts one or more arguments of `func` that when\n     * invoked either executes `func` returning its result, if all `func` arguments\n     * have been provided, or returns a function that accepts one or more of the\n     * remaining `func` arguments, and so on. The arity of `func` can be specified\n     * if `func.length` is not sufficient.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var curried = _.curry(function(a, b, c) {\n     *   console.log(a + b + c);\n     * });\n     *\n     * curried(1)(2)(3);\n     * // => 6\n     *\n     * curried(1, 2)(3);\n     * // => 6\n     *\n     * curried(1, 2, 3);\n     * // => 6\n     */\n    function curry(func, arity) {\n      arity = typeof arity == 'number' ? arity : (+arity || func.length);\n      return createWrapper(func, 4, null, null, null, arity);\n    }\n\n    /**\n     * Creates a function that will delay the execution of `func` until after\n     * `wait` milliseconds have elapsed since the last time it was invoked.\n     * Provide an options object to indicate that `func` should be invoked on\n     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls\n     * to the debounced function will return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the debounced function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to debounce.\n     * @param {number} wait The number of milliseconds to delay.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.\n     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // avoid costly calculations while the window size is in flux\n     * var lazyLayout = _.debounce(calculateLayout, 150);\n     * jQuery(window).on('resize', lazyLayout);\n     *\n     * // execute `sendMail` when the click event is fired, debouncing subsequent calls\n     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * });\n     *\n     * // ensure `batchLog` is executed once after 1 second of debounced calls\n     * var source = new EventSource('/stream');\n     * source.addEventListener('message', _.debounce(batchLog, 250, {\n     *   'maxWait': 1000\n     * }, false);\n     */\n    function debounce(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      wait = nativeMax(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if (isObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - (now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Defers executing the `func` function until the current call stack has cleared.\n     * Additional arguments will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to defer.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) { console.log(text); }, 'deferred');\n     * // logs 'deferred' after one or more milliseconds\n     */\n    function defer(func) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 1);\n      return setTimeout(function() { func.apply(undefined, args); }, 1);\n    }\n\n    /**\n     * Executes the `func` function after `wait` milliseconds. Additional arguments\n     * will be provided to `func` when it is invoked.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay execution.\n     * @param {...*} [arg] Arguments to invoke the function with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) { console.log(text); }, 1000, 'later');\n     * // => logs 'later' after one second\n     */\n    function delay(func, wait) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var args = slice(arguments, 2);\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided it will be used to determine the cache key for storing the result\n     * based on the arguments provided to the memoized function. By default, the\n     * first argument provided to the memoized function is used as the cache key.\n     * The `func` is executed with the `this` binding of the memoized function.\n     * The result cache is exposed as the `cache` property on the memoized function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] A function used to resolve the cache key.\n     * @returns {Function} Returns the new memoizing function.\n     * @example\n     *\n     * var fibonacci = _.memoize(function(n) {\n     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n     * });\n     *\n     * fibonacci(9)\n     * // => 34\n     *\n     * var data = {\n     *   'fred': { 'name': 'fred', 'age': 40 },\n     *   'pebbles': { 'name': 'pebbles', 'age': 1 }\n     * };\n     *\n     * // modifying the result cache\n     * var get = _.memoize(function(name) { return data[name]; }, _.identity);\n     * get('pebbles');\n     * // => { 'name': 'pebbles', 'age': 1 }\n     *\n     * get.cache.pebbles.name = 'penelope';\n     * get('pebbles');\n     * // => { 'name': 'penelope', 'age': 1 }\n     */\n    function memoize(func, resolver) {\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      var memoized = function() {\n        var cache = memoized.cache,\n            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];\n\n        return hasOwnProperty.call(cache, key)\n          ? cache[key]\n          : (cache[key] = func.apply(this, arguments));\n      }\n      memoized.cache = {};\n      return memoized;\n    }\n\n    /**\n     * Creates a function that is restricted to execute `func` once. Repeat calls to\n     * the function will return the value of the first call. The `func` is executed\n     * with the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // `initialize` executes `createApplication` once\n     */\n    function once(func) {\n      var ran,\n          result;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      return function() {\n        if (ran) {\n          return result;\n        }\n        ran = true;\n        result = func.apply(this, arguments);\n\n        // clear the `func` variable so the function may be garbage collected\n        func = null;\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that, when called, invokes `func` with any additional\n     * `partial` arguments prepended to those provided to the new function. This\n     * method is similar to `_.bind` except it does **not** alter the `this` binding.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var greet = function(greeting, name) { return greeting + ' ' + name; };\n     * var hi = _.partial(greet, 'hi');\n     * hi('fred');\n     * // => 'hi fred'\n     */\n    function partial(func) {\n      return createWrapper(func, 16, slice(arguments, 1));\n    }\n\n    /**\n     * This method is like `_.partial` except that `partial` arguments are\n     * appended to those provided to the new function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [arg] Arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * var defaultsDeep = _.partialRight(_.merge, _.defaults);\n     *\n     * var options = {\n     *   'variable': 'data',\n     *   'imports': { 'jq': $ }\n     * };\n     *\n     * defaultsDeep(options, _.templateSettings);\n     *\n     * options.variable\n     * // => 'data'\n     *\n     * options.imports\n     * // => { '_': _, 'jq': $ }\n     */\n    function partialRight(func) {\n      return createWrapper(func, 32, null, slice(arguments, 1));\n    }\n\n    /**\n     * Creates a function that, when executed, will only call the `func` function\n     * at most once per every `wait` milliseconds. Provide an options object to\n     * indicate that `func` should be invoked on the leading and/or trailing edge\n     * of the `wait` timeout. Subsequent calls to the throttled function will\n     * return the result of the last `func` call.\n     *\n     * Note: If `leading` and `trailing` options are `true` `func` will be called\n     * on the trailing edge of the timeout only if the the throttled function is\n     * invoked more than once during the `wait` timeout.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {Function} func The function to throttle.\n     * @param {number} wait The number of milliseconds to throttle executions to.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // avoid excessively updating the position while scrolling\n     * var throttled = _.throttle(updatePosition, 100);\n     * jQuery(window).on('scroll', throttled);\n     *\n     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes\n     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {\n     *   'trailing': false\n     * }));\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (!isFunction(func)) {\n        throw new TypeError;\n      }\n      if (options === false) {\n        leading = false;\n      } else if (isObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      debounceOptions.leading = leading;\n      debounceOptions.maxWait = wait;\n      debounceOptions.trailing = trailing;\n\n      return debounce(func, wait, debounceOptions);\n    }\n\n    /**\n     * Creates a function that provides `value` to the wrapper function as its\n     * first argument. Additional arguments provided to the function are appended\n     * to those provided to the wrapper function. The wrapper is executed with\n     * the `this` binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @category Functions\n     * @param {*} value The value to wrap.\n     * @param {Function} wrapper The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('Fred, Wilma, & Pebbles');\n     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return createWrapper(wrapper, 16, [value]);\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * var getter = _.constant(object);\n     * getter() === object;\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Produces a callback bound to an optional `thisArg`. If `func` is a property\n     * name the created callback will return the property value for a given element.\n     * If `func` is an object the created callback will return `true` for elements\n     * that contain the equivalent object properties, otherwise it will return `false`.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} [func=identity] The value to convert to a callback.\n     * @param {*} [thisArg] The `this` binding of the created callback.\n     * @param {number} [argCount] The number of arguments the callback accepts.\n     * @returns {Function} Returns a callback function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // wrap to create custom callback shorthands\n     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {\n     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);\n     *   return !match ? func(callback, thisArg) : function(object) {\n     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];\n     *   };\n     * });\n     *\n     * _.filter(characters, 'age__gt38');\n     * // => [{ 'name': 'fred', 'age': 40 }]\n     */\n    function createCallback(func, thisArg, argCount) {\n      var type = typeof func;\n      if (func == null || type == 'function') {\n        return baseCreateCallback(func, thisArg, argCount);\n      }\n      // handle \"_.pluck\" style callback shorthands\n      if (type != 'object') {\n        return property(func);\n      }\n      var props = keys(func),\n          key = props[0],\n          a = func[key];\n\n      // handle \"_.where\" style callback shorthands\n      if (props.length == 1 && a === a && !isObject(a)) {\n        // fast path the common case of providing an object with a single\n        // property containing a primitive value\n        return function(object) {\n          var b = object[key];\n          return a === b && (a !== 0 || (1 / a == 1 / b));\n        };\n      }\n      return function(object) {\n        var length = props.length,\n            result = false;\n\n        while (length--) {\n          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {\n            break;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Converts the characters `&`, `<`, `>`, `\"`, and `'` in `string` to their\n     * corresponding HTML entities.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('Fred, Wilma, & Pebbles');\n     * // => 'Fred, Wilma, &amp; Pebbles'\n     */\n    function escape(string) {\n      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);\n    }\n\n    /**\n     * This method returns the first argument provided to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.identity(object) === object;\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Adds function properties of a source object to the destination object.\n     * If `object` is a function methods will be added to its prototype as well.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Function|Object} [object=lodash] object The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options] The options object.\n     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.\n     * @example\n     *\n     * function capitalize(string) {\n     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n     * }\n     *\n     * _.mixin({ 'capitalize': capitalize });\n     * _.capitalize('fred');\n     * // => 'Fred'\n     *\n     * _('fred').capitalize().value();\n     * // => 'Fred'\n     *\n     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });\n     * _('fred').capitalize();\n     * // => 'Fred'\n     */\n    function mixin(object, source, options) {\n      var chain = true,\n          methodNames = source && functions(source);\n\n      if (!source || (!options && !methodNames.length)) {\n        if (options == null) {\n          options = source;\n        }\n        ctor = lodashWrapper;\n        source = object;\n        object = lodash;\n        methodNames = functions(source);\n      }\n      if (options === false) {\n        chain = false;\n      } else if (isObject(options) && 'chain' in options) {\n        chain = options.chain;\n      }\n      var ctor = object,\n          isFunc = isFunction(ctor);\n\n      forEach(methodNames, function(methodName) {\n        var func = object[methodName] = source[methodName];\n        if (isFunc) {\n          ctor.prototype[methodName] = function() {\n            var chainAll = this.__chain__,\n                value = this.__wrapped__,\n                args = [value];\n\n            push.apply(args, arguments);\n            var result = func.apply(object, args);\n            if (chain || chainAll) {\n              if (value === result && isObject(result)) {\n                return this;\n              }\n              result = new ctor(result);\n              result.__chain__ = chainAll;\n            }\n            return result;\n          };\n        }\n      });\n    }\n\n    /**\n     * Reverts the '_' variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      context._ = oldDash;\n      return this;\n    }\n\n    /**\n     * A no-operation function.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var object = { 'name': 'fred' };\n     * _.noop(object) === undefined;\n     * // => true\n     */\n    function noop() {\n      // no operation performed\n    }\n\n    /**\n     * Gets the number of milliseconds that have elapsed since the Unix epoch\n     * (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @example\n     *\n     * var stamp = _.now();\n     * _.defer(function() { console.log(_.now() - stamp); });\n     * // => logs the number of milliseconds it took for the deferred function to be called\n     */\n    var now = isNative(now = Date.now) && now || function() {\n      return new Date().getTime();\n    };\n\n    /**\n     * Converts the given value into an integer of the specified radix.\n     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the\n     * `value` is a hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * Note: This method avoids differences in native ES3 and ES5 `parseInt`\n     * implementations. See http://es5.github.io/#E.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} value The value to parse.\n     * @param {number} [radix] The radix used to interpret the value to parse.\n     * @returns {number} Returns the new integer value.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     */\n    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {\n      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`\n      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);\n    };\n\n    /**\n     * Creates a \"_.pluck\" style function, which returns the `key` value of a\n     * given object.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} key The name of the property to retrieve.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'fred',   'age': 40 },\n     *   { 'name': 'barney', 'age': 36 }\n     * ];\n     *\n     * var getName = _.property('name');\n     *\n     * _.map(characters, getName);\n     * // => ['barney', 'fred']\n     *\n     * _.sortBy(characters, getName);\n     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]\n     */\n    function property(key) {\n      return function(object) {\n        return object[key];\n      };\n    }\n\n    /**\n     * Produces a random number between `min` and `max` (inclusive). If only one\n     * argument is provided a number between `0` and the given number will be\n     * returned. If `floating` is truey or either `min` or `max` are floats a\n     * floating-point number will be returned instead of an integer.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} [min=0] The minimum possible value.\n     * @param {number} [max=1] The maximum possible value.\n     * @param {boolean} [floating=false] Specify returning a floating-point number.\n     * @returns {number} Returns a random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(min, max, floating) {\n      var noMin = min == null,\n          noMax = max == null;\n\n      if (floating == null) {\n        if (typeof min == 'boolean' && noMax) {\n          floating = min;\n          min = 1;\n        }\n        else if (!noMax && typeof max == 'boolean') {\n          floating = max;\n          noMax = true;\n        }\n      }\n      if (noMin && noMax) {\n        max = 1;\n      }\n      min = +min || 0;\n      if (noMax) {\n        max = min;\n        min = 0;\n      } else {\n        max = +max || 0;\n      }\n      if (floating || min % 1 || max % 1) {\n        var rand = nativeRandom();\n        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);\n      }\n      return baseRandom(min, max);\n    }\n\n    /**\n     * Resolves the value of property `key` on `object`. If `key` is a function\n     * it will be invoked with the `this` binding of `object` and its result returned,\n     * else the property value is returned. If `object` is falsey then `undefined`\n     * is returned.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {Object} object The object to inspect.\n     * @param {string} key The name of the property to resolve.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = {\n     *   'cheese': 'crumpets',\n     *   'stuff': function() {\n     *     return 'nonsense';\n     *   }\n     * };\n     *\n     * _.result(object, 'cheese');\n     * // => 'crumpets'\n     *\n     * _.result(object, 'stuff');\n     * // => 'nonsense'\n     */\n    function result(object, key) {\n      if (object) {\n        var value = object[key];\n        return isFunction(value) ? object[key]() : value;\n      }\n    }\n\n    /**\n     * A micro-templating method that handles arbitrary delimiters, preserves\n     * whitespace, and correctly escapes quotes within interpolated code.\n     *\n     * Note: In the development build, `_.template` utilizes sourceURLs for easier\n     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n     *\n     * For more information on precompiling templates see:\n     * http://lodash.com/custom-builds\n     *\n     * For more information on Chrome extension sandboxes see:\n     * http://developer.chrome.com/stable/extensions/sandboxingEval.html\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} text The template text.\n     * @param {Object} data The data object used to populate the text.\n     * @param {Object} [options] The options object.\n     * @param {RegExp} [options.escape] The \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate] The \"evaluate\" delimiter.\n     * @param {Object} [options.imports] An object to import into the template as local variables.\n     * @param {RegExp} [options.interpolate] The \"interpolate\" delimiter.\n     * @param {string} [sourceURL] The sourceURL of the template's compiled source.\n     * @param {string} [variable] The data object variable name.\n     * @returns {Function|string} Returns a compiled function when no `data` object\n     *  is given, else it returns the interpolated text.\n     * @example\n     *\n     * // using the \"interpolate\" delimiter to create a compiled template\n     * var compiled = _.template('hello <%= name %>');\n     * compiled({ 'name': 'fred' });\n     * // => 'hello fred'\n     *\n     * // using the \"escape\" delimiter to escape HTML in data property values\n     * _.template('<b><%- value %></b>', { 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // using the \"evaluate\" delimiter to generate HTML\n     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the ES6 delimiter as an alternative to the default \"interpolate\" delimiter\n     * _.template('hello ${ name }', { 'name': 'pebbles' });\n     * // => 'hello pebbles'\n     *\n     * // using the internal `print` function in \"evaluate\" delimiters\n     * _.template('<% print(\"hello \" + name); %>!', { 'name': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // using a custom template delimiters\n     * _.templateSettings = {\n     *   'interpolate': /{{([\\s\\S]+?)}}/g\n     * };\n     *\n     * _.template('hello {{ name }}!', { 'name': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // using the `imports` option to import jQuery\n     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';\n     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // using the `sourceURL` option to specify a custom sourceURL for the template\n     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector\n     *\n     * // using the `variable` option to ensure a with-statement isn't used in the compiled template\n     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     *   var __t, __p = '', __e = _.escape;\n     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';\n     *   return __p;\n     * }\n     *\n     * // using the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and a stack trace\n     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(text, data, options) {\n      // based on John Resig's `tmpl` implementation\n      // http://ejohn.org/blog/javascript-micro-templating/\n      // and Laura Doktorova's doT.js\n      // https://github.com/olado/doT\n      var settings = lodash.templateSettings;\n      text = String(text || '');\n\n      // avoid missing dependencies when `iteratorTemplate` is not defined\n      options = defaults({}, options, settings);\n\n      var imports = defaults({}, options.imports, settings.imports),\n          importsKeys = keys(imports),\n          importsValues = values(imports);\n\n      var isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // compile the regexp to match each delimiter\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // escape characters that cannot be included in string literals\n        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // replace delimiters with snippets\n        if (escapeValue) {\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // the JS engine embedded in Adobe products requires returning the `match`\n        // string in order to produce the correct `offset` value\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // if `variable` is not specified, wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain\n      var variable = options.variable,\n          hasVariable = variable;\n\n      if (!hasVariable) {\n        variable = 'obj';\n        source = 'with (' + variable + ') {\\n' + source + '\\n}\\n';\n      }\n      // cleanup code by stripping empty strings\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // frame code as the function body\n      source = 'function(' + variable + ') {\\n' +\n        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\\n') +\n        \"var __t, __p = '', __e = _.escape\" +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      // Use a sourceURL for easier debugging.\n      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl\n      var sourceURL = '\\n/*\\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\\n*/';\n\n      try {\n        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);\n      } catch(e) {\n        e.source = source;\n        throw e;\n      }\n      if (data) {\n        return result(data);\n      }\n      // provide the compiled function's source by its `toString` method, in\n      // supported environments, or the `source` property as a convenience for\n      // inlining compiled templates during the build process\n      result.source = source;\n      return result;\n    }\n\n    /**\n     * Executes the callback `n` times, returning an array of the results\n     * of each callback execution. The callback is bound to `thisArg` and invoked\n     * with one argument; (index).\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {number} n The number of times to execute the callback.\n     * @param {Function} callback The function called per iteration.\n     * @param {*} [thisArg] The `this` binding of `callback`.\n     * @returns {Array} Returns an array of the results of each `callback` execution.\n     * @example\n     *\n     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));\n     * // => [3, 6, 4]\n     *\n     * _.times(3, function(n) { mage.castSpell(n); });\n     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively\n     *\n     * _.times(3, function(n) { this.cast(n); }, mage);\n     * // => also calls `mage.castSpell(n)` three times\n     */\n    function times(n, callback, thisArg) {\n      n = (n = +n) > -1 ? n : 0;\n      var index = -1,\n          result = Array(n);\n\n      callback = baseCreateCallback(callback, thisArg, 1);\n      while (++index < n) {\n        result[index] = callback(index);\n      }\n      return result;\n    }\n\n    /**\n     * The inverse of `_.escape` this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their\n     * corresponding characters.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} string The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('Fred, Barney &amp; Pebbles');\n     * // => 'Fred, Barney & Pebbles'\n     */\n    function unescape(string) {\n      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.\n     *\n     * @static\n     * @memberOf _\n     * @category Utilities\n     * @param {string} [prefix] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return String(prefix == null ? '' : prefix) + id;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object that wraps the given value with explicit\n     * method chaining enabled.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney',  'age': 36 },\n     *   { 'name': 'fred',    'age': 40 },\n     *   { 'name': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _.chain(characters)\n     *     .sortBy('age')\n     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })\n     *     .first()\n     *     .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      value = new lodashWrapper(value);\n      value.__chain__ = true;\n      return value;\n    }\n\n    /**\n     * Invokes `interceptor` with the `value` as the first argument and then\n     * returns `value`. The purpose of this method is to \"tap into\" a method\n     * chain in order to perform operations on intermediate results within\n     * the chain.\n     *\n     * @static\n     * @memberOf _\n     * @category Chaining\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3, 4])\n     *  .tap(function(array) { array.pop(); })\n     *  .reverse()\n     *  .value();\n     * // => [3, 2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * Enables explicit method chaining on the wrapper object.\n     *\n     * @name chain\n     * @memberOf _\n     * @category Chaining\n     * @returns {*} Returns the wrapper object.\n     * @example\n     *\n     * var characters = [\n     *   { 'name': 'barney', 'age': 36 },\n     *   { 'name': 'fred',   'age': 40 }\n     * ];\n     *\n     * // without explicit chaining\n     * _(characters).first();\n     * // => { 'name': 'barney', 'age': 36 }\n     *\n     * // with explicit chaining\n     * _(characters).chain()\n     *   .first()\n     *   .pick('age')\n     *   .value();\n     * // => { 'age': 36 }\n     */\n    function wrapperChain() {\n      this.__chain__ = true;\n      return this;\n    }\n\n    /**\n     * Produces the `toString` result of the wrapped value.\n     *\n     * @name toString\n     * @memberOf _\n     * @category Chaining\n     * @returns {string} Returns the string result.\n     * @example\n     *\n     * _([1, 2, 3]).toString();\n     * // => '1,2,3'\n     */\n    function wrapperToString() {\n      return String(this.__wrapped__);\n    }\n\n    /**\n     * Extracts the wrapped value.\n     *\n     * @name valueOf\n     * @memberOf _\n     * @alias value\n     * @category Chaining\n     * @returns {*} Returns the wrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).valueOf();\n     * // => [1, 2, 3]\n     */\n    function wrapperValueOf() {\n      return this.__wrapped__;\n    }\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return wrapped values when chaining\n    lodash.after = after;\n    lodash.assign = assign;\n    lodash.at = at;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.chain = chain;\n    lodash.compact = compact;\n    lodash.compose = compose;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.createCallback = createCallback;\n    lodash.curry = curry;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.filter = filter;\n    lodash.flatten = flatten;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.functions = functions;\n    lodash.groupBy = groupBy;\n    lodash.indexBy = indexBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.invert = invert;\n    lodash.invoke = invoke;\n    lodash.keys = keys;\n    lodash.map = map;\n    lodash.mapValues = mapValues;\n    lodash.max = max;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.min = min;\n    lodash.omit = omit;\n    lodash.once = once;\n    lodash.pairs = pairs;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.pick = pick;\n    lodash.pluck = pluck;\n    lodash.property = property;\n    lodash.pull = pull;\n    lodash.range = range;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.shuffle = shuffle;\n    lodash.sortBy = sortBy;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.times = times;\n    lodash.toArray = toArray;\n    lodash.transform = transform;\n    lodash.union = union;\n    lodash.uniq = uniq;\n    lodash.values = values;\n    lodash.where = where;\n    lodash.without = without;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n\n    // add aliases\n    lodash.collect = map;\n    lodash.drop = rest;\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.extend = assign;\n    lodash.methods = functions;\n    lodash.object = zipObject;\n    lodash.select = filter;\n    lodash.tail = rest;\n    lodash.unique = uniq;\n    lodash.unzip = zip;\n\n    // add functions to `lodash.prototype`\n    mixin(lodash);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions that return unwrapped values when chaining\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.contains = contains;\n    lodash.escape = escape;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.has = has;\n    lodash.identity = identity;\n    lodash.indexOf = indexOf;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isBoolean = isBoolean;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isNaN = isNaN;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isString = isString;\n    lodash.isUndefined = isUndefined;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.mixin = mixin;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.result = result;\n    lodash.runInContext = runInContext;\n    lodash.size = size;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.template = template;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n\n    // add aliases\n    lodash.all = every;\n    lodash.any = some;\n    lodash.detect = find;\n    lodash.findWhere = find;\n    lodash.foldl = reduce;\n    lodash.foldr = reduceRight;\n    lodash.include = contains;\n    lodash.inject = reduce;\n\n    mixin(function() {\n      var source = {}\n      forOwn(lodash, function(func, methodName) {\n        if (!lodash.prototype[methodName]) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }(), false);\n\n    /*--------------------------------------------------------------------------*/\n\n    // add functions capable of returning wrapped and unwrapped values when chaining\n    lodash.first = first;\n    lodash.last = last;\n    lodash.sample = sample;\n\n    // add aliases\n    lodash.take = first;\n    lodash.head = first;\n\n    forOwn(lodash, function(func, methodName) {\n      var callbackable = methodName !== 'sample';\n      if (!lodash.prototype[methodName]) {\n        lodash.prototype[methodName]= function(n, guard) {\n          var chainAll = this.__chain__,\n              result = func(this.__wrapped__, n, guard);\n\n          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))\n            ? result\n            : new lodashWrapper(result, chainAll);\n        };\n      }\n    });\n\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type string\n     */\n    lodash.VERSION = '2.4.1';\n\n    // add \"Chaining\" functions to the wrapper\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.toString = wrapperToString;\n    lodash.prototype.value = wrapperValueOf;\n    lodash.prototype.valueOf = wrapperValueOf;\n\n    // add `Array` functions that return unwrapped values\n    baseEach(['join', 'pop', 'shift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        var chainAll = this.__chain__,\n            result = func.apply(this.__wrapped__, arguments);\n\n        return chainAll\n          ? new lodashWrapper(result, chainAll)\n          : result;\n      };\n    });\n\n    // add `Array` functions that return the existing wrapped value\n    baseEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        func.apply(this.__wrapped__, arguments);\n        return this;\n      };\n    });\n\n    // add `Array` functions that return new wrapped values\n    baseEach(['concat', 'slice', 'splice'], function(methodName) {\n      var func = arrayRef[methodName];\n      lodash.prototype[methodName] = function() {\n        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);\n      };\n    });\n\n    // avoid array-like object bugs with `Array#shift` and `Array#splice`\n    // in IE < 9, Firefox < 10, Narwhal, and RingoJS\n    if (!support.spliceObjects) {\n      baseEach(['pop', 'shift', 'splice'], function(methodName) {\n        var func = arrayRef[methodName],\n            isSplice = methodName == 'splice';\n\n        lodash.prototype[methodName] = function() {\n          var chainAll = this.__chain__,\n              value = this.__wrapped__,\n              result = func.apply(value, arguments);\n\n          if (value.length === 0) {\n            delete value[0];\n          }\n          return (chainAll || isSplice)\n            ? new lodashWrapper(result, chainAll)\n            : result;\n        };\n      });\n    }\n\n    return lodash;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // expose Lo-Dash\n  var _ = runInContext();\n\n  // some AMD build optimizers like r.js check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lo-Dash to the global object even when an AMD loader is present in\n    // case Lo-Dash is loaded with a RequireJS shim config.\n    // See http://requirejs.org/docs/api.html#config-shim\n    root._ = _;\n\n    // define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module\n    define(function() {\n      return _;\n    });\n  }\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (freeExports && freeModule) {\n    // in Node.js or RingoJS\n    if (moduleExports) {\n      (freeModule.exports = _)._ = _;\n    }\n    // in Narwhal or Rhino -require\n    else {\n      freeExports._ = _;\n    }\n  }\n  else {\n    // in a browser or Rhino\n    root._ = _;\n  }\n}.call(this));\n","//     Backbone.js 1.1.2\n\n//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(root, factory) {\n\n  // Set up Backbone appropriately for the environment. Start with AMD.\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      root.Backbone = factory(root, exports, _, $);\n    });\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    factory(root, exports, _);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n\n}(this, function(root, Backbone, _, $) {\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create local references to array methods we'll want to use later.\n  var array = [];\n  var push = array.push;\n  var slice = array.slice;\n  var splice = array.splice;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.1.2';\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = $;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = void 0;\n        return this;\n      }\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                  (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeningTo = this._listeningTo;\n      if (!listeningTo) return this;\n      var remove = !name && !callback;\n      if (!callback && typeof name === 'object') callback = this;\n      if (obj) (listeningTo = {})[obj._listenId] = obj;\n      for (var id in listeningTo) {\n        obj = listeningTo[id];\n        obj.off(name, callback, this);\n        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];\n      }\n      return this;\n    }\n\n  };\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n  };\n\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  _.each(listenMethods, function(implementation, method) {\n    Events[method] = function(obj, name, callback) {\n      var listeningTo = this._listeningTo || (this._listeningTo = {});\n      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n      listeningTo[id] = obj;\n      if (!callback && typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  });\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.cid = _.uniqueId('c');\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      var attr, attrs, unset, changes, silent, changing, prev, current;\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      unset           = options.unset;\n      silent          = options.silent;\n      changes         = [];\n      changing        = this._changing;\n      this._changing  = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n      current = this.attributes, prev = this._previousAttributes;\n\n      // Check for changes of `id`.\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n      // For each `set` attribute, update or delete the current value.\n      for (attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          this.changed[attr] = val;\n        } else {\n          delete this.changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = options;\n        for (var i = 0, l = changes.length; i < l; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          options = this._pending;\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var val, changed = false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      for (var attr in diff) {\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n        (changed || (changed = {}))[attr] = val;\n      }\n      return changed;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server. If the server's representation of the\n    // model differs from its current attributes, they will be overridden,\n    // triggering a `\"change\"` event.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        if (!model.set(model.parse(resp, options), options)) return false;\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      var attrs, method, xhr, attributes = this.attributes;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options = _.extend({validate: true}, options);\n\n      // If we're not waiting and attributes exist, save acts as\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\n      // the model will be valid when the attributes, if any, are set.\n      if (attrs && !options.wait) {\n        if (!this.set(attrs, options)) return false;\n      } else {\n        if (!this._validate(attrs, options)) return false;\n      }\n\n      // Set temporary attributes if `{wait: true}`.\n      if (attrs && options.wait) {\n        this.attributes = _.extend({}, attributes, attrs);\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = model.parse(resp, options);\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\n        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\n          return false;\n        }\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method === 'patch') options.attrs = attrs;\n      xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      if (attrs && options.wait) this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n\n      var destroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (options.wait || model.isNew()) destroy();\n        if (success) success(model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      if (this.isNew()) {\n        options.success();\n        return false;\n      }\n      wrapError(this, options);\n\n      var xhr = this.sync('delete', this, options);\n      if (!options.wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base =\n        _.result(this, 'urlRoot') ||\n        _.result(this.collection, 'url') ||\n        urlError();\n      if (this.isNew()) return base;\n      return base.replace(/([^\\/])$/, '$1/') + encodeURIComponent(this.id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return !this.has(this.idAttribute);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.extend(options || {}, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Model.\n  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  _.each(modelMethods, function(method) {\n    Model.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.attributes);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analagous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, remove: false};\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model){ return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set.\n    add: function(models, options) {\n      return this.set(models, _.extend({merge: false}, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      var singular = !_.isArray(models);\n      models = singular ? [models] : _.clone(models);\n      options || (options = {});\n      var i, l, index, model;\n      for (i = 0, l = models.length; i < l; i++) {\n        model = models[i] = this.get(models[i]);\n        if (!model) continue;\n        delete this._byId[model.id];\n        delete this._byId[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model, options);\n      }\n      return singular ? models[0] : models;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      options = _.defaults({}, options, setOptions);\n      if (options.parse) models = this.parse(models, options);\n      var singular = !_.isArray(models);\n      models = singular ? (models ? [models] : []) : _.clone(models);\n      var i, l, id, model, attrs, existing, sort;\n      var at = options.at;\n      var targetModel = this.model;\n      var sortable = this.comparator && (at == null) && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n      var toAdd = [], toRemove = [], modelMap = {};\n      var add = options.add, merge = options.merge, remove = options.remove;\n      var order = !sortable && add && remove ? [] : false;\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      for (i = 0, l = models.length; i < l; i++) {\n        attrs = models[i] || {};\n        if (attrs instanceof Model) {\n          id = model = attrs;\n        } else {\n          id = attrs[targetModel.prototype.idAttribute || 'id'];\n        }\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        if (existing = this.get(id)) {\n          if (remove) modelMap[existing.cid] = true;\n          if (merge) {\n            attrs = attrs === model ? model.attributes : attrs;\n            if (options.parse) attrs = existing.parse(attrs, options);\n            existing.set(attrs, options);\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n          }\n          models[i] = existing;\n\n        // If this is a new, valid model, push it to the `toAdd` list.\n        } else if (add) {\n          model = models[i] = this._prepareModel(attrs, options);\n          if (!model) continue;\n          toAdd.push(model);\n          this._addReference(model, options);\n        }\n\n        // Do not add multiple models with the same `id`.\n        model = existing || model;\n        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);\n        modelMap[model.id] = true;\n      }\n\n      // Remove nonexistent models if appropriate.\n      if (remove) {\n        for (i = 0, l = this.length; i < l; ++i) {\n          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this.remove(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      if (toAdd.length || (order && order.length)) {\n        if (sortable) sort = true;\n        this.length += toAdd.length;\n        if (at != null) {\n          for (i = 0, l = toAdd.length; i < l; i++) {\n            this.models.splice(at + i, 0, toAdd[i]);\n          }\n        } else {\n          if (order) this.models.length = 0;\n          var orderedModels = order || toAdd;\n          for (i = 0, l = orderedModels.length; i < l; i++) {\n            this.models.push(orderedModels[i]);\n          }\n        }\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      // Unless silenced, it's time to fire all appropriate add/sort events.\n      if (!options.silent) {\n        for (i = 0, l = toAdd.length; i < l; i++) {\n          (model = toAdd[i]).trigger('add', model, this, options);\n        }\n        if (sort || (order && order.length)) this.trigger('sort', this, options);\n      }\n\n      // Return the added (or merged) model (or models).\n      return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options || (options = {});\n      for (var i = 0, l = this.models.length; i < l; i++) {\n        this._removeReference(this.models[i], options);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      models = this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      return this.add(model, _.extend({at: this.length}, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      return this.add(model, _.extend({at: 0}, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n      return slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      if (_.isEmpty(attrs)) return first ? void 0 : [];\n      return this[first ? 'find' : 'filter'](function(model) {\n        for (var key in attrs) {\n          if (attrs[key] !== model.get(key)) return false;\n        }\n        return true;\n      });\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      // Run sort based on type of `comparator`.\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\n        this.models = this.sortBy(this.comparator, this);\n      } else {\n        this.models.sort(_.bind(this.comparator, this));\n      }\n\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.invoke(this.models, 'get', attr);\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success(collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      if (!(model = this._prepareModel(model, options))) return false;\n      if (!options.wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(model, resp) {\n        if (options.wait) collection.add(model, options);\n        if (success) success(model, resp, options);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (attrs instanceof Model) return attrs;\n      options = options ? _.clone(options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n      this._byId[model.cid] = model;\n      if (model.id != null) this._byId[model.id] = model;\n      if (!model.collection) model.collection = this;\n      model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\n      if (event === 'destroy') this.remove(model, options);\n      if (model && event === 'change:' + model.idAttribute) {\n        delete this._byId[model.previous(model.idAttribute)];\n        if (model.id != null) this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n    'lastIndexOf', 'isEmpty', 'chain', 'sample'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  _.each(methods, function(method) {\n    Collection.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.models);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Underscore methods that take a property name as an argument.\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];\n\n  // Use attributes instead of properties.\n  _.each(attributeMethods, function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = _.isFunction(value) ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    options || (options = {});\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this.$el.remove();\n      this.stopListening();\n      return this;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    setElement: function(element, delegate) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) this.delegateEvents();\n      return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function(events) {\n      if (!(events || (events = _.result(this, 'events')))) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[events[key]];\n        if (!method) continue;\n\n        var match = key.match(delegateEventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, this);\n        eventName += '.delegateEvents' + this.cid;\n        if (selector === '') {\n          this.$el.on(eventName, method);\n        } else {\n          this.$el.on(eventName, selector, method);\n        }\n      }\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\n        this.setElement($el, false);\n      } else {\n        this.setElement(_.result(this, 'el'), false);\n      }\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // If we're sending a `PATCH` request, and we're in an old Internet Explorer\n    // that still has ActiveX enabled by default, override jQuery to use that\n    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\n    if (params.type === 'PATCH' && noXhrPatch) {\n      params.xhr = function() {\n        return new ActiveXObject(\"Microsoft.XMLHTTP\");\n      };\n    }\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  var noXhrPatch =\n    typeof window !== 'undefined' && !!window.ActiveXObject &&\n      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch':  'PATCH',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        router.execute(callback, args);\n        router.trigger.apply(router, ['route:' + name].concat(args));\n        router.trigger('route', name, args);\n        Backbone.history.trigger('route', router, name, args);\n      });\n      return this;\n    },\n\n    // Execute a route handler with the provided parameters.  This is an\n    // excellent place to do pre-route setup or post-route cleanup.\n    execute: function(callback, args) {\n      if (callback) callback.apply(this, args);\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, function(match, optional) {\n                     return optional ? match : '([^/?]+)';\n                   })\n                   .replace(splatParam, '([^?]*?)');\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param, i) {\n        // Don't decode the search params.\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Cached regex for removing a trailing slash.\n  var trailingSlash = /\\/$/;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n          fragment = decodeURI(this.location.pathname + this.location.search);\n          var root = this.root.replace(trailingSlash, '');\n          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      if (oldIE && this._wantsHashChange) {\n        var frame = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');\n        this.iframe = frame.hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Backbone.$(window).on('popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        Backbone.$(window).on('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = this.location;\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          this.fragment = this.getFragment(null, true);\n          this.location.replace(this.root + '#' + this.fragment);\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot() && loc.hash) {\n          this.fragment = this.getHash().replace(routeStripper, '');\n          this.history.replaceState({}, document.title, this.root + this.fragment);\n        }\n\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n      // Strip the hash for matching.\n      fragment = fragment.replace(pathStripper, '');\n\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n\n      // Don't include a trailing slash on the root.\n      if (fragment === '' && url !== '/') url = url.slice(0, -1);\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error(model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  return Backbone;\n\n}));\n","/*!\n * Chaplin 1.0.0\n *\n * Chaplin may be freely distributed under the MIT license.\n * For all details and documentation:\n * http://chaplinjs.org\n */\n\n(function(){\n\nvar loader = (function() {\n  var modules = {};\n  var cache = {};\n\n  var dummy = function() {return function() {};};\n  var initModule = function(name, definition) {\n    var module = {id: name, exports: {}};\n    definition(module.exports, dummy(), module);\n    var exports = cache[name] = module.exports;\n    return exports;\n  };\n\n  var loader = function(path) {\n    if (cache.hasOwnProperty(path)) return cache[path];\n    if (modules.hasOwnProperty(path)) return initModule(path, modules[path]);\n    throw new Error('Cannot find module \"' + path + '\"');\n  };\n\n  loader.register = function(bundle, fn) {\n    modules[bundle] = fn;\n  };\n  return loader;\n})();\n\nloader.register('chaplin/application', function(e, r, module) {\n'use strict';\n\nvar Application, Backbone, Composer, Dispatcher, EventBroker, Layout, Router, mediator, _;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nDispatcher = loader('chaplin/dispatcher');\n\nLayout = loader('chaplin/views/layout');\n\nComposer = loader('chaplin/composer');\n\nRouter = loader('chaplin/lib/router');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nmediator = loader('chaplin/mediator');\n\nmodule.exports = Application = (function() {\n\n  Application.extend = Backbone.Model.extend;\n\n  _.extend(Application.prototype, EventBroker);\n\n  Application.prototype.title = '';\n\n  Application.prototype.dispatcher = null;\n\n  Application.prototype.layout = null;\n\n  Application.prototype.router = null;\n\n  Application.prototype.composer = null;\n\n  Application.prototype.started = false;\n\n  function Application(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.initialize(options);\n  }\n\n  Application.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    if (this.started) {\n      throw new Error('Application#initialize: App was already started');\n    }\n    this.initRouter(options.routes, options);\n    this.initDispatcher(options);\n    this.initLayout(options);\n    this.initComposer(options);\n    this.initMediator();\n    return this.start();\n  };\n\n  Application.prototype.initDispatcher = function(options) {\n    return this.dispatcher = new Dispatcher(options);\n  };\n\n  Application.prototype.initLayout = function(options) {\n    var _ref;\n    if (options == null) {\n      options = {};\n    }\n    if ((_ref = options.title) == null) {\n      options.title = this.title;\n    }\n    return this.layout = new Layout(options);\n  };\n\n  Application.prototype.initComposer = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    return this.composer = new Composer(options);\n  };\n\n  Application.prototype.initMediator = function() {\n    return mediator.seal();\n  };\n\n  Application.prototype.initRouter = function(routes, options) {\n    this.router = new Router(options);\n    return typeof routes === \"function\" ? routes(this.router.match) : void 0;\n  };\n\n  Application.prototype.start = function() {\n    this.router.startHistory();\n    this.started = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  Application.prototype.disposed = false;\n\n  Application.prototype.dispose = function() {\n    var prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    properties = ['dispatcher', 'layout', 'router', 'composer'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      if (this[prop] != null) {\n        this[prop].dispose();\n      }\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Application;\n\n})();\n\n});;loader.register('chaplin/mediator', function(e, r, module) {\n'use strict';\n\nvar Backbone, handlers, mediator, support, utils, _,\n  __slice = [].slice;\n\nBackbone = loader('backbone');\n\n_ = loader('underscore');\n\nsupport = loader('chaplin/lib/support');\n\nutils = loader('chaplin/lib/utils');\n\nmediator = {};\n\nmediator.subscribe = Backbone.Events.on;\n\nmediator.unsubscribe = Backbone.Events.off;\n\nmediator.publish = Backbone.Events.trigger;\n\nmediator._callbacks = null;\n\nhandlers = mediator._handlers = {};\n\nmediator.setHandler = function(name, method, instance) {\n  return handlers[name] = {\n    instance: instance,\n    method: method\n  };\n};\n\nmediator.execute = function() {\n  var args, handler, name, nameOrObj, silent;\n  nameOrObj = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n  silent = false;\n  if (typeof nameOrObj === 'object') {\n    silent = nameOrObj.silent;\n    name = nameOrObj.name;\n  } else {\n    name = nameOrObj;\n  }\n  handler = handlers[name];\n  if (handler) {\n    return handler.method.apply(handler.instance, args);\n  } else if (!silent) {\n    throw new Error(\"mediator.execute: \" + name + \" handler is not defined\");\n  }\n};\n\nmediator.removeHandlers = function(instanceOrNames) {\n  var handler, name, _i, _len;\n  if (!instanceOrNames) {\n    mediator._handlers = {};\n  }\n  if (utils.isArray(instanceOrNames)) {\n    for (_i = 0, _len = instanceOrNames.length; _i < _len; _i++) {\n      name = instanceOrNames[_i];\n      delete handlers[name];\n    }\n  } else {\n    for (name in handlers) {\n      handler = handlers[name];\n      if (handler.instance === instanceOrNames) {\n        delete handlers[name];\n      }\n    }\n  }\n};\n\nutils.readonly(mediator, 'subscribe', 'unsubscribe', 'publish', 'setHandler', 'execute', 'removeHandlers');\n\nmediator.seal = function() {\n  if (support.propertyDescriptors && Object.seal) {\n    return Object.seal(mediator);\n  }\n};\n\nutils.readonly(mediator, 'seal');\n\nmodule.exports = mediator;\n\n});;loader.register('chaplin/dispatcher', function(e, r, module) {\n'use strict';\n\nvar Backbone, Dispatcher, EventBroker, mediator, utils, _;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nutils = loader('chaplin/lib/utils');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nmodule.exports = Dispatcher = (function() {\n\n  Dispatcher.extend = Backbone.Model.extend;\n\n  _.extend(Dispatcher.prototype, EventBroker);\n\n  Dispatcher.prototype.previousRoute = null;\n\n  Dispatcher.prototype.currentController = null;\n\n  Dispatcher.prototype.currentRoute = null;\n\n  Dispatcher.prototype.currentParams = null;\n\n  Dispatcher.prototype.currentQuery = null;\n\n  function Dispatcher() {\n    this.initialize.apply(this, arguments);\n  }\n\n  Dispatcher.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.settings = _.defaults(options, {\n      controllerPath: 'controllers/',\n      controllerSuffix: '_controller'\n    });\n    return this.subscribeEvent('router:match', this.dispatch);\n  };\n\n  Dispatcher.prototype.dispatch = function(route, params, options) {\n    var _ref, _ref1,\n      _this = this;\n    params = params ? _.extend({}, params) : {};\n    options = options ? _.extend({}, options) : {};\n    if (!(options.query != null)) {\n      options.query = {};\n    }\n    if (options.forceStartup !== true) {\n      options.forceStartup = false;\n    }\n    if (!options.forceStartup && ((_ref = this.currentRoute) != null ? _ref.controller : void 0) === route.controller && ((_ref1 = this.currentRoute) != null ? _ref1.action : void 0) === route.action && _.isEqual(this.currentParams, params) && _.isEqual(this.currentQuery, options.query)) {\n      return;\n    }\n    return this.loadController(route.controller, function(Controller) {\n      return _this.controllerLoaded(route, params, options, Controller);\n    });\n  };\n\n  Dispatcher.prototype.loadController = function(name, handler) {\n    var fileName, moduleName,\n      _this = this;\n    fileName = name + this.settings.controllerSuffix;\n    moduleName = this.settings.controllerPath + fileName;\n    if (typeof define !== \"undefined\" && define !== null ? define.amd : void 0) {\n      return require([moduleName], handler);\n    } else {\n      return setTimeout(function() {\n        return handler(require(moduleName));\n      }, 0);\n    }\n  };\n\n  Dispatcher.prototype.controllerLoaded = function(route, params, options, Controller) {\n    var controller, prev, previous;\n    if (this.nextPreviousRoute = this.currentRoute) {\n      previous = _.extend({}, this.nextPreviousRoute);\n      if (this.currentParams != null) {\n        previous.params = this.currentParams;\n      }\n      if (previous.previous) {\n        delete previous.previous;\n      }\n      prev = {\n        previous: previous\n      };\n    }\n    this.nextCurrentRoute = _.extend({}, route, prev);\n    controller = new Controller(params, this.nextCurrentRoute, options);\n    return this.executeBeforeAction(controller, this.nextCurrentRoute, params, options);\n  };\n\n  Dispatcher.prototype.executeAction = function(controller, route, params, options) {\n    if (this.currentController) {\n      this.publishEvent('beforeControllerDispose', this.currentController);\n      this.currentController.dispose(params, route, options);\n    }\n    this.currentController = controller;\n    this.currentParams = params;\n    this.currentQuery = options.query;\n    controller[route.action](params, route, options);\n    if (controller.redirected) {\n      return;\n    }\n    return this.publishEvent('dispatcher:dispatch', this.currentController, params, route, options);\n  };\n\n  Dispatcher.prototype.executeBeforeAction = function(controller, route, params, options) {\n    var before, executeAction, promise,\n      _this = this;\n    before = controller.beforeAction;\n    executeAction = function() {\n      if (controller.redirected || _this.currentRoute && route === _this.currentRoute) {\n        _this.nextPreviousRoute = _this.nextCurrentRoute = null;\n        controller.dispose();\n        return;\n      }\n      _this.previousRoute = _this.nextPreviousRoute;\n      _this.currentRoute = _this.nextCurrentRoute;\n      _this.nextPreviousRoute = _this.nextCurrentRoute = null;\n      return _this.executeAction(controller, route, params, options);\n    };\n    if (!before) {\n      executeAction();\n      return;\n    }\n    if (typeof before !== 'function') {\n      throw new TypeError('Controller#beforeAction: function expected. ' + 'Old object-like form is not supported.');\n    }\n    promise = controller.beforeAction(params, route, options);\n    if (promise && promise.then) {\n      return promise.then(executeAction);\n    } else {\n      return executeAction();\n    }\n  };\n\n  Dispatcher.prototype.disposed = false;\n\n  Dispatcher.prototype.dispose = function() {\n    if (this.disposed) {\n      return;\n    }\n    this.unsubscribeAllEvents();\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Dispatcher;\n\n})();\n\n});;loader.register('chaplin/composer', function(e, r, module) {\n'use strict';\n\nvar Backbone, Composer, Composition, EventBroker, mediator, utils, _;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nutils = loader('chaplin/lib/utils');\n\nComposition = loader('chaplin/lib/composition');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nmodule.exports = Composer = (function() {\n\n  Composer.extend = Backbone.Model.extend;\n\n  _.extend(Composer.prototype, EventBroker);\n\n  Composer.prototype.compositions = null;\n\n  function Composer() {\n    this.initialize.apply(this, arguments);\n  }\n\n  Composer.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.compositions = {};\n    mediator.setHandler('composer:compose', this.compose, this);\n    mediator.setHandler('composer:retrieve', this.retrieve, this);\n    return this.subscribeEvent('dispatcher:dispatch', this.cleanup);\n  };\n\n  Composer.prototype.compose = function(name, second, third) {\n    if (typeof second === 'function') {\n      if (third || second.prototype.dispose) {\n        if (second.prototype instanceof Composition) {\n          return this._compose(name, {\n            composition: second,\n            options: third\n          });\n        } else {\n          return this._compose(name, {\n            options: third,\n            compose: function() {\n              var autoRender, disabledAutoRender;\n              this.item = new second(this.options);\n              autoRender = this.item.autoRender;\n              disabledAutoRender = autoRender === void 0 || !autoRender;\n              if (disabledAutoRender && typeof this.item.render === 'function') {\n                return this.item.render();\n              }\n            }\n          });\n        }\n      }\n      return this._compose(name, {\n        compose: second\n      });\n    }\n    if (typeof third === 'function') {\n      return this._compose(name, {\n        compose: third,\n        options: second\n      });\n    }\n    return this._compose(name, second);\n  };\n\n  Composer.prototype._compose = function(name, options) {\n    var composition, current, isPromise, returned;\n    if (typeof options.compose !== 'function' && !(options.composition != null)) {\n      throw new Error('Composer#compose was used incorrectly');\n    }\n    if (options.composition != null) {\n      composition = new options.composition(options.options);\n    } else {\n      composition = new Composition(options.options);\n      composition.compose = options.compose;\n      if (options.check) {\n        composition.check = options.check;\n      }\n    }\n    current = this.compositions[name];\n    isPromise = false;\n    if (current && current.check(composition.options)) {\n      current.stale(false);\n    } else {\n      if (current) {\n        current.dispose();\n      }\n      returned = composition.compose(composition.options);\n      isPromise = typeof (returned != null ? returned.then : void 0) === 'function';\n      composition.stale(false);\n      this.compositions[name] = composition;\n    }\n    if (isPromise) {\n      return returned;\n    } else {\n      return this.compositions[name].item;\n    }\n  };\n\n  Composer.prototype.retrieve = function(name) {\n    var active;\n    active = this.compositions[name];\n    if (active && !active.stale()) {\n      return active.item;\n    } else {\n      return void 0;\n    }\n  };\n\n  Composer.prototype.cleanup = function() {\n    var composition, name, _ref;\n    _ref = this.compositions;\n    for (name in _ref) {\n      composition = _ref[name];\n      if (composition.stale()) {\n        composition.dispose();\n        delete this.compositions[name];\n      } else {\n        composition.stale(true);\n      }\n    }\n  };\n\n  Composer.prototype.dispose = function() {\n    var composition, name, _ref;\n    if (this.disposed) {\n      return;\n    }\n    this.unsubscribeAllEvents();\n    mediator.removeHandlers(this);\n    _ref = this.compositions;\n    for (name in _ref) {\n      composition = _ref[name];\n      composition.dispose();\n    }\n    delete this.compositions;\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Composer;\n\n})();\n\n});;loader.register('chaplin/controllers/controller', function(e, r, module) {\n'use strict';\n\nvar Backbone, Controller, EventBroker, mediator, utils, _,\n  __slice = [].slice,\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nutils = loader('chaplin/lib/utils');\n\nmediator = loader('chaplin/mediator');\n\nmodule.exports = Controller = (function() {\n\n  Controller.extend = Backbone.Model.extend;\n\n  _.extend(Controller.prototype, Backbone.Events);\n\n  _.extend(Controller.prototype, EventBroker);\n\n  Controller.prototype.view = null;\n\n  Controller.prototype.redirected = false;\n\n  function Controller() {\n    this.initialize.apply(this, arguments);\n  }\n\n  Controller.prototype.initialize = function() {};\n\n  Controller.prototype.beforeAction = function() {};\n\n  Controller.prototype.adjustTitle = function(subtitle) {\n    return mediator.execute('adjustTitle', subtitle);\n  };\n\n  Controller.prototype.reuse = function(name) {\n    var method;\n    method = arguments.length === 1 ? 'retrieve' : 'compose';\n    return mediator.execute.apply(mediator, [\"composer:\" + method].concat(__slice.call(arguments)));\n  };\n\n  Controller.prototype.compose = function() {\n    throw new Error('Controller#compose was moved to Controller#reuse');\n  };\n\n  Controller.prototype.redirectTo = function(pathDesc, params, options) {\n    this.redirected = true;\n    return utils.redirectTo(pathDesc, params, options);\n  };\n\n  Controller.prototype.disposed = false;\n\n  Controller.prototype.dispose = function() {\n    var obj, prop;\n    if (this.disposed) {\n      return;\n    }\n    for (prop in this) {\n      if (!__hasProp.call(this, prop)) continue;\n      obj = this[prop];\n      if (!(obj && typeof obj.dispose === 'function')) {\n        continue;\n      }\n      obj.dispose();\n      delete this[prop];\n    }\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Controller;\n\n})();\n\n});;loader.register('chaplin/models/collection', function(e, r, module) {\n'use strict';\n\nvar Backbone, Collection, EventBroker, Model, utils, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nModel = loader('chaplin/models/model');\n\nutils = loader('chaplin/lib/utils');\n\nmodule.exports = Collection = (function(_super) {\n\n  __extends(Collection, _super);\n\n  function Collection() {\n    return Collection.__super__.constructor.apply(this, arguments);\n  }\n\n  _.extend(Collection.prototype, EventBroker);\n\n  Collection.prototype.model = Model;\n\n  Collection.prototype.serialize = function() {\n    return this.map(utils.serialize);\n  };\n\n  Collection.prototype.disposed = false;\n\n  Collection.prototype.dispose = function() {\n    var prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    this.trigger('dispose', this);\n    this.reset([], {\n      silent: true\n    });\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    this.off();\n    properties = ['model', 'models', '_byId', '_byCid', '_callbacks'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Collection;\n\n})(Backbone.Collection);\n\n});;loader.register('chaplin/models/model', function(e, r, module) {\n'use strict';\n\nvar Backbone, EventBroker, Model, serializeAttributes, serializeModelAttributes, utils, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nutils = loader('chaplin/lib/utils');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nserializeAttributes = function(model, attributes, modelStack) {\n  var delegator, key, otherModel, serializedModels, value, _i, _len, _ref;\n  delegator = utils.beget(attributes);\n  if (modelStack == null) {\n    modelStack = {};\n  }\n  modelStack[model.cid] = true;\n  for (key in attributes) {\n    value = attributes[key];\n    if (value instanceof Backbone.Model) {\n      delegator[key] = serializeModelAttributes(value, model, modelStack);\n    } else if (value instanceof Backbone.Collection) {\n      serializedModels = [];\n      _ref = value.models;\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        otherModel = _ref[_i];\n        serializedModels.push(serializeModelAttributes(otherModel, model, modelStack));\n      }\n      delegator[key] = serializedModels;\n    }\n  }\n  delete modelStack[model.cid];\n  return delegator;\n};\n\nserializeModelAttributes = function(model, currentModel, modelStack) {\n  var attributes;\n  if (model === currentModel || model.cid in modelStack) {\n    return null;\n  }\n  attributes = typeof model.getAttributes === 'function' ? model.getAttributes() : model.attributes;\n  return serializeAttributes(model, attributes, modelStack);\n};\n\nmodule.exports = Model = (function(_super) {\n\n  __extends(Model, _super);\n\n  function Model() {\n    return Model.__super__.constructor.apply(this, arguments);\n  }\n\n  _.extend(Model.prototype, EventBroker);\n\n  Model.prototype.getAttributes = function() {\n    return this.attributes;\n  };\n\n  Model.prototype.serialize = function() {\n    return serializeAttributes(this, this.getAttributes());\n  };\n\n  Model.prototype.disposed = false;\n\n  Model.prototype.dispose = function() {\n    var prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    this.trigger('dispose', this);\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    this.off();\n    properties = ['collection', 'attributes', 'changed', '_escapedAttributes', '_previousAttributes', '_silent', '_pending', '_callbacks'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Model;\n\n})(Backbone.Model);\n\n});;loader.register('chaplin/views/layout', function(e, r, module) {\n'use strict';\n\nvar $, Backbone, EventBroker, Layout, View, mediator, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nutils = loader('chaplin/lib/utils');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nView = loader('chaplin/views/view');\n\n$ = Backbone.$;\n\nmodule.exports = Layout = (function(_super) {\n\n  __extends(Layout, _super);\n\n  Layout.prototype.el = 'body';\n\n  Layout.prototype.keepElement = true;\n\n  Layout.prototype.title = '';\n\n  Layout.prototype.globalRegions = null;\n\n  Layout.prototype.listen = {\n    'beforeControllerDispose mediator': 'scroll'\n  };\n\n  function Layout(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.openLink = __bind(this.openLink, this);\n\n    this.globalRegions = [];\n    this.title = options.title;\n    if (options.regions) {\n      this.regions = options.regions;\n    }\n    this.settings = _.defaults(options, {\n      titleTemplate: function(data) {\n        var st;\n        st = data.subtitle ? \"\" + data.subtitle + \" \\u2013 \" : '';\n        return st + data.title;\n      },\n      openExternalToBlank: false,\n      routeLinks: 'a, .go-to',\n      skipRouting: '.noscript',\n      scrollTo: [0, 0]\n    });\n    mediator.setHandler('region:show', this.showRegion, this);\n    mediator.setHandler('region:register', this.registerRegionHandler, this);\n    mediator.setHandler('region:unregister', this.unregisterRegionHandler, this);\n    mediator.setHandler('region:find', this.regionByName, this);\n    mediator.setHandler('adjustTitle', this.adjustTitle, this);\n    Layout.__super__.constructor.apply(this, arguments);\n    if (this.settings.routeLinks) {\n      this.startLinkRouting();\n    }\n  }\n\n  Layout.prototype.scroll = function() {\n    var position;\n    position = this.settings.scrollTo;\n    if (position) {\n      return window.scrollTo(position[0], position[1]);\n    }\n  };\n\n  Layout.prototype.adjustTitle = function(subtitle) {\n    var title,\n      _this = this;\n    if (subtitle == null) {\n      subtitle = '';\n    }\n    title = this.settings.titleTemplate({\n      title: this.title,\n      subtitle: subtitle\n    });\n    setTimeout(function() {\n      document.title = title;\n      return _this.publishEvent('adjustTitle', subtitle, title);\n    }, 50);\n    return title;\n  };\n\n  Layout.prototype.startLinkRouting = function() {\n    var route;\n    route = this.settings.routeLinks;\n    if (!route) {\n      return;\n    }\n    if ($) {\n      return this.$el.on('click', route, this.openLink);\n    } else {\n      return this.delegate('click', route, this.openLink);\n    }\n  };\n\n  Layout.prototype.stopLinkRouting = function() {\n    var route;\n    route = this.settings.routeLinks;\n    if ($) {\n      if (route) {\n        return this.$el.off('click', route);\n      }\n    } else {\n      return this.undelegate('click', route, this.openLink);\n    }\n  };\n\n  Layout.prototype.isExternalLink = function(link) {\n    var _ref, _ref1;\n    return link.target === '_blank' || link.rel === 'external' || ((_ref = link.protocol) !== 'http:' && _ref !== 'https:' && _ref !== 'file:') || ((_ref1 = link.hostname) !== location.hostname && _ref1 !== '');\n  };\n\n  Layout.prototype.openLink = function(event) {\n    var el, external, href, isAnchor, skipRouting, type;\n    if (utils.modifierKeyPressed(event)) {\n      return;\n    }\n    el = $ ? event.currentTarget : event.delegateTarget;\n    isAnchor = el.nodeName === 'A';\n    href = el.getAttribute('href') || el.getAttribute('data-href') || null;\n    if (!(href != null) || href === '' || href.charAt(0) === '#') {\n      return;\n    }\n    skipRouting = this.settings.skipRouting;\n    type = typeof skipRouting;\n    if (type === 'function' && !skipRouting(href, el) || type === 'string' && ($ ? $(el).is(skipRouting) : Backbone.utils.matchesSelector(el, skipRouting))) {\n      return;\n    }\n    external = isAnchor && this.isExternalLink(el);\n    if (external) {\n      if (this.settings.openExternalToBlank) {\n        event.preventDefault();\n        window.open(href);\n      }\n      return;\n    }\n    utils.redirectTo({\n      url: href\n    });\n    event.preventDefault();\n  };\n\n  Layout.prototype.registerRegionHandler = function(instance, name, selector) {\n    if (name != null) {\n      return this.registerGlobalRegion(instance, name, selector);\n    } else {\n      return this.registerGlobalRegions(instance);\n    }\n  };\n\n  Layout.prototype.registerGlobalRegion = function(instance, name, selector) {\n    this.unregisterGlobalRegion(instance, name);\n    return this.globalRegions.unshift({\n      instance: instance,\n      name: name,\n      selector: selector\n    });\n  };\n\n  Layout.prototype.registerGlobalRegions = function(instance) {\n    var name, selector, version, _i, _len, _ref;\n    _ref = utils.getAllPropertyVersions(instance, 'regions');\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      version = _ref[_i];\n      for (name in version) {\n        selector = version[name];\n        this.registerGlobalRegion(instance, name, selector);\n      }\n    }\n  };\n\n  Layout.prototype.unregisterRegionHandler = function(instance, name) {\n    if (name != null) {\n      return this.unregisterGlobalRegion(instance, name);\n    } else {\n      return this.unregisterGlobalRegions(instance);\n    }\n  };\n\n  Layout.prototype.unregisterGlobalRegion = function(instance, name) {\n    var cid, region;\n    cid = instance.cid;\n    return this.globalRegions = (function() {\n      var _i, _len, _ref, _results;\n      _ref = this.globalRegions;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        region = _ref[_i];\n        if (region.instance.cid !== cid || region.name !== name) {\n          _results.push(region);\n        }\n      }\n      return _results;\n    }).call(this);\n  };\n\n  Layout.prototype.unregisterGlobalRegions = function(instance) {\n    var region;\n    return this.globalRegions = (function() {\n      var _i, _len, _ref, _results;\n      _ref = this.globalRegions;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        region = _ref[_i];\n        if (region.instance.cid !== instance.cid) {\n          _results.push(region);\n        }\n      }\n      return _results;\n    }).call(this);\n  };\n\n  Layout.prototype.regionByName = function(name) {\n    var reg, _i, _len, _ref;\n    _ref = this.globalRegions;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      reg = _ref[_i];\n      if (reg.name === name && !reg.instance.stale) {\n        return reg;\n      }\n    }\n  };\n\n  Layout.prototype.showRegion = function(name, instance) {\n    var region;\n    region = this.regionByName(name);\n    if (!region) {\n      throw new Error(\"No region registered under \" + name);\n    }\n    return instance.container = region.selector === '' ? $ ? region.instance.$el : region.instance.el : region.instance.noWrap ? $ ? $(region.instance.container).find(region.selector) : region.instance.container.querySelector(region.selector) : region.instance[$ ? '$' : 'find'](region.selector);\n  };\n\n  Layout.prototype.dispose = function() {\n    var prop, _i, _len, _ref;\n    if (this.disposed) {\n      return;\n    }\n    this.stopLinkRouting();\n    _ref = ['globalRegions', 'title', 'route'];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      prop = _ref[_i];\n      delete this[prop];\n    }\n    mediator.removeHandlers(this);\n    return Layout.__super__.dispose.apply(this, arguments);\n  };\n\n  return Layout;\n\n})(View);\n\n});;loader.register('chaplin/views/view', function(e, r, module) {\n'use strict';\n\nvar $, Backbone, EventBroker, View, attach, bind, mediator, setHTML, utils, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nutils = loader('chaplin/lib/utils');\n\n$ = Backbone.$;\n\nbind = (function() {\n  if (Function.prototype.bind) {\n    return function(item, ctx) {\n      return item.bind(ctx);\n    };\n  } else if (_.bind) {\n    return _.bind;\n  }\n})();\n\nsetHTML = (function() {\n  if ($) {\n    return function(elem, html) {\n      return elem.html(html);\n    };\n  } else {\n    return function(elem, html) {\n      return elem.innerHTML = html;\n    };\n  }\n})();\n\nattach = (function() {\n  if ($) {\n    return function(view) {\n      var actual;\n      actual = $(view.container);\n      if (typeof view.containerMethod === 'function') {\n        return view.containerMethod(actual, view.el);\n      } else {\n        return actual[view.containerMethod](view.el);\n      }\n    };\n  } else {\n    return function(view) {\n      var actual;\n      actual = typeof view.container === 'string' ? document.querySelector(view.container) : view.container;\n      if (typeof view.containerMethod === 'function') {\n        return view.containerMethod(actual, view.el);\n      } else {\n        return actual[view.containerMethod](view.el);\n      }\n    };\n  }\n})();\n\nmodule.exports = View = (function(_super) {\n\n  __extends(View, _super);\n\n  _.extend(View.prototype, EventBroker);\n\n  View.prototype.autoRender = false;\n\n  View.prototype.autoAttach = true;\n\n  View.prototype.container = null;\n\n  View.prototype.containerMethod = $ ? 'append' : 'appendChild';\n\n  View.prototype.regions = null;\n\n  View.prototype.region = null;\n\n  View.prototype.stale = false;\n\n  View.prototype.noWrap = false;\n\n  View.prototype.keepElement = false;\n\n  View.prototype.subviews = null;\n\n  View.prototype.subviewsByName = null;\n\n  View.prototype.optionNames = ['autoAttach', 'autoRender', 'container', 'containerMethod', 'region', 'regions', 'noWrap'];\n\n  function View(options) {\n    var optName, optValue, region, render,\n      _this = this;\n    if (options) {\n      for (optName in options) {\n        optValue = options[optName];\n        if (__indexOf.call(this.optionNames, optName) >= 0) {\n          this[optName] = optValue;\n        }\n      }\n    }\n    render = this.render;\n    this.render = function() {\n      if (_this.disposed) {\n        return false;\n      }\n      render.apply(_this, arguments);\n      if (_this.autoAttach) {\n        _this.attach.apply(_this, arguments);\n      }\n      return _this;\n    };\n    this.subviews = [];\n    this.subviewsByName = {};\n    if (this.noWrap) {\n      if (this.region) {\n        region = mediator.execute('region:find', this.region);\n        if (region != null) {\n          this.el = region.instance.container != null ? region.instance.region != null ? $(region.instance.container).find(region.selector) : region.instance.container : region.instance.$(region.selector);\n        }\n      }\n      if (this.container) {\n        this.el = this.container;\n      }\n    }\n    View.__super__.constructor.apply(this, arguments);\n    this.delegateListeners();\n    if (this.model) {\n      this.listenTo(this.model, 'dispose', this.dispose);\n    }\n    if (this.collection) {\n      this.listenTo(this.collection, 'dispose', function(subject) {\n        if (!subject || subject === _this.collection) {\n          return _this.dispose();\n        }\n      });\n    }\n    if (this.regions != null) {\n      mediator.execute('region:register', this);\n    }\n    if (this.autoRender) {\n      this.render();\n    }\n  }\n\n  View.prototype.delegate = function(eventName, second, third) {\n    var bound, event, events, handler, list, selector;\n    if (Backbone.utils) {\n      return Backbone.utils.delegate(this, eventName, second, third);\n    }\n    if (typeof eventName !== 'string') {\n      throw new TypeError('View#delegate: first argument must be a string');\n    }\n    if (arguments.length === 2) {\n      handler = second;\n    } else if (arguments.length === 3) {\n      selector = second;\n      if (typeof selector !== 'string') {\n        throw new TypeError('View#delegate: ' + 'second argument must be a string');\n      }\n      handler = third;\n    } else {\n      throw new TypeError('View#delegate: ' + 'only two or three arguments are allowed');\n    }\n    if (typeof handler !== 'function') {\n      throw new TypeError('View#delegate: ' + 'handler argument must be function');\n    }\n    list = (function() {\n      var _i, _len, _ref, _results;\n      _ref = eventName.split(' ');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        event = _ref[_i];\n        _results.push(\"\" + event + \".delegate\" + this.cid);\n      }\n      return _results;\n    }).call(this);\n    events = list.join(' ');\n    bound = bind(handler, this);\n    this.$el.on(events, selector || null, bound);\n    return bound;\n  };\n\n  View.prototype._delegateEvents = function(events) {\n    var bound, eventName, handler, key, match, selector, value;\n    if (Backbone.View.prototype.delegateEvents.length === 2) {\n      return Backbone.View.prototype.delegateEvents.call(this, events, true);\n    }\n    for (key in events) {\n      value = events[key];\n      handler = typeof value === 'function' ? value : this[value];\n      if (!handler) {\n        throw new Error(\"Method '\" + value + \"' does not exist\");\n      }\n      match = key.match(/^(\\S+)\\s*(.*)$/);\n      eventName = \"\" + match[1] + \".delegateEvents\" + this.cid;\n      selector = match[2];\n      bound = bind(handler, this);\n      this.$el.on(eventName, selector || null, bound);\n    }\n  };\n\n  View.prototype.delegateEvents = function(events, keepOld) {\n    var classEvents, _i, _len, _ref;\n    if (!keepOld) {\n      this.undelegateEvents();\n    }\n    if (events) {\n      return this._delegateEvents(events);\n    }\n    _ref = utils.getAllPropertyVersions(this, 'events');\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      classEvents = _ref[_i];\n      if (typeof classEvents === 'function') {\n        throw new TypeError('View#delegateEvents: functions are not supported');\n      }\n      this._delegateEvents(classEvents);\n    }\n  };\n\n  View.prototype.undelegate = function(eventName, second, third) {\n    var event, events, handler, list, selector;\n    if (Backbone.utils) {\n      return Backbone.utils.undelegate(this, eventName, second, third);\n    }\n    if (eventName) {\n      if (typeof eventName !== 'string') {\n        throw new TypeError('View#undelegate: first argument must be a string');\n      }\n      if (arguments.length === 2) {\n        if (typeof second === 'string') {\n          selector = second;\n        } else {\n          handler = second;\n        }\n      } else if (arguments.length === 3) {\n        selector = second;\n        if (typeof selector !== 'string') {\n          throw new TypeError('View#undelegate: ' + 'second argument must be a string');\n        }\n        handler = third;\n      }\n      list = (function() {\n        var _i, _len, _ref, _results;\n        _ref = eventName.split(' ');\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          event = _ref[_i];\n          _results.push(\"\" + event + \".delegate\" + this.cid);\n        }\n        return _results;\n      }).call(this);\n      events = list.join(' ');\n      return this.$el.off(events, selector || null);\n    } else {\n      return this.$el.off(\".delegate\" + this.cid);\n    }\n  };\n\n  View.prototype.delegateListeners = function() {\n    var eventName, key, method, target, version, _i, _len, _ref, _ref1;\n    if (!this.listen) {\n      return;\n    }\n    _ref = utils.getAllPropertyVersions(this, 'listen');\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      version = _ref[_i];\n      for (key in version) {\n        method = version[key];\n        if (typeof method !== 'function') {\n          method = this[method];\n        }\n        if (typeof method !== 'function') {\n          throw new Error('View#delegateListeners: ' + (\"\" + method + \" must be function\"));\n        }\n        _ref1 = key.split(' '), eventName = _ref1[0], target = _ref1[1];\n        this.delegateListener(eventName, target, method);\n      }\n    }\n  };\n\n  View.prototype.delegateListener = function(eventName, target, callback) {\n    var prop;\n    if (target === 'model' || target === 'collection') {\n      prop = this[target];\n      if (prop) {\n        this.listenTo(prop, eventName, callback);\n      }\n    } else if (target === 'mediator') {\n      this.subscribeEvent(eventName, callback);\n    } else if (!target) {\n      this.on(eventName, callback, this);\n    }\n  };\n\n  View.prototype.registerRegion = function(name, selector) {\n    return mediator.execute('region:register', this, name, selector);\n  };\n\n  View.prototype.unregisterRegion = function(name) {\n    return mediator.execute('region:unregister', this, name);\n  };\n\n  View.prototype.unregisterAllRegions = function() {\n    return mediator.execute({\n      name: 'region:unregister',\n      silent: true\n    }, this);\n  };\n\n  View.prototype.subview = function(name, view) {\n    var byName, subviews;\n    subviews = this.subviews;\n    byName = this.subviewsByName;\n    if (name && view) {\n      this.removeSubview(name);\n      subviews.push(view);\n      byName[name] = view;\n      return view;\n    } else if (name) {\n      return byName[name];\n    }\n  };\n\n  View.prototype.removeSubview = function(nameOrView) {\n    var byName, index, name, otherName, otherView, subviews, view;\n    if (!nameOrView) {\n      return;\n    }\n    subviews = this.subviews;\n    byName = this.subviewsByName;\n    if (typeof nameOrView === 'string') {\n      name = nameOrView;\n      view = byName[name];\n    } else {\n      view = nameOrView;\n      for (otherName in byName) {\n        otherView = byName[otherName];\n        if (!(otherView === view)) {\n          continue;\n        }\n        name = otherName;\n        break;\n      }\n    }\n    if (!(name && view && view.dispose)) {\n      return;\n    }\n    view.dispose();\n    index = utils.indexOf(subviews, view);\n    if (index !== -1) {\n      subviews.splice(index, 1);\n    }\n    return delete byName[name];\n  };\n\n  View.prototype.getTemplateData = function() {\n    var data, source;\n    data = this.model ? utils.serialize(this.model) : this.collection ? {\n      items: utils.serialize(this.collection),\n      length: this.collection.length\n    } : {};\n    source = this.model || this.collection;\n    if (source) {\n      if (typeof source.isSynced === 'function' && !('synced' in data)) {\n        data.synced = source.isSynced();\n      }\n    }\n    return data;\n  };\n\n  View.prototype.getTemplateFunction = function() {\n    throw new Error('View#getTemplateFunction must be overridden');\n  };\n\n  View.prototype.render = function() {\n    var el, html, templateFunc;\n    if (this.disposed) {\n      return false;\n    }\n    templateFunc = this.getTemplateFunction();\n    if (typeof templateFunc === 'function') {\n      html = templateFunc(this.getTemplateData());\n      if (this.noWrap) {\n        el = document.createElement('div');\n        el.innerHTML = html;\n        if (el.children.length > 1) {\n          throw new Error('There must be a single top-level element when ' + 'using `noWrap`.');\n        }\n        this.undelegateEvents();\n        this.setElement(el.firstChild, true);\n      } else {\n        setHTML(($ ? this.$el : this.el), html);\n      }\n    }\n    return this;\n  };\n\n  View.prototype.attach = function() {\n    if (this.region != null) {\n      mediator.execute('region:show', this.region, this);\n    }\n    if (this.container && !document.body.contains(this.el)) {\n      attach(this);\n      return this.trigger('addedToDOM');\n    }\n  };\n\n  View.prototype.disposed = false;\n\n  View.prototype.dispose = function() {\n    var prop, properties, subview, _i, _j, _len, _len1, _ref;\n    if (this.disposed) {\n      return;\n    }\n    this.unregisterAllRegions();\n    _ref = this.subviews;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      subview = _ref[_i];\n      subview.dispose();\n    }\n    this.unsubscribeAllEvents();\n    this.off();\n    if (this.keepElement) {\n      this.undelegateEvents();\n      this.undelegate();\n      this.stopListening();\n    } else {\n      this.remove();\n    }\n    properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];\n    for (_j = 0, _len1 = properties.length; _j < _len1; _j++) {\n      prop = properties[_j];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return View;\n\n})(Backbone.View);\n\n});;loader.register('chaplin/views/collection_view', function(e, r, module) {\n'use strict';\n\nvar $, Backbone, CollectionView, View, addClass, endAnimation, filterChildren, insertView, startAnimation, toggleElement, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nView = loader('chaplin/views/view');\n\nutils = loader('chaplin/lib/utils');\n\n$ = Backbone.$;\n\nfilterChildren = function(nodeList, selector) {\n  var node, _i, _len, _results;\n  if (!selector) {\n    return nodeList;\n  }\n  _results = [];\n  for (_i = 0, _len = nodeList.length; _i < _len; _i++) {\n    node = nodeList[_i];\n    if (Backbone.utils.matchesSelector(node, selector)) {\n      _results.push(node);\n    }\n  }\n  return _results;\n};\n\ntoggleElement = (function() {\n  if ($) {\n    return function(elem, visible) {\n      return elem.toggle(visible);\n    };\n  } else {\n    return function(elem, visible) {\n      return elem.style.display = (visible ? '' : 'none');\n    };\n  }\n})();\n\naddClass = (function() {\n  if ($) {\n    return function(elem, cls) {\n      return elem.addClass(cls);\n    };\n  } else {\n    return function(elem, cls) {\n      return elem.classList.add(cls);\n    };\n  }\n})();\n\nstartAnimation = (function() {\n  if ($) {\n    return function(elem, useCssAnimation, cls) {\n      if (useCssAnimation) {\n        return addClass(elem, cls);\n      } else {\n        return elem.css('opacity', 0);\n      }\n    };\n  } else {\n    return function(elem, useCssAnimation, cls) {\n      if (useCssAnimation) {\n        return addClass(elem, cls);\n      } else {\n        return elem.style.opacity = 0;\n      }\n    };\n  }\n})();\n\nendAnimation = (function() {\n  if ($) {\n    return function(elem, duration) {\n      return elem.animate({\n        opacity: 1\n      }, duration);\n    };\n  } else {\n    return function(elem, duration) {\n      elem.style.transition = \"opacity \" + (duration / 1000) + \"s\";\n      return elem.opacity = 1;\n    };\n  }\n})();\n\ninsertView = (function() {\n  if ($) {\n    return function(list, viewEl, position, length, itemSelector) {\n      var children, childrenLength, insertInMiddle, isEnd, method;\n      insertInMiddle = (0 < position && position < length);\n      isEnd = function(length) {\n        return length === 0 || position === length;\n      };\n      if (insertInMiddle || itemSelector) {\n        children = list.children(itemSelector);\n        childrenLength = children.length;\n        if (children[position] !== viewEl) {\n          if (isEnd(childrenLength)) {\n            return list.append(viewEl);\n          } else {\n            if (position === 0) {\n              return children.eq(position).before(viewEl);\n            } else {\n              return children.eq(position - 1).after(viewEl);\n            }\n          }\n        }\n      } else {\n        method = isEnd(length) ? 'append' : 'prepend';\n        return list[method](viewEl);\n      }\n    };\n  } else {\n    return function(list, viewEl, position, length, itemSelector) {\n      var children, childrenLength, insertInMiddle, isEnd, last;\n      insertInMiddle = (0 < position && position < length);\n      isEnd = function(length) {\n        return length === 0 || position === length;\n      };\n      if (insertInMiddle || itemSelector) {\n        children = filterChildren(list.children, itemSelector);\n        childrenLength = children.length;\n        if (children[position] !== viewEl) {\n          if (isEnd(childrenLength)) {\n            return list.appendChild(viewEl);\n          } else if (position === 0) {\n            return list.insertBefore(viewEl, children[position]);\n          } else {\n            last = children[position - 1];\n            if (list.lastChild === last) {\n              return list.appendChild(viewEl);\n            } else {\n              return list.insertBefore(viewEl, last.nextElementSibling);\n            }\n          }\n        }\n      } else if (isEnd(length)) {\n        return list.appendChild(viewEl);\n      } else {\n        return list.insertBefore(viewEl, list.firstChild);\n      }\n    };\n  }\n})();\n\nmodule.exports = CollectionView = (function(_super) {\n\n  __extends(CollectionView, _super);\n\n  CollectionView.prototype.itemView = null;\n\n  CollectionView.prototype.autoRender = true;\n\n  CollectionView.prototype.renderItems = true;\n\n  CollectionView.prototype.animationDuration = 500;\n\n  CollectionView.prototype.useCssAnimation = false;\n\n  CollectionView.prototype.animationStartClass = 'animated-item-view';\n\n  CollectionView.prototype.animationEndClass = 'animated-item-view-end';\n\n  CollectionView.prototype.listSelector = null;\n\n  CollectionView.prototype.$list = null;\n\n  CollectionView.prototype.fallbackSelector = null;\n\n  CollectionView.prototype.$fallback = null;\n\n  CollectionView.prototype.loadingSelector = null;\n\n  CollectionView.prototype.$loading = null;\n\n  CollectionView.prototype.itemSelector = void 0;\n\n  CollectionView.prototype.filterer = null;\n\n  CollectionView.prototype.filterCallback = function(view, included) {\n    if ($) {\n      view.$el.stop(true, true);\n    }\n    return toggleElement(($ ? view.$el : view.el), included);\n  };\n\n  CollectionView.prototype.visibleItems = null;\n\n  CollectionView.prototype.optionNames = View.prototype.optionNames.concat(['renderItems', 'itemView']);\n\n  function CollectionView(options) {\n    this.renderAllItems = __bind(this.renderAllItems, this);\n\n    this.toggleFallback = __bind(this.toggleFallback, this);\n\n    this.itemsReset = __bind(this.itemsReset, this);\n\n    this.itemRemoved = __bind(this.itemRemoved, this);\n\n    this.itemAdded = __bind(this.itemAdded, this);\n    this.visibleItems = [];\n    CollectionView.__super__.constructor.apply(this, arguments);\n  }\n\n  CollectionView.prototype.initialize = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.addCollectionListeners();\n    if (options.filterer != null) {\n      return this.filter(options.filterer);\n    }\n  };\n\n  CollectionView.prototype.addCollectionListeners = function() {\n    this.listenTo(this.collection, 'add', this.itemAdded);\n    this.listenTo(this.collection, 'remove', this.itemRemoved);\n    return this.listenTo(this.collection, 'reset sort', this.itemsReset);\n  };\n\n  CollectionView.prototype.getTemplateData = function() {\n    var templateData;\n    templateData = {\n      length: this.collection.length\n    };\n    if (typeof this.collection.isSynced === 'function') {\n      templateData.synced = this.collection.isSynced();\n    }\n    return templateData;\n  };\n\n  CollectionView.prototype.getTemplateFunction = function() {};\n\n  CollectionView.prototype.render = function() {\n    var listSelector;\n    CollectionView.__super__.render.apply(this, arguments);\n    listSelector = _.result(this, 'listSelector');\n    if ($) {\n      this.$list = listSelector ? this.$(listSelector) : this.$el;\n    } else {\n      this.list = listSelector ? this.find(this.listSelector) : this.el;\n    }\n    this.initFallback();\n    this.initLoadingIndicator();\n    if (this.renderItems) {\n      return this.renderAllItems();\n    }\n  };\n\n  CollectionView.prototype.itemAdded = function(item, collection, options) {\n    return this.insertView(item, this.renderItem(item), options.at);\n  };\n\n  CollectionView.prototype.itemRemoved = function(item) {\n    return this.removeViewForItem(item);\n  };\n\n  CollectionView.prototype.itemsReset = function() {\n    return this.renderAllItems();\n  };\n\n  CollectionView.prototype.initFallback = function() {\n    if (!this.fallbackSelector) {\n      return;\n    }\n    if ($) {\n      this.$fallback = this.$(this.fallbackSelector);\n    } else {\n      this.fallback = this.find(this.fallbackSelector);\n    }\n    this.on('visibilityChange', this.toggleFallback);\n    this.listenTo(this.collection, 'syncStateChange', this.toggleFallback);\n    return this.toggleFallback();\n  };\n\n  CollectionView.prototype.toggleFallback = function() {\n    var visible;\n    visible = this.visibleItems.length === 0 && (typeof this.collection.isSynced === 'function' ? this.collection.isSynced() : true);\n    return toggleElement(($ ? this.$fallback : this.fallback), visible);\n  };\n\n  CollectionView.prototype.initLoadingIndicator = function() {\n    if (!(this.loadingSelector && typeof this.collection.isSyncing === 'function')) {\n      return;\n    }\n    if ($) {\n      this.$loading = this.$(this.loadingSelector);\n    } else {\n      this.loading = this.find(this.loadingSelector);\n    }\n    this.listenTo(this.collection, 'syncStateChange', this.toggleLoadingIndicator);\n    return this.toggleLoadingIndicator();\n  };\n\n  CollectionView.prototype.toggleLoadingIndicator = function() {\n    var visible;\n    visible = this.collection.length === 0 && this.collection.isSyncing();\n    return toggleElement(($ ? this.$loading : this.loading), visible);\n  };\n\n  CollectionView.prototype.getItemViews = function() {\n    var itemViews, name, view, _ref;\n    itemViews = {};\n    if (this.subviews.length > 0) {\n      _ref = this.subviewsByName;\n      for (name in _ref) {\n        view = _ref[name];\n        if (name.slice(0, 9) === 'itemView:') {\n          itemViews[name.slice(9)] = view;\n        }\n      }\n    }\n    return itemViews;\n  };\n\n  CollectionView.prototype.filter = function(filterer, filterCallback) {\n    var hasItemViews, included, index, item, view, _i, _len, _ref,\n      _this = this;\n    if (typeof filterer === 'function' || filterer === null) {\n      this.filterer = filterer;\n    }\n    if (typeof filterCallback === 'function' || filterCallback === null) {\n      this.filterCallback = filterCallback;\n    }\n    hasItemViews = (function() {\n      var name;\n      if (_this.subviews.length > 0) {\n        for (name in _this.subviewsByName) {\n          if (name.slice(0, 9) === 'itemView:') {\n            return true;\n          }\n        }\n      }\n      return false;\n    })();\n    if (hasItemViews) {\n      _ref = this.collection.models;\n      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n        item = _ref[index];\n        included = typeof this.filterer === 'function' ? this.filterer(item, index) : true;\n        view = this.subview(\"itemView:\" + item.cid);\n        if (!view) {\n          throw new Error('CollectionView#filter: ' + (\"no view found for \" + item.cid));\n        }\n        this.filterCallback(view, included);\n        this.updateVisibleItems(view.model, included, false);\n      }\n    }\n    return this.trigger('visibilityChange', this.visibleItems);\n  };\n\n  CollectionView.prototype.renderAllItems = function() {\n    var cid, index, item, items, remainingViewsByCid, view, _i, _j, _len, _len1, _ref;\n    items = this.collection.models;\n    this.visibleItems = [];\n    remainingViewsByCid = {};\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n      view = this.subview(\"itemView:\" + item.cid);\n      if (view) {\n        remainingViewsByCid[item.cid] = view;\n      }\n    }\n    _ref = this.getItemViews();\n    for (cid in _ref) {\n      if (!__hasProp.call(_ref, cid)) continue;\n      view = _ref[cid];\n      if (!(cid in remainingViewsByCid)) {\n        this.removeSubview(\"itemView:\" + cid);\n      }\n    }\n    for (index = _j = 0, _len1 = items.length; _j < _len1; index = ++_j) {\n      item = items[index];\n      view = this.subview(\"itemView:\" + item.cid);\n      if (view) {\n        this.insertView(item, view, index, false);\n      } else {\n        this.insertView(item, this.renderItem(item), index);\n      }\n    }\n    if (items.length === 0) {\n      return this.trigger('visibilityChange', this.visibleItems);\n    }\n  };\n\n  CollectionView.prototype.renderItem = function(item) {\n    var view;\n    view = this.subview(\"itemView:\" + item.cid);\n    if (!view) {\n      view = this.initItemView(item);\n      this.subview(\"itemView:\" + item.cid, view);\n    }\n    view.render();\n    return view;\n  };\n\n  CollectionView.prototype.initItemView = function(model) {\n    if (this.itemView) {\n      return new this.itemView({\n        autoRender: false,\n        model: model\n      });\n    } else {\n      throw new Error('The CollectionView#itemView property ' + 'must be defined or the initItemView() must be overridden.');\n    }\n  };\n\n  CollectionView.prototype.insertView = function(item, view, position, enableAnimation) {\n    var elem, included, length, list,\n      _this = this;\n    if (enableAnimation == null) {\n      enableAnimation = true;\n    }\n    if (this.animationDuration === 0) {\n      enableAnimation = false;\n    }\n    if (typeof position !== 'number') {\n      position = this.collection.indexOf(item);\n    }\n    included = typeof this.filterer === 'function' ? this.filterer(item, position) : true;\n    elem = $ ? view.$el : view.el;\n    if (included && enableAnimation) {\n      startAnimation(elem, this.useCssAnimation, this.animationStartClass);\n    }\n    if (this.filterer) {\n      this.filterCallback(view, included);\n    }\n    length = this.collection.length;\n    list = $ ? this.$list : this.list;\n    insertView(list, elem, position, length, this.itemSelector);\n    view.trigger('addedToParent');\n    this.updateVisibleItems(item, included);\n    if (included && enableAnimation) {\n      if (this.useCssAnimation) {\n        setTimeout((function() {\n          return addClass(elem, _this.animationEndClass);\n        }), 0);\n      } else {\n        endAnimation(elem, this.animationDuration);\n      }\n    }\n    return view;\n  };\n\n  CollectionView.prototype.removeViewForItem = function(item) {\n    this.updateVisibleItems(item, false);\n    return this.removeSubview(\"itemView:\" + item.cid);\n  };\n\n  CollectionView.prototype.updateVisibleItems = function(item, includedInFilter, triggerEvent) {\n    var includedInVisibleItems, visibilityChanged, visibleItemsIndex;\n    if (triggerEvent == null) {\n      triggerEvent = true;\n    }\n    visibilityChanged = false;\n    visibleItemsIndex = utils.indexOf(this.visibleItems, item);\n    includedInVisibleItems = visibleItemsIndex !== -1;\n    if (includedInFilter && !includedInVisibleItems) {\n      this.visibleItems.push(item);\n      visibilityChanged = true;\n    } else if (!includedInFilter && includedInVisibleItems) {\n      this.visibleItems.splice(visibleItemsIndex, 1);\n      visibilityChanged = true;\n    }\n    if (visibilityChanged && triggerEvent) {\n      this.trigger('visibilityChange', this.visibleItems);\n    }\n    return visibilityChanged;\n  };\n\n  CollectionView.prototype.dispose = function() {\n    var prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    properties = ['$list', '$fallback', '$loading', 'visibleItems'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    return CollectionView.__super__.dispose.apply(this, arguments);\n  };\n\n  return CollectionView;\n\n})(View);\n\n});;loader.register('chaplin/lib/route', function(e, r, module) {\n'use strict';\n\nvar Backbone, Controller, EventBroker, Route, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nController = loader('chaplin/controllers/controller');\n\nutils = loader('chaplin/lib/utils');\n\nmodule.exports = Route = (function() {\n  var escapeRegExp, optionalRegExp, paramRegExp, processTrailingSlash;\n\n  Route.extend = Backbone.Model.extend;\n\n  _.extend(Route.prototype, EventBroker);\n\n  escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  optionalRegExp = /\\((.*?)\\)/g;\n\n  paramRegExp = /(?::|\\*)(\\w+)/g;\n\n  processTrailingSlash = function(path, trailing) {\n    switch (trailing) {\n      case true:\n        if (path.slice(-1) !== '/') {\n          path += '/';\n        }\n        break;\n      case false:\n        if (path.slice(-1) === '/') {\n          path = path.slice(0, -1);\n        }\n    }\n    return path;\n  };\n\n  function Route(pattern, controller, action, options) {\n    var _ref;\n    this.pattern = pattern;\n    this.controller = controller;\n    this.action = action;\n    this.handler = __bind(this.handler, this);\n\n    this.replaceParams = __bind(this.replaceParams, this);\n\n    this.parseOptionalPortion = __bind(this.parseOptionalPortion, this);\n\n    if (typeof this.pattern !== 'string') {\n      throw new Error('Route: RegExps are not supported.\\\n        Use strings with :names and `constraints` option of route');\n    }\n    this.options = options ? _.extend({}, options) : {};\n    if (this.options.name != null) {\n      this.name = this.options.name;\n    }\n    if (this.name && this.name.indexOf('#') !== -1) {\n      throw new Error('Route: \"#\" cannot be used in name');\n    }\n    if ((_ref = this.name) == null) {\n      this.name = this.controller + '#' + this.action;\n    }\n    this.allParams = [];\n    this.requiredParams = [];\n    this.optionalParams = [];\n    if (this.action in Controller.prototype) {\n      throw new Error('Route: You should not use existing controller ' + 'properties as action names');\n    }\n    this.createRegExp();\n    if (typeof Object.freeze === \"function\") {\n      Object.freeze(this);\n    }\n  }\n\n  Route.prototype.matches = function(criteria) {\n    var invalidParamsCount, name, propertiesCount, property, _i, _len, _ref;\n    if (typeof criteria === 'string') {\n      return criteria === this.name;\n    } else {\n      propertiesCount = 0;\n      _ref = ['name', 'action', 'controller'];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        name = _ref[_i];\n        propertiesCount++;\n        property = criteria[name];\n        if (property && property !== this[name]) {\n          return false;\n        }\n      }\n      invalidParamsCount = propertiesCount === 1 && (name === 'action' || name === 'controller');\n      return !invalidParamsCount;\n    }\n  };\n\n  Route.prototype.reverse = function(params, query) {\n    var name, queryString, raw, url, value, _i, _j, _len, _len1, _ref, _ref1;\n    params = this.normalizeParams(params);\n    if (params === false) {\n      return false;\n    }\n    url = this.pattern;\n    _ref = this.requiredParams;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      name = _ref[_i];\n      value = params[name];\n      url = url.replace(RegExp(\"[:*]\" + name, \"g\"), value);\n    }\n    _ref1 = this.optionalParams;\n    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n      name = _ref1[_j];\n      if (value = params[name]) {\n        url = url.replace(RegExp(\"[:*]\" + name, \"g\"), value);\n      }\n    }\n    raw = url.replace(optionalRegExp, function(match, portion) {\n      if (portion.match(/[:*]/g)) {\n        return \"\";\n      } else {\n        return portion;\n      }\n    });\n    url = processTrailingSlash(raw, this.options.trailing);\n    if (!query) {\n      return url;\n    }\n    if (typeof query === 'object') {\n      queryString = utils.queryParams.stringify(query);\n      return url += queryString ? '?' + queryString : '';\n    } else {\n      return url += (query[0] === '?' ? '' : '?') + query;\n    }\n  };\n\n  Route.prototype.normalizeParams = function(params) {\n    var paramIndex, paramName, paramsHash, _i, _len, _ref;\n    if (utils.isArray(params)) {\n      if (params.length < this.requiredParams.length) {\n        return false;\n      }\n      paramsHash = {};\n      _ref = this.requiredParams;\n      for (paramIndex = _i = 0, _len = _ref.length; _i < _len; paramIndex = ++_i) {\n        paramName = _ref[paramIndex];\n        paramsHash[paramName] = params[paramIndex];\n      }\n      if (!this.testConstraints(paramsHash)) {\n        return false;\n      }\n      params = paramsHash;\n    } else {\n      if (params == null) {\n        params = {};\n      }\n      if (!this.testParams(params)) {\n        return false;\n      }\n    }\n    return params;\n  };\n\n  Route.prototype.testConstraints = function(params) {\n    var constraint, constraints, name;\n    constraints = this.options.constraints;\n    if (constraints) {\n      for (name in constraints) {\n        if (!__hasProp.call(constraints, name)) continue;\n        constraint = constraints[name];\n        if (!constraint.test(params[name])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n\n  Route.prototype.testParams = function(params) {\n    var paramName, _i, _len, _ref;\n    _ref = this.requiredParams;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      paramName = _ref[_i];\n      if (params[paramName] === void 0) {\n        return false;\n      }\n    }\n    return this.testConstraints(params);\n  };\n\n  Route.prototype.createRegExp = function() {\n    var pattern,\n      _this = this;\n    pattern = this.pattern;\n    pattern = pattern.replace(escapeRegExp, '\\\\$&');\n    this.replaceParams(pattern, function(match, param) {\n      return _this.allParams.push(param);\n    });\n    pattern = pattern.replace(optionalRegExp, this.parseOptionalPortion);\n    pattern = this.replaceParams(pattern, function(match, param) {\n      _this.requiredParams.push(param);\n      return _this.paramCapturePattern(match);\n    });\n    return this.regExp = RegExp(\"^\" + pattern + \"(?=\\\\/?(?=\\\\?|$))\");\n  };\n\n  Route.prototype.parseOptionalPortion = function(match, optionalPortion) {\n    var portion,\n      _this = this;\n    portion = this.replaceParams(optionalPortion, function(match, param) {\n      _this.optionalParams.push(param);\n      return _this.paramCapturePattern(match);\n    });\n    return \"(?:\" + portion + \")?\";\n  };\n\n  Route.prototype.replaceParams = function(s, callback) {\n    return s.replace(paramRegExp, callback);\n  };\n\n  Route.prototype.paramCapturePattern = function(param) {\n    if (param.charAt(0) === ':') {\n      return '([^\\/\\?]+)';\n    } else {\n      return '(.*?)';\n    }\n  };\n\n  Route.prototype.test = function(path) {\n    var constraints, matched;\n    matched = this.regExp.test(path);\n    if (!matched) {\n      return false;\n    }\n    constraints = this.options.constraints;\n    if (constraints) {\n      return this.testConstraints(this.extractParams(path));\n    }\n    return true;\n  };\n\n  Route.prototype.handler = function(pathParams, options) {\n    var actionParams, params, path, query, route, _ref;\n    options = options ? _.extend({}, options) : {};\n    if (typeof pathParams === 'object') {\n      query = utils.queryParams.stringify(options.query);\n      params = pathParams;\n      path = this.reverse(params);\n    } else {\n      _ref = pathParams.split('?'), path = _ref[0], query = _ref[1];\n      if (!(query != null)) {\n        query = '';\n      } else {\n        options.query = utils.queryParams.parse(query);\n      }\n      params = this.extractParams(path);\n      path = processTrailingSlash(path, this.options.trailing);\n    }\n    actionParams = _.extend({}, params, this.options.params);\n    route = {\n      path: path,\n      action: this.action,\n      controller: this.controller,\n      name: this.name,\n      query: query\n    };\n    return this.publishEvent('router:match', route, actionParams, options);\n  };\n\n  Route.prototype.extractParams = function(path) {\n    var index, match, matches, paramName, params, _i, _len, _ref;\n    params = {};\n    matches = this.regExp.exec(path);\n    _ref = matches.slice(1);\n    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {\n      match = _ref[index];\n      paramName = this.allParams.length ? this.allParams[index] : index;\n      params[paramName] = match;\n    }\n    return params;\n  };\n\n  return Route;\n\n})();\n\n});;loader.register('chaplin/lib/router', function(e, r, module) {\n'use strict';\n\nvar Backbone, EventBroker, History, Route, Router, mediator, utils, _,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nmediator = loader('chaplin/mediator');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nHistory = loader('chaplin/lib/history');\n\nRoute = loader('chaplin/lib/route');\n\nutils = loader('chaplin/lib/utils');\n\nmodule.exports = Router = (function() {\n\n  Router.extend = Backbone.Model.extend;\n\n  _.extend(Router.prototype, EventBroker);\n\n  function Router(options) {\n    var isWebFile;\n    this.options = options != null ? options : {};\n    this.match = __bind(this.match, this);\n\n    isWebFile = window.location.protocol !== 'file:';\n    _.defaults(this.options, {\n      pushState: isWebFile,\n      root: '/',\n      trailing: false\n    });\n    this.removeRoot = new RegExp('^' + utils.escapeRegExp(this.options.root) + '(#)?');\n    this.subscribeEvent('!router:route', this.oldEventError);\n    this.subscribeEvent('!router:routeByName', this.oldEventError);\n    this.subscribeEvent('!router:changeURL', this.oldURLEventError);\n    this.subscribeEvent('dispatcher:dispatch', this.changeURL);\n    mediator.setHandler('router:route', this.route, this);\n    mediator.setHandler('router:reverse', this.reverse, this);\n    this.createHistory();\n  }\n\n  Router.prototype.oldEventError = function() {\n    throw new Error('!router:route and !router:routeByName events were removed.\\\n  Use `Chaplin.utils.redirectTo`');\n  };\n\n  Router.prototype.oldURLEventError = function() {\n    throw new Error('!router:changeURL event was removed.');\n  };\n\n  Router.prototype.createHistory = function() {\n    return Backbone.history = new History();\n  };\n\n  Router.prototype.startHistory = function() {\n    return Backbone.history.start(this.options);\n  };\n\n  Router.prototype.stopHistory = function() {\n    if (Backbone.History.started) {\n      return Backbone.history.stop();\n    }\n  };\n\n  Router.prototype.findHandler = function(predicate) {\n    var handler, _i, _len, _ref;\n    _ref = Backbone.history.handlers;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      handler = _ref[_i];\n      if (predicate(handler)) {\n        return handler;\n      }\n    }\n  };\n\n  Router.prototype.match = function(pattern, target, options) {\n    var action, controller, route, _ref;\n    if (options == null) {\n      options = {};\n    }\n    if (arguments.length === 2 && typeof target === 'object') {\n      options = target;\n      controller = options.controller, action = options.action;\n      if (!(controller && action)) {\n        throw new Error('Router#match must receive either target or ' + 'options.controller & options.action');\n      }\n    } else {\n      controller = options.controller, action = options.action;\n      if (controller || action) {\n        throw new Error('Router#match cannot use both target and ' + 'options.controller / options.action');\n      }\n      _ref = target.split('#'), controller = _ref[0], action = _ref[1];\n    }\n    _.defaults(options, {\n      trailing: this.options.trailing\n    });\n    route = new Route(pattern, controller, action, options);\n    Backbone.history.handlers.push({\n      route: route,\n      callback: route.handler\n    });\n    return route;\n  };\n\n  Router.prototype.route = function(pathDesc, params, options) {\n    var handler, path;\n    if (typeof pathDesc === 'object') {\n      path = pathDesc.url;\n      if (!params && pathDesc.params) {\n        params = pathDesc.params;\n      }\n    }\n    params = params ? utils.isArray(params) ? params.slice() : _.extend({}, params) : {};\n    if (path != null) {\n      path = path.replace(this.removeRoot, '');\n      handler = this.findHandler(function(handler) {\n        return handler.route.test(path);\n      });\n      options = params;\n      params = null;\n    } else {\n      options = options ? _.extend({}, options) : {};\n      handler = this.findHandler(function(handler) {\n        if (handler.route.matches(pathDesc)) {\n          params = handler.route.normalizeParams(params);\n          if (params) {\n            return true;\n          }\n        }\n        return false;\n      });\n    }\n    if (handler) {\n      _.defaults(options, {\n        changeURL: true\n      });\n      handler.callback(path || params, options);\n      return true;\n    } else {\n      throw new Error('Router#route: request was not routed');\n    }\n  };\n\n  Router.prototype.reverse = function(criteria, params, query) {\n    var handler, handlers, reversed, root, url, _i, _len;\n    root = this.options.root;\n    if ((params != null) && typeof params !== 'object') {\n      throw new TypeError('Router#reverse: params must be an array or an ' + 'object');\n    }\n    handlers = Backbone.history.handlers;\n    for (_i = 0, _len = handlers.length; _i < _len; _i++) {\n      handler = handlers[_i];\n      if (!(handler.route.matches(criteria))) {\n        continue;\n      }\n      reversed = handler.route.reverse(params, query);\n      if (reversed !== false) {\n        url = root ? root + reversed : reversed;\n        return url;\n      }\n    }\n    throw new Error('Router#reverse: invalid route specified');\n  };\n\n  Router.prototype.changeURL = function(controller, params, route, options) {\n    var navigateOptions, url;\n    if (!((route.path != null) && options.changeURL)) {\n      return;\n    }\n    url = route.path + (route.query ? \"?\" + route.query : \"\");\n    navigateOptions = {\n      trigger: options.trigger === true,\n      replace: options.replace === true\n    };\n    return Backbone.history.navigate(url, navigateOptions);\n  };\n\n  Router.prototype.disposed = false;\n\n  Router.prototype.dispose = function() {\n    if (this.disposed) {\n      return;\n    }\n    this.stopHistory();\n    delete Backbone.history;\n    this.unsubscribeAllEvents();\n    mediator.removeHandlers(this);\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Router;\n\n})();\n\n});;loader.register('chaplin/lib/history', function(e, r, module) {\n'use strict';\n\nvar Backbone, History, isExplorer, rootStripper, routeStripper, trailingSlash, _,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nrouteStripper = /^[#\\/]|\\s+$/g;\n\nrootStripper = /^\\/+|\\/+$/g;\n\nisExplorer = /msie [\\w.]+/;\n\ntrailingSlash = /\\/$/;\n\nHistory = (function(_super) {\n\n  __extends(History, _super);\n\n  function History() {\n    return History.__super__.constructor.apply(this, arguments);\n  }\n\n  History.prototype.getFragment = function(fragment, forcePushState) {\n    var root;\n    if (!(fragment != null)) {\n      if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n        fragment = this.location.pathname + this.location.search;\n        root = this.root.replace(trailingSlash, '');\n        if (!fragment.indexOf(root)) {\n          fragment = fragment.substr(root.length);\n        }\n      } else {\n        fragment = this.getHash();\n      }\n    }\n    return fragment.replace(routeStripper, '');\n  };\n\n  History.prototype.start = function(options) {\n    var atRoot, fragment, loc;\n    if (Backbone.History.started) {\n      throw new Error('Backbone.history has already been started');\n    }\n    Backbone.History.started = true;\n    this.options = _.extend({}, {\n      root: '/'\n    }, this.options, options);\n    this.root = this.options.root;\n    this._wantsHashChange = this.options.hashChange !== false;\n    this._wantsPushState = Boolean(this.options.pushState);\n    this._hasPushState = Boolean(this.options.pushState && this.history && this.history.pushState);\n    fragment = this.getFragment();\n    this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n    if (this._hasPushState) {\n      Backbone.$(window).on('popstate', this.checkUrl);\n    } else if (this._wantsHashChange && 'onhashchange' in window) {\n      Backbone.$(window).on('hashchange', this.checkUrl);\n    } else if (this._wantsHashChange) {\n      this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n    }\n    this.fragment = fragment;\n    loc = this.location;\n    atRoot = loc.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n    if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {\n      this.fragment = this.getFragment(null, true);\n      this.location.replace(this.root + '#' + this.fragment);\n      return true;\n    } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {\n      this.fragment = this.getHash().replace(routeStripper, '');\n      this.history.replaceState({}, document.title, this.root + this.fragment);\n    }\n    if (!this.options.silent) {\n      return this.loadUrl();\n    }\n  };\n\n  History.prototype.navigate = function(fragment, options) {\n    var historyMethod, isSameFragment, url;\n    if (fragment == null) {\n      fragment = '';\n    }\n    if (!Backbone.History.started) {\n      return false;\n    }\n    if (!options || options === true) {\n      options = {\n        trigger: options\n      };\n    }\n    fragment = this.getFragment(fragment);\n    url = this.root + fragment;\n    if (this.fragment === fragment) {\n      return false;\n    }\n    this.fragment = fragment;\n    if (fragment.length === 0 && url !== '/') {\n      url = url.slice(0, -1);\n    }\n    if (this._hasPushState) {\n      historyMethod = options.replace ? 'replaceState' : 'pushState';\n      this.history[historyMethod]({}, document.title, url);\n    } else if (this._wantsHashChange) {\n      this._updateHash(this.location, fragment, options.replace);\n      isSameFragment = fragment !== this.getFragment(this.getHash(this.iframe));\n      if ((this.iframe != null) && isSameFragment) {\n        if (!options.replace) {\n          this.iframe.document.open().close();\n        }\n        this._updateHash(this.iframe.location, fragment, options.replace);\n      }\n    } else {\n      return this.location.assign(url);\n    }\n    if (options.trigger) {\n      return this.loadUrl(fragment);\n    }\n  };\n\n  return History;\n\n})(Backbone.History);\n\nmodule.exports = Backbone.$ ? History : Backbone.History;\n\n});;loader.register('chaplin/lib/event_broker', function(e, r, module) {\n'use strict';\n\nvar EventBroker, mediator,\n  __slice = [].slice;\n\nmediator = loader('chaplin/mediator');\n\nEventBroker = {\n  subscribeEvent: function(type, handler) {\n    if (typeof type !== 'string') {\n      throw new TypeError('EventBroker#subscribeEvent: ' + 'type argument must be a string');\n    }\n    if (typeof handler !== 'function') {\n      throw new TypeError('EventBroker#subscribeEvent: ' + 'handler argument must be a function');\n    }\n    mediator.unsubscribe(type, handler, this);\n    return mediator.subscribe(type, handler, this);\n  },\n  unsubscribeEvent: function(type, handler) {\n    if (typeof type !== 'string') {\n      throw new TypeError('EventBroker#unsubscribeEvent: ' + 'type argument must be a string');\n    }\n    if (typeof handler !== 'function') {\n      throw new TypeError('EventBroker#unsubscribeEvent: ' + 'handler argument must be a function');\n    }\n    return mediator.unsubscribe(type, handler);\n  },\n  unsubscribeAllEvents: function() {\n    return mediator.unsubscribe(null, null, this);\n  },\n  publishEvent: function() {\n    var args, type;\n    type = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (typeof type !== 'string') {\n      throw new TypeError('EventBroker#publishEvent: ' + 'type argument must be a string');\n    }\n    return mediator.publish.apply(mediator, [type].concat(__slice.call(args)));\n  }\n};\n\nif (typeof Object.freeze === \"function\") {\n  Object.freeze(EventBroker);\n}\n\nmodule.exports = EventBroker;\n\n});;loader.register('chaplin/lib/support', function(e, r, module) {\n'use strict';\n\nvar support;\n\nsupport = {\n  propertyDescriptors: (function() {\n    var o;\n    if (!(typeof Object.defineProperty === 'function' && typeof Object.defineProperties === 'function')) {\n      return false;\n    }\n    try {\n      o = {};\n      Object.defineProperty(o, 'foo', {\n        value: 'bar'\n      });\n      return o.foo === 'bar';\n    } catch (error) {\n      return false;\n    }\n  })()\n};\n\nmodule.exports = support;\n\n});;loader.register('chaplin/lib/composition', function(e, r, module) {\n'use strict';\n\nvar Backbone, Composition, EventBroker, has, _,\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nBackbone = loader('backbone');\n\nEventBroker = loader('chaplin/lib/event_broker');\n\nhas = Object.prototype.hasOwnProperty;\n\nmodule.exports = Composition = (function() {\n\n  Composition.extend = Backbone.Model.extend;\n\n  _.extend(Composition.prototype, Backbone.Events);\n\n  _.extend(Composition.prototype, EventBroker);\n\n  Composition.prototype.item = null;\n\n  Composition.prototype.options = null;\n\n  Composition.prototype._stale = false;\n\n  function Composition(options) {\n    if (options != null) {\n      this.options = _.extend({}, options);\n    }\n    this.item = this;\n    this.initialize(this.options);\n  }\n\n  Composition.prototype.initialize = function() {};\n\n  Composition.prototype.compose = function() {};\n\n  Composition.prototype.check = function(options) {\n    return _.isEqual(this.options, options);\n  };\n\n  Composition.prototype.stale = function(value) {\n    var item, name;\n    if (value == null) {\n      return this._stale;\n    }\n    this._stale = value;\n    for (name in this) {\n      item = this[name];\n      if (item && item !== this && typeof item === 'object' && has.call(item, 'stale')) {\n        item.stale = value;\n      }\n    }\n  };\n\n  Composition.prototype.disposed = false;\n\n  Composition.prototype.dispose = function() {\n    var obj, prop, properties, _i, _len;\n    if (this.disposed) {\n      return;\n    }\n    for (prop in this) {\n      if (!__hasProp.call(this, prop)) continue;\n      obj = this[prop];\n      if (obj && typeof obj.dispose === 'function') {\n        if (obj !== this) {\n          obj.dispose();\n          delete this[prop];\n        }\n      }\n    }\n    this.unsubscribeAllEvents();\n    this.stopListening();\n    properties = ['redirected'];\n    for (_i = 0, _len = properties.length; _i < _len; _i++) {\n      prop = properties[_i];\n      delete this[prop];\n    }\n    this.disposed = true;\n    return typeof Object.freeze === \"function\" ? Object.freeze(this) : void 0;\n  };\n\n  return Composition;\n\n})();\n\n});;loader.register('chaplin/lib/sync_machine', function(e, r, module) {\n'use strict';\n\nvar STATE_CHANGE, SYNCED, SYNCING, SyncMachine, UNSYNCED, event, _fn, _i, _len, _ref;\n\nUNSYNCED = 'unsynced';\n\nSYNCING = 'syncing';\n\nSYNCED = 'synced';\n\nSTATE_CHANGE = 'syncStateChange';\n\nSyncMachine = {\n  _syncState: UNSYNCED,\n  _previousSyncState: null,\n  syncState: function() {\n    return this._syncState;\n  },\n  isUnsynced: function() {\n    return this._syncState === UNSYNCED;\n  },\n  isSynced: function() {\n    return this._syncState === SYNCED;\n  },\n  isSyncing: function() {\n    return this._syncState === SYNCING;\n  },\n  unsync: function() {\n    var _ref;\n    if ((_ref = this._syncState) === SYNCING || _ref === SYNCED) {\n      this._previousSync = this._syncState;\n      this._syncState = UNSYNCED;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  },\n  beginSync: function() {\n    var _ref;\n    if ((_ref = this._syncState) === UNSYNCED || _ref === SYNCED) {\n      this._previousSync = this._syncState;\n      this._syncState = SYNCING;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  },\n  finishSync: function() {\n    if (this._syncState === SYNCING) {\n      this._previousSync = this._syncState;\n      this._syncState = SYNCED;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  },\n  abortSync: function() {\n    if (this._syncState === SYNCING) {\n      this._syncState = this._previousSync;\n      this._previousSync = this._syncState;\n      this.trigger(this._syncState, this, this._syncState);\n      this.trigger(STATE_CHANGE, this, this._syncState);\n    }\n  }\n};\n\n_ref = [UNSYNCED, SYNCING, SYNCED, STATE_CHANGE];\n_fn = function(event) {\n  return SyncMachine[event] = function(callback, context) {\n    if (context == null) {\n      context = this;\n    }\n    this.on(event, callback, context);\n    if (this._syncState === event) {\n      return callback.call(context);\n    }\n  };\n};\nfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n  event = _ref[_i];\n  _fn(event);\n}\n\nif (typeof Object.freeze === \"function\") {\n  Object.freeze(SyncMachine);\n}\n\nmodule.exports = SyncMachine;\n\n});;loader.register('chaplin/lib/utils', function(e, r, module) {\n'use strict';\n\nvar support, utils, _,\n  __slice = [].slice,\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  __hasProp = {}.hasOwnProperty;\n\n_ = loader('underscore');\n\nsupport = loader('chaplin/lib/support');\n\nutils = {\n  beget: (function() {\n    var ctor;\n    if (typeof Object.create === 'function') {\n      return Object.create;\n    } else {\n      ctor = function() {};\n      return function(obj) {\n        ctor.prototype = obj;\n        return new ctor;\n      };\n    }\n  })(),\n  indexOf: (function() {\n    if (Array.prototype.indexOf) {\n      return function(list, index) {\n        return list.indexOf(index);\n      };\n    } else if (_.indexOf) {\n      return _.indexOf;\n    }\n  })(),\n  isArray: Array.isArray || _.isArray,\n  serialize: function(data) {\n    if (typeof data.serialize === 'function') {\n      return data.serialize();\n    } else if (typeof data.toJSON === 'function') {\n      return data.toJSON();\n    } else {\n      throw new TypeError('utils.serialize: Unknown data was passed');\n    }\n  },\n  readonly: (function() {\n    var readonlyDescriptor;\n    if (support.propertyDescriptors) {\n      readonlyDescriptor = {\n        writable: false,\n        enumerable: true,\n        configurable: false\n      };\n      return function() {\n        var obj, prop, properties, _i, _len;\n        obj = arguments[0], properties = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n        for (_i = 0, _len = properties.length; _i < _len; _i++) {\n          prop = properties[_i];\n          readonlyDescriptor.value = obj[prop];\n          Object.defineProperty(obj, prop, readonlyDescriptor);\n        }\n        return true;\n      };\n    } else {\n      return function() {\n        return false;\n      };\n    }\n  })(),\n  getPrototypeChain: function(object) {\n    var chain, _ref, _ref1, _ref2;\n    chain = [object.constructor.prototype];\n    while (object = (_ref = (_ref1 = object.constructor) != null ? _ref1.__super__ : void 0) != null ? _ref : (_ref2 = object.constructor) != null ? _ref2.superclass : void 0) {\n      chain.push(object);\n    }\n    return chain.reverse();\n  },\n  getAllPropertyVersions: function(object, property) {\n    var proto, result, value, _i, _len, _ref;\n    result = [];\n    _ref = utils.getPrototypeChain(object);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      proto = _ref[_i];\n      value = proto[property];\n      if (value && __indexOf.call(result, value) < 0) {\n        result.push(value);\n      }\n    }\n    return result;\n  },\n  upcase: function(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  },\n  escapeRegExp: function(str) {\n    return String(str || '').replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  },\n  modifierKeyPressed: function(event) {\n    return event.shiftKey || event.altKey || event.ctrlKey || event.metaKey;\n  },\n  reverse: function(criteria, params, query) {\n    return loader('chaplin/mediator').execute('router:reverse', criteria, params, query);\n  },\n  redirectTo: function(pathDesc, params, options) {\n    return loader('chaplin/mediator').execute('router:route', pathDesc, params, options);\n  },\n  queryParams: {\n    stringify: function(queryParams) {\n      var arrParam, encodedKey, key, query, stringifyKeyValuePair, value, _i, _len;\n      query = '';\n      stringifyKeyValuePair = function(encodedKey, value) {\n        if (value != null) {\n          return '&' + encodedKey + '=' + encodeURIComponent(value);\n        } else {\n          return '';\n        }\n      };\n      for (key in queryParams) {\n        if (!__hasProp.call(queryParams, key)) continue;\n        value = queryParams[key];\n        encodedKey = encodeURIComponent(key);\n        if (utils.isArray(value)) {\n          for (_i = 0, _len = value.length; _i < _len; _i++) {\n            arrParam = value[_i];\n            query += stringifyKeyValuePair(encodedKey, arrParam);\n          }\n        } else {\n          query += stringifyKeyValuePair(encodedKey, value);\n        }\n      }\n      return query && query.substring(1);\n    },\n    parse: function(queryString) {\n      var current, field, pair, pairs, params, value, _i, _len, _ref;\n      params = {};\n      if (!queryString) {\n        return params;\n      }\n      pairs = queryString.split('&');\n      for (_i = 0, _len = pairs.length; _i < _len; _i++) {\n        pair = pairs[_i];\n        if (!pair.length) {\n          continue;\n        }\n        _ref = pair.split('='), field = _ref[0], value = _ref[1];\n        if (!field.length) {\n          continue;\n        }\n        field = decodeURIComponent(field);\n        value = decodeURIComponent(value);\n        current = params[field];\n        if (current) {\n          if (current.push) {\n            current.push(value);\n          } else {\n            params[field] = [current, value];\n          }\n        } else {\n          params[field] = value;\n        }\n      }\n      return params;\n    }\n  }\n};\n\nif (typeof Object.seal === \"function\") {\n  Object.seal(utils);\n}\n\nmodule.exports = utils;\n\n});;loader.register('chaplin', function(e, r, module) {\n\nmodule.exports = {\n  Application: loader('chaplin/application'),\n  mediator: loader('chaplin/mediator'),\n  Dispatcher: loader('chaplin/dispatcher'),\n  Controller: loader('chaplin/controllers/controller'),\n  Composer: loader('chaplin/composer'),\n  Composition: loader('chaplin/lib/composition'),\n  Collection: loader('chaplin/models/collection'),\n  Model: loader('chaplin/models/model'),\n  Layout: loader('chaplin/views/layout'),\n  View: loader('chaplin/views/view'),\n  CollectionView: loader('chaplin/views/collection_view'),\n  Route: loader('chaplin/lib/route'),\n  Router: loader('chaplin/lib/router'),\n  EventBroker: loader('chaplin/lib/event_broker'),\n  support: loader('chaplin/lib/support'),\n  SyncMachine: loader('chaplin/lib/sync_machine'),\n  utils: loader('chaplin/lib/utils')\n};\n\n});\nvar regDeps = function(Backbone, _) {\n  loader.register('backbone', function(exports, require, module) {\n    module.exports = Backbone;\n  });\n  loader.register('underscore', function(exports, require, module) {\n    module.exports = _;\n  });\n};\n\nif (typeof define === 'function' && define.amd) {\n  define(['backbone', 'underscore'], function(Backbone, _) {\n    regDeps(Backbone, _);\n    return loader('chaplin');\n  });\n} else if (typeof module === 'object' && module && module.exports) {\n  regDeps(require('backbone'), require('underscore'));\n  module.exports = loader('chaplin');\n} else if (typeof require === 'function') {\n  regDeps(window.Backbone, window._ || window.Backbone.utils);\n  window.Chaplin = loader('chaplin');\n} else {\n  throw new Error('Chaplin requires Common.js or AMD modules');\n}\n\n})();","// Console-polyfill. MIT license.\n// https://github.com/paulmillr/console-polyfill\n// Make it safe to do console.log() always.\n(function(con) {\n  'use strict';\n  var prop, method;\n  var empty = {};\n  var dummy = function() {};\n  var properties = 'memory'.split(',');\n  var methods = ('assert,count,debug,dir,dirxml,error,exception,group,' +\n     'groupCollapsed,groupEnd,info,log,markTimeline,profile,profileEnd,' +\n     'time,timeEnd,trace,warn').split(',');\n  while (prop = properties.pop()) con[prop] = con[prop] || empty;\n  while (method = methods.pop()) con[method] = con[method] || dummy;\n})(this.console = this.console || {});\n","/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*\n* @overview\n*\n* Phaser - http://phaser.io\n*\n* v2.0.4 \"Mos Shirare\" - Built: Tue Apr 29 2014 22:39:37\n*\n* By Richard Davey http://www.photonstorm.com @photonstorm\n*\n* Phaser is a fun, free and fast 2D game framework for making HTML5 games\n* for desktop and mobile web browsers, supporting Canvas and WebGL rendering.\n*\n* Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23\n* Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe\n* Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com\n*\n* Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser\n* and my love of framework development originate.\n*\n* Follow development at http://phaser.io and on our forum\n*\n* \"If you want your children to be intelligent,  read them fairy tales.\"\n* \"If you want them to be more intelligent, read them more fairy tales.\"\n*                                                     -- Albert Einstein\n*/\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n(function(){\n\n    var root = this;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @module PIXI\n */\nvar PIXI = PIXI || {};\n\n/* \n* \n* This file contains a lot of pixi consts which are used across the rendering engine\n* @class Consts\n*/\nPIXI.WEBGL_RENDERER = 0;\nPIXI.CANVAS_RENDERER = 1;\n\n// useful for testing against if your lib is using pixi.\nPIXI.VERSION = \"v1.5.2\";\n\n// the various blend modes supported by pixi\nPIXI.blendModes = {\n    NORMAL:0,\n    ADD:1,\n    MULTIPLY:2,\n    SCREEN:3,\n    OVERLAY:4,\n    DARKEN:5,\n    LIGHTEN:6,\n    COLOR_DODGE:7,\n    COLOR_BURN:8,\n    HARD_LIGHT:9,\n    SOFT_LIGHT:10,\n    DIFFERENCE:11,\n    EXCLUSION:12,\n    HUE:13,\n    SATURATION:14,\n    COLOR:15,\n    LUMINOSITY:16\n};\n\n// the scale modes\nPIXI.scaleModes = {\n    DEFAULT:0,\n    LINEAR:0,\n    NEAREST:1\n};\n\n// interaction frequency \nPIXI.INTERACTION_FREQUENCY = 30;\nPIXI.AUTO_PREVENT_DEFAULT = true;\n\nPIXI.RAD_TO_DEG = 180 / Math.PI;\nPIXI.DEG_TO_RAD = Math.PI / 180;\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where x represents the horizontal axis and y represents the vertical axis.\n *\n * @class Point\n * @constructor\n * @param x {Number} position of the point on the x axis\n * @param y {Number} position of the point on the y axis\n */\nPIXI.Point = function(x, y)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n};\n\n/**\n * Creates a clone of this point\n *\n * @method clone\n * @return {Point} a copy of the point\n */\nPIXI.Point.prototype.clone = function()\n{\n    return new PIXI.Point(this.x, this.y);\n};\n\n// constructor\nPIXI.Point.prototype.constructor = PIXI.Point;\n\nPIXI.Point.prototype.set = function(x, y)\n{\n    this.x = x || 0;\n    this.y = y || ( (y !== 0) ? this.x : 0 ) ;\n};\n\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * the Rectangle object is an area defined by its position, as indicated by its top-left corner point (x, y) and by its width and its height.\n *\n * @class Rectangle\n * @constructor\n * @param x {Number} The X coord of the upper-left corner of the rectangle\n * @param y {Number} The Y coord of the upper-left corner of the rectangle\n * @param width {Number} The overall width of this rectangle\n * @param height {Number} The overall height of this rectangle\n */\nPIXI.Rectangle = function(x, y, width, height)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n};\n\n/**\n * Creates a clone of this Rectangle\n *\n * @method clone\n * @return {Rectangle} a copy of the rectangle\n */\nPIXI.Rectangle.prototype.clone = function()\n{\n    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this Rectangle\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coords are within this Rectangle\n */\nPIXI.Rectangle.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    var x1 = this.x;\n    if(x >= x1 && x <= x1 + this.width)\n    {\n        var y1 = this.y;\n\n        if(y >= y1 && y <= y1 + this.height)\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n// constructor\nPIXI.Rectangle.prototype.constructor = PIXI.Rectangle;\n\nPIXI.EmptyRectangle = new PIXI.Rectangle(0,0,0,0);\n/**\n * @author Adrien Brault <adrien.brault@gmail.com>\n */\n\n/**\n * @class Polygon\n * @constructor\n * @param points* {Array<Point>|Array<Number>|Point...|Number...} This can be an array of Points that form the polygon,\n *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be\n *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the\n *      arguments passed can be flat x,y values e.g. `new PIXI.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are\n *      Numbers.\n */\nPIXI.Polygon = function(points)\n{\n    //if points isn't an array, use arguments as the array\n    if(!(points instanceof Array))\n        points = Array.prototype.slice.call(arguments);\n\n    //if this is a flat array of numbers, convert it to points\n    if(typeof points[0] === 'number') {\n        var p = [];\n        for(var i = 0, il = points.length; i < il; i+=2) {\n            p.push(\n                new PIXI.Point(points[i], points[i + 1])\n            );\n        }\n\n        points = p;\n    }\n\n    this.points = points;\n};\n\n/**\n * Creates a clone of this polygon\n *\n * @method clone\n * @return {Polygon} a copy of the polygon\n */\nPIXI.Polygon.prototype.clone = function()\n{\n    var points = [];\n    for (var i=0; i<this.points.length; i++) {\n        points.push(this.points[i].clone());\n    }\n\n    return new PIXI.Polygon(points);\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this polygon\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this polygon\n */\nPIXI.Polygon.prototype.contains = function(x, y)\n{\n    var inside = false;\n\n    // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    for(var i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {\n        var xi = this.points[i].x, yi = this.points[i].y,\n            xj = this.points[j].x, yj = this.points[j].y,\n            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n        if(intersect) inside = !inside;\n    }\n\n    return inside;\n};\n\n// constructor\nPIXI.Polygon.prototype.constructor = PIXI.Polygon;\n\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Circle object can be used to specify a hit area for displayObjects\n *\n * @class Circle\n * @constructor\n * @param x {Number} The X coordinate of the center of this circle\n * @param y {Number} The Y coordinate of the center of this circle\n * @param radius {Number} The radius of the circle\n */\nPIXI.Circle = function(x, y, radius)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property radius\n     * @type Number\n     * @default 0\n     */\n    this.radius = radius || 0;\n};\n\n/**\n * Creates a clone of this Circle instance\n *\n * @method clone\n * @return {Circle} a copy of the polygon\n */\nPIXI.Circle.prototype.clone = function()\n{\n    return new PIXI.Circle(this.x, this.y, this.radius);\n};\n\n/**\n * Checks whether the x, and y coordinates passed to this function are contained within this circle\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coordinates are within this polygon\n */\nPIXI.Circle.prototype.contains = function(x, y)\n{\n    if(this.radius <= 0)\n        return false;\n\n    var dx = (this.x - x),\n        dy = (this.y - y),\n        r2 = this.radius * this.radius;\n\n    dx *= dx;\n    dy *= dy;\n\n    return (dx + dy <= r2);\n};\n\n// constructor\nPIXI.Circle.prototype.constructor = PIXI.Circle;\n\n\n/**\n * @author Chad Engler <chad@pantherdev.com>\n */\n\n/**\n * The Ellipse object can be used to specify a hit area for displayObjects\n *\n * @class Ellipse\n * @constructor\n * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param width {Number} The overall width of this ellipse\n * @param height {Number} The overall height of this ellipse\n */\nPIXI.Ellipse = function(x, y, width, height)\n{\n    /**\n     * @property x\n     * @type Number\n     * @default 0\n     */\n    this.x = x || 0;\n\n    /**\n     * @property y\n     * @type Number\n     * @default 0\n     */\n    this.y = y || 0;\n\n    /**\n     * @property width\n     * @type Number\n     * @default 0\n     */\n    this.width = width || 0;\n\n    /**\n     * @property height\n     * @type Number\n     * @default 0\n     */\n    this.height = height || 0;\n};\n\n/**\n * Creates a clone of this Ellipse instance\n *\n * @method clone\n * @return {Ellipse} a copy of the ellipse\n */\nPIXI.Ellipse.prototype.clone = function()\n{\n    return new PIXI.Ellipse(this.x, this.y, this.width, this.height);\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this ellipse\n *\n * @method contains\n * @param x {Number} The X coordinate of the point to test\n * @param y {Number} The Y coordinate of the point to test\n * @return {Boolean} Whether the x/y coords are within this ellipse\n */\nPIXI.Ellipse.prototype.contains = function(x, y)\n{\n    if(this.width <= 0 || this.height <= 0)\n        return false;\n\n    //normalize the coords to an ellipse with center 0,0\n    var normx = ((x - this.x) / this.width),\n        normy = ((y - this.y) / this.height);\n\n    normx *= normx;\n    normy *= normy;\n\n    return (normx + normy <= 1);\n};\n\n/**\n* Returns the framing rectangle of the ellipse as a PIXI.Rectangle object\n*\n* @method getBounds\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Ellipse.prototype.getBounds = function()\n{\n    return new PIXI.Rectangle(this.x, this.y, this.width, this.height);\n};\n\n// constructor\nPIXI.Ellipse.prototype.constructor = PIXI.Ellipse;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.determineMatrixArrayType = function() {\n    return (typeof Float32Array !== 'undefined') ? Float32Array : Array;\n};\n\n/*\n* @class Matrix2\n* The Matrix2 class will choose the best type of array to use between\n* a regular javascript Array and a Float32Array if the latter is available\n*\n*/\nPIXI.Matrix2 = PIXI.determineMatrixArrayType();\n\n/*\n* @class Matrix\n* The Matrix class is now an object, which makes it a lot faster, \n* here is a representation of it : \n* | a | b | tx|\n* | c | c | ty|\n* | 0 | 0 | 1 |\n*\n*/\nPIXI.Matrix = function()\n{\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n};\n\n/**\n * Creates a pixi matrix object based on the array given as a parameter\n *\n * @method fromArray\n * @param array {Array} The array that the matrix will be filled with\n */\nPIXI.Matrix.prototype.fromArray = function(array)\n{\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n};\n\n/**\n * Creates an array from the current Matrix object\n *\n * @method toArray\n * @param transpose {Boolean} Whether we need to transpose the matrix or not\n * @return array {Array} the newly created array which contains the matrix\n */\nPIXI.Matrix.prototype.toArray = function(transpose)\n{\n    if(!this.array) this.array = new Float32Array(9);\n    var array = this.array;\n\n    if(transpose)\n    {\n        this.array[0] = this.a;\n        this.array[1] = this.c;\n        this.array[2] = 0;\n        this.array[3] = this.b;\n        this.array[4] = this.d;\n        this.array[5] = 0;\n        this.array[6] = this.tx;\n        this.array[7] = this.ty;\n        this.array[8] = 1;\n    }\n    else\n    {\n        this.array[0] = this.a;\n        this.array[1] = this.b;\n        this.array[2] = this.tx;\n        this.array[3] = this.c;\n        this.array[4] = this.d;\n        this.array[5] = this.ty;\n        this.array[6] = 0;\n        this.array[7] = 0;\n        this.array[8] = 1;\n    }\n\n    return array;//[this.a, this.b, this.tx, this.c, this.d, this.ty, 0, 0, 1];\n};\n\nPIXI.identityMatrix = new PIXI.Matrix();\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The base class for all objects that are rendered on the screen. \n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class DisplayObject\n * @constructor\n */\nPIXI.DisplayObject = function()\n{\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     *\n     * @property position\n     * @type Point\n     */\n    this.position = new PIXI.Point();\n\n    /**\n     * The scale factor of the object.\n     *\n     * @property scale\n     * @type Point\n     */\n    this.scale = new PIXI.Point(1,1);//{x:1, y:1};\n\n    /**\n     * The pivot point of the displayObject that it rotates around\n     *\n     * @property pivot\n     * @type Point\n     */\n    this.pivot = new PIXI.Point(0,0);\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @property rotation\n     * @type Number\n     */\n    this.rotation = 0;\n\n    /**\n     * The opacity of the object.\n     *\n     * @property alpha\n     * @type Number\n     */\n    this.alpha = 1;\n\n    /**\n     * The visibility of the object.\n     *\n     * @property visible\n     * @type Boolean\n     */\n    this.visible = true;\n\n    /**\n     * This is the defined area that will pick up mouse / touch events. It is null by default.\n     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)\n     *\n     * @property hitArea\n     * @type Rectangle|Circle|Ellipse|Polygon\n     */\n    this.hitArea = null;\n\n    /**\n     * This is used to indicate if the displayObject should display a mouse hand cursor on rollover\n     *\n     * @property buttonMode\n     * @type Boolean\n     */\n    this.buttonMode = false;\n\n    /**\n     * Can this object be rendered\n     *\n     * @property renderable\n     * @type Boolean\n     */\n    this.renderable = false;\n\n    /**\n     * [read-only] The display object container that contains this display object.\n     *\n     * @property parent\n     * @type DisplayObjectContainer\n     * @readOnly\n     */\n    this.parent = null;\n\n    /**\n     * [read-only] The stage the display object is connected to, or undefined if it is not connected to the stage.\n     *\n     * @property stage\n     * @type Stage\n     * @readOnly\n     */\n    this.stage = null;\n\n    /**\n     * [read-only] The multiplied alpha of the displayObject\n     *\n     * @property worldAlpha\n     * @type Number\n     * @readOnly\n     */\n    this.worldAlpha = 1;\n\n    /**\n     * [read-only] Whether or not the object is interactive, do not toggle directly! use the `interactive` property\n     *\n     * @property _interactive\n     * @type Boolean\n     * @readOnly\n     * @private\n     */\n    this._interactive = false;\n\n    /**\n     * This is the cursor that will be used when the mouse is over this object. To enable this the element must have interaction = true and buttonMode = true\n     * \n     * @property defaultCursor\n     * @type String\n     *\n    */\n    this.defaultCursor = 'pointer';\n\n    /**\n     * [read-only] Current transform of the object based on world (parent) factors\n     *\n     * @property worldTransform\n     * @type Mat3\n     * @readOnly\n     * @private\n     */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n     * [NYI] Unknown\n     *\n     * @property color\n     * @type Array<>\n     * @private\n     */\n    this.color = [];\n\n    /**\n     * [NYI] Holds whether or not this object is dynamic, for rendering optimization\n     *\n     * @property dynamic\n     * @type Boolean\n     * @private\n     */\n    this.dynamic = true;\n\n    // cached sin rotation and cos rotation\n    this._sr = 0;\n    this._cr = 1;\n\n    /**\n     * The area the filter is applied to like the hitArea this is used as more of an optimisation\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n     *\n     * @property filterArea\n     * @type Rectangle\n     */\n    this.filterArea = null;//new PIXI.Rectangle(0,0,1,1);\n\n    /**\n     * The original, cached bounds of the object\n     *\n     * @property _bounds\n     * @type Rectangle\n     * @private\n     */\n    this._bounds = new PIXI.Rectangle(0, 0, 1, 1);\n    /**\n     * The most up-to-date bounds of the object\n     *\n     * @property _currentBounds\n     * @type Rectangle\n     * @private\n     */\n    this._currentBounds = null;\n    /**\n     * The original, cached mask of the object\n     *\n     * @property _currentBounds\n     * @type Rectangle\n     * @private\n     */\n    this._mask = null;\n\n    this._cacheAsBitmap = false;\n    this._cacheIsDirty = false;\n\n\n    /*\n     * MOUSE Callbacks\n     */\n\n    /**\n     * A callback that is used when the users clicks on the displayObject with their mouse\n     * @method click\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user clicks the mouse down over the sprite\n     * @method mousedown\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse that was over the displayObject\n     * for this callback to be fired the mouse must have been pressed down over the displayObject\n     * @method mouseup\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the mouse that was over the displayObject but is no longer over the displayObject\n     * for this callback to be fired, The touch must have started over the displayObject\n     * @method mouseupoutside\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the users mouse rolls over the displayObject\n     * @method mouseover\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the users mouse leaves the displayObject\n     * @method mouseout\n     * @param interactionData {InteractionData}\n     */\n\n\n    /*\n     * TOUCH Callbacks\n     */\n\n    /**\n     * A callback that is used when the users taps on the sprite with their finger\n     * basically a touch version of click\n     * @method tap\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user touches over the displayObject\n     * @method touchstart\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases a touch over the displayObject\n     * @method touchend\n     * @param interactionData {InteractionData}\n     */\n\n    /**\n     * A callback that is used when the user releases the touch that was over the displayObject\n     * for this callback to be fired, The touch must have started over the sprite\n     * @method touchendoutside\n     * @param interactionData {InteractionData}\n     */\n};\n\n// constructor\nPIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject;\n\n/**\n * [Deprecated] Indicates if the sprite will have touch and mouse interactivity. It is false by default\n * Instead of using this function you can now simply set the interactive property to true or false\n *\n * @method setInteractive\n * @param interactive {Boolean}\n * @deprecated Simply set the `interactive` property directly\n */\nPIXI.DisplayObject.prototype.setInteractive = function(interactive)\n{\n    this.interactive = interactive;\n};\n\n/**\n * Indicates if the sprite will have touch and mouse interactivity. It is false by default\n *\n * @property interactive\n * @type Boolean\n * @default false\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'interactive', {\n    get: function() {\n        return this._interactive;\n    },\n    set: function(value) {\n        this._interactive = value;\n\n        // TODO more to be done here..\n        // need to sort out a re-crawl!\n        if(this.stage)this.stage.dirty = true;\n    }\n});\n\n/**\n * [read-only] Indicates if the sprite is globaly visible.\n *\n * @property worldVisible\n * @type Boolean\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'worldVisible', {\n    get: function() {\n        var item = this;\n\n        do\n        {\n            if(!item.visible)return false;\n            item = item.parent;\n        }\n        while(item);\n\n        return true;\n    }\n});\n\n/**\n * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.\n * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.\n * To remove a mask, set this property to null.\n *\n * @property mask\n * @type Graphics\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'mask', {\n    get: function() {\n        return this._mask;\n    },\n    set: function(value) {\n\n        if(this._mask)this._mask.isMask = false;\n        this._mask = value;\n        if(this._mask)this._mask.isMask = true;\n    }\n});\n\n/**\n * Sets the filters for the displayObject.\n * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n * To remove filters simply set this property to 'null'\n * @property filters\n * @type Array An array of filters\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'filters', {\n    get: function() {\n        return this._filters;\n    },\n    set: function(value) {\n\n        if(value)\n        {\n            // now put all the passes in one place..\n            var passes = [];\n            for (var i = 0; i < value.length; i++)\n            {\n                var filterPasses = value[i].passes;\n                for (var j = 0; j < filterPasses.length; j++)\n                {\n                    passes.push(filterPasses[j]);\n                }\n            }\n\n            // TODO change this as it is legacy\n            this._filterBlock = {target:this, filterPasses:passes};\n        }\n\n        this._filters = value;\n    }\n});\n\n/**\n * Set weather or not a the display objects is cached as a bitmap.\n * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects\n * To remove filters simply set this property to 'null'\n * @property cacheAsBitmap\n * @type Boolean\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'cacheAsBitmap', {\n    get: function() {\n        return  this._cacheAsBitmap;\n    },\n    set: function(value) {\n\n        if(this._cacheAsBitmap === value)return;\n\n        if(value)\n        {\n            //this._cacheIsDirty = true;\n            this._generateCachedSprite();\n        }\n        else\n        {\n            this._destroyCachedSprite();\n        }\n\n        this._cacheAsBitmap = value;\n    }\n});\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObject.prototype.updateTransform = function()\n{\n    // TODO OPTIMIZE THIS!! with dirty\n    if(this.rotation !== this.rotationCache)\n    {\n\n        this.rotationCache = this.rotation;\n        this._sr =  Math.sin(this.rotation);\n        this._cr =  Math.cos(this.rotation);\n    }\n\n   // var localTransform = this.localTransform//.toArray();\n    var parentTransform = this.parent.worldTransform;//.toArray();\n    var worldTransform = this.worldTransform;//.toArray();\n\n    var px = this.pivot.x;\n    var py = this.pivot.y;\n\n    var a00 = this._cr * this.scale.x,\n        a01 = -this._sr * this.scale.y,\n        a10 = this._sr * this.scale.x,\n        a11 = this._cr * this.scale.y,\n        a02 = this.position.x - a00 * px - py * a01,\n        a12 = this.position.y - a11 * py - px * a10,\n        b00 = parentTransform.a, b01 = parentTransform.b,\n        b10 = parentTransform.c, b11 = parentTransform.d;\n\n    worldTransform.a = b00 * a00 + b01 * a10;\n    worldTransform.b = b00 * a01 + b01 * a11;\n    worldTransform.tx = b00 * a02 + b01 * a12 + parentTransform.tx;\n\n    worldTransform.c = b10 * a00 + b11 * a10;\n    worldTransform.d = b10 * a01 + b11 * a11;\n    worldTransform.ty = b10 * a02 + b11 * a12 + parentTransform.ty;\n\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n};\n\n/**\n * Retrieves the bounds of the displayObject as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObject.prototype.getBounds = function( matrix )\n{\n    matrix = matrix;//just to get passed js hinting (and preserve inheritance)\n    return PIXI.EmptyRectangle;\n};\n\n/**\n * Retrieves the local bounds of the displayObject as a rectangle object\n *\n * @method getLocalBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObject.prototype.getLocalBounds = function()\n{\n    return this.getBounds(PIXI.identityMatrix);///PIXI.EmptyRectangle();\n};\n\n\n/**\n * Sets the object's stage reference, the stage this object is connected to\n *\n * @method setStageReference\n * @param stage {Stage} the stage that the object will have as its current stage reference\n */\nPIXI.DisplayObject.prototype.setStageReference = function(stage)\n{\n    this.stage = stage;\n    if(this._interactive)this.stage.dirty = true;\n};\n\nPIXI.DisplayObject.prototype.generateTexture = function(renderer)\n{\n    var bounds = this.getLocalBounds();\n\n    var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer);\n    renderTexture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );\n\n    return renderTexture;\n};\n\nPIXI.DisplayObject.prototype.updateCache = function()\n{\n    this._generateCachedSprite();\n};\n\nPIXI.DisplayObject.prototype._renderCachedSprite = function(renderSession)\n{\n    if(renderSession.gl)\n    {\n        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n    }\n    else\n    {\n        PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);\n    }\n};\n\nPIXI.DisplayObject.prototype._generateCachedSprite = function()//renderSession)\n{\n    this._cacheAsBitmap = false;\n    var bounds = this.getLocalBounds();\n   \n    if(!this._cachedSprite)\n    {\n        var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0);//, renderSession.renderer);\n        \n        this._cachedSprite = new PIXI.Sprite(renderTexture);\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.texture.resize(bounds.width | 0, bounds.height | 0);\n    }\n\n    //REMOVE filter!\n    var tempFilters = this._filters;\n    this._filters = null;\n\n    this._cachedSprite.filters = tempFilters;\n    this._cachedSprite.texture.render(this, new PIXI.Point(-bounds.x, -bounds.y) );\n\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n\n    this._filters = tempFilters;\n\n    this._cacheAsBitmap = true;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObject.prototype._destroyCachedSprite = function()\n{\n    if(!this._cachedSprite)return;\n\n    this._cachedSprite.texture.destroy(true);\n  //  console.log(\"DESTROY\")\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};\n\n\nPIXI.DisplayObject.prototype._renderWebGL = function(renderSession)\n{\n    // OVERWRITE;\n    // this line is just here to pass jshinting :)\n    renderSession = renderSession;\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObject.prototype._renderCanvas = function(renderSession)\n{\n    // OVERWRITE;\n    // this line is just here to pass jshinting :)\n    renderSession = renderSession;\n};\n\n/**\n * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n *\n * @property x\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'x', {\n    get: function() {\n        return  this.position.x;\n    },\n    set: function(value) {\n        this.position.x = value;\n    }\n});\n\n/**\n * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n *\n * @property y\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObject.prototype, 'y', {\n    get: function() {\n        return  this.position.y;\n    },\n    set: function(value) {\n        this.position.y = value;\n    }\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A DisplayObjectContainer represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n * @class DisplayObjectContainer\n * @extends DisplayObject\n * @constructor\n */\nPIXI.DisplayObjectContainer = function()\n{\n    PIXI.DisplayObject.call( this );\n\n    /**\n     * [read-only] The array of children of this container.\n     *\n     * @property children\n     * @type Array<DisplayObject>\n     * @readOnly\n     */\n    this.children = [];\n};\n\n// constructor\nPIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype );\nPIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;\n\n/**\n * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\n\n /*\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {\n    get: function() {\n        return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function(value) {\n        this.scale.x = value / (this.getLocalBounds().width/this.scale.x);\n        this._width = value;\n    }\n});\n*/\n\n/**\n * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\n\n/*\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {\n    get: function() {\n        return  this.scale.y * this.getLocalBounds().height;\n    },\n    set: function(value) {\n        this.scale.y = value / (this.getLocalBounds().height/this.scale.y);\n        this._height = value;\n    }\n});\n*/\n\n/**\n * Adds a child to the container.\n *\n * @method addChild\n * @param child {DisplayObject} The DisplayObject to add to the container\n */\nPIXI.DisplayObjectContainer.prototype.addChild = function(child)\n{\n    this.addChildAt(child, this.children.length);\n};\n\n/**\n * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @method addChildAt\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n */\nPIXI.DisplayObjectContainer.prototype.addChildAt = function(child, index)\n{\n    if(index >= 0 && index <= this.children.length)\n    {\n        if(child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n\n        this.children.splice(index, 0, child);\n\n        if(this.stage)child.setStageReference(this.stage);\n    }\n    else\n    {\n        throw new Error(child + ' The index '+ index +' supplied is out of bounds ' + this.children.length);\n    }\n};\n\n/**\n * [NYI] Swaps the depth of 2 displayObjects\n *\n * @method swapChildren\n * @param child {DisplayObject}\n * @param child2 {DisplayObject}\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.swapChildren = function(child, child2)\n{\n    if(child === child2) {\n        return;\n    }\n\n    var index1 = this.children.indexOf(child);\n    var index2 = this.children.indexOf(child2);\n\n    if(index1 < 0 || index2 < 0) {\n        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');\n    }\n\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    \n};\n\n/**\n * Returns the child at the specified index\n *\n * @method getChildAt\n * @param index {Number} The index to get the child from\n */\nPIXI.DisplayObjectContainer.prototype.getChildAt = function(index)\n{\n    if(index >= 0 && index < this.children.length)\n    {\n        return this.children[index];\n    }\n    else\n    {\n        throw new Error('Supplied index does not exist in the child list, or the supplied DisplayObject must be a child of the caller');\n    }\n};\n\n/**\n * Removes a child from the container.\n *\n * @method removeChild\n * @param child {DisplayObject} The DisplayObject to remove\n */\nPIXI.DisplayObjectContainer.prototype.removeChild = function(child)\n{\n    return this.removeChildAt( this.children.indexOf( child ) );\n};\n\n/**\n * Removes a child from the specified index position in the child list of the container.\n *\n * @method removeChildAt\n * @param index {Number} The index to get the child from\n */\nPIXI.DisplayObjectContainer.prototype.removeChildAt = function(index)\n{\n    var child = this.getChildAt( index );\n    if(this.stage)\n        child.removeStageReference();\n\n    child.parent = undefined;\n    this.children.splice( index, 1 );\n    return child;\n};\n\n/**\n* Removes all child instances from the child list of the container.\n*\n* @method removeChildren\n* @param beginIndex {Number} The beginning position. Predefined value is 0.\n* @param endIndex {Number} The ending position. Predefined value is children's array length.\n*/\nPIXI.DisplayObjectContainer.prototype.removeChildren = function(beginIndex, endIndex)\n{\n    var begin = beginIndex || 0;\n    var end = typeof endIndex === 'number' ? endIndex : this.children.length;\n    var range = end - begin;\n\n    if (range > 0 && range <= end)\n    {\n        var removed = this.children.splice(begin, range);\n        for (var i = 0; i < removed.length; i++) {\n            var child = removed[i];\n            if(this.stage)\n                child.removeStageReference();\n            child.parent = undefined;\n        }\n        return removed;\n    }\n    else\n    {\n        throw new Error( 'Range Error, numeric values are outside the acceptable range' );\n    }\n};\n\n/*\n * Updates the container's childrens transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.updateTransform = function()\n{\n    //this._currentBounds = null;\n\n    if(!this.visible)return;\n\n    PIXI.DisplayObject.prototype.updateTransform.call( this );\n\n    if(this._cacheAsBitmap)return;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n};\n\n/**\n * Retrieves the bounds of the displayObjectContainer as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getBounds = function(matrix)\n{\n    if(this.children.length === 0)return PIXI.EmptyRectangle;\n\n    // TODO the bounds have already been calculated this render session so return what we have\n    if(matrix)\n    {\n        var matrixCache = this.worldTransform;\n        this.worldTransform = matrix;\n        this.updateTransform();\n        this.worldTransform = matrixCache;\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var childBounds;\n    var childMaxX;\n    var childMaxY;\n\n    var childVisible = false;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        \n        if(!child.visible)continue;\n\n        childVisible = true;\n\n        childBounds = this.children[i].getBounds( matrix );\n     \n        minX = minX < childBounds.x ? minX : childBounds.x;\n        minY = minY < childBounds.y ? minY : childBounds.y;\n\n        childMaxX = childBounds.width + childBounds.x;\n        childMaxY = childBounds.height + childBounds.y;\n\n        maxX = maxX > childMaxX ? maxX : childMaxX;\n        maxY = maxY > childMaxY ? maxY : childMaxY;\n    }\n\n    if(!childVisible)\n        return PIXI.EmptyRectangle;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.y = minY;\n    bounds.width = maxX - minX;\n    bounds.height = maxY - minY;\n\n    // TODO: store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    //this._currentBounds = bounds;\n   \n    return bounds;\n};\n\nPIXI.DisplayObjectContainer.prototype.getLocalBounds = function()\n{\n    var matrixCache = this.worldTransform;\n\n    this.worldTransform = PIXI.identityMatrix;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    var bounds = this.getBounds();\n\n    this.worldTransform = matrixCache;\n\n    return bounds;\n};\n\n/**\n * Sets the container's stage reference, the stage this object is connected to\n *\n * @method setStageReference\n * @param stage {Stage} the stage that the container will have as its current stage reference\n */\nPIXI.DisplayObjectContainer.prototype.setStageReference = function(stage)\n{\n    this.stage = stage;\n    if(this._interactive)this.stage.dirty = true;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child.setStageReference(stage);\n    }\n};\n\n/**\n * removes the current stage reference of the container\n *\n * @method removeStageReference\n */\nPIXI.DisplayObjectContainer.prototype.removeStageReference = function()\n{\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child.removeStageReference();\n    }\n\n    if(this._interactive)this.stage.dirty = true;\n    \n    this.stage = null;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderWebGL = function(renderSession)\n{\n    if(!this.visible || this.alpha <= 0)return;\n    \n    if(this._cacheAsBitmap)\n    {\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n    \n    var i,j;\n\n    if(this._mask || this._filters)\n    {\n        if(this._mask)\n        {\n            renderSession.spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            renderSession.spriteBatch.start();\n        }\n\n        if(this._filters)\n        {\n            renderSession.spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        renderSession.spriteBatch.stop();\n\n        if(this._filters)renderSession.filterManager.popFilter();\n        if(this._mask)renderSession.maskManager.popMask(renderSession);\n        \n        renderSession.spriteBatch.start();\n    }\n    else\n    {\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderCanvas = function(renderSession)\n{\n    if(this.visible === false || this.alpha === 0)return;\n\n    if(this._cacheAsBitmap)\n    {\n\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession.context);\n    }\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child._renderCanvas(renderSession);\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession.context);\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * @class Sprite\n * @extends DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture for this sprite\n * \n * A sprite can be created directly from an image like this : \n * var sprite = nex PIXI.Sprite.FromImage('assets/image.png');\n * yourStage.addChild(sprite);\n * then obviously don't forget to add it to the stage you have already created\n */\nPIXI.Sprite = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    /**\n     * The anchor sets the origin point of the texture.\n     * The default is 0,0 this means the texture's origin is the top left\n     * Setting than anchor to 0.5,0.5 means the textures origin is centred\n     * Setting the anchor to 1,1 would mean the textures origin points will be the bottom right corner\n     *\n     * @property anchor\n     * @type Point\n     */\n    this.anchor = new PIXI.Point();\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = texture;\n\n    /**\n     * The width of the sprite (this is initially set by the texture)\n     *\n     * @property _width\n     * @type Number\n     * @private\n     */\n    this._width = 0;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     *\n     * @property _height\n     * @type Number\n     * @private\n     */\n    this._height = 0;\n\n\n    /**\n     * The tint applied to the sprite. This is a hex value\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;// * Math.random();\n    \n    /**\n     * The blend mode to be applied to the sprite\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n\n    if(texture.baseTexture.hasLoaded)\n    {\n        this.onTextureUpdate();\n    }\n    else\n    {\n        this.onTextureUpdateBind = this.onTextureUpdate.bind(this);\n        this.texture.addEventListener( 'update', this.onTextureUpdateBind );\n    }\n\n    this.renderable = true;\n};\n\n// constructor\nPIXI.Sprite.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Sprite.prototype.constructor = PIXI.Sprite;\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'width', {\n    get: function() {\n        return this.scale.x * this.texture.frame.width;\n    },\n    set: function(value) {\n        this.scale.x = value / this.texture.frame.width;\n        this._width = value;\n    }\n});\n\n/**\n * The height of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'height', {\n    get: function() {\n        return  this.scale.y * this.texture.frame.height;\n    },\n    set: function(value) {\n        this.scale.y = value / this.texture.frame.height;\n        this._height = value;\n    }\n});\n\n/**\n * Sets the texture of the sprite\n *\n * @method setTexture\n * @param texture {Texture} The PIXI texture that is displayed by the sprite\n */\nPIXI.Sprite.prototype.setTexture = function(texture)\n{\n    // stop current texture;\n    if(this.texture.baseTexture !== texture.baseTexture)\n    {\n        this.textureChange = true;\n        this.texture = texture;\n    }\n    else\n    {\n        this.texture = texture;\n    }\n\n    this.cachedTint = 0xFFFFFF;\n    this.updateFrame = true;\n};\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.Sprite.prototype.onTextureUpdate = function()\n{\n    // so if _width is 0 then width was not set..\n    if(this._width)this.scale.x = this._width / this.texture.frame.width;\n    if(this._height)this.scale.y = this._height / this.texture.frame.height;\n\n\n    this.updateFrame = true;\n};\n\n/**\n* Returns the framing rectangle of the sprite as a PIXI.Rectangle object\n*\n* @method getBounds\n* @param matrix {Matrix} the transformation matrix of the sprite\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Sprite.prototype.getBounds = function(matrix)\n{\n\n    var width = this.texture.frame.width;\n    var height = this.texture.frame.height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = matrix || this.worldTransform ;\n\n    var a = worldTransform.a;\n    var b = worldTransform.c;\n    var c = worldTransform.b;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    minX = x1 < minX ? x1 : minX;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1 < minY ? y1 : minY;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1 > maxX ? x1 : maxX;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1 > maxY ? y1 : maxY;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Sprite.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(!this.visible || this.alpha <= 0)return;\n    \n    var i,j;\n\n    // do a quick check to see if this element has a mask or a filter.\n    if(this._mask || this._filters)\n    {\n        var spriteBatch =  renderSession.spriteBatch;\n\n        if(this._mask)\n        {\n            spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            spriteBatch.start();\n        }\n\n        if(this._filters)\n        {\n            spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        // add this sprite to the batch\n        spriteBatch.render(this);\n\n        // now loop through the children and make sure they get rendered\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        // time to stop the sprite batch as either a mask element or a filter draw will happen next\n        spriteBatch.stop();\n\n        if(this._filters)renderSession.filterManager.popFilter();\n        if(this._mask)renderSession.maskManager.popMask(renderSession);\n        \n        spriteBatch.start();\n    }\n    else\n    {\n        renderSession.spriteBatch.render(this);\n\n        // simple render children!\n        for(i=0,j=this.children.length; i<j; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n\n   \n    //TODO check culling  \n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Sprite.prototype._renderCanvas = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0)return;\n    \n    var frame = this.texture.frame;\n    var context = renderSession.context;\n    var texture = this.texture;\n\n    if(this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession.context);\n    }\n\n    \n\n    //ignore null sources\n    if(frame && frame.width && frame.height && texture.baseTexture.source)\n    {\n        context.globalAlpha = this.worldAlpha;\n\n        var transform = this.worldTransform;\n\n        // allow for trimming\n        if (renderSession.roundPixels)\n        {\n            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx | 0, transform.ty | 0);\n        }\n        else\n        {\n            context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n        }\n\n        //if smoothingEnabled is supported and we need to change the smoothing property for this texture\n        if(renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) {\n            renderSession.scaleMode = this.texture.baseTexture.scaleMode;\n            context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);\n        }\n\n        if(this.tint !== 0xFFFFFF)\n        {\n            \n            if(this.cachedTint !== this.tint)\n            {\n                // no point tinting an image that has not loaded yet!\n                if(!texture.baseTexture.hasLoaded)return;\n\n                this.cachedTint = this.tint;\n                \n                //TODO clean up caching - how to clean up the caches?\n                this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);\n                \n            }\n\n            context.drawImage(this.tintedTexture,\n                               0,\n                               0,\n                               frame.width,\n                               frame.height,\n                               (this.anchor.x) * -frame.width,\n                               (this.anchor.y) * -frame.height,\n                               frame.width,\n                               frame.height);\n        }\n        else\n        {\n\n           \n\n            if(texture.trim)\n            {\n                var trim =  texture.trim;\n\n                context.drawImage(this.texture.baseTexture.source,\n                               frame.x,\n                               frame.y,\n                               frame.width,\n                               frame.height,\n                               trim.x - this.anchor.x * trim.width,\n                               trim.y - this.anchor.y * trim.height,\n                               frame.width,\n                               frame.height);\n            }\n            else\n            {\n               \n                context.drawImage(this.texture.baseTexture.source,\n                               frame.x,\n                               frame.y,\n                               frame.width,\n                               frame.height,\n                               (this.anchor.x) * -frame.width,\n                               (this.anchor.y) * -frame.height,\n                               frame.width,\n                               frame.height);\n            }\n            \n        }\n    }\n\n    // OVERWRITE\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        var child = this.children[i];\n        child._renderCanvas(renderSession);\n    }\n\n    if(this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession.context);\n    }\n};\n\n\n// some helper functions..\n\n/**\n *\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @method fromFrame\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId\n */\nPIXI.Sprite.fromFrame = function(frameId)\n{\n    var texture = PIXI.TextureCache[frameId];\n    if(!texture) throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache' + this);\n    return new PIXI.Sprite(texture);\n};\n\n/**\n *\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @method fromImage\n * @static\n * @param imageId {String} The image url of the texture\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id\n */\nPIXI.Sprite.fromImage = function(imageId, crossorigin, scaleMode)\n{\n    var texture = PIXI.Texture.fromImage(imageId, crossorigin, scaleMode);\n    return new PIXI.Sprite(texture);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * The SpriteBatch class is a really fast version of the DisplayObjectContainer \n * built solely for speed, so use when you need a lot of sprites or particles.\n * And it's extremely easy to use : \n\n    var container = new PIXI.SpriteBatch();\n \n    stage.addChild(container);\n \n    for(var i  = 0; i < 100; i++)\n    {\n        var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n        container.addChild(sprite);\n    }\n * And here you have a hundred sprites that will be renderer at the speed of light\n *\n * @class SpriteBatch\n * @constructor\n * @param texture {Texture}\n */\nPIXI.SpriteBatch = function(texture)\n{\n    PIXI.DisplayObjectContainer.call( this);\n\n    this.textureThing = texture;\n\n    this.ready = false;\n};\n\nPIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.SpriteBatch.constructor = PIXI.SpriteBatch;\n\n/*\n * Initialises the spriteBatch\n *\n * @method initWebGL\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.SpriteBatch.prototype.initWebGL = function(gl)\n{\n    // TODO only one needed for the whole engine really?\n    this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl);\n\n    this.ready = true;\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.SpriteBatch.prototype.updateTransform = function()\n{\n   // TODO dont need to!\n    PIXI.DisplayObject.prototype.updateTransform.call( this );\n  //  PIXI.DisplayObjectContainer.prototype.updateTransform.call( this );\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderWebGL = function(renderSession)\n{\n    if(!this.visible || this.alpha <= 0 || !this.children.length)return;\n\n    if(!this.ready)this.initWebGL( renderSession.gl );\n    \n    renderSession.spriteBatch.stop();\n    \n    renderSession.shaderManager.activateShader(renderSession.shaderManager.fastShader);\n    \n    this.fastSpriteBatch.begin(this, renderSession);\n    this.fastSpriteBatch.render(this);\n\n    renderSession.shaderManager.activateShader(renderSession.shaderManager.defaultShader);\n\n    renderSession.spriteBatch.start();\n \n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.SpriteBatch.prototype._renderCanvas = function(renderSession)\n{\n    var context = renderSession.context;\n    context.globalAlpha = this.worldAlpha;\n\n    PIXI.DisplayObject.prototype.updateTransform.call(this);\n\n    var transform = this.worldTransform;\n    // alow for trimming\n       \n    var isRotated = true;\n\n    for (var i = 0; i < this.children.length; i++) {\n       \n        var child = this.children[i];\n\n        if(!child.visible)continue;\n\n        var texture = child.texture;\n        var frame = texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if(child.rotation % (Math.PI * 2) === 0)\n        {\n            if(isRotated)\n            {\n                context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n                isRotated = false;\n            }\n\n            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5) | 0,\n                                 ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5) | 0,\n                                 frame.width * child.scale.x,\n                                 frame.height * child.scale.y);\n        }\n        else\n        {\n            if(!isRotated)isRotated = true;\n    \n            PIXI.DisplayObject.prototype.updateTransform.call(child);\n           \n            var childTransform = child.worldTransform;\n\n            // allow for trimming\n           \n            if (renderSession.roundPixels)\n            {\n                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);\n            }\n            else\n            {\n                context.setTransform(childTransform.a, childTransform.c, childTransform.b, childTransform.d, childTransform.tx, childTransform.ty);\n            }\n\n            context.drawImage(texture.baseTexture.source,\n                                 frame.x,\n                                 frame.y,\n                                 frame.width,\n                                 frame.height,\n                                 ((child.anchor.x) * (-frame.width) + 0.5) | 0,\n                                 ((child.anchor.y) * (-frame.height) + 0.5) | 0,\n                                 frame.width,\n                                 frame.height);\n           \n\n        }\n\n       // context.restore();\n    }\n\n//    context.restore();\n};\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * This is the base class for creating a pixi.js filter. Currently only webGL supports filters.\n * If you want to make a custom filter this should be your base class.\n * @class AbstractFilter\n * @constructor\n * @param fragmentSrc\n * @param uniforms\n */\nPIXI.AbstractFilter = function(fragmentSrc, uniforms)\n{\n    /**\n    * An array of passes - some filters contain a few steps this array simply stores the steps in a liniear fashion.\n    * For example the blur filter has two passes blurX and blurY.\n    * @property passes\n    * @type Array an array of filter objects\n    * @private\n    */\n    this.passes = [this];\n\n    /**\n    * @property shaders\n    * @type Array an array of shaders\n    * @private\n    */\n    this.shaders = [];\n    \n    this.dirty = true;\n    this.padding = 0;\n\n    /**\n    * @property uniforms\n    * @type object\n    * @private\n    */\n    this.uniforms = uniforms || {};\n    /**\n    * @property fragmentSrc\n    * @type Array\n    * @private\n    */\n    this.fragmentSrc = fragmentSrc || [];\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\nPIXI.FilterBlock = function()\n{\n    this.visible = true;\n    this.renderable = true;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * - Modified by Tom Slezakowski http://www.tomslezakowski.com @TomSlezakowski (24/03/2014) - Added dropShadowColor.\n */\n\n/**\n * A Text Object will create a line(s) of text. To split a line you can use '\\n' \n * or add a wordWrap property set to true and and wordWrapWidth property with a value\n * in the style object\n *\n * @class Text\n * @extends Sprite\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param [style] {Object} The style parameters\n * @param [style.font] {String} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap, it needs wordWrap to be set to true\n * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow\n */\nPIXI.Text = function(text, style)\n{\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type HTMLCanvasElement 2d Context\n     */\n    this.context = this.canvas.getContext('2d');\n\n    PIXI.Sprite.call(this, PIXI.Texture.fromCanvas(this.canvas));\n\n    this.setText(text);\n    this.setStyle(style);\n\n    this.updateText();\n    this.dirty = false;\n};\n\n// constructor\nPIXI.Text.prototype = Object.create(PIXI.Sprite.prototype);\nPIXI.Text.prototype.constructor = PIXI.Text;\n\n/**\n * Set the style of the text\n *\n * @method setStyle\n * @param [style] {Object} The style parameters\n * @param [style.font='bold 20pt Arial'] {String} The style and size of the font\n * @param [style.fill='black'] {Object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke='black'] {String} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {Number} The width at which text will wrap\n * @param [style.dropShadow=false] {Boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {String} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {Number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {Number} Set a distance of the drop shadow\n */\nPIXI.Text.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.font = style.font || 'bold 20pt Arial';\n    style.fill = style.fill || 'black';\n    style.align = style.align || 'left';\n    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n    style.strokeThickness = style.strokeThickness || 0;\n    style.wordWrap = style.wordWrap || false;\n    style.wordWrapWidth = style.wordWrapWidth || 100;\n    style.wordWrapWidth = style.wordWrapWidth || 100;\n    \n    style.dropShadow = style.dropShadow || false;\n    style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;\n    style.dropShadowDistance = style.dropShadowDistance || 4;\n    style.dropShadowColor = style.dropShadowColor || 'black';\n\n    this.style = style;\n    this.dirty = true;\n};\n\n/**\n * Set the copy for the text object. To split a line you can use '\\n'\n *\n * @method setText\n * @param {String} text The copy that you would like the text to display\n */\nPIXI.Text.prototype.setText = function(text)\n{\n    this.text = text.toString() || ' ';\n    this.dirty = true;\n\n};\n\n/**\n * Renders text and updates it when needed\n *\n * @method updateText\n * @private\n */\nPIXI.Text.prototype.updateText = function()\n{\n    this.context.font = this.style.font;\n\n    var outputText = this.text;\n\n    // word wrap\n    // preserve original text\n    if(this.style.wordWrap)outputText = this.wordWrap(this.text);\n\n    //split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    //calculate text width\n    var lineWidths = [];\n    var maxLineWidth = 0;\n    for (var i = 0; i < lines.length; i++)\n    {\n        var lineWidth = this.context.measureText(lines[i]).width;\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    var width = maxLineWidth + this.style.strokeThickness;\n    if(this.style.dropShadow)width += this.style.dropShadowDistance;\n\n    this.canvas.width = width + this.context.lineWidth;\n    //calculate text height\n    var lineHeight = this.determineFontHeight('font: ' + this.style.font  + ';') + this.style.strokeThickness;\n    \n    var height = lineHeight * lines.length;\n    if(this.style.dropShadow)height += this.style.dropShadowDistance;\n\n    this.canvas.height = height;\n\n    if(navigator.isCocoonJS) this.context.clearRect(0,0,this.canvas.width,this.canvas.height);\n    \n    this.context.font = this.style.font;\n    this.context.strokeStyle = this.style.stroke;\n    this.context.lineWidth = this.style.strokeThickness;\n    this.context.textBaseline = 'top';\n\n    var linePositionX;\n    var linePositionY;\n\n    if(this.style.dropShadow)\n    {\n        this.context.fillStyle = this.style.dropShadowColor;\n\n        var xShadowOffset = Math.sin(this.style.dropShadowAngle) * this.style.dropShadowDistance;\n        var yShadowOffset = Math.cos(this.style.dropShadowAngle) * this.style.dropShadowDistance;\n\n        for (i = 0; i < lines.length; i++)\n        {\n            linePositionX = this.style.strokeThickness / 2;\n            linePositionY = this.style.strokeThickness / 2 + i * lineHeight;\n\n            if(this.style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if(this.style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if(this.style.fill)\n            {\n                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset);\n            }\n\n          //  if(dropShadow)\n        }\n    }\n\n    //set canvas text styles\n    this.context.fillStyle = this.style.fill;\n    \n    //draw lines line by line\n    for (i = 0; i < lines.length; i++)\n    {\n        linePositionX = this.style.strokeThickness / 2;\n        linePositionY = this.style.strokeThickness / 2 + i * lineHeight;\n\n        if(this.style.align === 'right')\n        {\n            linePositionX += maxLineWidth - lineWidths[i];\n        }\n        else if(this.style.align === 'center')\n        {\n            linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if(this.style.stroke && this.style.strokeThickness)\n        {\n            this.context.strokeText(lines[i], linePositionX, linePositionY);\n        }\n\n        if(this.style.fill)\n        {\n            this.context.fillText(lines[i], linePositionX, linePositionY);\n        }\n\n      //  if(dropShadow)\n    }\n\n\n    this.updateTexture();\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @method updateTexture\n * @private\n */\nPIXI.Text.prototype.updateTexture = function()\n{\n    this.texture.baseTexture.width = this.canvas.width;\n    this.texture.baseTexture.height = this.canvas.height;\n    this.texture.frame.width = this.canvas.width;\n    this.texture.frame.height = this.canvas.height;\n\n    this._width = this.canvas.width;\n    this._height = this.canvas.height;\n\n    this.requiresUpdate =  true;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Text.prototype._renderWebGL = function(renderSession)\n{\n    if(this.requiresUpdate)\n    {\n        this.requiresUpdate = false;\n        PIXI.updateWebGLTexture(this.texture.baseTexture, renderSession.gl);\n    }\n\n    PIXI.Sprite.prototype._renderWebGL.call(this, renderSession);\n};\n\n/**\n * Updates the transform of this object\n *\n * @method updateTransform\n * @private\n */\nPIXI.Text.prototype.updateTransform = function()\n{\n    if(this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    PIXI.Sprite.prototype.updateTransform.call(this);\n};\n\n/*\n * http://stackoverflow.com/users/34441/ellisbben\n * great solution to the problem!\n * returns the height of the given font\n *\n * @method determineFontHeight\n * @param fontStyle {Object}\n * @private\n */\nPIXI.Text.prototype.determineFontHeight = function(fontStyle)\n{\n    // build a little reference dictionary so if the font style has been used return a\n    // cached version...\n    var result = PIXI.Text.heightCache[fontStyle];\n\n    if(!result)\n    {\n        var body = document.getElementsByTagName('body')[0];\n        var dummy = document.createElement('div');\n        var dummyText = document.createTextNode('M');\n        dummy.appendChild(dummyText);\n        dummy.setAttribute('style', fontStyle + ';position:absolute;top:0;left:0');\n        body.appendChild(dummy);\n\n        result = dummy.offsetHeight;\n        PIXI.Text.heightCache[fontStyle] = result;\n\n        body.removeChild(dummy);\n    }\n\n    return result;\n};\n\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @method wordWrap\n * @param text {String}\n * @private\n */\nPIXI.Text.prototype.wordWrap = function(text)\n{\n    // Greedy wrapping algorithm that will wrap words as the line grows longer\n    // than its horizontal bounds.\n    var result = '';\n    var lines = text.split('\\n');\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = this.style.wordWrapWidth;\n        var words = lines[i].split(' ');\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n            if(j === 0 || wordWidthWithSpace > spaceLeft)\n            {\n                // Skip printing the newline if it's the first word of the line that is\n                // greater than the word wrap width.\n                if(j > 0)\n                {\n                    result += '\\n';\n                }\n                result += words[j];\n                spaceLeft = this.style.wordWrapWidth - wordWidth;\n            }\n            else\n            {\n                spaceLeft -= wordWidthWithSpace;\n                result += ' ' + words[j];\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n    return result;\n};\n\n/**\n * Destroys this text object\n *\n * @method destroy\n * @param destroyTexture {Boolean}\n */\nPIXI.Text.prototype.destroy = function(destroyTexture)\n{\n    if(destroyTexture)\n    {\n        this.texture.destroy();\n    }\n\n};\n\nPIXI.Text.heightCache = {};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Text Object will create a line(s) of text using bitmap font. To split a line you can use '\\n', '\\r' or '\\r\\n'\n * You can generate the fnt files using\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class BitmapText\n * @extends DisplayObjectContainer\n * @constructor\n * @param text {String} The copy that you would like the text to display\n * @param style {Object} The style parameters\n * @param style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)\n * @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n */\nPIXI.BitmapText = function(text, style)\n{\n    PIXI.DisplayObjectContainer.call(this);\n\n    this._pool = [];\n\n    this.setText(text);\n    this.setStyle(style);\n    this.updateText();\n    this.dirty = false;\n};\n\n// constructor\nPIXI.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.BitmapText.prototype.constructor = PIXI.BitmapText;\n\n/**\n * Set the copy for the text object\n *\n * @method setText\n * @param text {String} The copy that you would like the text to display\n */\nPIXI.BitmapText.prototype.setText = function(text)\n{\n    this.text = text || ' ';\n    this.dirty = true;\n};\n\n/**\n * Set the style of the text\n * style.font {String} The size (optional) and bitmap font id (required) eq 'Arial' or '20px Arial' (must have loaded previously)\n * [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n *\n * @method setStyle\n * @param style {Object} The style parameters, contained as properties of an object\n */\nPIXI.BitmapText.prototype.setStyle = function(style)\n{\n    style = style || {};\n    style.align = style.align || 'left';\n    this.style = style;\n\n    var font = style.font.split(' ');\n    this.fontName = font[font.length - 1];\n    this.fontSize = font.length >= 2 ? parseInt(font[font.length - 2], 10) : PIXI.BitmapText.fonts[this.fontName].size;\n\n    this.dirty = true;\n    this.tint = style.tint;\n};\n\n/**\n * Renders text and updates it when needed\n *\n * @method updateText\n * @private\n */\nPIXI.BitmapText.prototype.updateText = function()\n{\n    var data = PIXI.BitmapText.fonts[this.fontName];\n    var pos = new PIXI.Point();\n    var prevCharCode = null;\n    var chars = [];\n    var maxLineWidth = 0;\n    var lineWidths = [];\n    var line = 0;\n    var scale = this.fontSize / data.size;\n    \n\n    for(var i = 0; i < this.text.length; i++)\n    {\n        var charCode = this.text.charCodeAt(i);\n        if(/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n        {\n            lineWidths.push(pos.x);\n            maxLineWidth = Math.max(maxLineWidth, pos.x);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n\n        var charData = data.chars[charCode];\n        if(!charData) continue;\n\n        if(prevCharCode && charData[prevCharCode])\n        {\n            pos.x += charData.kerning[prevCharCode];\n        }\n        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new PIXI.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});\n        pos.x += charData.xAdvance;\n\n        prevCharCode = charCode;\n    }\n\n    lineWidths.push(pos.x);\n    maxLineWidth = Math.max(maxLineWidth, pos.x);\n\n    var lineAlignOffsets = [];\n    for(i = 0; i <= line; i++)\n    {\n        var alignOffset = 0;\n        if(this.style.align === 'right')\n        {\n            alignOffset = maxLineWidth - lineWidths[i];\n        }\n        else if(this.style.align === 'center')\n        {\n            alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n        }\n        lineAlignOffsets.push(alignOffset);\n    }\n\n    var lenChildren = this.children.length;\n    var lenChars = chars.length;\n    var tint = this.tint || 0xFFFFFF;\n    for(i = 0; i < lenChars; i++)\n    {\n        var c = i < lenChildren ? this.children[i] : this._pool.pop(); // get old child if have. if not - take from pool.\n\n        if (c) c.setTexture(chars[i].texture); // check if got one before.\n        else c = new PIXI.Sprite(chars[i].texture); // if no create new one.\n\n        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n        c.position.y = chars[i].position.y * scale;\n        c.scale.x = c.scale.y = scale;\n        c.tint = tint;\n        if (!c.parent) this.addChild(c);\n    }\n\n    // remove unnecessary children.\n    // and put their into the pool.\n    while(this.children.length > lenChars)\n    {\n        var child = this.getChildAt(this.children.length - 1);\n        this._pool.push(child);\n        this.removeChild(child);\n    }\n\n\n    /**\n     * [read-only] The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @property textWidth\n     * @type Number\n     */\n    this.textWidth = maxLineWidth * scale;\n\n    /**\n     * [read-only] The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @property textHeight\n     * @type Number\n     */\n    this.textHeight = (pos.y + data.lineHeight) * scale;\n};\n\n/**\n * Updates the transform of this object\n *\n * @method updateTransform\n * @private\n */\nPIXI.BitmapText.prototype.updateTransform = function()\n{\n    if(this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n\n    PIXI.DisplayObjectContainer.prototype.updateTransform.call(this);\n};\n\nPIXI.BitmapText.fonts = {};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A Stage represents the root of the display tree. Everything connected to the stage is rendered\n *\n * @class Stage\n * @extends DisplayObjectContainer\n * @constructor\n * @param backgroundColor {Number} the background color of the stage, you have to pass this in is in hex format\n *      like: 0xFFFFFF for white\n * \n * Creating a stage is a mandatory process when you use Pixi, which is as simple as this : \n * var stage = new PIXI.Stage(0xFFFFFF);\n * where the parameter given is the background colour of the stage, in hex\n * you will use this stage instance to add your sprites to it and therefore to the renderer\n * Here is how to add a sprite to the stage : \n * stage.addChild(sprite);\n */\nPIXI.Stage = function(backgroundColor)\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    /**\n     * [read-only] Current transform of the object based on world (parent) factors\n     *\n     * @property worldTransform\n     * @type Mat3\n     * @readOnly\n     * @private\n     */\n    this.worldTransform = new PIXI.Matrix();\n\n    /**\n     * Whether or not the stage is interactive\n     *\n     * @property interactive\n     * @type Boolean\n     */\n    this.interactive = true;\n\n    /**\n     * The interaction manage for this stage, manages all interactive activity on the stage\n     *\n     * @property interactive\n     * @type InteractionManager\n     */\n    this.interactionManager = new PIXI.InteractionManager(this);\n\n    /**\n     * Whether the stage is dirty and needs to have interactions updated\n     *\n     * @property dirty\n     * @type Boolean\n     * @private\n     */\n    this.dirty = true;\n\n    //the stage is its own stage\n    this.stage = this;\n\n    //optimize hit detection a bit\n    this.stage.hitArea = new PIXI.Rectangle(0,0,100000, 100000);\n\n    this.setBackgroundColor(backgroundColor);\n};\n\n// constructor\nPIXI.Stage.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Stage.prototype.constructor = PIXI.Stage;\n\n/**\n * Sets another DOM element which can receive mouse/touch interactions instead of the default Canvas element.\n * This is useful for when you have other DOM elements on top of the Canvas element.\n *\n * @method setInteractionDelegate\n * @param domElement {DOMElement} This new domElement which will receive mouse/touch events\n */\nPIXI.Stage.prototype.setInteractionDelegate = function(domElement)\n{\n    this.interactionManager.setTargetDomElement( domElement );\n};\n\n/*\n * Updates the object transform for rendering\n *\n * @method updateTransform\n * @private\n */\nPIXI.Stage.prototype.updateTransform = function()\n{\n    this.worldAlpha = 1;\n\n    for(var i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    if(this.dirty)\n    {\n        this.dirty = false;\n        // update interactive!\n        this.interactionManager.dirty = true;\n    }\n\n    if(this.interactive)this.interactionManager.update();\n};\n\n/**\n * Sets the background color for the stage\n *\n * @method setBackgroundColor\n * @param backgroundColor {Number} the color of the background, easiest way to pass this in is in hex format\n *      like: 0xFFFFFF for white\n */\nPIXI.Stage.prototype.setBackgroundColor = function(backgroundColor)\n{\n    this.backgroundColor = backgroundColor || 0x000000;\n    this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);\n    var hex = this.backgroundColor.toString(16);\n    hex = '000000'.substr(0, 6 - hex.length) + hex;\n    this.backgroundColorString = '#' + hex;\n};\n\n/**\n * This will return the point containing global coords of the mouse.\n *\n * @method getMousePosition\n * @return {Point} The point containing the coords of the global InteractionData position.\n */\nPIXI.Stage.prototype.getMousePosition = function()\n{\n    return this.interactionManager.mouse.global;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n/**\n * A polyfill for requestAnimationFrame\n * You can actually use both requestAnimationFrame and requestAnimFrame, \n * you will still benefit from the polyfill\n *\n * @method requestAnimationFrame\n */\n/**\n * A polyfill for cancelAnimationFrame\n *\n * @method cancelAnimationFrame\n */\nvar lastTime = 0;\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\nfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n        window[vendors[x] + 'CancelRequestAnimationFrame'];\n}\n\nif (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n        var currTime = new Date().getTime();\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n        var id = window.setTimeout(function() { callback(currTime + timeToCall); },\n          timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n    };\n}\n\nif (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n        clearTimeout(id);\n    };\n}\n\nwindow.requestAnimFrame = window.requestAnimationFrame;\n\n/**\n * Converts a hex color number to an [R, G, B] array\n *\n * @method hex2rgb\n * @param hex {Number}\n */\nPIXI.hex2rgb = function(hex) {\n    return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255];\n};\n\n/**\n * Converts a color as an [R, G, B] array to a hex number\n *\n * @method rgb2hex\n * @param rgb {Array}\n */\nPIXI.rgb2hex = function(rgb) {\n    return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255);\n};\n\n/**\n * A polyfill for Function.prototype.bind\n *\n * @method bind\n */\nif (typeof Function.prototype.bind !== 'function') {\n    Function.prototype.bind = (function () {\n        var slice = Array.prototype.slice;\n        return function (thisArg) {\n            var target = this, boundArgs = slice.call(arguments, 1);\n\n            if (typeof target !== 'function') throw new TypeError();\n\n            function bound() {\n                var args = boundArgs.concat(slice.call(arguments));\n                target.apply(this instanceof bound ? this : thisArg, args);\n            }\n\n            bound.prototype = (function F(proto) {\n                if (proto) F.prototype = proto;\n                if (!(this instanceof F)) return new F();\n            })(target.prototype);\n\n            return bound;\n        };\n    })();\n}\n\n/**\n * A wrapper for ajax requests to be handled cross browser\n *\n * @class AjaxRequest\n * @constructor\n */\nPIXI.AjaxRequest = function()\n{\n    var activexmodes = ['Msxml2.XMLHTTP.6.0', 'Msxml2.XMLHTTP.3.0', 'Microsoft.XMLHTTP']; //activeX versions to check for in IE\n\n    if (window.ActiveXObject)\n    { //Test for support for ActiveXObject in IE first (as XMLHttpRequest in IE7 is broken)\n        for (var i=0; i<activexmodes.length; i++)\n        {\n            try{\n                return new window.ActiveXObject(activexmodes[i]);\n            }\n            catch(e) {\n                //suppress error\n            }\n        }\n    }\n    else if (window.XMLHttpRequest) // if Mozilla, Safari etc\n    {\n        return new window.XMLHttpRequest();\n    }\n    else\n    {\n        return false;\n    }\n};\n/*\nPIXI.packColorRGBA = function(r, g, b, a)//r, g, b, a)\n{\n  //  console.log(r, b, c, d)\n  return (Math.floor((r)*63) << 18) | (Math.floor((g)*63) << 12) | (Math.floor((b)*63) << 6);// | (Math.floor((a)*63))\n  //  i = i | (Math.floor((a)*63));\n   // return i;\n   // var r = (i / 262144.0 ) / 64;\n   // var g = (i / 4096.0)%64 / 64;\n  //  var b = (i / 64.0)%64 / 64;\n  //  var a = (i)%64 / 64;\n     \n  //  console.log(r, g, b, a);\n  //  return i;\n\n};\n*/\n/*\nPIXI.packColorRGB = function(r, g, b)//r, g, b, a)\n{\n    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));\n};\n\nPIXI.unpackColorRGB = function(r, g, b)//r, g, b, a)\n{\n    return (Math.floor((r)*255) << 16) | (Math.floor((g)*255) << 8) | (Math.floor((b)*255));\n};\n*/\n\n/**\n * Checks whether the Canvas BlendModes are supported by the current browser\n *\n * @method canUseNewCanvasBlendModes\n * @return {Boolean} whether they are supported\n */\nPIXI.canUseNewCanvasBlendModes = function()\n{\n    var canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    var context = canvas.getContext('2d');\n    context.fillStyle = '#000';\n    context.fillRect(0,0,1,1);\n    context.globalCompositeOperation = 'multiply';\n    context.fillStyle = '#fff';\n    context.fillRect(0,0,1,1);\n    return context.getImageData(0,0,1,1).data[0] === 0;\n};\n\n/**\n * Given a number, this function returns the closest number that is a power of two\n * this function is taken from Starling Framework as its pretty neat ;)\n *\n * @method getNextPowerOfTwo\n * @param number {Number}\n * @return {Number} the closest number that is a power of two\n */\nPIXI.getNextPowerOfTwo = function(number)\n{\n    if (number > 0 && (number & (number - 1)) === 0) // see: http://goo.gl/D9kPj\n        return number;\n    else\n    {\n        var result = 1;\n        while (result < number) result <<= 1;\n        return result;\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n/**\n * https://github.com/mrdoob/eventtarget.js/\n * THankS mr DOob!\n */\n\n/**\n * Adds event emitter functionality to a class\n *\n * @class EventTarget\n * @example\n *      function MyEmitter() {\n *          PIXI.EventTarget.call(this); //mixes in event target stuff\n *      }\n *\n *      var em = new MyEmitter();\n *      em.emit({ type: 'eventName', data: 'some data' });\n */\nPIXI.EventTarget = function () {\n\n    /**\n     * Holds all the listeners\n     *\n     * @property listeners\n     * @type Object\n     */\n    var listeners = {};\n\n    /**\n     * Adds a listener for a specific event\n     *\n     * @method addEventListener\n     * @param type {string} A string representing the event type to listen for.\n     * @param listener {function} The callback function that will be fired when the event occurs\n     */\n    this.addEventListener = this.on = function ( type, listener ) {\n\n\n        if ( listeners[ type ] === undefined ) {\n\n            listeners[ type ] = [];\n\n        }\n\n        if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n            listeners[ type ].push( listener );\n        }\n\n    };\n\n    /**\n     * Fires the event, ie pretends that the event has happened\n     *\n     * @method dispatchEvent\n     * @param event {Event} the event object\n     */\n    this.dispatchEvent = this.emit = function ( event ) {\n\n        if ( !listeners[ event.type ] || !listeners[ event.type ].length ) {\n\n            return;\n\n        }\n\n        for(var i = 0, l = listeners[ event.type ].length; i < l; i++) {\n\n            listeners[ event.type ][ i ]( event );\n\n        }\n\n    };\n\n    /**\n     * Removes the specified listener that was assigned to the specified event type\n     *\n     * @method removeEventListener\n     * @param type {string} A string representing the event type which will have its listener removed\n     * @param listener {function} The callback function that was be fired when the event occured\n     */\n    this.removeEventListener = this.off = function ( type, listener ) {\n\n        var index = listeners[ type ].indexOf( listener );\n\n        if ( index !== - 1 ) {\n\n            listeners[ type ].splice( index, 1 );\n\n        }\n\n    };\n\n    /**\n     * Removes all the listeners that were active for the specified event type\n     *\n     * @method removeAllEventListeners\n     * @param type {string} A string representing the event type which will have all its listeners removed\n     */\n\tthis.removeAllEventListeners = function( type ) {\n\t\tvar a = listeners[type];\n\t\tif (a)\n\t\t\ta.length = 0;\n\t};\n};\n\n/*\n    PolyK library\n    url: http://polyk.ivank.net\n    Released under MIT licence.\n\n    Copyright (c) 2012 Ivan Kuckir\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\n    This is an amazing lib!\n\n    slightly modified by Mat Groves (matgroves.com);\n*/\n\n/**\n * Based on the Polyk library http://polyk.ivank.net released under MIT licence.\n * This is an amazing lib!\n * slightly modified by Mat Groves (matgroves.com);\n * @class PolyK\n *\n */\nPIXI.PolyK = {};\n\n/**\n * Triangulates shapes for webGL graphic fills\n *\n * @method Triangulate\n * \n */\nPIXI.PolyK.Triangulate = function(p)\n{\n    var sign = true;\n\n    var n = p.length >> 1;\n    if(n < 3) return [];\n\n    var tgs = [];\n    var avl = [];\n    for(var i = 0; i < n; i++) avl.push(i);\n\n    i = 0;\n    var al = n;\n    while(al > 3)\n    {\n        var i0 = avl[(i+0)%al];\n        var i1 = avl[(i+1)%al];\n        var i2 = avl[(i+2)%al];\n\n        var ax = p[2*i0],  ay = p[2*i0+1];\n        var bx = p[2*i1],  by = p[2*i1+1];\n        var cx = p[2*i2],  cy = p[2*i2+1];\n\n        var earFound = false;\n        if(PIXI.PolyK._convex(ax, ay, bx, by, cx, cy, sign))\n        {\n            earFound = true;\n            for(var j = 0; j < al; j++)\n            {\n                var vi = avl[j];\n                if(vi === i0 || vi === i1 || vi === i2) continue;\n\n                if(PIXI.PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false;\n                    break;\n                }\n            }\n        }\n\n        if(earFound)\n        {\n            tgs.push(i0, i1, i2);\n            avl.splice((i+1)%al, 1);\n            al--;\n            i = 0;\n        }\n        else if(i++ > 3*al)\n        {\n            // need to flip flip reverse it!\n            // reset!\n            if(sign)\n            {\n                tgs = [];\n                avl = [];\n                for(i = 0; i < n; i++) avl.push(i);\n\n                i = 0;\n                al = n;\n\n                sign = false;\n            }\n            else\n            {\n                window.console.log(\"PIXI Warning: shape too complex to fill\");\n                return [];\n            }\n        }\n    }\n\n    tgs.push(avl[0], avl[1], avl[2]);\n    return tgs;\n};\n\n/**\n * Checks whether a point is within a triangle\n *\n * @method _PointInTriangle\n * @param px {Number} x coordinate of the point to test\n * @param py {Number} y coordinate of the point to test\n * @param ax {Number} x coordinate of the a point of the triangle\n * @param ay {Number} y coordinate of the a point of the triangle\n * @param bx {Number} x coordinate of the b point of the triangle\n * @param by {Number} y coordinate of the b point of the triangle\n * @param cx {Number} x coordinate of the c point of the triangle\n * @param cy {Number} y coordinate of the c point of the triangle\n * @private\n */\nPIXI.PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n{\n    var v0x = cx-ax;\n    var v0y = cy-ay;\n    var v1x = bx-ax;\n    var v1y = by-ay;\n    var v2x = px-ax;\n    var v2y = py-ay;\n\n    var dot00 = v0x*v0x+v0y*v0y;\n    var dot01 = v0x*v1x+v0y*v1y;\n    var dot02 = v0x*v2x+v0y*v2y;\n    var dot11 = v1x*v1x+v1y*v1y;\n    var dot12 = v1x*v2x+v1y*v2y;\n\n    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0) && (v >= 0) && (u + v < 1);\n};\n\n/**\n * Checks whether a shape is convex\n *\n * @method _convex\n * \n * @private\n */\nPIXI.PolyK._convex = function(ax, ay, bx, by, cx, cy, sign)\n{\n    return ((ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0) === sign;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n// TODO Alvin and Mat\n// Should we eventually create a Utils class ? \n// Or just move this file to the pixi.js file ?\nPIXI.initDefaultShaders = function()\n{\n   \n  //  PIXI.stripShader = new PIXI.StripShader();\n//    PIXI.stripShader.init();\n\n};\n\nPIXI.CompileVertexShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);\n};\n\nPIXI.CompileFragmentShader = function(gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);\n};\n\nPIXI._CompileShader = function(gl, shaderSrc, shaderType)\n{\n    var src = shaderSrc.join(\"\\n\");\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        window.console.log(gl.getShaderInfoLog(shader));\n        return null;\n    }\n\n    return shader;\n};\n\nPIXI.compileProgram = function(gl, vertexSrc, fragmentSrc)\n{\n    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);\n    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);\n\n    var shaderProgram = gl.createProgram();\n\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n        window.console.log(\"Could not initialise shaders\");\n    }\n\n    return shaderProgram;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Richard Davey http://www.photonstorm.com @photonstorm\n */\n\n/**\n* @class PixiShader\n* @constructor\n*/\nPIXI.PixiShader = function(gl)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n    * @property {any} program - The WebGL program.\n    */\n    this.program = null;\n\n    /**\n    * @property {array} fragmentSrc - The fragment shader.\n    */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n    /**\n    * @property {number} textureCount - A local texture counter for multi-texture shaders.\n    */\n    this.textureCount = 0;\n\n    this.attributes = [];\n\n    this.init();\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.PixiShader.prototype.init = function()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);\n    \n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its something to do with the current state of the gl context.\n    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];\n\n    // End worst hack eva //\n\n    // add those custom shaders!\n    for (var key in this.uniforms)\n    {\n        // get the uniform locations..\n        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);\n    }\n\n    this.initUniforms();\n\n    this.program = program;\n};\n\n/**\n* Initialises the shader uniform values.\n* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\n* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n*\n* @method initUniforms\n*/\nPIXI.PixiShader.prototype.initUniforms = function()\n{\n    this.textureCount = 1;\n    var gl = this.gl;\n    var uniform;\n\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        var type = uniform.type;\n\n        if (type === 'sampler2D')\n        {\n            uniform._init = false;\n\n            if (uniform.value !== null)\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')\n        {\n            //  These require special handling\n            uniform.glMatrix = true;\n            uniform.glValueLength = 1;\n\n            if (type === 'mat2')\n            {\n                uniform.glFunc = gl.uniformMatrix2fv;\n            }\n            else if (type === 'mat3')\n            {\n                uniform.glFunc = gl.uniformMatrix3fv;\n            }\n            else if (type === 'mat4')\n            {\n                uniform.glFunc = gl.uniformMatrix4fv;\n            }\n        }\n        else\n        {\n            //  GL function reference\n            uniform.glFunc = gl['uniform' + type];\n\n            if (type === '2f' || type === '2i')\n            {\n                uniform.glValueLength = 2;\n            }\n            else if (type === '3f' || type === '3i')\n            {\n                uniform.glValueLength = 3;\n            }\n            else if (type === '4f' || type === '4i')\n            {\n                uniform.glValueLength = 4;\n            }\n            else\n            {\n                uniform.glValueLength = 1;\n            }\n        }\n    }\n\n};\n\n/**\n* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)\n*\n* @method initSampler2D\n*/\nPIXI.PixiShader.prototype.initSampler2D = function(uniform)\n{\n    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);\n\n    //  Extended texture data\n    if (uniform.textureData)\n    {\n        var data = uniform.textureData;\n\n        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);\n        // GLTextureLinear = mag/min linear, wrap clamp\n        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat\n        // GLTextureNearest = mag/min nearest, wrap clamp\n        // AudioTexture = whatever + luminance + width 512, height 2, border 0\n        // KeyTexture = whatever + luminance + width 256, height 2, border 0\n\n        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n\n        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;\n        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;\n        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;\n        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;\n        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;\n\n        if (data.repeat)\n        {\n            wrapS = gl.REPEAT;\n            wrapT = gl.REPEAT;\n        }\n\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\n\n        if (data.width)\n        {\n            var width = (data.width) ? data.width : 512;\n            var height = (data.height) ? data.height : 2;\n            var border = (data.border) ? data.border : 0;\n\n            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\n        }\n        else\n        {\n            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);\n        }\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    }\n\n    gl.uniform1i(uniform.uniformLocation, this.textureCount);\n\n    uniform._init = true;\n\n    this.textureCount++;\n\n};\n\n/**\n* Updates the shader uniform values.\n*\n* @method syncUniforms\n*/\nPIXI.PixiShader.prototype.syncUniforms = function()\n{\n    this.textureCount = 1;\n    var uniform;\n    var gl = this.gl;\n\n    //  This would probably be faster in an array and it would guarantee key order\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        if (uniform.glValueLength === 1)\n        {\n            if (uniform.glMatrix === true)\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);\n            }\n            else\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);\n            }\n        }\n        else if (uniform.glValueLength === 2)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);\n        }\n        else if (uniform.glValueLength === 3)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);\n        }\n        else if (uniform.glValueLength === 4)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);\n        }\n        else if (uniform.type === 'sampler2D')\n        {\n            if (uniform._init)\n            {\n                gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));\n                gl.uniform1i(uniform.uniformLocation, this.textureCount);\n                this.textureCount++;\n            }\n            else\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n    }\n\n};\n\n/**\n* Destroys the shader\n* @method destroy\n*/\nPIXI.PixiShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n* The Default Vertex shader source\n* @property defaultVertexSrc\n* @type String\n*/\nPIXI.PixiShader.defaultVertexSrc = [\n    'attribute vec2 aVertexPosition;',\n    'attribute vec2 aTextureCoord;',\n    'attribute vec2 aColor;',\n\n    'uniform vec2 projectionVector;',\n    'uniform vec2 offsetVector;',\n\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n\n    'const vec2 center = vec2(-1.0, 1.0);',\n\n    'void main(void) {',\n    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',\n    '   vTextureCoord = aTextureCoord;',\n    '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n    '   vColor = vec4(color * aColor.x, aColor.x);',\n    '}'\n];\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Richard Davey http://www.photonstorm.com @photonstorm\n */\n\n/**\n* @class PixiFastShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PixiFastShader = function(gl)\n{\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * @property {any} program - The WebGL program.\n     */\n    this.program = null;\n\n    /**\n     * @property {array} fragmentSrc - The fragment shader.\n     */\n    this.fragmentSrc = [\n        'precision lowp float;',\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n        'uniform sampler2D uSampler;',\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n        '}'\n    ];\n\n    /**\n    * @property {array} vertexSrc - The vertex shader\n    */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aPositionCoord;',\n        'attribute vec2 aScale;',\n        'attribute float aRotation;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aColor;',\n\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform mat3 uMatrix;',\n\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n\n        'const vec2 center = vec2(-1.0, 1.0);',\n\n        'void main(void) {',\n        '   vec2 v;',\n        '   vec2 sv = aVertexPosition * aScale;',\n        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',\n        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',\n        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',\n        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n      //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n        '   vColor = aColor;',\n        '}'\n    ];\n\n\n    /**\n    * @property {number} textureCount - A local texture counter for multi-texture shaders.\n    */\n    this.textureCount = 0;\n\n    \n    this.init();\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.PixiFastShader.prototype.init = function()\n{\n\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    \n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');\n\n    this.aScale = gl.getAttribLocation(program, 'aScale');\n    this.aRotation = gl.getAttribLocation(program, 'aRotation');\n\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n   \n\n   \n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its somthing to do with the current state of the gl context.\n    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute];\n    \n    // End worst hack eva //\n\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader\n* @method destroy\n*\n*/\nPIXI.PixiFastShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\nPIXI.StripShader = function()\n{\n    /**\n    * @property {any} program - The WebGL program.\n    */\n    this.program = null;\n\n    /**\n     * @property {array} fragmentSrc - The fragment shader.\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n        'uniform float alpha;',\n        'uniform sampler2D uSampler;',\n\n        'void main(void) {',\n        '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));',\n        '   gl_FragColor = gl_FragColor * alpha;',\n        '}'\n    ];\n\n    /**\n    * @property {array} fragmentSrc - The fragment shader.\n    */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'varying vec2 vTextureCoord;',\n        'uniform vec2 offsetVector;',\n        'varying float vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n        '   vColor = aColor;',\n        '}'\n    ];\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.StripShader.prototype.init = function()\n{\n\n    var gl = PIXI.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n    //this.dimensions = gl.getUniformLocation(this.program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PrimitiveShader = function(gl)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n    * @property {any} program - The WebGL program.\n    */\n    this.program = null;\n\n    /**\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc  = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform float alpha;',\n        'uniform vec3 tint;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\n/**\n* Initialises the shader\n* @method init\n*\n*/\nPIXI.PrimitiveShader.prototype.init = function()\n{\n\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [this.aVertexPosition, this.colorAttribute];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader\n* @method destroy\n*\n*/\nPIXI.PrimitiveShader.prototype.destroy = function()\n{\n    this.gl.deleteProgram( this.program );\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used by the webGL renderer to draw the primitive graphics data\n *\n * @class WebGLGraphics\n * @private\n * @static\n */\nPIXI.WebGLGraphics = function()\n{\n\n};\n\n/**\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics}\n * @param renderSession {Object}\n */\nPIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession)//projection, offset)\n{\n    var gl = renderSession.gl;\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader = renderSession.shaderManager.primitiveShader;\n\n    if(!graphics._webGL[gl.id])graphics._webGL[gl.id] = {points:[], indices:[], lastIndex:0,\n                                           buffer:gl.createBuffer(),\n                                           indexBuffer:gl.createBuffer()};\n\n    var webGL = graphics._webGL[gl.id];\n\n    if(graphics.dirty)\n    {\n        graphics.dirty = false;\n\n        if(graphics.clearDirty)\n        {\n            graphics.clearDirty = false;\n\n            webGL.lastIndex = 0;\n            webGL.points = [];\n            webGL.indices = [];\n\n        }\n\n        PIXI.WebGLGraphics.updateGraphics(graphics, gl);\n    }\n\n    renderSession.shaderManager.activatePrimitiveShader();\n\n    // This  could be speeded up for sure!\n\n    // set the matrix transform\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n    gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n    gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n    gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n    gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint));\n\n    gl.uniform1f(shader.alpha, graphics.worldAlpha);\n    gl.bindBuffer(gl.ARRAY_BUFFER, webGL.buffer);\n\n    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n    gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n    // set the index buffer!\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGL.indexBuffer);\n\n    gl.drawElements(gl.TRIANGLE_STRIP,  webGL.indices.length, gl.UNSIGNED_SHORT, 0 );\n\n    renderSession.shaderManager.deactivatePrimitiveShader();\n\n    // return to default shader...\n//  PIXI.activateShader(PIXI.defaultShader);\n};\n\n/**\n * Updates the graphics object\n *\n * @static\n * @private\n * @method updateGraphics\n * @param graphicsData {Graphics} The graphics object to update\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLGraphics.updateGraphics = function(graphics, gl)\n{\n    var webGL = graphics._webGL[gl.id];\n    \n    for (var i = webGL.lastIndex; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            if(data.fill)\n            {\n                if(data.points.length>3)\n                    PIXI.WebGLGraphics.buildPoly(data, webGL);\n            }\n\n            if(data.lineWidth > 0)\n            {\n                PIXI.WebGLGraphics.buildLine(data, webGL);\n            }\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n            PIXI.WebGLGraphics.buildRectangle(data, webGL);\n        }\n        else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP)\n        {\n            PIXI.WebGLGraphics.buildCircle(data, webGL);\n        }\n    }\n\n    webGL.lastIndex = graphics.graphicsData.length;\n\n   \n\n    webGL.glPoints = new Float32Array(webGL.points);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, webGL.buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, webGL.glPoints, gl.STATIC_DRAW);\n\n    webGL.glIndicies = new Uint16Array(webGL.indices);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGL.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, webGL.glIndicies, gl.STATIC_DRAW);\n};\n\n/**\n * Builds a rectangle to draw\n *\n * @static\n * @private\n * @method buildRectangle\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData)\n{\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.points;\n    var x = rectData[0];\n    var y = rectData[1];\n    var width = rectData[2];\n    var height = rectData[3];\n\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vertPos = verts.length/6;\n\n        // start\n        verts.push(x, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x , y + height);\n        verts.push(r, g, b, alpha);\n\n        verts.push(x + width, y + height);\n        verts.push(r, g, b, alpha);\n\n        // insert 2 dead triangles..\n        indices.push(vertPos, vertPos, vertPos+1, vertPos+2, vertPos+3, vertPos+3);\n    }\n\n    if(graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [x, y,\n                  x + width, y,\n                  x + width, y + height,\n                  x, y + height,\n                  x, y];\n\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a circle to draw\n *\n * @static\n * @private\n * @method buildCircle\n * @param graphicsData {Graphics} The graphics object to draw\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData)\n{\n    \n    // need to convert points to a nice regular data\n    var rectData = graphicsData.points;\n    var x = rectData[0];\n    var y = rectData[1];\n    var width = rectData[2];\n    var height = rectData[3];\n\n    var totalSegs = 40;\n    var seg = (Math.PI * 2) / totalSegs ;\n\n    var i = 0;\n\n    if(graphicsData.fill)\n    {\n        var color = PIXI.hex2rgb(graphicsData.fillColor);\n        var alpha = graphicsData.fillAlpha;\n\n        var r = color[0] * alpha;\n        var g = color[1] * alpha;\n        var b = color[2] * alpha;\n\n        var verts = webGLData.points;\n        var indices = webGLData.indices;\n\n        var vecPos = verts.length/6;\n\n        indices.push(vecPos);\n\n        for (i = 0; i < totalSegs + 1 ; i++)\n        {\n            verts.push(x,y, r, g, b, alpha);\n\n            verts.push(x + Math.sin(seg * i) * width,\n                       y + Math.cos(seg * i) * height,\n                       r, g, b, alpha);\n\n            indices.push(vecPos++, vecPos++);\n        }\n\n        indices.push(vecPos-1);\n    }\n\n    if(graphicsData.lineWidth)\n    {\n        var tempPoints = graphicsData.points;\n\n        graphicsData.points = [];\n\n        for (i = 0; i < totalSegs + 1; i++)\n        {\n            graphicsData.points.push(x + Math.sin(seg * i) * width,\n                                     y + Math.cos(seg * i) * height);\n        }\n\n        PIXI.WebGLGraphics.buildLine(graphicsData, webGLData);\n\n        graphicsData.points = tempPoints;\n    }\n};\n\n/**\n * Builds a line to draw\n *\n * @static\n * @private\n * @method buildLine\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData)\n{\n    // TODO OPTIMISE!\n    var i = 0;\n\n    var points = graphicsData.points;\n    if(points.length === 0)return;\n\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    if(graphicsData.lineWidth%2)\n    {\n        for (i = 0; i < points.length; i++) {\n            points[i] += 0.5;\n        }\n    }\n\n    // get first and last point.. figure out the middle!\n    var firstPoint = new PIXI.Point( points[0], points[1] );\n    var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n    // if the first point is the last point - gonna have issues :)\n    if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y)\n    {\n        points.pop();\n        points.pop();\n\n        lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] );\n\n        var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5;\n        var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var length = points.length / 2;\n    var indexCount = points.length;\n    var indexStart = verts.length/6;\n\n    // DRAW the Line\n    var width = graphicsData.lineWidth / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.lineColor);\n    var alpha = graphicsData.lineAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var px, py, p1x, p1y, p2x, p2y, p3x, p3y;\n    var perpx, perpy, perp2x, perp2y, perp3x, perp3y;\n    var a1, b1, c1, a2, b2, c2;\n    var denom, pdist, dist;\n\n    p1x = points[0];\n    p1y = points[1];\n\n    p2x = points[2];\n    p2y = points[3];\n\n    perpx = -(p1y - p2y);\n    perpy =  p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    // start\n    verts.push(p1x - perpx , p1y - perpy,\n                r, g, b, alpha);\n\n    verts.push(p1x + perpx , p1y + perpy,\n                r, g, b, alpha);\n\n    for (i = 1; i < length-1; i++)\n    {\n        p1x = points[(i-1)*2];\n        p1y = points[(i-1)*2 + 1];\n\n        p2x = points[(i)*2];\n        p2y = points[(i)*2 + 1];\n\n        p3x = points[(i+1)*2];\n        p3y = points[(i+1)*2 + 1];\n\n        perpx = -(p1y - p2y);\n        perpy = p1x - p2x;\n\n        dist = Math.sqrt(perpx*perpx + perpy*perpy);\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp2x = -(p2y - p3y);\n        perp2y = p2x - p3x;\n\n        dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y);\n        perp2x /= dist;\n        perp2y /= dist;\n        perp2x *= width;\n        perp2y *= width;\n\n        a1 = (-perpy + p1y) - (-perpy + p2y);\n        b1 = (-perpx + p2x) - (-perpx + p1x);\n        c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);\n        a2 = (-perp2y + p3y) - (-perp2y + p2y);\n        b2 = (-perp2x + p2x) - (-perp2x + p3x);\n        c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);\n\n        denom = a1*b2 - a2*b1;\n\n        if(Math.abs(denom) < 0.1 )\n        {\n\n            denom+=10.1;\n            verts.push(p2x - perpx , p2y - perpy,\n                r, g, b, alpha);\n\n            verts.push(p2x + perpx , p2y + perpy,\n                r, g, b, alpha);\n\n            continue;\n        }\n\n        px = (b1*c2 - b2*c1)/denom;\n        py = (a2*c1 - a1*c2)/denom;\n\n\n        pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y);\n\n\n        if(pdist > 140 * 140)\n        {\n            perp3x = perpx - perp2x;\n            perp3y = perpy - perp2y;\n\n            dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y);\n            perp3x /= dist;\n            perp3y /= dist;\n            perp3x *= width;\n            perp3y *= width;\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x + perp3x, p2y +perp3y);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - perp3x, p2y -perp3y);\n            verts.push(r, g, b, alpha);\n\n            indexCount++;\n        }\n        else\n        {\n\n            verts.push(px , py);\n            verts.push(r, g, b, alpha);\n\n            verts.push(p2x - (px-p2x), p2y - (py - p2y));\n            verts.push(r, g, b, alpha);\n        }\n    }\n\n    p1x = points[(length-2)*2];\n    p1y = points[(length-2)*2 + 1];\n\n    p2x = points[(length-1)*2];\n    p2y = points[(length-1)*2 + 1];\n\n    perpx = -(p1y - p2y);\n    perpy = p1x - p2x;\n\n    dist = Math.sqrt(perpx*perpx + perpy*perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(p2x - perpx , p2y - perpy);\n    verts.push(r, g, b, alpha);\n\n    verts.push(p2x + perpx , p2y + perpy);\n    verts.push(r, g, b, alpha);\n\n    indices.push(indexStart);\n\n    for (i = 0; i < indexCount; i++)\n    {\n        indices.push(indexStart++);\n    }\n\n    indices.push(indexStart-1);\n};\n\n/**\n * Builds a polygon to draw\n *\n * @static\n * @private\n * @method buildPoly\n * @param graphicsData {Graphics} The graphics object containing all the necessary properties\n * @param webGLData {Object}\n */\nPIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData)\n{\n    var points = graphicsData.points;\n    if(points.length < 6)return;\n\n    // get first and last point.. figure out the middle!\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n\n    var length = points.length / 2;\n\n    // sort color\n    var color = PIXI.hex2rgb(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n\n    var triangles = PIXI.PolyK.Triangulate(points);\n\n    var vertPos = verts.length / 6;\n\n    var i = 0;\n\n    for (i = 0; i < triangles.length; i+=3)\n    {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i+1] + vertPos);\n        indices.push(triangles[i+2] +vertPos);\n        indices.push(triangles[i+2] + vertPos);\n    }\n\n    for (i = 0; i < length; i++)\n    {\n        verts.push(points[i * 2], points[i * 2 + 1],\n                   r, g, b, alpha);\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.glContexts = []; // this is where we store the webGL contexts for easy access.\n\n/**\n * the WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatch's.\n * So no need for Sprite Batch's or Sprite Cloud's\n * Dont forget to add the view to your DOM or you will not see anything :)\n *\n * @class WebGLRenderer\n * @constructor\n * @param width=0 {Number} the width of the canvas view\n * @param height=0 {Number} the height of the canvas view\n * @param view {HTMLCanvasElement} the canvas to use as a view, optional\n * @param transparent=false {Boolean} If the render view is transparent, default false\n * @param antialias=false {Boolean} sets antialias (only applicable in chrome at the moment)\n *\n */\nPIXI.WebGLRenderer = function(width, height, view, transparent, antialias)\n{\n    if(!PIXI.defaultRenderer)PIXI.defaultRenderer = this;\n\n    this.type = PIXI.WEBGL_RENDERER;\n\n    // do a catch.. only 1 webGL renderer..\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = !!transparent;\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = width || 800;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = height || 600;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = view || document.createElement( 'canvas' );\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    // deal with losing context..\n    this.contextLost = this.handleContextLost.bind(this);\n    this.contextRestoredLost = this.handleContextRestored.bind(this);\n    \n    this.view.addEventListener('webglcontextlost', this.contextLost, false);\n    this.view.addEventListener('webglcontextrestored', this.contextRestoredLost, false);\n\n    this.options = {\n        alpha: this.transparent,\n        antialias:!!antialias, // SPEED UP??\n        premultipliedAlpha:!!transparent,\n        stencil:true\n    };\n\n    //try 'experimental-webgl'\n    try {\n        this.gl = this.view.getContext('experimental-webgl',  this.options);\n    } catch (e) {\n        //try 'webgl'\n        try {\n            this.gl = this.view.getContext('webgl',  this.options);\n        } catch (e2) {\n            // fail, not able to get a context\n            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);\n        }\n    }\n\n    var gl = this.gl;\n    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId ++;\n\n    PIXI.glContexts[this.glContextId] = gl;\n\n    if(!PIXI.blendModesWebGL)\n    {\n        PIXI.blendModesWebGL = [];\n\n        PIXI.blendModesWebGL[PIXI.blendModes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE];\n        PIXI.blendModesWebGL[PIXI.blendModes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n        PIXI.blendModesWebGL[PIXI.blendModes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA];\n    }\n\n\n\n\n    this.projection = new PIXI.Point();\n    this.projection.x =  this.width/2;\n    this.projection.y =  -this.height/2;\n\n    this.offset = new PIXI.Point(0, 0);\n\n    this.resize(this.width, this.height);\n    this.contextLost = false;\n\n    // time to create the render managers! each one focuses on managine a state in webGL\n    this.shaderManager = new PIXI.WebGLShaderManager(gl);                   // deals with managing the shader programs and their attribs\n    this.spriteBatch = new PIXI.WebGLSpriteBatch(gl);                       // manages the rendering of sprites\n    this.maskManager = new PIXI.WebGLMaskManager(gl);                       // manages the masks using the stencil buffer\n    this.filterManager = new PIXI.WebGLFilterManager(gl, this.transparent); // manages the filters\n\n    this.renderSession = {};\n    this.renderSession.gl = this.gl;\n    this.renderSession.drawCount = 0;\n    this.renderSession.shaderManager = this.shaderManager;\n    this.renderSession.maskManager = this.maskManager;\n    this.renderSession.filterManager = this.filterManager;\n    this.renderSession.spriteBatch = this.spriteBatch;\n    this.renderSession.renderer = this;\n\n    gl.useProgram(this.shaderManager.defaultShader.program);\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n\n    gl.enable(gl.BLEND);\n    gl.colorMask(true, true, true, this.transparent);\n};\n\n// constructor\nPIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;\n\n/**\n * Renders the stage to its webGL view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.WebGLRenderer.prototype.render = function(stage)\n{\n    if(this.contextLost)return;\n\n\n    // if rendering a new stage clear the batches..\n    if(this.__stage !== stage)\n    {\n        if(stage.interactive)stage.interactionManager.removeEvents();\n\n        // TODO make this work\n        // dont think this is needed any more?\n        this.__stage = stage;\n    }\n\n    // update any textures this includes uvs and uploading them to the gpu\n    PIXI.WebGLRenderer.updateTextures();\n\n    // update the scene graph\n    stage.updateTransform();\n\n\n    // interaction\n    if(stage._interactive)\n    {\n        //need to add some events!\n        if(!stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = true;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n    \n    var gl = this.gl;\n\n    // -- Does this need to be set every frame? -- //\n    //gl.colorMask(true, true, true, this.transparent);\n    gl.viewport(0, 0, this.width, this.height);\n\n    // make sure we are bound to the main frame buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    if(this.transparent)\n    {\n        gl.clearColor(0, 0, 0, 0);\n    }\n    else\n    {\n        gl.clearColor(stage.backgroundColorSplit[0],stage.backgroundColorSplit[1],stage.backgroundColorSplit[2], 1);\n    }\n\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    this.renderDisplayObject( stage, this.projection );\n\n    // interaction\n    if(stage.interactive)\n    {\n        //need to add some events!\n        if(!stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = true;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n    else\n    {\n        if(stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = false;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n\n    /*\n    //can simulate context loss in Chrome like so:\n     this.view.onmousedown = function(ev) {\n     console.dir(this.gl.getSupportedExtensions());\n        var ext = (\n            gl.getExtension(\"WEBGL_scompressed_texture_s3tc\")\n       // gl.getExtension(\"WEBGL_compressed_texture_s3tc\") ||\n       // gl.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") ||\n       // gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\")\n     );\n     console.dir(ext);\n     var loseCtx = this.gl.getExtension(\"WEBGL_lose_context\");\n      console.log(\"killing context\");\n      loseCtx.loseContext();\n     setTimeout(function() {\n          console.log(\"restoring context...\");\n          loseCtx.restoreContext();\n      }.bind(this), 1000);\n     }.bind(this);\n     */\n};\n\n/**\n * Renders a display Object\n *\n * @method renderDIsplayObject\n * @param displayObject {DisplayObject} The DisplayObject to render\n * @param projection {Point} The projection\n * @param buffer {Array} a standard WebGL buffer \n */\nPIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer)\n{\n    // reset the render session data..\n    this.renderSession.drawCount = 0;\n    this.renderSession.currentBlendMode = 9999;\n\n    this.renderSession.projection = projection;\n    this.renderSession.offset = this.offset;\n\n    // start the sprite batch\n    this.spriteBatch.begin(this.renderSession);\n\n    // start the filter manager\n    this.filterManager.begin(this.renderSession, buffer);\n\n    // render the scene!\n    displayObject._renderWebGL(this.renderSession);\n\n    // finish the sprite batch\n    this.spriteBatch.end();\n};\n\n/**\n * Updates the textures loaded into this webgl renderer\n *\n * @static\n * @method updateTextures\n * @private\n */\nPIXI.WebGLRenderer.updateTextures = function()\n{\n    var i = 0;\n\n    //TODO break this out into a texture manager...\n    //for (i = 0; i < PIXI.texturesToUpdate.length; i++)\n    //    PIXI.WebGLRenderer.updateTexture(PIXI.texturesToUpdate[i]);\n\n\n    for (i=0; i < PIXI.Texture.frameUpdates.length; i++)\n        PIXI.WebGLRenderer.updateTextureFrame(PIXI.Texture.frameUpdates[i]);\n\n    for (i = 0; i < PIXI.texturesToDestroy.length; i++)\n        PIXI.WebGLRenderer.destroyTexture(PIXI.texturesToDestroy[i]);\n\n    PIXI.texturesToUpdate.length = 0;\n    PIXI.texturesToDestroy.length = 0;\n    PIXI.Texture.frameUpdates.length = 0;\n};\n\n/**\n * Destroys a loaded webgl texture\n *\n * @method destroyTexture\n * @param texture {Texture} The texture to update\n * @private\n */\nPIXI.WebGLRenderer.destroyTexture = function(texture)\n{\n    //TODO break this out into a texture manager...\n\n    for (var i = texture._glTextures.length - 1; i >= 0; i--)\n    {\n        var glTexture = texture._glTextures[i];\n        var gl = PIXI.glContexts[i];\n\n        if(gl && glTexture)\n        {\n            gl.deleteTexture(glTexture);\n        }\n    }\n\n    texture._glTextures.length = 0;\n};\n\n/**\n *\n * @method updateTextureFrame\n * @param texture {Texture} The texture to update the frame from\n * @private\n */\nPIXI.WebGLRenderer.updateTextureFrame = function(texture)\n{\n    texture.updateFrame = false;\n\n    // now set the uvs. Figured that the uv data sits with a texture rather than a sprite.\n    // so uv data is stored on the texture itself\n    texture._updateWebGLuvs();\n};\n\n/**\n * resizes the webGL view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the webGL view\n * @param height {Number} the new height of the webGL view\n */\nPIXI.WebGLRenderer.prototype.resize = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.view.width = width;\n    this.view.height = height;\n\n    this.gl.viewport(0, 0, this.width, this.height);\n\n    this.projection.x =  this.width/2;\n    this.projection.y =  -this.height/2;\n};\n\n/**\n * Creates a WebGL texture\n *\n * @method createWebGLTexture\n * @param texture {Texture} the texture to render\n * @param gl {webglContext} the WebGL context\n * @static\n */\nPIXI.createWebGLTexture = function(texture, gl)\n{\n\n\n    if(texture.hasLoaded)\n    {\n        texture._glTextures[gl.id] = gl.createTexture();\n\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n        // reguler...\n\n        if(!texture._powerOf2)\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        }\n        else\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n        }\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    return  texture._glTextures[gl.id];\n};\n\n/**\n * Updates a WebGL texture\n *\n * @method updateWebGLTexture\n * @param texture {Texture} the texture to update\n * @param gl {webglContext} the WebGL context\n * @private\n */\nPIXI.updateWebGLTexture = function(texture, gl)\n{\n    if( texture._glTextures[gl.id] )\n    {\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n        // reguler...\n\n        if(!texture._powerOf2)\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        }\n        else\n        {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n        }\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n    \n};\n\n/**\n * Handles a lost webgl context\n *\n * @method handleContextLost\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextLost = function(event)\n{\n    event.preventDefault();\n    this.contextLost = true;\n};\n\n/**\n * Handles a restored webgl context\n *\n * @method handleContextRestored\n * @param event {Event}\n * @private\n */\nPIXI.WebGLRenderer.prototype.handleContextRestored = function()\n{\n\n    //try 'experimental-webgl'\n    try {\n        this.gl = this.view.getContext('experimental-webgl',  this.options);\n    } catch (e) {\n        //try 'webgl'\n        try {\n            this.gl = this.view.getContext('webgl',  this.options);\n        } catch (e2) {\n            // fail, not able to get a context\n            throw new Error(' This browser does not support webGL. Try using the canvas renderer' + this);\n        }\n    }\n\n    var gl = this.gl;\n    gl.id = PIXI.WebGLRenderer.glContextId ++;\n\n\n\n    // need to set the context...\n    this.shaderManager.setContext(gl);\n    this.spriteBatch.setContext(gl);\n    this.maskManager.setContext(gl);\n    this.filterManager.setContext(gl);\n\n\n    this.renderSession.gl = this.gl;\n\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n\n    gl.enable(gl.BLEND);\n    gl.colorMask(true, true, true, this.transparent);\n\n    this.gl.viewport(0, 0, this.width, this.height);\n\n    for(var key in PIXI.TextureCache)\n    {\n        var texture = PIXI.TextureCache[key].baseTexture;\n        texture._glTextures = [];\n    }\n\n    /**\n     * Whether the context was lost \n     * @property contextLost\n     * @type Boolean\n     */\n    this.contextLost = false;\n\n};\n\n/**\n * Removes everything from the renderer (event listeners, spritebatch, etc...)\n *\n * @method destroy\n */\nPIXI.WebGLRenderer.prototype.destroy = function()\n{\n\n    // deal with losing context..\n    \n    // remove listeners\n    this.view.removeEventListener('webglcontextlost', this.contextLost);\n    this.view.removeEventListener('webglcontextrestored', this.contextRestoredLost);\n\n    PIXI.glContexts[this.glContextId] = null;\n\n    this.projection = null;\n    this.offset = null;\n\n    // time to create the render managers! each one focuses on managine a state in webGL\n    this.shaderManager.destroy();\n    this.spriteBatch.destroy();\n    this.maskManager.destroy();\n    this.filterManager.destroy();\n\n    this.shaderManager = null;\n    this.spriteBatch = null;\n    this.maskManager = null;\n    this.filterManager = null;\n    \n    this.gl = null;\n    //\n    this.renderSession = null;\n};\n\n\nPIXI.WebGLRenderer.glContextId = 0;\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n \n\n/**\n* @class WebGLMaskManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @private\n*/\nPIXI.WebGLMaskManager = function(gl)\n{\n    this.maskStack = [];\n    this.maskPosition = 0;\n\n    this.setContext(gl);\n};\n\n/**\n* Sets the drawing context to the one given in parameter\n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLMaskManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack\n* @method pushMask\n* @param maskData {Array}\n* @param renderSession {RenderSession}\n*/\nPIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession)\n{\n    var gl = this.gl;\n\n    if(this.maskStack.length === 0)\n    {\n        gl.enable(gl.STENCIL_TEST);\n        gl.stencilFunc(gl.ALWAYS,1,1);\n    }\n    \n  //  maskData.visible = false;\n\n    this.maskStack.push(maskData);\n    \n    gl.colorMask(false, false, false, false);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n\n    PIXI.WebGLGraphics.renderGraphics(maskData, renderSession);\n\n    gl.colorMask(true, true, true, true);\n    gl.stencilFunc(gl.NOTEQUAL,0, this.maskStack.length);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it\n* @method popMask\n*\n* @param renderSession {RenderSession} an object containing all the useful parameters\n*/\nPIXI.WebGLMaskManager.prototype.popMask = function(renderSession)\n{\n    var gl = this.gl;\n\n    var maskData = this.maskStack.pop();\n\n    if(maskData)\n    {\n        gl.colorMask(false, false, false, false);\n\n        //gl.stencilFunc(gl.ALWAYS,1,1);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n\n        PIXI.WebGLGraphics.renderGraphics(maskData, renderSession);\n\n        gl.colorMask(true, true, true, true);\n        gl.stencilFunc(gl.NOTEQUAL,0,this.maskStack.length);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n    }\n   \n    if(this.maskStack.length === 0)gl.disable(gl.STENCIL_TEST);\n};\n\n/**\n* Destroys the mask stack\n* @method destroy\n*/\nPIXI.WebGLMaskManager.prototype.destroy = function()\n{\n    this.maskStack = null;\n    this.gl = null;\n};\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLShaderManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @private\n*/\nPIXI.WebGLShaderManager = function(gl)\n{\n\n    this.maxAttibs = 10;\n    this.attribState = [];\n    this.tempAttribState = [];\n\n    for (var i = 0; i < this.maxAttibs; i++) {\n        this.attribState[i] = false;\n    }\n\n    this.setContext(gl);\n    // the final one is used for the rendering strips\n    //this.stripShader = new PIXI.StripShader(gl);\n};\n\n\n/**\n* Initialises the context and the properties\n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n* @param transparent {Boolean} Whether or not the drawing context should be transparent\n*/\nPIXI.WebGLShaderManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    \n    // the next one is used for rendering primatives\n    this.primitiveShader = new PIXI.PrimitiveShader(gl);\n\n    // this shader is used for the default sprite rendering\n    this.defaultShader = new PIXI.PixiShader(gl);\n\n    // this shader is used for the fast sprite rendering\n    this.fastShader = new PIXI.PixiFastShader(gl);\n\n\n    this.activateShader(this.defaultShader);\n};\n\n\n/**\n* Takes the attributes given in parameters \n* @method setAttribs\n* @param attribs {Array} attribs \n*/\nPIXI.WebGLShaderManager.prototype.setAttribs = function(attribs)\n{\n    // reset temp state\n\n    var i;\n\n    for (i = 0; i < this.tempAttribState.length; i++)\n    {\n        this.tempAttribState[i] = false;\n    }\n\n    // set the new attribs\n    for (i = 0; i < attribs.length; i++)\n    {\n        var attribId = attribs[i];\n        this.tempAttribState[attribId] = true;\n    }\n\n    var gl = this.gl;\n\n    for (i = 0; i < this.attribState.length; i++)\n    {\n\n        if(this.attribState[i] !== this.tempAttribState[i])\n        {\n            this.attribState[i] = this.tempAttribState[i];\n\n            if(this.tempAttribState[i])\n            {\n                gl.enableVertexAttribArray(i);\n            }\n            else\n            {\n                gl.disableVertexAttribArray(i);\n            }\n        }\n    }\n};\n\n/**\n* Sets-up the given shader \n*\n* @method activateShader\n* @param shader {Object} the shader that is going to be activated\n*/\nPIXI.WebGLShaderManager.prototype.activateShader = function(shader)\n{\n    //if(this.currentShader == shader)return;\n\n    this.currentShader = shader;\n\n    this.gl.useProgram(shader.program);\n    this.setAttribs(shader.attributes);\n  \n};\n\n/**\n* Triggers the primitive shader\n* @method activatePrimitiveShader\n*/\nPIXI.WebGLShaderManager.prototype.activatePrimitiveShader = function()\n{\n    var gl = this.gl;\n\n    gl.useProgram(this.primitiveShader.program);\n\n    this.setAttribs(this.primitiveShader.attributes);\n    \n};\n\n/**\n* Disable the primitive shader\n* @method deactivatePrimitiveShader\n*/\nPIXI.WebGLShaderManager.prototype.deactivatePrimitiveShader = function()\n{\n    var gl = this.gl;\n\n    gl.useProgram(this.defaultShader.program);\n\n    this.setAttribs(this.defaultShader.attributes);\n};\n\n/**\n* Destroys\n* @method destroy\n*/\nPIXI.WebGLShaderManager.prototype.destroy = function()\n{\n    this.attribState = null;\n\n    this.tempAttribState = null;\n\n    this.primitiveShader.destroy();\n\n    this.defaultShader.destroy();\n\n    this.fastShader.destroy();\n\n    this.gl = null;\n};\n\n\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n /**\n *\n * @class WebGLSpriteBatch\n * @private\n * @constructor\n * @param gl {WebGLContext} the current WebGL drawing context\n *\n */\nPIXI.WebGLSpriteBatch = function(gl)\n{\n\n    /**\n     * \n     *\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 6;\n\n    /**\n     * The number of images in the SpriteBatch before it flushes\n     * @property size\n     * @type Number\n     */\n    this.size = 2000;//Math.pow(2, 16) /  this.vertSize;\n\n    //the total number of floats in our batch\n    var numVerts = this.size * 4 *  this.vertSize;\n    //the total number of indices in our batch\n    var numIndices = this.size * 6;\n\n    //vertex data\n\n    /**\n    * Holds the vertices\n    *\n    * @property vertices\n    * @type Float32Array\n    */\n    this.vertices = new Float32Array(numVerts);\n\n    //index data\n    /**\n     * Holds the indices\n     *\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new Uint16Array(numIndices);\n    \n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n\n    this.drawing = false;\n    this.currentBatchSize = 0;\n    this.currentBaseTexture = null;\n    \n    this.setContext(gl);\n};\n\n/**\n* \n* @method setContext\n*\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n};\n\n/**\n* \n* @method begin\n*\n* @param renderSession {RenderSession} the RenderSession\n*/\nPIXI.WebGLSpriteBatch.prototype.begin = function(renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.defaultShader;\n\n    this.start();\n};\n\n/**\n* \n* @method end\n*\n*/\nPIXI.WebGLSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n/**\n* \n* @method render\n* \n* @param sprite {Sprite} the sprite to render when using this spritebatch\n*/\nPIXI.WebGLSpriteBatch.prototype.render = function(sprite)\n{\n    var texture = sprite.texture;\n\n    // check texture..\n    if(texture.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n\n    // check blend mode\n    if(sprite.blendMode !== this.currentBlendMode)\n    {\n        this.setBlendMode(sprite.blendMode);\n    }\n\n    // get the uvs for the texture\n    var uvs = sprite._uvs || sprite.texture._uvs;\n    // if the uvs have not updated then no point rendering just yet!\n    if(!uvs)return;\n\n    // get the sprites current alpha\n    var alpha = sprite.worldAlpha;\n    var tint = sprite.tint;\n\n    var verticies = this.vertices;\n\n\n    // TODO trim??\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n\n    var w0, w1, h0, h1;\n        \n    if (sprite.texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = sprite.texture.trim;\n\n        w1 = trim.x - aX * trim.width;\n        w0 = w1 + texture.frame.width;\n\n        h1 = trim.y - aY * trim.height;\n        h0 = h1 + texture.frame.height;\n\n    }\n    else\n    {\n        w0 = (texture.frame.width ) * (1-aX);\n        w1 = (texture.frame.width ) * -aX;\n\n        h0 = texture.frame.height * (1-aY);\n        h1 = texture.frame.height * -aY;\n    }\n\n    var index = this.currentBatchSize * 4 * this.vertSize;\n\n    var worldTransform = sprite.worldTransform;//.toArray();\n\n    var a = worldTransform.a;//[0];\n    var b = worldTransform.c;//[3];\n    var c = worldTransform.b;//[1];\n    var d = worldTransform.d;//[4];\n    var tx = worldTransform.tx;//[2];\n    var ty = worldTransform.ty;///[5];\n\n    // xy\n    verticies[index++] = a * w1 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y0;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w1 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n    \n    // increment the batchsize\n    this.currentBatchSize++;\n\n\n};\n\n/**\n* Renders a tilingSprite using the spriteBatch\n* @method renderTilingSprite\n* \n* @param sprite {TilingSprite} the tilingSprite to render\n*/\nPIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(tilingSprite)\n{\n    var texture = tilingSprite.tilingTexture;\n\n    if(texture.baseTexture !== this.currentBaseTexture || this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n     // check blend mode\n    if(tilingSprite.blendMode !== this.currentBlendMode)\n    {\n        this.setBlendMode(tilingSprite.blendMode);\n    }\n\n     // set the textures uvs temporarily\n    // TODO create a separate texture so that we can tile part of a texture\n\n    if(!tilingSprite._uvs)tilingSprite._uvs = new PIXI.TextureUvs();\n\n    var uvs = tilingSprite._uvs;\n\n    tilingSprite.tilePosition.x %= texture.baseTexture.width * tilingSprite.tileScaleOffset.x;\n    tilingSprite.tilePosition.y %= texture.baseTexture.height * tilingSprite.tileScaleOffset.y;\n\n    var offsetX =  tilingSprite.tilePosition.x/(texture.baseTexture.width*tilingSprite.tileScaleOffset.x);\n    var offsetY =  tilingSprite.tilePosition.y/(texture.baseTexture.height*tilingSprite.tileScaleOffset.y);\n\n    var scaleX =  (tilingSprite.width / texture.baseTexture.width)  / (tilingSprite.tileScale.x * tilingSprite.tileScaleOffset.x);\n    var scaleY =  (tilingSprite.height / texture.baseTexture.height) / (tilingSprite.tileScale.y * tilingSprite.tileScaleOffset.y);\n\n    uvs.x0 = 0 - offsetX;\n    uvs.y0 = 0 - offsetY;\n\n    uvs.x1 = (1 * scaleX) - offsetX;\n    uvs.y1 = 0 - offsetY;\n\n    uvs.x2 = (1 * scaleX) - offsetX;\n    uvs.y2 = (1 * scaleY) - offsetY;\n\n    uvs.x3 = 0 - offsetX;\n    uvs.y3 = (1 *scaleY) - offsetY;\n\n    // get the tilingSprites current alpha\n    var alpha = tilingSprite.worldAlpha;\n    var tint = tilingSprite.tint;\n\n    var  verticies = this.vertices;\n\n    var width = tilingSprite.width;\n    var height = tilingSprite.height;\n\n    // TODO trim??\n    var aX = tilingSprite.anchor.x; // - tilingSprite.texture.trim.x\n    var aY = tilingSprite.anchor.y; //- tilingSprite.texture.trim.y\n    var w0 = width * (1-aX);\n    var w1 = width * -aX;\n\n    var h0 = height * (1-aY);\n    var h1 = height * -aY;\n\n    var index = this.currentBatchSize * 4 * this.vertSize;\n\n    var worldTransform = tilingSprite.worldTransform;\n\n    var a = worldTransform.a;//[0];\n    var b = worldTransform.c;//[3];\n    var c = worldTransform.b;//[1];\n    var d = worldTransform.d;//[4];\n    var tx = worldTransform.tx;//[2];\n    var ty = worldTransform.ty;///[5];\n\n    // xy\n    verticies[index++] = a * w1 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y0;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w0 + c * h1 + tx;\n    verticies[index++] = d * h1 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n    \n    // xy\n    verticies[index++] = a * w0 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w0 + ty;\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // xy\n    verticies[index++] = a * w1 + c * h0 + tx;\n    verticies[index++] = d * h0 + b * w1 + ty;\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = alpha;\n    verticies[index++] = tint;\n\n    // increment the batchs\n    this.currentBatchSize++;\n};\n\n\n/**\n* Renders the content and empties the current batch\n*\n* @method flush\n* \n*/\nPIXI.WebGLSpriteBatch.prototype.flush = function()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize===0)return;\n\n    var gl = this.gl;\n    \n    // bind the current texture\n    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id] || PIXI.createWebGLTexture(this.currentBaseTexture, gl));\n\n    // upload the verts to the buffer\n    \n    if(this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n   // var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n    //gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    \n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);\n   \n    // then reset the batch!\n    this.currentBatchSize = 0;\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n/**\n* \n* @method stop\n*\n*/\nPIXI.WebGLSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n};\n\n/**\n* \n* @method start\n*\n*/\nPIXI.WebGLSpriteBatch.prototype.start = function()\n{\n    var gl = this.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // set the projection\n    var projection = this.renderSession.projection;\n    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);\n\n    // set the pointers\n    var stride =  this.vertSize * 4;\n    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n    gl.vertexAttribPointer(this.shader.colorAttribute, 2, gl.FLOAT, false, stride, 4 * 4);\n\n    // set the blend mode..\n    if(this.currentBlendMode !== PIXI.blendModes.NORMAL)\n    {\n        this.setBlendMode(PIXI.blendModes.NORMAL);\n    }\n};\n\n/**\n* Sets-up the given blendMode from WebGL's point of view\n* @method setBlendMode \n*\n* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD\n*/\nPIXI.WebGLSpriteBatch.prototype.setBlendMode = function(blendMode)\n{\n    this.flush();\n\n    this.currentBlendMode = blendMode;\n    \n    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];\n    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n};\n\n/**\n* Destroys the SpriteBatch\n* @method destroy\n*/\nPIXI.WebGLSpriteBatch.prototype.destroy = function()\n{\n\n    this.vertices = null;\n    this.indices = null;\n    \n    this.gl.deleteBuffer( this.vertexBuffer );\n    this.gl.deleteBuffer( this.indexBuffer );\n    \n    this.currentBaseTexture = null;\n    \n    this.gl = null;\n};\n\n\n/**\n * @author Mat Groves\n * \n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\nPIXI.WebGLFastSpriteBatch = function(gl)\n{\n   \n\n    this.vertSize = 10;\n    this.maxSize = 6000;//Math.pow(2, 16) /  this.vertSize;\n    this.size = this.maxSize;\n\n    //the total number of floats in our batch\n    var numVerts = this.size * 4 *  this.vertSize;\n    //the total number of indices in our batch\n    var numIndices = this.maxSize * 6;\n\n     //vertex data\n    this.vertices = new Float32Array(numVerts);\n    //index data\n    this.indices = new Uint16Array(numIndices);\n    \n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n\n    this.lastIndexCount = 0;\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    this.drawing = false;\n    this.currentBatchSize = 0;\n    this.currentBaseTexture = null;\n   \n    this.currentBlendMode = 0;\n    this.renderSession = null;\n    \n\n    this.shader = null;\n\n    this.matrix = null;\n\n    this.setContext(gl);\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.fastShader;\n\n    this.matrix = spriteBatch.worldTransform.toArray(true);\n\n    this.start();\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.end = function()\n{\n    this.flush();\n};\n\n\nPIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch)\n{\n\n    var children = spriteBatch.children;\n    var sprite = children[0];\n\n    // if the uvs have not updated then no point rendering just yet!\n    \n    // check texture.\n    if(!sprite.texture._uvs)return;\n   \n    this.currentBaseTexture = sprite.texture.baseTexture;\n    // check blend mode\n    if(sprite.blendMode !== this.currentBlendMode)\n    {\n        this.setBlendMode(sprite.blendMode);\n    }\n    \n    for(var i=0,j= children.length; i<j; i++)\n    {\n        this.renderSprite(children[i]);\n    }\n\n    this.flush();\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite)\n{\n    //sprite = children[i];\n    if(!sprite.visible)return;\n    \n    // TODO trim??\n    if(sprite.texture.baseTexture !== this.currentBaseTexture)\n    {\n        this.flush();\n        this.currentBaseTexture = sprite.texture.baseTexture;\n        \n        if(!sprite.texture._uvs)return;\n    }\n\n    var uvs, verticies = this.vertices, width, height, w0, w1, h0, h1, index;\n\n    uvs = sprite.texture._uvs;\n\n\n    width = sprite.texture.frame.width;\n    height = sprite.texture.frame.height;\n\n    if (sprite.texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = sprite.texture.trim;\n\n        w1 = trim.x - sprite.anchor.x * trim.width;\n        w0 = w1 + sprite.texture.frame.width;\n\n        h1 = trim.y - sprite.anchor.y * trim.height;\n        h0 = h1 + sprite.texture.frame.height;\n    }\n    else\n    {\n        w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x);\n        w1 = (sprite.texture.frame.width ) * -sprite.anchor.x;\n\n        h0 = sprite.texture.frame.height * (1-sprite.anchor.y);\n        h1 = sprite.texture.frame.height * -sprite.anchor.y;\n    }\n\n    index = this.currentBatchSize * 4 * this.vertSize;\n\n    // xy\n    verticies[index++] = w1;\n    verticies[index++] = h1;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n    //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x0;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = sprite.alpha;\n \n\n    // xy\n    verticies[index++] = w0;\n    verticies[index++] = h1;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x1;\n    verticies[index++] = uvs.y1;\n    // color\n    verticies[index++] = sprite.alpha;\n  \n\n    // xy\n    verticies[index++] = w0;\n    verticies[index++] = h0;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x2;\n    verticies[index++] = uvs.y2;\n    // color\n    verticies[index++] = sprite.alpha;\n \n\n\n\n    // xy\n    verticies[index++] = w1;\n    verticies[index++] = h0;\n\n    verticies[index++] = sprite.position.x;\n    verticies[index++] = sprite.position.y;\n\n    //scale\n    verticies[index++] = sprite.scale.x;\n    verticies[index++] = sprite.scale.y;\n\n     //rotation\n    verticies[index++] = sprite.rotation;\n\n    // uv\n    verticies[index++] = uvs.x3;\n    verticies[index++] = uvs.y3;\n    // color\n    verticies[index++] = sprite.alpha;\n\n    // increment the batchs\n    this.currentBatchSize++;\n\n    if(this.currentBatchSize >= this.size)\n    {\n        this.flush();\n    }\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.flush = function()\n{\n\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize===0)return;\n\n    var gl = this.gl;\n    \n    // bind the current texture\n\n    if(!this.currentBaseTexture._glTextures[gl.id])PIXI.createWebGLTexture(this.currentBaseTexture, gl);\n\n    gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);// || PIXI.createWebGLTexture(this.currentBaseTexture, gl));\n\n    // upload the verts to the buffer\n\n   \n    if(this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n    \n    \n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);\n   \n    // then reset the batch!\n    this.currentBatchSize = 0;\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n\nPIXI.WebGLFastSpriteBatch.prototype.stop = function()\n{\n    this.flush();\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.start = function()\n{\n    var gl = this.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // set the projection\n    var projection = this.renderSession.projection;\n    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);\n\n    // set the matrix\n    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);\n\n    // set the pointers\n    var stride =  this.vertSize * 4;\n\n    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);\n    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);\n    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);\n    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);\n\n    // set the blend mode..\n    if(this.currentBlendMode !== PIXI.blendModes.NORMAL)\n    {\n        this.setBlendMode(PIXI.blendModes.NORMAL);\n    }\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.setBlendMode = function(blendMode)\n{\n    this.flush();\n\n    this.currentBlendMode = blendMode;\n    \n    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];\n    this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n};\n\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class WebGLFilterManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param transparent {Boolean} Whether or not the drawing context should be transparent\n* @private\n*/\nPIXI.WebGLFilterManager = function(gl, transparent)\n{\n    this.transparent = transparent;\n\n    this.filterStack = [];\n    \n    this.offsetX = 0;\n    this.offsetY = 0;\n\n    this.setContext(gl);\n};\n\n// API\n/**\n* Initialises the context and the properties\n* @method setContext \n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLFilterManager.prototype.setContext = function(gl)\n{\n    this.gl = gl;\n    this.texturePool = [];\n\n    this.initShaderBuffers();\n};\n\n/**\n* \n* @method begin\n* @param renderSession {RenderSession} \n* @param buffer {ArrayBuffer} \n*/\nPIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer)\n{\n    this.renderSession = renderSession;\n    this.defaultShader = renderSession.shaderManager.defaultShader;\n\n    var projection = this.renderSession.projection;\n   // console.log(this.width)\n    this.width = projection.x * 2;\n    this.height = -projection.y * 2;\n    this.buffer = buffer;\n};\n\n/**\n* Applies the filter and adds it to the current filter stack\n* @method pushFilter\n* @param filterBlock {Object} the filter that will be pushed to the current filter stack\n*/\nPIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock)\n{\n    var gl = this.gl;\n\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();\n\n\n    // filter program\n    // OPTIMISATION - the first filter is free if its a simple color change?\n    this.filterStack.push(filterBlock);\n\n    var filter = filterBlock.filterPasses[0];\n\n    this.offsetX += filterBlock._filterArea.x;\n    this.offsetY += filterBlock._filterArea.y;\n\n    var texture = this.texturePool.pop();\n    if(!texture)\n    {\n        texture = new PIXI.FilterTexture(this.gl, this.width, this.height);\n    }\n    else\n    {\n        texture.resize(this.width, this.height);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D,  texture.texture);\n\n    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;\n\n    var padding = filter.padding;\n    filterArea.x -= padding;\n    filterArea.y -= padding;\n    filterArea.width += padding * 2;\n    filterArea.height += padding * 2;\n\n    // cap filter to screen size..\n    if(filterArea.x < 0)filterArea.x = 0;\n    if(filterArea.width > this.width)filterArea.width = this.width;\n    if(filterArea.y < 0)filterArea.y = 0;\n    if(filterArea.height > this.height)filterArea.height = this.height;\n\n    //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);\n\n    // set view port\n    gl.viewport(0, 0, filterArea.width, filterArea.height);\n\n    projection.x = filterArea.width/2;\n    projection.y = -filterArea.height/2;\n\n    offset.x = -filterArea.x;\n    offset.y = -filterArea.y;\n\n    // update projection\n    gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);\n    gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);\n\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    filterBlock._glFilterTexture = texture;\n\n};\n\n\n/**\n* Removes the last filter from the filter stack and doesn't return it\n* @method popFilter\n*/\nPIXI.WebGLFilterManager.prototype.popFilter = function()\n{\n    var gl = this.gl;\n    var filterBlock = this.filterStack.pop();\n    var filterArea = filterBlock._filterArea;\n    var texture = filterBlock._glFilterTexture;\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    if(filterBlock.filterPasses.length > 1)\n    {\n        gl.viewport(0, 0, filterArea.width, filterArea.height);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n        this.vertexArray[0] = 0;\n        this.vertexArray[1] = filterArea.height;\n\n        this.vertexArray[2] = filterArea.width;\n        this.vertexArray[3] = filterArea.height;\n\n        this.vertexArray[4] = 0;\n        this.vertexArray[5] = 0;\n\n        this.vertexArray[6] = filterArea.width;\n        this.vertexArray[7] = 0;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n        // now set the uvs..\n        this.uvArray[2] = filterArea.width/this.width;\n        this.uvArray[5] = filterArea.height/this.height;\n        this.uvArray[6] = filterArea.width/this.width;\n        this.uvArray[7] = filterArea.height/this.height;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n        var inputTexture = texture;\n        var outputTexture = this.texturePool.pop();\n        if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width, this.height);\n        outputTexture.resize(this.width, this.height);\n\n        // need to clear this FBO as it may have some left over elements from a previous filter.\n        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.disable(gl.BLEND);\n\n        for (var i = 0; i < filterBlock.filterPasses.length-1; i++)\n        {\n            var filterPass = filterBlock.filterPasses[i];\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer );\n\n            // set texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n\n            // draw texture..\n            //filterPass.applyFilterPass(filterArea.width, filterArea.height);\n            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);\n\n            // swap the textures..\n            var temp = inputTexture;\n            inputTexture = outputTexture;\n            outputTexture = temp;\n        }\n\n        gl.enable(gl.BLEND);\n\n        texture = inputTexture;\n        this.texturePool.push(outputTexture);\n    }\n\n    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1];\n\n    this.offsetX -= filterArea.x;\n    this.offsetY -= filterArea.y;\n\n\n    var sizeX = this.width;\n    var sizeY = this.height;\n\n    var offsetX = 0;\n    var offsetY = 0;\n\n    var buffer = this.buffer;\n\n    // time to render the filters texture to the previous scene\n    if(this.filterStack.length === 0)\n    {\n        gl.colorMask(true, true, true, true);//this.transparent);\n    }\n    else\n    {\n        var currentFilter = this.filterStack[this.filterStack.length-1];\n        filterArea = currentFilter._filterArea;\n\n        sizeX = filterArea.width;\n        sizeY = filterArea.height;\n\n        offsetX = filterArea.x;\n        offsetY = filterArea.y;\n\n        buffer =  currentFilter._glFilterTexture.frameBuffer;\n    }\n\n\n\n    // TODO need toremove thease global elements..\n    projection.x = sizeX/2;\n    projection.y = -sizeY/2;\n\n    offset.x = offsetX;\n    offset.y = offsetY;\n\n    filterArea = filterBlock._filterArea;\n\n    var x = filterArea.x-offsetX;\n    var y = filterArea.y-offsetY;\n\n    // update the buffers..\n    // make sure to flip the y!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    this.vertexArray[0] = x;\n    this.vertexArray[1] = y + filterArea.height;\n\n    this.vertexArray[2] = x + filterArea.width;\n    this.vertexArray[3] = y + filterArea.height;\n\n    this.vertexArray[4] = x;\n    this.vertexArray[5] = y;\n\n    this.vertexArray[6] = x + filterArea.width;\n    this.vertexArray[7] = y;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n    this.uvArray[2] = filterArea.width/this.width;\n    this.uvArray[5] = filterArea.height/this.height;\n    this.uvArray[6] = filterArea.width/this.width;\n    this.uvArray[7] = filterArea.height/this.height;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n   //console.log(this.vertexArray)\n   //console.log(this.uvArray)\n    //console.log(sizeX + \" : \" + sizeY)\n\n    gl.viewport(0, 0, sizeX, sizeY);\n\n    // bind the buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer );\n\n    // set the blend mode! \n    //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n\n    // set texture\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture.texture);\n\n    // apply!\n    this.applyFilterPass(filter, filterArea, sizeX, sizeY);\n\n    // now restore the regular shader..\n    gl.useProgram(this.defaultShader.program);\n    gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);\n    gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);\n\n    // return the texture to the pool\n    this.texturePool.push(texture);\n    filterBlock._glFilterTexture = null;\n};\n\n\n/**\n* Applies the filter to the specified area\n* @method applyFilterPass\n* @param filter {AbstractFilter} the filter that needs to be applied\n* @param filterArea {texture} TODO - might need an update\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n*/\nPIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height)\n{\n    // use program\n    var gl = this.gl;\n    var shader = filter.shaders[gl.id];\n\n    if(!shader)\n    {\n        shader = new PIXI.PixiShader(gl);\n\n        shader.fragmentSrc = filter.fragmentSrc;\n        shader.uniforms = filter.uniforms;\n        shader.init();\n\n        filter.shaders[gl.id] = shader;\n    }\n\n    // set the shader\n    gl.useProgram(shader.program);\n\n    gl.uniform2f(shader.projectionVector, width/2, -height/2);\n    gl.uniform2f(shader.offsetVector, 0,0);\n\n    if(filter.uniforms.dimensions)\n    {\n        filter.uniforms.dimensions.value[0] = this.width;//width;\n        filter.uniforms.dimensions.value[1] = this.height;//height;\n        filter.uniforms.dimensions.value[2] = this.vertexArray[0];\n        filter.uniforms.dimensions.value[3] = this.vertexArray[5];//filterArea.height;\n    }\n\n  //  console.log(this.uvArray )\n    shader.syncUniforms();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // draw the filter...\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n\n    this.renderSession.drawCount++;\n};\n\n/**\n* Initialises the shader buffers\n* @method initShaderBuffers\n*/\nPIXI.WebGLFilterManager.prototype.initShaderBuffers = function()\n{\n    var gl = this.gl;\n\n    // create some buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.uvBuffer = gl.createBuffer();\n    this.colorBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n\n    // bind and upload the vertexs..\n    // keep a reference to the vertexFloatData..\n    this.vertexArray = new Float32Array([0.0, 0.0,\n                                         1.0, 0.0,\n                                         0.0, 1.0,\n                                         1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(\n    gl.ARRAY_BUFFER,\n    this.vertexArray,\n    gl.STATIC_DRAW);\n\n\n    // bind and upload the uv buffer\n    this.uvArray = new Float32Array([0.0, 0.0,\n                                     1.0, 0.0,\n                                     0.0, 1.0,\n                                     1.0, 1.0]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.bufferData(\n    gl.ARRAY_BUFFER,\n    this.uvArray,\n    gl.STATIC_DRAW);\n\n    this.colorArray = new Float32Array([1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF,\n                                        1.0, 0xFFFFFF]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.bufferData(\n    gl.ARRAY_BUFFER,\n    this.colorArray,\n    gl.STATIC_DRAW);\n\n    // bind and upload the index\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(\n    gl.ELEMENT_ARRAY_BUFFER,\n    new Uint16Array([0, 1, 2, 1, 3, 2]),\n    gl.STATIC_DRAW);\n};\n\n/**\n* Destroys the filter and removes it from the filter stack\n* @method destroy\n*/\nPIXI.WebGLFilterManager.prototype.destroy = function()\n{\n    var gl = this.gl;\n\n    this.filterStack = null;\n    \n    this.offsetX = 0;\n    this.offsetY = 0;\n\n    // destroy textures\n    for (var i = 0; i < this.texturePool.length; i++) {\n        this.texturePool.destroy();\n    }\n    \n    this.texturePool = null;\n\n    //destroy buffers..\n    gl.deleteBuffer(this.vertexBuffer);\n    gl.deleteBuffer(this.uvBuffer);\n    gl.deleteBuffer(this.colorBuffer);\n    gl.deleteBuffer(this.indexBuffer);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class FilterTexture\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n* @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n* @private\n*/\nPIXI.FilterTexture = function(gl, width, height, scaleMode)\n{\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    // next time to create a frame buffer and texture\n    this.frameBuffer = gl.createFramebuffer();\n    this.texture = gl.createTexture();\n\n    scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer );\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer );\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);\n\n    // required for masking a mask??\n    this.renderBuffer = gl.createRenderbuffer();\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);\n  \n    this.resize(width, height);\n};\n\n\n/**\n* Clears the filter texture\n* @method clear\n*/\nPIXI.FilterTexture.prototype.clear = function()\n{\n    var gl = this.gl;\n    \n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n};\n\n/**\n * Resizes the texture to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the texture\n * @param height {Number} the new height of the texture\n */\nPIXI.FilterTexture.prototype.resize = function(width, height)\n{\n    if(this.width === width && this.height === height) return;\n\n    this.width = width;\n    this.height = height;\n\n    var gl = this.gl;\n\n    gl.bindTexture(gl.TEXTURE_2D,  this.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n    // update the stencil buffer width and height\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n};\n\n/**\n* Destroys the filter texture\n* @method destroy\n*/\nPIXI.FilterTexture.prototype.destroy = function()\n{\n    var gl = this.gl;\n    gl.deleteFramebuffer( this.frameBuffer );\n    gl.deleteTexture( this.texture );\n\n    this.frameBuffer = null;\n    this.texture = null;\n};\n\n/**\n * @author Mat Groves\n * \n * \n */\n/**\n * A set of functions used to handle masking\n *\n * @class CanvasMaskManager\n */\nPIXI.CanvasMaskManager = function()\n{\n    \n};\n\n/**\n * This method adds it to the current stack of masks\n *\n * @method pushMask\n * @param maskData the maskData that will be pushed\n * @param context {Context2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasMaskManager.prototype.pushMask = function(maskData, context)\n{\n    context.save();\n    \n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.worldTransform;\n\n    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n\n    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);\n\n    context.clip();\n\n    maskData.worldAlpha = cacheAlpha;\n};\n\n/**\n * Restores the current drawing context to the state it was before the mask was applied\n *\n * @method popMask\n * @param context {Context2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasMaskManager.prototype.popMask = function(context)\n{\n    context.restore();\n};\n\n/**\n * @author Mat Groves\n * \n * \n */\n\n/**\n * @class CanvasTinter\n * @constructor\n * @static\n */\nPIXI.CanvasTinter = function()\n{\n    /// this.textureCach\n};\n\n//PIXI.CanvasTinter.cachTint = true;\n    \n\n/**\n * Basically this method just needs a sprite and a color and tints the sprite \n * with the given color\n * \n * @method getTintedTexture \n * @param sprite {Sprite} the sprite to tint\n * @param color {Number} the color to use to tint the sprite with\n */\nPIXI.CanvasTinter.getTintedTexture = function(sprite, color)\n{\n\n    var texture = sprite.texture;\n\n    color = PIXI.CanvasTinter.roundColor(color);\n\n    var stringColor = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n   \n    texture.tintCache = texture.tintCache || {};\n\n    if(texture.tintCache[stringColor]) return texture.tintCache[stringColor];\n\n     // clone texture..\n    var canvas = PIXI.CanvasTinter.canvas || document.createElement(\"canvas\");\n    \n    //PIXI.CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n\n    \n    PIXI.CanvasTinter.tintMethod(texture, color, canvas);\n\n    if(PIXI.CanvasTinter.convertTintToImage)\n    {\n        // is this better?\n        var tintImage = new Image();\n        tintImage.src = canvas.toDataURL();\n\n        texture.tintCache[stringColor] = tintImage;\n    }\n    else\n    {\n      \n        texture.tintCache[stringColor] = canvas;\n        // if we are not converting the texture to an image then we need to lose the reference to the canvas\n        PIXI.CanvasTinter.canvas = null;\n\n    }\n\n    return canvas;\n};\n\n/**\n * Tint a texture using the \"multiply\" operation\n * @method tintWithMultiply\n * @param texture {texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var frame = texture.frame;\n\n    canvas.width = frame.width;\n    canvas.height = frame.height;\n\n    context.fillStyle = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n    \n    context.fillRect(0, 0, frame.width, frame.height);\n    \n    context.globalCompositeOperation = \"multiply\";\n\n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n\n    context.globalCompositeOperation = \"destination-atop\";\n    \n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n};\n\n/**\n * Tint a texture using the \"overlay\" operation\n * @method tintWithOverlay\n * @param texture {texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithOverlay = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var frame = texture.frame;\n\n    canvas.width = frame.width;\n    canvas.height = frame.height;\n\n    \n    \n    context.globalCompositeOperation = \"copy\";\n    context.fillStyle = \"#\" + (\"00000\" + ( color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, frame.width, frame.height);\n\n    context.globalCompositeOperation = \"destination-atop\";\n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n\n    \n    //context.globalCompositeOperation = \"copy\";\n\n};\n\n/**\n * Tint a texture pixel per pixel\n * @method tintPerPixel\n * @param texture {texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas)\n{\n    var context = canvas.getContext( \"2d\" );\n\n    var frame = texture.frame;\n\n    canvas.width = frame.width;\n    canvas.height = frame.height;\n  \n    context.globalCompositeOperation = \"copy\";\n    context.drawImage(texture.baseTexture.source,\n                           frame.x,\n                           frame.y,\n                           frame.width,\n                           frame.height,\n                           0,\n                           0,\n                           frame.width,\n                           frame.height);\n\n    var rgbValues = PIXI.hex2rgb(color);\n    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];\n\n    var pixelData = context.getImageData(0, 0, frame.width, frame.height);\n\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4)\n    {\n        pixels[i+0] *= r;\n        pixels[i+1] *= g;\n        pixels[i+2] *= b;\n    }\n\n    context.putImageData(pixelData, 0, 0);\n};\n\n/**\n * Rounds the specified color according to the PIXI.CanvasTinter.cacheStepsPerColorChannel\n * @method roundColor\n * @param color {number} the color to round, should be a hex color\n */\nPIXI.CanvasTinter.roundColor = function(color)\n{\n    var step = PIXI.CanvasTinter.cacheStepsPerColorChannel;\n\n    var rgbValues = PIXI.hex2rgb(color);\n\n    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n    return PIXI.rgb2hex(rgbValues);\n};\n\n/**\n * \n * Number of steps which will be used as a cap when rounding colors\n *\n * @property cacheStepsPerColorChannel\n * @type Number\n */\nPIXI.CanvasTinter.cacheStepsPerColorChannel = 8;\n/**\n * \n * Number of steps which will be used as a cap when rounding colors\n *\n * @property convertTintToImage\n * @type Boolean\n */\nPIXI.CanvasTinter.convertTintToImage = false;\n\n/**\n * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method\n *\n * @property canUseMultiply\n * @type Boolean\n */\nPIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes();\n\nPIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel;\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * the CanvasRenderer draws the stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Dont forget to add the view to your DOM or you will not see anything :)\n *\n * @class CanvasRenderer\n * @constructor\n * @param width=800 {Number} the width of the canvas view\n * @param height=600 {Number} the height of the canvas view\n * @param [view] {HTMLCanvasElement} the canvas to use as a view, optional\n * @param [transparent=false] {Boolean} the transparency of the render view, default false\n */\nPIXI.CanvasRenderer = function(width, height, view, transparent)\n{\n    PIXI.defaultRenderer = PIXI.defaultRenderer || this;\n\n    this.type = PIXI.CANVAS_RENDERER;\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.\n     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.\n     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = true;\n\n    /**\n     * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n     * Handy for crisp pixel art and speed on legacy devices.\n     *\n     * @property roundPixels\n     * @type Boolean\n     * @default\n     */\n    this.roundPixels = false;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = !!transparent;\n\n    if(!PIXI.blendModesCanvas)\n    {\n        PIXI.blendModesCanvas = [];\n        \n        if(PIXI.canUseNewCanvasBlendModes())\n        {\n            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = \"lighter\"; //IS THIS OK???\n            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = \"multiply\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = \"screen\";\n            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = \"overlay\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = \"darken\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = \"lighten\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = \"color-dodge\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = \"color-burn\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = \"hard-light\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = \"soft-light\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = \"difference\";\n            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = \"exclusion\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = \"hue\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = \"saturation\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = \"color\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = \"luminosity\";\n        }\n        else\n        {\n            // this means that the browser does not support the cool new blend modes in canvas \"cough\" ie \"cough\"\n            PIXI.blendModesCanvas[PIXI.blendModes.NORMAL]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.ADD]      = \"lighter\"; //IS THIS OK???\n            PIXI.blendModesCanvas[PIXI.blendModes.MULTIPLY] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SCREEN]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.OVERLAY]  = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DARKEN]   = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LIGHTEN]  = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_DODGE] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR_BURN] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HARD_LIGHT] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SOFT_LIGHT] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.DIFFERENCE] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.EXCLUSION] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.HUE]       = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.SATURATION] = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.COLOR]      = \"source-over\";\n            PIXI.blendModesCanvas[PIXI.blendModes.LUMINOSITY] = \"source-over\";\n        }\n    }\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = width || 800;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = height || 600;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = view || document.createElement( \"canvas\" );\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type HTMLCanvasElement 2d Context\n     */\n    this.context = this.view.getContext( \"2d\", { alpha: this.transparent } );\n\n    this.refresh = true;\n    // hack to enable some hardware acceleration!\n    //this.view.style[\"transform\"] = \"translatez(0)\";\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n    this.count = 0;\n\n    /**\n     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer\n     * @property CanvasMaskManager\n     * @type CanvasMaskManager\n     */\n    this.maskManager = new PIXI.CanvasMaskManager();\n\n    /**\n     * The render session is just a bunch of parameter used for rendering\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {\n        context: this.context,\n        maskManager: this.maskManager,\n        scaleMode: null,\n        smoothProperty: null\n    };\n\n    if(\"imageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"imageSmoothingEnabled\";\n    else if(\"webkitImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"webkitImageSmoothingEnabled\";\n    else if(\"mozImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"mozImageSmoothingEnabled\";\n    else if(\"oImageSmoothingEnabled\" in this.context)\n        this.renderSession.smoothProperty = \"oImageSmoothingEnabled\";\n};\n\n// constructor\nPIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;\n\n/**\n * Renders the stage to its canvas view\n *\n * @method render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.CanvasRenderer.prototype.render = function(stage)\n{\n    // update textures if need be\n    PIXI.texturesToUpdate.length = 0;\n    PIXI.texturesToDestroy.length = 0;\n\n    stage.updateTransform();\n\n    this.context.setTransform(1,0,0,1,0,0);\n    this.context.globalAlpha = 1;\n\n    if (!this.transparent && this.clearBeforeRender)\n    {\n        this.context.fillStyle = stage.backgroundColorString;\n        this.context.fillRect(0, 0, this.width, this.height);\n    }\n    else if (this.transparent && this.clearBeforeRender)\n    {\n        this.context.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.renderDisplayObject(stage);\n\n    // run interaction!\n    if(stage.interactive)\n    {\n        //need to add some events!\n        if(!stage._interactiveEventsAdded)\n        {\n            stage._interactiveEventsAdded = true;\n            stage.interactionManager.setTarget(this);\n        }\n    }\n\n    // remove frame updates..\n    if(PIXI.Texture.frameUpdates.length > 0)\n    {\n        PIXI.Texture.frameUpdates.length = 0;\n    }\n};\n\n/**\n * Resizes the canvas view to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the canvas view\n * @param height {Number} the new height of the canvas view\n */\nPIXI.CanvasRenderer.prototype.resize = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.view.width = width;\n    this.view.height = height;\n};\n\n/**\n * Renders a display object\n *\n * @method renderDisplayObject\n * @param displayObject {DisplayObject} The displayObject to render\n * @param context {Context2D} the context 2d method of the canvas\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderDisplayObject = function(displayObject, context)\n{\n    // no longer recursive!\n    //var transform;\n    //var context = this.context;\n\n    this.renderSession.context = context || this.context;\n    displayObject._renderCanvas(this.renderSession);\n};\n\n/**\n * Renders a flat strip\n *\n * @method renderStripFlat\n * @param strip {Strip} The Strip to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderStripFlat = function(strip)\n{\n    var context = this.context;\n    var verticies = strip.verticies;\n\n    var length = verticies.length/2;\n    this.count++;\n\n    context.beginPath();\n    for (var i=1; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n    }\n\n    context.fillStyle = \"#FF0000\";\n    context.fill();\n    context.closePath();\n};\n\n/**\n * Renders a strip\n *\n * @method renderStrip\n * @param strip {Strip} The Strip to render\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderStrip = function(strip)\n{\n    var context = this.context;\n\n    // draw triangles!!\n    var verticies = strip.verticies;\n    var uvs = strip.uvs;\n\n    var length = verticies.length/2;\n    this.count++;\n\n    for (var i = 1; i < length-2; i++)\n    {\n        // draw some triangles!\n        var index = i*2;\n\n        var x0 = verticies[index],   x1 = verticies[index+2], x2 = verticies[index+4];\n        var y0 = verticies[index+1], y1 = verticies[index+3], y2 = verticies[index+5];\n\n        var u0 = uvs[index] * strip.texture.width,   u1 = uvs[index+2] * strip.texture.width, u2 = uvs[index+4]* strip.texture.width;\n        var v0 = uvs[index+1]* strip.texture.height, v1 = uvs[index+3] * strip.texture.height, v2 = uvs[index+5]* strip.texture.height;\n\n        context.save();\n        context.beginPath();\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n        context.closePath();\n\n        context.clip();\n\n        // Compute matrix transform\n        var delta = u0*v1 + v0*u2 + u1*v2 - v1*u2 - v0*u1 - u0*v2;\n        var deltaA = x0*v1 + v0*x2 + x1*v2 - v1*x2 - v0*x1 - x0*v2;\n        var deltaB = u0*x1 + x0*u2 + u1*x2 - x1*u2 - x0*u1 - u0*x2;\n        var deltaC = u0*v1*x2 + v0*x1*u2 + x0*u1*v2 - x0*v1*u2 - v0*u1*x2 - u0*x1*v2;\n        var deltaD = y0*v1 + v0*y2 + y1*v2 - v1*y2 - v0*y1 - y0*v2;\n        var deltaE = u0*y1 + y0*u2 + u1*y2 - y1*u2 - y0*u1 - u0*y2;\n        var deltaF = u0*v1*y2 + v0*y1*u2 + y0*u1*v2 - y0*v1*u2 - v0*u1*y2 - u0*y1*v2;\n\n        context.transform(deltaA / delta, deltaD / delta,\n                            deltaB / delta, deltaE / delta,\n                            deltaC / delta, deltaF / delta);\n\n        context.drawImage(strip.texture.baseTexture.source, 0, 0);\n        context.restore();\n    }\n};\n\n/**\n * Creates a Canvas element of the given size\n *\n * @method CanvasBuffer\n * @param width {Number} the width for the newly created canvas\n * @param height {Number} the height for the newly created canvas\n * @static\n * @private\n */\nPIXI.CanvasBuffer = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.canvas = document.createElement( \"canvas\" );\n    this.context = this.canvas.getContext( \"2d\" );\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n};\n\n/**\n * Clears the canvas that was created by the CanvasBuffer class\n *\n * @method clear\n * @private\n */\nPIXI.CanvasBuffer.prototype.clear = function()\n{\n    this.context.clearRect(0,0, this.width, this.height);\n};\n\n/**\n * Resizes the canvas that was created by the CanvasBuffer class to the specified width and height\n *\n * @method resize\n * @param width {Number} the new width of the canvas\n * @param height {Number} the new height of the canvas\n * @private\n */\n\nPIXI.CanvasBuffer.prototype.resize = function(width, height)\n{\n    this.width = this.canvas.width = width;\n    this.height = this.canvas.height = height;\n};\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * A set of functions used by the canvas renderer to draw the primitive graphics data\n *\n * @class CanvasGraphics\n */\nPIXI.CanvasGraphics = function()\n{\n\n};\n\n\n/*\n * Renders the graphics object\n *\n * @static\n * @private\n * @method renderGraphics\n * @param graphics {Graphics} the actual graphics object to render\n * @param context {Context2D} the 2d drawing method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphics = function(graphics, context)\n{\n    var worldAlpha = graphics.worldAlpha;\n    var color = '';\n\n    for (var i = 0; i < graphics.graphicsData.length; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var points = data.points;\n\n        context.strokeStyle = color = '#' + ('00000' + ( data.lineColor | 0).toString(16)).substr(-6);\n\n        context.lineWidth = data.lineWidth;\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            context.beginPath();\n\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n\n            if(data.fillColor || data.fillColor === 0)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fillRect(points[0], points[1], points[2], points[3]);\n\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.strokeRect(points[0], points[1], points[2], points[3]);\n            }\n\n        }\n        else if(data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(points[0], points[1], points[2],0,2*Math.PI);\n            context.closePath();\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n        else if(data.type === PIXI.Graphics.ELIP)\n        {\n\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n            var ellipseData =  data.points;\n\n            var w = ellipseData[2] * 2;\n            var h = ellipseData[3] * 2;\n\n            var x = ellipseData[0] - w/2;\n            var y = ellipseData[1] - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n\n            context.closePath();\n\n            if(data.fill)\n            {\n                context.globalAlpha = data.fillAlpha * worldAlpha;\n                context.fillStyle = color = '#' + ('00000' + ( data.fillColor | 0).toString(16)).substr(-6);\n                context.fill();\n            }\n            if(data.lineWidth)\n            {\n                context.globalAlpha = data.lineAlpha * worldAlpha;\n                context.stroke();\n            }\n        }\n    }\n};\n\n/*\n * Renders a graphics mask\n *\n * @static\n * @private\n * @method renderGraphicsMask\n * @param graphics {Graphics} the graphics which will be used as a mask\n * @param context {Context2D} the context 2d method of the canvas\n */\nPIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context)\n{\n    var len = graphics.graphicsData.length;\n\n    if(len === 0) return;\n\n    if(len > 1)\n    {\n        len = 1;\n        window.console.log('Pixi.js warning: masks in canvas can only mask using the first path in the graphics object');\n    }\n\n    for (var i = 0; i < 1; i++)\n    {\n        var data = graphics.graphicsData[i];\n        var points = data.points;\n\n        if(data.type === PIXI.Graphics.POLY)\n        {\n            context.beginPath();\n            context.moveTo(points[0], points[1]);\n\n            for (var j=1; j < points.length/2; j++)\n            {\n                context.lineTo(points[j * 2], points[j * 2 + 1]);\n            }\n\n            // if the first and last point are the same close the path - much neater :)\n            if(points[0] === points[points.length-2] && points[1] === points[points.length-1])\n            {\n                context.closePath();\n            }\n\n        }\n        else if(data.type === PIXI.Graphics.RECT)\n        {\n            context.beginPath();\n            context.rect(points[0], points[1], points[2], points[3]);\n            context.closePath();\n        }\n        else if(data.type === PIXI.Graphics.CIRC)\n        {\n            // TODO - need to be Undefined!\n            context.beginPath();\n            context.arc(points[0], points[1], points[2],0,2*Math.PI);\n            context.closePath();\n        }\n        else if(data.type === PIXI.Graphics.ELIP)\n        {\n\n            // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n            var ellipseData =  data.points;\n\n            var w = ellipseData[2] * 2;\n            var h = ellipseData[3] * 2;\n\n            var x = ellipseData[0] - w/2;\n            var y = ellipseData[1] - h/2;\n\n            context.beginPath();\n\n            var kappa = 0.5522848,\n                ox = (w / 2) * kappa, // control point offset horizontal\n                oy = (h / 2) * kappa, // control point offset vertical\n                xe = x + w,           // x-end\n                ye = y + h,           // y-end\n                xm = x + w / 2,       // x-middle\n                ym = y + h / 2;       // y-middle\n\n            context.moveTo(x, ym);\n            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n            context.closePath();\n        }\n    }\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n\n/**\n * The Graphics class contains a set of methods that you can use to create primitive shapes and lines.\n * It is important to know that with the webGL renderer only simple polygons can be filled at this stage\n * Complex polygons will not be filled. Heres an example of a complex polygon: http://www.goodboydigital.com/wp-content/uploads/2013/06/complexPolygon.png\n *\n * @class Graphics\n * @extends DisplayObjectContainer\n * @constructor\n */\nPIXI.Graphics = function()\n{\n    PIXI.DisplayObjectContainer.call( this );\n\n    this.renderable = true;\n\n    /**\n     * The alpha of the fill of this graphics object\n     *\n     * @property fillAlpha\n     * @type Number\n     */\n    this.fillAlpha = 1;\n\n    /**\n     * The width of any lines drawn\n     *\n     * @property lineWidth\n     * @type Number\n     */\n    this.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn\n     *\n     * @property lineColor\n     * @type String\n     */\n    this.lineColor = \"black\";\n\n    /**\n     * Graphics data\n     *\n     * @property graphicsData\n     * @type Array\n     * @private\n     */\n    this.graphicsData = [];\n\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;// * Math.random();\n    \n    /**\n     * The blend mode to be applied to the graphic shape\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n    \n    /**\n     * Current path\n     *\n     * @property currentPath\n     * @type Object\n     * @private\n     */\n    this.currentPath = {points:[]};\n\n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer\n     *\n     * @property _webGL\n     * @type Array\n     * @private\n     */\n    this._webGL = [];\n\n    /**\n     * Whether this shape is being used as a mask\n     *\n     * @property isMask\n     * @type isMask\n     */\n    this.isMask = false;\n\n    /**\n     * The bounds of the graphic shape as rectangle object\n     *\n     * @property bounds\n     * @type Rectangle\n     */\n    this.bounds = null;\n\n    /**\n     * the bounds' padding used for bounds calculation\n     *\n     * @property boundsPadding\n     * @type Number\n     */\n    this.boundsPadding = 10;\n};\n\n// constructor\nPIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype );\nPIXI.Graphics.prototype.constructor = PIXI.Graphics;\n\n/**\n * If cacheAsBitmap is true the graphics object will then be rendered as if it was a sprite.\n * This is useful if your graphics element does not change often as it will speed up the rendering of the object\n * It is also usful as the graphics object will always be antialiased because it will be rendered using canvas\n * Not recommended if you are constanly redrawing the graphics element.\n *\n * @property cacheAsBitmap\n * @default false\n * @type Boolean\n * @private\n */\nObject.defineProperty(PIXI.Graphics.prototype, \"cacheAsBitmap\", {\n    get: function() {\n        return  this._cacheAsBitmap;\n    },\n    set: function(value) {\n        this._cacheAsBitmap = value;\n\n        if(this._cacheAsBitmap)\n        {\n            this._generateCachedSprite();\n        }\n        else\n        {\n            this.destroyCachedSprite();\n            this.dirty = true;\n        }\n\n    }\n});\n\n\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @method lineStyle\n * @param lineWidth {Number} width of the line to draw, will update the object's stored style\n * @param color {Number} color of the line to draw, will update the object's stored style\n * @param alpha {Number} alpha of the line to draw, will update the object's stored style\n */\nPIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha)\n{\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.lineWidth = lineWidth || 0;\n    this.lineColor = color || 0;\n    this.lineAlpha = (arguments.length < 3) ? 1 : alpha;\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};\n\n    this.graphicsData.push(this.currentPath);\n\n    return this;\n};\n\n/**\n * Moves the current drawing position to (x, y).\n *\n * @method moveTo\n * @param x {Number} the X coordinate to move to\n * @param y {Number} the Y coordinate to move to\n */\nPIXI.Graphics.prototype.moveTo = function(x, y)\n{\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling, points:[], type:PIXI.Graphics.POLY};\n\n    this.currentPath.points.push(x, y);\n\n    this.graphicsData.push(this.currentPath);\n\n    return this;\n};\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * the current drawing position is then set to (x, y).\n *\n * @method lineTo\n * @param x {Number} the X coordinate to draw to\n * @param y {Number} the Y coordinate to draw to\n */\nPIXI.Graphics.prototype.lineTo = function(x, y)\n{\n    this.currentPath.points.push(x, y);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @method beginFill\n * @param color {Number} the color of the fill\n * @param alpha {Number} the alpha of the fill\n */\nPIXI.Graphics.prototype.beginFill = function(color, alpha)\n{\n\n    this.filling = true;\n    this.fillColor = color || 0;\n    this.fillAlpha = (arguments.length < 2) ? 1 : alpha;\n\n    return this;\n};\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @method endFill\n */\nPIXI.Graphics.prototype.endFill = function()\n{\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n\n    return this;\n};\n\n/**\n * @method drawRect\n *\n * @param x {Number} The X coord of the top-left of the rectangle\n * @param y {Number} The Y coord of the top-left of the rectangle\n * @param width {Number} The width of the rectangle\n * @param height {Number} The height of the rectangle\n */\nPIXI.Graphics.prototype.drawRect = function( x, y, width, height )\n{\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,\n                        points:[x, y, width, height], type:PIXI.Graphics.RECT};\n\n    this.graphicsData.push(this.currentPath);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Draws a circle.\n *\n * @method drawCircle\n * @param x {Number} The X coordinate of the center of the circle\n * @param y {Number} The Y coordinate of the center of the circle\n * @param radius {Number} The radius of the circle\n */\nPIXI.Graphics.prototype.drawCircle = function( x, y, radius)\n{\n\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,\n                        points:[x, y, radius, radius], type:PIXI.Graphics.CIRC};\n\n    this.graphicsData.push(this.currentPath);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Draws an ellipse.\n *\n * @method drawEllipse\n * @param x {Number} The X coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param y {Number} The Y coordinate of the upper-left corner of the framing rectangle of this ellipse\n * @param width {Number} The width of the ellipse\n * @param height {Number} The height of the ellipse\n */\nPIXI.Graphics.prototype.drawEllipse = function( x, y, width, height)\n{\n\n    if (!this.currentPath.points.length) this.graphicsData.pop();\n\n    this.currentPath = {lineWidth:this.lineWidth, lineColor:this.lineColor, lineAlpha:this.lineAlpha,\n                        fillColor:this.fillColor, fillAlpha:this.fillAlpha, fill:this.filling,\n                        points:[x, y, width, height], type:PIXI.Graphics.ELIP};\n\n    this.graphicsData.push(this.currentPath);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @method clear\n */\nPIXI.Graphics.prototype.clear = function()\n{\n    this.lineWidth = 0;\n    this.filling = false;\n\n    this.dirty = true;\n    this.clearDirty = true;\n    this.graphicsData = [];\n\n    this.bounds = null; //new PIXI.Rectangle();\n\n    return this;\n};\n\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @method generateTexture\n * @return {Texture} a texture of the graphics object\n */\nPIXI.Graphics.prototype.generateTexture = function()\n{\n    var bounds = this.getBounds();\n\n    var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);\n    var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n\n    canvasBuffer.context.translate(-bounds.x,-bounds.y);\n    \n    PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n\n    return texture;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderWebGL = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;\n    \n    if(this._cacheAsBitmap)\n    {\n       \n        if(this.dirty)\n        {\n            this._generateCachedSprite();\n            // we will also need to update the texture on the gpu too!\n            PIXI.updateWebGLTexture(this._cachedSprite.texture.baseTexture, renderSession.gl);\n            \n            this.dirty =  false;\n        }\n\n        this._cachedSprite.alpha = this.alpha;\n        PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n\n        return;\n    }\n    else\n    {\n        renderSession.spriteBatch.stop();\n\n        if(this._mask)renderSession.maskManager.pushMask(this.mask, renderSession);\n        if(this._filters)renderSession.filterManager.pushFilter(this._filterBlock);\n      \n        // check blend mode\n        if(this.blendMode !== renderSession.spriteBatch.currentBlendMode)\n        {\n            renderSession.spriteBatch.currentBlendMode = this.blendMode;\n            var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode];\n            renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n        }\n     \n        PIXI.WebGLGraphics.renderGraphics(this, renderSession);\n        \n        // only render if it has children!\n        if(this.children.length)\n        {\n            renderSession.spriteBatch.start();\n\n             // simple render children!\n            for(var i=0, j=this.children.length; i<j; i++)\n            {\n                this.children[i]._renderWebGL(renderSession);\n            }\n\n            renderSession.spriteBatch.stop();\n        }\n\n        if(this._filters)renderSession.filterManager.popFilter();\n        if(this._mask)renderSession.maskManager.popMask(renderSession);\n          \n        renderSession.drawCount++;\n\n        renderSession.spriteBatch.start();\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.Graphics.prototype._renderCanvas = function(renderSession)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if(this.visible === false || this.alpha === 0 || this.isMask === true)return;\n    \n    var context = renderSession.context;\n    var transform = this.worldTransform;\n    \n    if(this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx, transform.ty);\n    PIXI.CanvasGraphics.renderGraphics(this, context);\n\n     // simple render children!\n    for(var i=0, j=this.children.length; i<j; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n};\n\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @method getBounds\n * @return {Rectangle} the rectangular bounding area\n */\nPIXI.Graphics.prototype.getBounds = function( matrix )\n{\n    if(!this.bounds)this.updateBounds();\n\n    var w0 = this.bounds.x;\n    var w1 = this.bounds.width + this.bounds.x;\n\n    var h0 = this.bounds.y;\n    var h1 = this.bounds.height + this.bounds.y;\n\n    var worldTransform = matrix || this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.c;\n    var c = worldTransform.b;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = x1;\n    var maxY = y1;\n\n    var minX = x1;\n    var minY = y1;\n\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    return bounds;\n};\n\n/**\n * Update the bounds of the object\n *\n * @method updateBounds\n */\nPIXI.Graphics.prototype.updateBounds = function()\n{\n    \n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    var points, x, y, w, h;\n\n    for (var i = 0; i < this.graphicsData.length; i++) {\n        var data = this.graphicsData[i];\n        var type = data.type;\n        var lineWidth = data.lineWidth;\n\n        points = data.points;\n\n        if(type === PIXI.Graphics.RECT)\n        {\n            x = points[0] - lineWidth/2;\n            y = points[1] - lineWidth/2;\n            w = points[2] + lineWidth;\n            h = points[3] + lineWidth;\n\n            minX = x < minX ? x : minX;\n            maxX = x + w > maxX ? x + w : maxX;\n\n            minY = y < minY ? x : minY;\n            maxY = y + h > maxY ? y + h : maxY;\n        }\n        else if(type === PIXI.Graphics.CIRC || type === PIXI.Graphics.ELIP)\n        {\n            x = points[0];\n            y = points[1];\n            w = points[2] + lineWidth/2;\n            h = points[3] + lineWidth/2;\n\n            minX = x - w < minX ? x - w : minX;\n            maxX = x + w > maxX ? x + w : maxX;\n\n            minY = y - h < minY ? y - h : minY;\n            maxY = y + h > maxY ? y + h : maxY;\n        }\n        else\n        {\n            // POLY\n            for (var j = 0; j < points.length; j+=2)\n            {\n\n                x = points[j];\n                y = points[j+1];\n                minX = x-lineWidth < minX ? x-lineWidth : minX;\n                maxX = x+lineWidth > maxX ? x+lineWidth : maxX;\n\n                minY = y-lineWidth < minY ? y-lineWidth : minY;\n                maxY = y+lineWidth > maxY ? y+lineWidth : maxY;\n            }\n        }\n    }\n\n    var padding = this.boundsPadding;\n    this.bounds = new PIXI.Rectangle(minX - padding, minY - padding, (maxX - minX) + padding * 2, (maxY - minY) + padding * 2);\n};\n\n\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @method _generateCachedSprite\n * @private\n */\nPIXI.Graphics.prototype._generateCachedSprite = function()\n{\n    var bounds = this.getLocalBounds();\n\n    if(!this._cachedSprite)\n    {\n        var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height);\n        var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n        \n        this._cachedSprite = new PIXI.Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n   // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n    \n    PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n    this._cachedSprite.alpha = this.alpha;\n\n   // this._cachedSprite.buffer.context.restore();\n};\n\nPIXI.Graphics.prototype.destroyCachedSprite = function()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};\n\n\n// SOME TYPES:\nPIXI.Graphics.POLY = 0;\nPIXI.Graphics.RECT = 1;\nPIXI.Graphics.CIRC = 2;\nPIXI.Graphics.ELIP = 3;\n\n/**\n * @author Mat Groves http://matgroves.com/\n */\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class TilingSprite\n * @extends Sprite\n * @constructor\n * @param texture {Texture} the texture of the tiling sprite\n * @param width {Number}  the width of the tiling sprite\n * @param height {Number} the height of the tiling sprite\n */\nPIXI.TilingSprite = function(texture, width, height)\n{\n    PIXI.Sprite.call( this, texture);\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width || 100;\n\n    /**\n     * The height of the tiling sprite\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height || 100;\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @property tileScale\n     * @type Point\n     */\n    this.tileScale = new PIXI.Point(1,1);\n\n    /**\n     * A point that represents the scale of the texture object\n     *\n     * @property tileScaleOffset\n     * @type Point\n     */\n    this.tileScaleOffset = new PIXI.Point(1,1);\n    \n    /**\n     * The offset position of the image that is being tiled\n     *\n     * @property tilePosition\n     * @type Point\n     */\n    this.tilePosition = new PIXI.Point(0,0);\n\n\n    /**\n     * Whether this sprite is renderable or not\n     *\n     * @property renderable\n     * @type Boolean\n     * @default true\n     */\n    this.renderable = true;\n\n    /**\n     * The tint applied to the sprite. This is a hex value\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n    \n    /**\n     * The blend mode to be applied to the sprite\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n};\n\n// constructor\nPIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype);\nPIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite;\n\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.TilingSprite.prototype, 'width', {\n    get: function() {\n        return this._width;\n    },\n    set: function(value) {\n        \n        this._width = value;\n    }\n});\n\n/**\n * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.TilingSprite.prototype, 'height', {\n    get: function() {\n        return  this._height;\n    },\n    set: function(value) {\n        this._height = value;\n    }\n});\n\n/**\n * When the texture is updated, this event will be fired to update the scale and frame\n *\n * @method onTextureUpdate\n * @param event\n * @private\n */\nPIXI.TilingSprite.prototype.onTextureUpdate = function()\n{\n    this.updateFrame = true;\n};\n\nPIXI.TilingSprite.prototype.setTexture = function(texture)\n{\n    if(this.texture === texture)return;\n\n    this.texture = texture;\n\n    this.refreshTexture = true;\n    /*\n    if(this.tilingTexture)\n    {\n        this.generateTilingTexture(true);\n    }\n*/\n\n    /*\n    // stop current texture;\n    if(this.texture.baseTexture !== texture.baseTexture)\n    {\n        this.textureChange = true;\n        this.texture = texture;\n    }\n    else\n    {\n        this.texture = texture;\n    }\n\n    this.updateFrame = true;*/\n    this.cachedTint = 0xFFFFFF;\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method _renderWebGL\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.TilingSprite.prototype._renderWebGL = function(renderSession)\n{\n\n    if(this.visible === false || this.alpha === 0)return;\n    \n    var i,j;\n\n    if(this.mask)\n    {\n        renderSession.spriteBatch.stop();\n        renderSession.maskManager.pushMask(this.mask, renderSession);\n        renderSession.spriteBatch.start();\n    }\n\n    if(this.filters)\n    {\n        renderSession.spriteBatch.flush();\n        renderSession.filterManager.pushFilter(this._filterBlock);\n    }\n\n\n    if(!this.tilingTexture || this.refreshTexture)\n    {\n        this.generateTilingTexture(true);\n        if(this.tilingTexture && this.tilingTexture.needsUpdate)\n        {\n            //TODO - tweaking\n            PIXI.updateWebGLTexture(this.tilingTexture.baseTexture, renderSession.gl);\n            this.tilingTexture.needsUpdate = false;\n           // this.tilingTexture._uvs = null;\n        }\n    }\n    else renderSession.spriteBatch.renderTilingSprite(this);\n    \n\n    // simple render children!\n    for(i=0,j=this.children.length; i<j; i++)\n    {\n        this.children[i]._renderWebGL(renderSession);\n    }\n\n    renderSession.spriteBatch.stop();\n\n    if(this.filters)renderSession.filterManager.popFilter();\n    if(this.mask)renderSession.maskManager.popMask(renderSession);\n    \n    renderSession.spriteBatch.start();\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method _renderCanvas\n* @param renderSession {RenderSession} \n* @private\n*/\nPIXI.TilingSprite.prototype._renderCanvas = function(renderSession)\n{\n    if(this.visible === false || this.alpha === 0)return;\n    \n    var context = renderSession.context;\n\n    if(this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, context);\n    }\n\n    context.globalAlpha = this.worldAlpha;\n\n    \n    var transform = this.worldTransform;\n\n    // allow for trimming\n//(this.anchor.x) * -frame.width,\n//                               (this.anchor.y) * -frame.height,\n\n         \n    context.setTransform(transform.a, transform.c, transform.b, transform.d, transform.tx , transform.ty);\n\n\n    if(!this.__tilePattern ||  this.refreshTexture)\n    {\n        this.generateTilingTexture(false);\n    \n        if(this.tilingTexture)\n        {\n            this.__tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, 'repeat');\n        }\n        else\n        {\n            return;\n        }\n    }\n\n    // check blend mode\n    if(this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    context.beginPath();\n\n    var tilePosition = this.tilePosition;\n    var tileScale = this.tileScale;\n\n    tilePosition.x %= this.tilingTexture.baseTexture.width;\n    tilePosition.y %= this.tilingTexture.baseTexture.height;\n\n    // offset\n    context.scale(tileScale.x,tileScale.y);\n    context.translate(tilePosition.x, tilePosition.y);\n\n    context.fillStyle = this.__tilePattern;\n\n    // make sure to account for the anchor point..\n    context.fillRect(-tilePosition.x + (this.anchor.x * -this._width),-tilePosition.y + (this.anchor.y * -this._height),\n                        this._width / tileScale.x, this._height / tileScale.y);\n\n    context.scale(1/tileScale.x, 1/tileScale.y);\n    context.translate(-tilePosition.x, -tilePosition.y);\n\n    context.closePath();\n\n    if(this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession.context);\n    }\n};\n\n\n/**\n* Returns the framing rectangle of the sprite as a PIXI.Rectangle object\n*\n* @method getBounds\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.TilingSprite.prototype.getBounds = function()\n{\n\n    var width = this._width;\n    var height = this._height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.c;\n    var c = worldTransform.b;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n    \n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    minX = x1 < minX ? x1 : minX;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1 < minY ? y1 : minY;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1 > maxX ? x1 : maxX;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1 > maxY ? y1 : maxY;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n* \n* @method generateTilingTexture\n* \n* @param forcePowerOfTwo {Boolean} Whether we want to force the texture to be a power of two\n*/\nPIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo)\n{\n    var texture = this.texture;\n\n    if(!texture.baseTexture.hasLoaded)return;\n\n    var baseTexture = texture.baseTexture;\n    var frame = texture.frame;\n\n    var targetWidth, targetHeight;\n\n    // check that the frame is the same size as the base texture.\n    var isFrame = frame.width !== baseTexture.width || frame.height !== baseTexture.height;\n\n    var newTextureRequired = false;\n\n    if(!forcePowerOfTwo)\n    {\n        if(isFrame)\n        {\n            targetWidth = frame.width;\n            targetHeight = frame.height;\n           \n            newTextureRequired = true;\n            \n        }\n    }\n    else\n    {\n        targetWidth = PIXI.getNextPowerOfTwo(frame.width);\n        targetHeight = PIXI.getNextPowerOfTwo(frame.height);\n        if(frame.width !== targetWidth && frame.height !== targetHeight)newTextureRequired = true;\n    }\n\n    if(newTextureRequired)\n    {\n        var canvasBuffer;\n\n        if(this.tilingTexture && this.tilingTexture.isTiling)\n        {\n            canvasBuffer = this.tilingTexture.canvasBuffer;\n            canvasBuffer.resize(targetWidth, targetHeight);\n            this.tilingTexture.baseTexture.width = targetWidth;\n            this.tilingTexture.baseTexture.height = targetHeight;\n            this.tilingTexture.needsUpdate = true;\n        }\n        else\n        {\n            canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight);\n\n            this.tilingTexture = PIXI.Texture.fromCanvas(canvasBuffer.canvas);\n            this.tilingTexture.canvasBuffer = canvasBuffer;\n            this.tilingTexture.isTiling = true;\n\n        }\n        \n        canvasBuffer.context.drawImage(texture.baseTexture.source,\n                                           frame.x,\n                                           frame.y,\n                                           frame.width,\n                                           frame.height,\n                                           0,\n                                           0,\n                                           targetWidth,\n                                           targetHeight);\n\n        this.tileScaleOffset.x = frame.width / targetWidth;\n        this.tileScaleOffset.y = frame.height / targetHeight;\n\n    }\n    else\n    {\n        //TODO - switching?\n        if(this.tilingTexture && this.tilingTexture.isTiling)\n        {\n            // destroy the tiling texture!\n            // TODO could store this somewhere?\n            this.tilingTexture.destroy(true);\n        }\n\n        this.tileScaleOffset.x = 1;\n        this.tileScaleOffset.y = 1;\n        this.tilingTexture = texture;\n    }\n    this.refreshTexture = false;\n    this.tilingTexture.baseTexture._powerOf2 = true;\n};\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.BaseTextureCache = {};\nPIXI.texturesToUpdate = [];\nPIXI.texturesToDestroy = [];\n\nPIXI.BaseTextureCacheIdGenerator = 0;\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture\n *\n * @class BaseTexture\n * @uses EventTarget\n * @constructor\n * @param source {String} the source object (image or canvas)\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n */\nPIXI.BaseTexture = function(source, scaleMode)\n{\n    PIXI.EventTarget.call( this );\n\n    /**\n     * [read-only] The width of the base texture set when the image has loaded\n     *\n     * @property width\n     * @type Number\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * [read-only] The height of the base texture set when the image has loaded\n     *\n     * @property height\n     * @type Number\n     * @readOnly\n     */\n    this.height = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     * @property scaleMode\n     * @type PIXI.scaleModes\n     * @default PIXI.scaleModes.LINEAR\n     */\n    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    /**\n     * [read-only] Describes if the base texture has loaded or not\n     *\n     * @property hasLoaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * The source that is loaded to create the texture\n     *\n     * @property source\n     * @type Image\n     */\n    this.source = source;\n\n    //TODO will be used for futer pixi 1.5...\n    this.id = PIXI.BaseTextureCacheIdGenerator++;\n\n    // used for webGL\n    this._glTextures = [];\n    \n    if(!source)return;\n\n    if((this.source.complete || this.source.getContext) && this.source.width && this.source.height)\n    {\n        this.hasLoaded = true;\n        this.width = this.source.width;\n        this.height = this.source.height;\n\n        PIXI.texturesToUpdate.push(this);\n    }\n    else\n    {\n\n        var scope = this;\n        this.source.onload = function() {\n\n            scope.hasLoaded = true;\n            scope.width = scope.source.width;\n            scope.height = scope.source.height;\n\n            // add it to somewhere...\n            PIXI.texturesToUpdate.push(scope);\n            scope.dispatchEvent( { type: 'loaded', content: scope } );\n        };\n    }\n\n    this.imageUrl = null;\n    this._powerOf2 = false;\n\n    \n\n};\n\nPIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;\n\n/**\n * Destroys this base texture\n *\n * @method destroy\n */\nPIXI.BaseTexture.prototype.destroy = function()\n{\n    if(this.imageUrl)\n    {\n        delete PIXI.BaseTextureCache[this.imageUrl];\n        this.imageUrl = null;\n        this.source.src = null;\n    }\n    this.source = null;\n    PIXI.texturesToDestroy.push(this);\n};\n\n/**\n * Changes the source image of the texture\n *\n * @method updateSourceImage\n * @param newSrc {String} the path of the image\n */\nPIXI.BaseTexture.prototype.updateSourceImage = function(newSrc)\n{\n    this.hasLoaded = false;\n    this.source.src = null;\n    this.source.src = newSrc;\n};\n\n/**\n * Helper function that returns a base texture based on an image url\n * If the image is not in the base texture cache it will be created and loaded\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @param crossorigin {Boolean} \n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n * @return BaseTexture\n */\nPIXI.BaseTexture.fromImage = function(imageUrl, crossorigin, scaleMode)\n{\n    var baseTexture = PIXI.BaseTextureCache[imageUrl];\n    \n    if(crossorigin === undefined && imageUrl.indexOf('data:') === -1) crossorigin = true;\n\n    if(!baseTexture)\n    {\n        // new Image() breaks tex loading in some versions of Chrome.\n        // See https://code.google.com/p/chromium/issues/detail?id=238071\n        var image = new Image();//document.createElement('img');\n        if (crossorigin)\n        {\n            image.crossOrigin = '';\n        }\n        image.src = imageUrl;\n        baseTexture = new PIXI.BaseTexture(image, scaleMode);\n        baseTexture.imageUrl = imageUrl;\n        PIXI.BaseTextureCache[imageUrl] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\nPIXI.BaseTexture.fromCanvas = function(canvas, scaleMode)\n{\n    if(!canvas._pixiId)\n    {\n        canvas._pixiId = 'canvas_' + PIXI.TextureCacheIdGenerator++;\n    }\n\n    var baseTexture = PIXI.BaseTextureCache[canvas._pixiId];\n\n    if(!baseTexture)\n    {\n        baseTexture = new PIXI.BaseTexture(canvas, scaleMode);\n        PIXI.BaseTextureCache[canvas._pixiId] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.TextureCache = {};\nPIXI.FrameCache = {};\n\nPIXI.TextureCacheIdGenerator = 0;\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. To do this use PIXI.Sprite. If no frame is provided then the whole image is used\n *\n * @class Texture\n * @uses EventTarget\n * @constructor\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param frame {Rectangle} The rectangle frame of the texture to show\n */\nPIXI.Texture = function(baseTexture, frame)\n{\n    PIXI.EventTarget.call( this );\n\n    if(!frame)\n    {\n        this.noFrame = true;\n        frame = new PIXI.Rectangle(0,0,1,1);\n    }\n\n    if(baseTexture instanceof PIXI.Texture)\n        baseTexture = baseTexture.baseTexture;\n\n    /**\n     * The base texture of that this texture uses\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = frame;\n\n    /**\n     * The trim point\n     *\n     * @property trim\n     * @type Rectangle\n     */\n    this.trim = null;\n  \n    this.scope = this;\n\n    this._uvs = null;\n    \n    if(baseTexture.hasLoaded)\n    {\n        if(this.noFrame)frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);\n      \n        this.setFrame(frame);\n    }\n    else\n    {\n        var scope = this;\n        baseTexture.addEventListener('loaded', function(){ scope.onBaseTextureLoaded(); });\n    }\n};\n\nPIXI.Texture.prototype.constructor = PIXI.Texture;\n\n/**\n * Called when the base texture is loaded\n *\n * @method onBaseTextureLoaded\n * @param event\n * @private\n */\nPIXI.Texture.prototype.onBaseTextureLoaded = function()\n{\n    var baseTexture = this.baseTexture;\n    baseTexture.removeEventListener( 'loaded', this.onLoaded );\n\n    if(this.noFrame)this.frame = new PIXI.Rectangle(0,0, baseTexture.width, baseTexture.height);\n    \n    this.setFrame(this.frame);\n\n    this.scope.dispatchEvent( { type: 'update', content: this } );\n};\n\n/**\n * Destroys this texture\n *\n * @method destroy\n * @param destroyBase {Boolean} Whether to destroy the base texture as well\n */\nPIXI.Texture.prototype.destroy = function(destroyBase)\n{\n    if(destroyBase) this.baseTexture.destroy();\n};\n\n/**\n * Specifies the rectangle region of the baseTexture\n *\n * @method setFrame\n * @param frame {Rectangle} The frame of the texture to set it to\n */\nPIXI.Texture.prototype.setFrame = function(frame)\n{\n    this.frame = frame;\n    this.width = frame.width;\n    this.height = frame.height;\n\n    if(frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)\n    {\n        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n    }\n\n    this.updateFrame = true;\n\n    PIXI.Texture.frameUpdates.push(this);\n\n\n    //this.dispatchEvent( { type: 'update', content: this } );\n};\n\nPIXI.Texture.prototype._updateWebGLuvs = function()\n{\n    if(!this._uvs)this._uvs = new PIXI.TextureUvs();\n\n    var frame = this.frame;\n    var tw = this.baseTexture.width;\n    var th = this.baseTexture.height;\n\n    this._uvs.x0 = frame.x / tw;\n    this._uvs.y0 = frame.y / th;\n\n    this._uvs.x1 = (frame.x + frame.width) / tw;\n    this._uvs.y1 = frame.y / th;\n\n    this._uvs.x2 = (frame.x + frame.width) / tw;\n    this._uvs.y2 = (frame.y + frame.height) / th;\n\n    this._uvs.x3 = frame.x / tw;\n    this._uvs.y3 = (frame.y + frame.height) / th;\n};\n\n/**\n * Helper function that returns a texture based on an image url\n * If the image is not in the texture cache it will be  created and loaded\n *\n * @static\n * @method fromImage\n * @param imageUrl {String} The image url of the texture\n * @param crossorigin {Boolean} Whether requests should be treated as crossorigin\n * @return Texture\n */\nPIXI.Texture.fromImage = function(imageUrl, crossorigin, scaleMode)\n{\n    var texture = PIXI.TextureCache[imageUrl];\n\n    if(!texture)\n    {\n        texture = new PIXI.Texture(PIXI.BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));\n        PIXI.TextureCache[imageUrl] = texture;\n    }\n\n    return texture;\n};\n\n/**\n * Helper function that returns a texture based on a frame id\n * If the frame id is not in the texture cache an error will be thrown\n *\n * @static\n * @method fromFrame\n * @param frameId {String} The frame id of the texture\n * @return Texture\n */\nPIXI.Texture.fromFrame = function(frameId)\n{\n    var texture = PIXI.TextureCache[frameId];\n    if(!texture) throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ');\n    return texture;\n};\n\n/**\n * Helper function that returns a texture based on a canvas element\n * If the canvas is not in the texture cache it will be  created and loaded\n *\n * @static\n * @method fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @return Texture\n */\nPIXI.Texture.fromCanvas = function(canvas, scaleMode)\n{\n    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);\n\n    return new PIXI.Texture( baseTexture );\n\n};\n\n\n/**\n * Adds a texture to the textureCache.\n *\n * @static\n * @method addTextureToCache\n * @param texture {Texture}\n * @param id {String} the id that the texture will be stored against.\n */\nPIXI.Texture.addTextureToCache = function(texture, id)\n{\n    PIXI.TextureCache[id] = texture;\n};\n\n/**\n * Remove a texture from the textureCache.\n *\n * @static\n * @method removeTextureFromCache\n * @param id {String} the id of the texture to be removed\n * @return {Texture} the texture that was removed\n */\nPIXI.Texture.removeTextureFromCache = function(id)\n{\n    var texture = PIXI.TextureCache[id];\n    delete PIXI.TextureCache[id];\n    delete PIXI.BaseTextureCache[id];\n    return texture;\n};\n\n// this is more for webGL.. it contains updated frames..\nPIXI.Texture.frameUpdates = [];\n\nPIXI.TextureUvs = function()\n{\n    this.x0 = 0;\n    this.y0 = 0;\n\n    this.x1 = 0;\n    this.y1 = 0;\n\n    this.x2 = 0;\n    this.y2 = 0;\n\n    this.x3 = 0;\n    this.y4 = 0;\n\n\n};\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n A RenderTexture is a special texture that allows any pixi displayObject to be rendered to it.\n\n __Hint__: All DisplayObjects (exmpl. Sprites) that render on RenderTexture should be preloaded.\n Otherwise black rectangles will be drawn instead.\n\n RenderTexture takes snapshot of DisplayObject passed to render method. If DisplayObject is passed to render method, position and rotation of it will be ignored. For example:\n\n    var renderTexture = new PIXI.RenderTexture(800, 600);\n    var sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n    sprite.position.x = 800/2;\n    sprite.position.y = 600/2;\n    sprite.anchor.x = 0.5;\n    sprite.anchor.y = 0.5;\n    renderTexture.render(sprite);\n\n Sprite in this case will be rendered to 0,0 position. To render this sprite at center DisplayObjectContainer should be used:\n\n    var doc = new PIXI.DisplayObjectContainer();\n    doc.addChild(sprite);\n    renderTexture.render(doc);  // Renders to center of renderTexture\n\n * @class RenderTexture\n * @extends Texture\n * @constructor\n * @param width {Number} The width of the render texture\n * @param height {Number} The height of the render texture\n * @param scaleMode {Number} Should be one of the PIXI.scaleMode consts\n */\nPIXI.RenderTexture = function(width, height, renderer, scaleMode)\n{\n    PIXI.EventTarget.call( this );\n\n    /**\n     * The with of the render texture\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width || 100;\n    /**\n     * The height of the render texture\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height || 100;\n\n    /**\n     * The framing rectangle of the render texture\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = new PIXI.Rectangle(0, 0, this.width, this.height);\n\n    /**\n     * The base texture object that this texture uses\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = new PIXI.BaseTexture();\n    this.baseTexture.width = this.width;\n    this.baseTexture.height = this.height;\n    this.baseTexture._glTextures = [];\n\n    this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    this.baseTexture.hasLoaded = true;\n\n    // each render texture can only belong to one renderer at the moment if its webGL\n    this.renderer = renderer || PIXI.defaultRenderer;\n\n    if(this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        var gl = this.renderer.gl;\n\n        this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode);\n        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;\n\n        this.render = this.renderWebGL;\n        this.projection = new PIXI.Point(this.width/2 , -this.height/2);\n    }\n    else\n    {\n        this.render = this.renderCanvas;\n        this.textureBuffer = new PIXI.CanvasBuffer(this.width, this.height);\n        this.baseTexture.source = this.textureBuffer.canvas;\n    }\n\n    PIXI.Texture.frameUpdates.push(this);\n\n\n};\n\nPIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype);\nPIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture;\n\nPIXI.RenderTexture.prototype.resize = function(width, height)\n{\n    this.width = width;\n    this.height = height;\n\n    this.frame.width = this.width;\n    this.frame.height = this.height;\n\n    if(this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.projection.x = this.width / 2;\n        this.projection.y = -this.height / 2;\n\n        var gl = this.renderer.gl;\n        gl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTextures[gl.id]);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  this.width,  this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    else\n    {\n        this.textureBuffer.resize(this.width, this.height);\n    }\n\n    PIXI.Texture.frameUpdates.push(this);\n};\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderWebGL\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderWebGL = function(displayObject, position, clear)\n{\n    //TOOD replace position with matrix..\n    var gl = this.renderer.gl;\n\n    gl.colorMask(true, true, true, true);\n\n    gl.viewport(0, 0, this.width, this.height);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer );\n\n    if(clear)this.textureBuffer.clear();\n\n    // THIS WILL MESS WITH HIT TESTING!\n    var children = displayObject.children;\n\n    //TODO -? create a new one??? dont think so!\n    var originalWorldTransform = displayObject.worldTransform;\n    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;\n    // modify to flip...\n    displayObject.worldTransform.d = -1;\n    displayObject.worldTransform.ty = this.projection.y * -2;\n\n    if(position)\n    {\n        displayObject.worldTransform.tx = position.x;\n        displayObject.worldTransform.ty -= position.y;\n    }\n\n    for(var i=0,j=children.length; i<j; i++)\n    {\n        children[i].updateTransform();\n    }\n\n    // update the textures!\n    PIXI.WebGLRenderer.updateTextures();\n\n    // \n    this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer);\n\n    displayObject.worldTransform = originalWorldTransform;\n};\n\n\n/**\n * This function will draw the display object to the texture.\n *\n * @method renderCanvas\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param clear {Boolean} If true the texture will be cleared before the displayObject is drawn\n * @private\n */\nPIXI.RenderTexture.prototype.renderCanvas = function(displayObject, position, clear)\n{\n    var children = displayObject.children;\n\n    var originalWorldTransform = displayObject.worldTransform;\n\n    displayObject.worldTransform = PIXI.RenderTexture.tempMatrix;\n\n    if(position)\n    {\n        displayObject.worldTransform.tx = position.x;\n        displayObject.worldTransform.ty = position.y;\n    }\n\n    for(var i = 0, j = children.length; i < j; i++)\n    {\n        children[i].updateTransform();\n    }\n\n    if(clear)this.textureBuffer.clear();\n\n    var context = this.textureBuffer.context;\n\n    this.renderer.renderDisplayObject(displayObject, context);\n\n    context.setTransform(1,0,0,1,0,0);\n\n    displayObject.worldTransform = originalWorldTransform;\n};\n\nPIXI.RenderTexture.tempMatrix = new PIXI.Matrix();\n\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = PIXI;\n        }\n        exports.PIXI = PIXI;\n    } else if (typeof define !== 'undefined' && define.amd) {\n        define('PIXI', (function() { return root.PIXI = PIXI; })() );\n    } else {\n        root.PIXI = PIXI;\n    }\n}).call(this);\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*\n* @overview\n*\n* Phaser - http://phaser.io\n*\n* v2.0.4 \"Mos Shirare\" - Built: Tue Apr 29 2014 22:39:37\n*\n* By Richard Davey http://www.photonstorm.com @photonstorm\n*\n* Phaser is a fun, free and fast 2D game framework for making HTML5 games\n* for desktop and mobile web browsers, supporting Canvas and WebGL rendering.\n*\n* Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23\n* Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe\n* Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com\n*\n* Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser\n* and my love of framework development originate.\n*\n* Follow development at http://phaser.io and on our forum\n*\n* \"If you want your children to be intelligent,  read them fairy tales.\"\n* \"If you want them to be more intelligent, read them more fairy tales.\"\n*                                                     -- Albert Einstein\n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n(function(){\n\n    var root = this;\n\n/* global Phaser:true */\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @namespace Phaser\n*/\nvar Phaser = Phaser || {\n\n\tVERSION: '2.0.4',\n\tGAMES: [],\n\n    AUTO: 0,\n    CANVAS: 1,\n    WEBGL: 2,\n    HEADLESS: 3,\n\n    NONE: 0,\n    LEFT: 1,\n    RIGHT: 2,\n    UP: 3,\n    DOWN: 4,\n\n    SPRITE: 0,\n    BUTTON: 1,\n    IMAGE: 2,\n    GRAPHICS: 3,\n    TEXT: 4,\n    TILESPRITE: 5,\n    BITMAPTEXT: 6,\n    GROUP: 7,\n    RENDERTEXTURE: 8,\n    TILEMAP: 9,\n    TILEMAPLAYER: 10,\n    EMITTER: 11,\n    POLYGON: 12,\n    BITMAPDATA: 13,\n    CANVAS_FILTER: 14,\n    WEBGL_FILTER: 15,\n    ELLIPSE: 16,\n    SPRITEBATCH: 17,\n    RETROFONT: 18,\n\n    // The various blend modes supported by pixi / phaser\n    blendModes: {\n        NORMAL:0,\n        ADD:1,\n        MULTIPLY:2,\n        SCREEN:3,\n        OVERLAY:4,\n        DARKEN:5,\n        LIGHTEN:6,\n        COLOR_DODGE:7,\n        COLOR_BURN:8,\n        HARD_LIGHT:9,\n        SOFT_LIGHT:10,\n        DIFFERENCE:11,\n        EXCLUSION:12,\n        HUE:13,\n        SATURATION:14,\n        COLOR:15,\n        LUMINOSITY:16\n    },\n\n    // The scale modes\n    scaleModes: {\n        DEFAULT:0,\n        LINEAR:0,\n        NEAREST:1\n    }\n\n};\n\nPIXI.InteractionManager = function () {\n    // We don't need this in Pixi, so we've removed it to save space\n    // however the Stage object expects a reference to it, so here is a dummy entry.\n};\n\n/* jshint supernew: true */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Utils\n* @static\n*/\nPhaser.Utils = {\n\n    /**\n    * Get a unit dimension from a string.\n    *\n    * @method Phaser.Utils.parseDimension\n    * @param {string|number} size - The size to parse.\n    * @param {number} dimension - The window dimension to check.\n    * @return {number} The parsed dimension.\n    */\n    parseDimension: function (size, dimension) {\n\n        var f = 0;\n        var px = 0;\n\n        if (typeof size === 'string')\n        {\n            //  %?\n            if (size.substr(-1) === '%')\n            {\n                f = parseInt(size, 10) / 100;\n\n                if (dimension === 0)\n                {\n                    px = window.innerWidth * f;\n                }\n                else\n                {\n                    px = window.innerHeight * f;\n                }\n            }\n            else\n            {\n                px = parseInt(size, 10);\n            }\n        }\n        else\n        {\n            px = size;\n        }\n\n        return px;\n\n    },\n\n    /**\n    * A standard Fisher-Yates Array shuffle implementation.\n    * @method Phaser.Utils.shuffle\n    * @param {array} array - The array to shuffle.\n    * @return {array} The shuffled array.\n    */\n    shuffle: function (array) {\n\n        for (var i = array.length - 1; i > 0; i--)\n        {\n            var j = Math.floor(Math.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n\n        return array;\n\n    },\n\n    /**\n    * Javascript string pad http://www.webtoolkit.info/.\n    * pad = the string to pad it out with (defaults to a space)\n    * dir = 1 (left), 2 (right), 3 (both)\n    * @method Phaser.Utils.pad\n    * @param {string} str - The target string.\n    * @param {number} len - The number of characters to be added.\n    * @param {number} pad - The string to pad it out with (defaults to a space).\n    * @param {number} [dir=3] The direction dir = 1 (left), 2 (right), 3 (both).\n    * @return {string} The padded string\n    */\n    pad: function (str, len, pad, dir) {\n\n        if (typeof(len) == \"undefined\") { var len = 0; }\n        if (typeof(pad) == \"undefined\") { var pad = ' '; }\n        if (typeof(dir) == \"undefined\") { var dir = 3; }\n\n        var padlen = 0;\n\n        if (len + 1 >= str.length)\n        {\n            switch (dir)\n            {\n                case 1:\n                    str = new Array(len + 1 - str.length).join(pad) + str;\n                    break;\n\n                case 3:\n                    var right = Math.ceil((padlen = len - str.length) / 2);\n                    var left = padlen - right;\n                    str = new Array(left+1).join(pad) + str + new Array(right+1).join(pad);\n                    break;\n\n                default:\n                    str = str + new Array(len + 1 - str.length).join(pad);\n                    break;\n            }\n        }\n\n        return str;\n\n    },\n\n    /**\n    * This is a slightly modified version of jQuery.isPlainObject. A plain object is an object whose internal class property is [object Object].\n    * @method Phaser.Utils.isPlainObject\n    * @param {object} obj - The object to inspect.\n    * @return {boolean} - true if the object is plain, otherwise false.\n    */\n    isPlainObject: function (obj) {\n\n        // Not plain objects:\n        // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n        // - DOM nodes\n        // - window\n        if (typeof(obj) !== \"object\" || obj.nodeType || obj === obj.window)\n        {\n            return false;\n        }\n\n        // Support: Firefox <20\n        // The try/catch suppresses exceptions thrown when attempting to access\n        // the \"constructor\" property of certain host objects, ie. |window.location|\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n        try {\n            if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\"))\n            {\n                return false;\n            }\n        } catch (e) {\n            return false;\n        }\n\n        // If the function hasn't returned already, we're confident that\n        // |obj| is a plain object, created by {} or constructed with new Object\n        return true;\n    },\n\n    /**\n    * This is a slightly modified version of http://api.jquery.com/jQuery.extend/\n    * @method Phaser.Utils.extend\n    * @param {boolean} deep - Perform a deep copy?\n    * @param {object} target - The target object to copy to.\n    * @return {object} The extended object.\n    */\n    extend: function () {\n\n        var options, name, src, copy, copyIsArray, clone,\n            target = arguments[0] || {},\n            i = 1,\n            length = arguments.length,\n            deep = false;\n\n        // Handle a deep copy situation\n        if (typeof target === \"boolean\")\n        {\n            deep = target;\n            target = arguments[1] || {};\n            // skip the boolean and the target\n            i = 2;\n        }\n\n        // extend Phaser if only one argument is passed\n        if (length === i)\n        {\n            target = this;\n            --i;\n        }\n\n        for (; i < length; i++)\n        {\n            // Only deal with non-null/undefined values\n            if ((options = arguments[i]) != null)\n            {\n                // Extend the base object\n                for (name in options)\n                {\n                    src = target[name];\n                    copy = options[name];\n\n                    // Prevent never-ending loop\n                    if (target === copy)\n                    {\n                        continue;\n                    }\n\n                    // Recurse if we're merging plain objects or arrays\n                    if (deep && copy && (Phaser.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))))\n                    {\n                        if (copyIsArray)\n                        {\n                            copyIsArray = false;\n                            clone = src && Array.isArray(src) ? src : [];\n                        }\n                        else\n                        {\n                            clone = src && Phaser.Utils.isPlainObject(src) ? src : {};\n                        }\n\n                        // Never move original objects, clone them\n                        target[name] = Phaser.Utils.extend(deep, clone, copy);\n\n                    // Don't bring in undefined values\n                    }\n                    else if (copy !== undefined)\n                    {\n                        target[name] = copy;\n                    }\n                }\n            }\n        }\n\n        // Return the modified object\n        return target;\n    }\n\n};\n\n/**\n* A polyfill for Function.prototype.bind\n*/\nif (typeof Function.prototype.bind != 'function') {\n\n    /* jshint freeze: false */\n    Function.prototype.bind = (function () {\n\n        var slice = Array.prototype.slice;\n\n        return function (thisArg) {\n\n            var target = this, boundArgs = slice.call(arguments, 1);\n\n            if (typeof target != 'function')\n            {\n                throw new TypeError();\n            }\n\n            function bound() {\n                var args = boundArgs.concat(slice.call(arguments));\n                target.apply(this instanceof bound ? this : thisArg, args);\n            }\n\n            bound.prototype = (function F(proto) {\n                if (proto)\n                {\n                    F.prototype = proto;\n                }\n\n                if (!(this instanceof F))\n                {\n                    return new F;\n                }\n            })(target.prototype);\n\n            return bound;\n        };\n    })();\n}\n\n/**\n* A polyfill for Array.isArray\n*/\nif (!Array.isArray)\n{\n    Array.isArray = function (arg)\n    {\n        return Object.prototype.toString.call(arg) == '[object Array]';\n    };\n}\n\n/**\n* A polyfill for Array.forEach\n* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n*/\nif (!Array.prototype.forEach)\n{\n    Array.prototype.forEach = function(fun /*, thisArg */)\n    {\n        \"use strict\";\n\n        if (this === void 0 || this === null)\n        {\n            throw new TypeError();\n        }\n\n        var t = Object(this);\n        var len = t.length >>> 0;\n\n        if (typeof fun !== \"function\")\n        {\n            throw new TypeError();\n        }\n\n        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n\n        for (var i = 0; i < len; i++)\n        {\n            if (i in t)\n            {\n                fun.call(thisArg, t[i], i, t);\n            }\n        }\n    };\n}\n\n/**\n* Low-budget Float32Array knock-off, suitable for use with P2.js in IE9\n* Source: http://www.html5gamedevs.com/topic/5988-phaser-12-ie9/\n* Cameron Foale (http://www.kibibu.com)\n*/\nif (typeof window.Uint32Array !== \"function\")\n{\n    var CheapArray = function(type)\n    {\n        var proto = new Array(); // jshint ignore:line\n\n        window[type] = function(arg) {\n\n            if (typeof(arg) === \"number\")\n            {\n                Array.call(this, arg);\n                this.length = arg;\n\n                for (var i = 0; i < this.length; i++)\n                {\n                    this[i] = 0;\n                }\n            }\n            else\n            {\n                Array.call(this, arg.length);\n\n                this.length = arg.length;\n\n                for (var i = 0; i < this.length; i++)\n                {\n                    this[i] = arg[i];\n                }\n            }\n        };\n\n        window[type].prototype = proto;\n        window[type].constructor = window[type];\n    };\n\n    CheapArray('Uint32Array'); // jshint ignore:line\n    CheapArray('Int16Array');  // jshint ignore:line\n}\n\n/**\n * Also fix for the absent console in IE9\n */\nif (!window.console)\n{\n    window.console = {};\n    window.console.log = window.console.assert = function(){};\n    window.console.warn = window.console.assert = function(){};\n}\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Circle object with the center coordinate specified by the x and y parameters and the diameter specified by the diameter parameter. If you call this function without parameters, a circle with x, y, diameter and radius properties set to 0 is created.\n* @class Circle\n* @classdesc Phaser - Circle\n* @constructor\n* @param {number} [x=0] - The x coordinate of the center of the circle.\n* @param {number} [y=0] - The y coordinate of the center of the circle.\n* @param {number} [diameter=0] - The diameter of the circle.\n* @return {Phaser.Circle} This circle object\n*/\nPhaser.Circle = function (x, y, diameter) {\n\n    x = x || 0;\n    y = y || 0;\n    diameter = diameter || 0;\n\n    /**\n    * @property {number} x - The x coordinate of the center of the circle.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y coordinate of the center of the circle.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} _diameter - The diameter of the circle.\n    * @private\n    */\n    this._diameter = diameter;\n\n    if (diameter > 0)\n    {\n        /**\n       * @property {number} _radius - The radius of the circle.\n       * @private\n       */\n        this._radius = diameter * 0.5;\n    }\n    else\n    {\n        this._radius = 0;\n    }\n\n};\n\nPhaser.Circle.prototype = {\n\n    /**\n    * The circumference of the circle.\n    * @method Phaser.Circle#circumference\n    * @return {number}\n    */\n    circumference: function () {\n        return 2 * (Math.PI * this._radius);\n    },\n\n    /**\n    * Sets the members of Circle to the specified values.\n    * @method Phaser.Circle#setTo\n    * @param {number} x - The x coordinate of the center of the circle.\n    * @param {number} y - The y coordinate of the center of the circle.\n    * @param {number} diameter - The diameter of the circle in pixels.\n    * @return {Circle} This circle object.\n    */\n    setTo: function (x, y, diameter) {\n\n        this.x = x;\n        this.y = y;\n        this._diameter = diameter;\n        this._radius = diameter * 0.5;\n\n        return this;\n\n    },\n\n    /**\n    * Copies the x, y and diameter properties from any given object to this Circle.\n    * @method Phaser.Circle#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Circle} This Circle object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y, source.diameter);\n\n    },\n\n    /**\n    * Copies the x, y and diameter properties from this Circle to any given object.\n    * @method Phaser.Circle#copyTo\n    * @param {any} dest - The object to copy to.\n    * @return {Object} This dest object.\n    */\n    copyTo: function (dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n        dest.diameter = this._diameter;\n\n        return dest;\n\n    },\n\n    /**\n    * Returns the distance from the center of the Circle object to the given object\n    * (can be Circle, Point or anything with x/y properties)\n    * @method Phaser.Circle#distance\n    * @param {object} dest - The target object. Must have visible x and y properties that represent the center of the object.\n    * @param {boolean} [round] - Round the distance to the nearest integer (default false).\n    * @return {number} The distance between this Point object and the destination Point object.\n    */\n    distance: function (dest, round) {\n\n        if (typeof round === \"undefined\") { round = false; }\n\n        if (round)\n        {\n            return Phaser.Math.distanceRounded(this.x, this.y, dest.x, dest.y);\n        }\n        else\n        {\n            return Phaser.Math.distance(this.x, this.y, dest.x, dest.y);\n        }\n\n    },\n\n    /**\n    * Returns a new Circle object with the same values for the x, y, width, and height properties as this Circle object.\n    * @method Phaser.Circle#clone\n    * @param {Phaser.Circle} out - Optional Circle object. If given the values will be set into the object, otherwise a brand new Circle object will be created and returned.\n    * @return {Phaser.Circle} The cloned Circle object.\n    */\n    clone: function (out) {\n\n        if (typeof out === \"undefined\")\n        {\n            out = new Phaser.Circle(this.x, this.y, this.diameter);\n        }\n        else\n        {\n            out.setTo(this.x, this.y, this.diameter);\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Return true if the given x/y coordinates are within this Circle object.\n    * @method Phaser.Circle#contains\n    * @param {number} x - The X value of the coordinate to test.\n    * @param {number} y - The Y value of the coordinate to test.\n    * @return {boolean} True if the coordinates are within this circle, otherwise false.\n    */\n    contains: function (x, y) {\n\n        return Phaser.Circle.contains(this, x, y);\n\n    },\n\n    /**\n    * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.\n    * @method Phaser.Circle#circumferencePoint\n    * @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.\n    * @param {boolean} asDegrees - Is the given angle in radians (false) or degrees (true)?\n    * @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.\n    * @return {Phaser.Point} The Point object holding the result.\n    */\n    circumferencePoint: function (angle, asDegrees, out) {\n\n        return Phaser.Circle.circumferencePoint(this, angle, asDegrees, out);\n\n    },\n\n    /**\n    * Adjusts the location of the Circle object, as determined by its center coordinate, by the specified amounts.\n    * @method Phaser.Circle#offset\n    * @param {number} dx - Moves the x value of the Circle object by this amount.\n    * @param {number} dy - Moves the y value of the Circle object by this amount.\n    * @return {Circle} This Circle object.\n    */\n    offset: function (dx, dy) {\n\n        this.x += dx;\n        this.y += dy;\n\n        return this;\n\n    },\n\n    /**\n    * Adjusts the location of the Circle object using a Point object as a parameter. This method is similar to the Circle.offset() method, except that it takes a Point object as a parameter.\n    * @method Phaser.Circle#offsetPoint\n    * @param {Point} point A Point object to use to offset this Circle object (or any valid object with exposed x and y properties).\n    * @return {Circle} This Circle object.\n    */\n    offsetPoint: function (point) {\n        return this.offset(point.x, point.y);\n    },\n\n    /**\n    * Returns a string representation of this object.\n    * @method Phaser.Circle#toString\n    * @return {string} a string representation of the instance.\n    */\n    toString: function () {\n        return \"[{Phaser.Circle (x=\" + this.x + \" y=\" + this.y + \" diameter=\" + this.diameter + \" radius=\" + this.radius + \")}]\";\n    }\n\n};\n\nPhaser.Circle.prototype.constructor = Phaser.Circle;\n\n/**\n* The largest distance between any two points on the circle. The same as the radius * 2.\n* @name Phaser.Circle#diameter\n* @property {number} diameter - Gets or sets the diameter of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"diameter\", {\n\n    get: function () {\n        return this._diameter;\n    },\n\n    set: function (value) {\n\n        if (value > 0)\n        {\n            this._diameter = value;\n            this._radius = value * 0.5;\n        }\n    }\n\n});\n\n/**\n* The length of a line extending from the center of the circle to any point on the circle itself. The same as half the diameter.\n* @name Phaser.Circle#radius\n* @property {number} radius - Gets or sets the radius of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"radius\", {\n\n    get: function () {\n        return this._radius;\n    },\n\n    set: function (value) {\n\n        if (value > 0)\n        {\n            this._radius = value;\n            this._diameter = value * 2;\n        }\n\n    }\n\n});\n\n/**\n* The x coordinate of the leftmost point of the circle. Changing the left property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.\n* @name Phaser.Circle#left\n* @propety {number} left - Gets or sets the value of the leftmost point of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"left\", {\n\n    get: function () {\n        return this.x - this._radius;\n    },\n\n    set: function (value) {\n\n        if (value > this.x)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = this.x - value;\n        }\n\n    }\n\n});\n\n/**\n* The x coordinate of the rightmost point of the circle. Changing the right property of a Circle object has no effect on the x and y properties. However it does affect the diameter, whereas changing the x value does not affect the diameter property.\n* @name Phaser.Circle#right\n* @property {number} right - Gets or sets the value of the rightmost point of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"right\", {\n\n    get: function () {\n        return this.x + this._radius;\n    },\n\n    set: function (value) {\n\n        if (value < this.x)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = value - this.x;\n        }\n\n    }\n\n});\n\n/**\n* The sum of the y minus the radius property. Changing the top property of a Circle object has no effect on the x and y properties, but does change the diameter.\n* @name Phaser.Circle#top\n* @property {number} top - Gets or sets the top of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"top\", {\n\n    get: function () {\n        return this.y - this._radius;\n    },\n\n    set: function (value) {\n\n        if (value > this.y)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = this.y - value;\n        }\n\n    }\n\n});\n\n/**\n* The sum of the y and radius properties. Changing the bottom property of a Circle object has no effect on the x and y properties, but does change the diameter.\n* @name Phaser.Circle#bottom\n* @property {number} bottom - Gets or sets the bottom of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"bottom\", {\n\n    get: function () {\n        return this.y + this._radius;\n    },\n\n    set: function (value) {\n\n        if (value < this.y)\n        {\n            this._radius = 0;\n            this._diameter = 0;\n        }\n        else\n        {\n            this.radius = value - this.y;\n        }\n\n    }\n\n});\n\n/**\n* The area of this Circle.\n* @name Phaser.Circle#area\n* @property {number} area - The area of this circle.\n* @readonly\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"area\", {\n\n    get: function () {\n\n        if (this._radius > 0)\n        {\n            return Math.PI * this._radius * this._radius;\n        }\n        else\n        {\n            return 0;\n        }\n\n    }\n\n});\n\n/**\n* Determines whether or not this Circle object is empty. Will return a value of true if the Circle objects diameter is less than or equal to 0; otherwise false.\n* If set to true it will reset all of the Circle objects properties to 0. A Circle object is empty if its diameter is less than or equal to 0.\n* @name Phaser.Circle#empty\n* @property {boolean} empty - Gets or sets the empty state of the circle.\n*/\nObject.defineProperty(Phaser.Circle.prototype, \"empty\", {\n\n    get: function () {\n        return (this._diameter === 0);\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            this.setTo(0, 0, 0);\n        }\n\n    }\n\n});\n\n/**\n* Return true if the given x/y coordinates are within the Circle object.\n* @method Phaser.Circle.contains\n* @param {Phaser.Circle} a - The Circle to be checked.\n* @param {number} x - The X value of the coordinate to test.\n* @param {number} y - The Y value of the coordinate to test.\n* @return {boolean} True if the coordinates are within this circle, otherwise false.\n*/\nPhaser.Circle.contains = function (a, x, y) {\n\n    //  Check if x/y are within the bounds first\n    if (a.radius > 0 && x >= a.left && x <= a.right && y >= a.top && y <= a.bottom)\n    {\n        var dx = (a.x - x) * (a.x - x);\n        var dy = (a.y - y) * (a.y - y);\n\n        return (dx + dy) <= (a.radius * a.radius);\n    }\n    else\n    {\n        return false;\n    }\n\n};\n\n/**\n* Determines whether the two Circle objects match. This method compares the x, y and diameter properties.\n* @method Phaser.Circle.equals\n* @param {Phaser.Circle} a - The first Circle object.\n* @param {Phaser.Circle} b - The second Circle object.\n* @return {boolean} A value of true if the object has exactly the same values for the x, y and diameter properties as this Circle object; otherwise false.\n*/\nPhaser.Circle.equals = function (a, b) {\n    return (a.x == b.x && a.y == b.y && a.diameter == b.diameter);\n};\n\n/**\n* Determines whether the two Circle objects intersect.\n* This method checks the radius distances between the two Circle objects to see if they intersect.\n* @method Phaser.Circle.intersects\n* @param {Phaser.Circle} a - The first Circle object.\n* @param {Phaser.Circle} b - The second Circle object.\n* @return {boolean} A value of true if the specified object intersects with this Circle object; otherwise false.\n*/\nPhaser.Circle.intersects = function (a, b) {\n    return (Phaser.Math.distance(a.x, a.y, b.x, b.y) <= (a.radius + b.radius));\n};\n\n/**\n* Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.\n* @method Phaser.Circle.circumferencePoint\n* @param {Phaser.Circle} a - The first Circle object.\n* @param {number} angle - The angle in radians (unless asDegrees is true) to return the point from.\n* @param {boolean} asDegrees - Is the given angle in radians (false) or degrees (true)?\n* @param {Phaser.Point} [out] - An optional Point object to put the result in to. If none specified a new Point object will be created.\n* @return {Phaser.Point} The Point object holding the result.\n*/\nPhaser.Circle.circumferencePoint = function (a, angle, asDegrees, out) {\n\n    if (typeof asDegrees === \"undefined\") { asDegrees = false; }\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    if (asDegrees === true)\n    {\n        angle = Phaser.Math.degToRad(angle);\n    }\n\n    out.x = a.x + a.radius * Math.cos(angle);\n    out.y = a.y + a.radius * Math.sin(angle);\n\n    return out;\n\n};\n\n/**\n* Checks if the given Circle and Rectangle objects intersect.\n* @method Phaser.Circle.intersectsRectangle\n* @param {Phaser.Circle} c - The Circle object to test.\n* @param {Phaser.Rectangle} r - The Rectangle object to test.\n* @return {boolean} True if the two objects intersect, otherwise false.\n*/\nPhaser.Circle.intersectsRectangle = function (c, r) {\n\n    var cx = Math.abs(c.x - r.x - r.halfWidth);\n    var xDist = r.halfWidth + c.radius;\n\n    if (cx > xDist)\n    {\n        return false;\n    }\n\n    var cy = Math.abs(c.y - r.y - r.halfHeight);\n    var yDist = r.halfHeight + c.radius;\n\n    if (cy > yDist)\n    {\n        return false;\n    }\n\n    if (cx <= r.halfWidth || cy <= r.halfHeight)\n    {\n        return true;\n    }\n\n    var xCornerDist = cx - r.halfWidth;\n    var yCornerDist = cy - r.halfHeight;\n    var xCornerDistSq = xCornerDist * xCornerDist;\n    var yCornerDistSq = yCornerDist * yCornerDist;\n    var maxCornerDistSq = c.radius * c.radius;\n\n    return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;\n\n};\n\n//   Because PIXI uses its own Circle, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Circle = Phaser.Circle;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Point\n* @classdesc\n* The Point object represents a location in a two-dimensional coordinate system, \n* where x represents the horizontal axis and y represents the vertical axis.\n* The following code creates a point at (0,0):\n* `var myPoint = new Phaser.Point();`\n* You can also use them as 2D Vectors and you'll find different vector related methods in this class.\n*/\n\n/**\n* Creates a new Point object. If you pass no parameters a Point is created set to (0, 0).\n*\n* @constructor\n* @param {number} [x=0] - The horizontal position of this Point.\n* @param {number} [y=0] - The vertical position of this Point.\n*/\nPhaser.Point = function (x, y) {\n\n    x = x || 0;\n    y = y || 0;\n\n    /**\n    * @property {number} x - The x value of the point.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y value of the point.\n    */\n    this.y = y;\n\n};\n\nPhaser.Point.prototype = {\n\n    /**\n    * Copies the x and y properties from any given object to this Point.\n    *\n    * @method Phaser.Point#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Phaser.Point} This Point object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y);\n\n    },\n\n    /**\n    * Inverts the x and y values of this Point\n    *\n    * @method Phaser.Point#invert\n    * @return {Phaser.Point} This Point object.\n    */\n    invert: function () {\n\n        return this.setTo(this.y, this.x);\n\n    },\n\n    /**\n    * Sets the `x` and `y` values of this Point object to the given values.\n    * If you omit the `y` value then the `x` value will be applied to both, for example:\n    * `Point.setTo(2)` is the same as `Point.setTo(2, 2)`\n    *\n    * @method Phaser.Point#setTo\n    * @param {number} x - The horizontal value of this point.\n    * @param {number} [y] - The vertical value of this point. If not given the x value will be used in its place.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    setTo: function (x, y) {\n\n        this.x = x || 0;\n        this.y = y || ( (y !== 0) ? this.x : 0 );\n\n        return this;\n\n    },\n\n    /**\n    * Sets the `x` and `y` values of this Point object to the given values.\n    * If you omit the `y` value then the `x` value will be applied to both, for example:\n    * `Point.setTo(2)` is the same as `Point.setTo(2, 2)`\n    *\n    * @method Phaser.Point#set\n    * @param {number} x - The horizontal value of this point.\n    * @param {number} [y] - The vertical value of this point. If not given the x value will be used in its place.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    set: function (x, y) {\n\n        this.x = x || 0;\n        this.y = y || ( (y !== 0) ? this.x : 0 );\n\n        return this;\n\n    },\n\n    /**\n    * Adds the given x and y values to this Point.\n    *\n    * @method Phaser.Point#add\n    * @param {number} x - The value to add to Point.x.\n    * @param {number} y - The value to add to Point.y.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    add: function (x, y) {\n\n        this.x += x;\n        this.y += y;\n        return this;\n\n    },\n\n    /**\n    * Subtracts the given x and y values from this Point.\n    *\n    * @method Phaser.Point#subtract\n    * @param {number} x - The value to subtract from Point.x.\n    * @param {number} y - The value to subtract from Point.y.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    subtract: function (x, y) {\n\n        this.x -= x;\n        this.y -= y;\n        return this;\n\n    },\n\n    /**\n    * Multiplies Point.x and Point.y by the given x and y values. Sometimes known as `Scale`.\n    *\n    * @method Phaser.Point#multiply\n    * @param {number} x - The value to multiply Point.x by.\n    * @param {number} y - The value to multiply Point.x by.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    multiply: function (x, y) {\n\n        this.x *= x;\n        this.y *= y;\n        return this;\n\n    },\n\n    /**\n    * Divides Point.x and Point.y by the given x and y values.\n    *\n    * @method Phaser.Point#divide\n    * @param {number} x - The value to divide Point.x by.\n    * @param {number} y - The value to divide Point.x by.\n    * @return {Phaser.Point} This Point object. Useful for chaining method calls.\n    */\n    divide: function (x, y) {\n\n        this.x /= x;\n        this.y /= y;\n        return this;\n\n    },\n\n    /**\n    * Clamps the x value of this Point to be between the given min and max.\n    *\n    * @method Phaser.Point#clampX\n    * @param {number} min - The minimum value to clamp this Point to.\n    * @param {number} max - The maximum value to clamp this Point to.\n    * @return {Phaser.Point} This Point object.\n    */\n    clampX: function (min, max) {\n\n        this.x = Phaser.Math.clamp(this.x, min, max);\n        return this;\n\n    },\n\n    /**\n    * Clamps the y value of this Point to be between the given min and max\n    *\n    * @method Phaser.Point#clampY\n    * @param {number} min - The minimum value to clamp this Point to.\n    * @param {number} max - The maximum value to clamp this Point to.\n    * @return {Phaser.Point} This Point object.\n    */\n    clampY: function (min, max) {\n\n        this.y = Phaser.Math.clamp(this.y, min, max);\n        return this;\n\n    },\n\n    /**\n    * Clamps this Point object values to be between the given min and max.\n    *\n    * @method Phaser.Point#clamp\n    * @param {number} min - The minimum value to clamp this Point to.\n    * @param {number} max - The maximum value to clamp this Point to.\n    * @return {Phaser.Point} This Point object.\n    */\n    clamp: function (min, max) {\n\n        this.x = Phaser.Math.clamp(this.x, min, max);\n        this.y = Phaser.Math.clamp(this.y, min, max);\n        return this;\n\n    },\n\n    /**\n    * Creates a copy of the given Point.\n    *\n    * @method Phaser.Point#clone\n    * @param {Phaser.Point} [output] Optional Point object. If given the values will be set into this object, otherwise a brand new Point object will be created and returned.\n    * @return {Phaser.Point} The new Point object.\n    */\n    clone: function (output) {\n\n        if (typeof output === \"undefined\")\n        {\n            output = new Phaser.Point(this.x, this.y);\n        }\n        else\n        {\n            output.setTo(this.x, this.y);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Copies the x and y properties from this Point to any given object.\n    *\n    * @method Phaser.Point#copyTo\n    * @param {any} dest - The object to copy to.\n    * @return {Object} The dest object.\n    */\n    copyTo: function (dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n\n        return dest;\n\n    },\n\n    /**\n    * Returns the distance of this Point object to the given object (can be a Circle, Point or anything with x/y properties)\n    *\n    * @method Phaser.Point#distance\n    * @param {object} dest - The target object. Must have visible x and y properties that represent the center of the object.\n    * @param {boolean} [round] - Round the distance to the nearest integer (default false).\n    * @return {number} The distance between this Point object and the destination Point object.\n    */\n    distance: function (dest, round) {\n\n        return Phaser.Point.distance(this, dest, round);\n\n    },\n\n    /**\n    * Determines whether the given objects x/y values are equal to this Point object.\n    *\n    * @method Phaser.Point#equals\n    * @param {Phaser.Point|any} a - The object to compare with this Point.\n    * @return {boolean} A value of true if the x and y points are equal, otherwise false.\n    */\n    equals: function (a) {\n\n        return (a.x === this.x && a.y === this.y);\n\n    },\n\n    /**\n    * Returns the angle between this Point object and another object with public x and y properties.\n    *\n    * @method Phaser.Point#angle\n    * @param {Phaser.Point|any} a - The object to get the angle from this Point to.\n    * @return {number} The angle between the two objects.\n    */\n    angle: function (a) {\n\n        return Math.atan2(this.x * a.y - this.y * a.x, this.x * a.x + this.y * a.y);\n\n    },\n\n    /**\n    * Returns the angle squared between this Point object and another object with public x and y properties.\n    *\n    * @method Phaser.Point#angleSq\n    * @param {Phaser.Point|any} a - The object to get the angleSq from this Point to.\n    * @return {number} The angleSq between the two objects.\n    */\n    angleSq: function (a) {\n\n        return this.subtract(a).angle(a.subtract(this));\n\n    },\n\n    /**\n    * Rotates this Point around the x/y coordinates given to the desired angle.\n    *\n    * @method Phaser.Point#rotate\n    * @param {number} x - The x coordinate of the anchor point.\n    * @param {number} y - The y coordinate of the anchor point.\n    * @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the Point to.\n    * @param {boolean} asDegrees - Is the given rotation in radians (false) or degrees (true)?\n    * @param {number} [distance] - An optional distance constraint between the Point and the anchor.\n    * @return {Phaser.Point} The modified point object.\n    */\n    rotate: function (x, y, angle, asDegrees, distance) {\n\n        return Phaser.Point.rotate(this, x, y, angle, asDegrees, distance);\n\n    },\n\n    /**\n    * Calculates the length of the Point object.\n    *\n    * @method Phaser.Point#getMagnitude\n    * @return {number} The length of the Point.\n    */\n    getMagnitude: function () {\n\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n    },\n\n    /**\n    * Calculates the length squared of the Point object.\n    *\n    * @method Phaser.Point#getMagnitudeSq\n    * @return {number} The length ^ 2 of the Point.\n    */\n    getMagnitudeSq: function () {\n\n        return (this.x * this.x) + (this.y * this.y);\n\n    },\n\n    /**\n    * Alters the length of the Point without changing the direction.\n    *\n    * @method Phaser.Point#setMagnitude\n    * @param {number} magnitude - The desired magnitude of the resulting Point.\n    * @return {Phaser.Point} This Point object.\n    */\n    setMagnitude: function (magnitude) {\n\n        return this.normalize().multiply(magnitude, magnitude);\n\n    },\n\n    /**\n    * Alters the Point object so that its length is 1, but it retains the same direction.\n    *\n    * @method Phaser.Point#normalize\n    * @return {Phaser.Point} This Point object.\n    */\n    normalize: function () {\n\n        if (!this.isZero())\n        {\n            var m = this.getMagnitude();\n            this.x /= m;\n            this.y /= m;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Determine if this point is at 0,0.\n    *\n    * @method Phaser.Point#isZero\n    * @return {boolean} True if this Point is 0,0, otherwise false.\n    */\n    isZero: function () {\n\n        return (this.x === 0 && this.y === 0);\n\n    },\n\n    /**\n    * The dot product of this and another Point object.\n    * \n    * @method Phaser.Point#dot\n    * @param {Phaser.Point} a - The Point object to get the dot product combined with this Point.\n    * @return {number} The result.\n    */\n    dot: function (a) {\n\n        return ((this.x * a.x) + (this.y * a.y));\n\n    },\n\n    /**\n    * The cross product of this and another Point object.\n    * \n    * @method Phaser.Point#cross\n    * @param {Phaser.Point} a - The Point object to get the cross product combined with this Point.\n    * @return {number} The result.\n    */\n    cross: function (a) {\n\n        return ((this.x * a.y) - (this.y * a.x));\n\n    },\n\n    /**\n    * Make this Point perpendicular (90 degrees rotation)\n    * \n    * @method Phaser.Point#perp\n    * @return {Phaser.Point} This Point object.\n    */\n    perp: function () {\n\n        return this.setTo(-this.y, this.x);\n\n    },\n\n    /**\n    * Make this Point perpendicular (-90 degrees rotation)\n    * \n    * @method Phaser.Point#rperp\n    * @return {Phaser.Point} This Point object.\n    */\n    rperp: function () {\n\n        return this.setTo(this.y, -this.x);\n\n    },\n\n    /**\n    * Right-hand normalize (make unit length) this Point.\n    *\n    * @method Phaser.Point#normalRightHand\n    * @return {Phaser.Point} This Point object.\n    */\n    normalRightHand: function () {\n\n        return this.setTo(this.y * -1, this.x);\n\n    },\n\n    /**\n    * Returns a string representation of this object.\n    *\n    * @method Phaser.Point#toString\n    * @return {string} A string representation of the instance.\n    */\n    toString: function () {\n\n        return '[{Point (x=' + this.x + ' y=' + this.y + ')}]';\n\n    }\n\n};\n\nPhaser.Point.prototype.constructor = Phaser.Point;\n\n/**\n* Adds the coordinates of two points together to create a new point.\n*\n* @method Phaser.Point.add\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.add = function (a, b, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    out.x = a.x + b.x;\n    out.y = a.y + b.y;\n\n    return out;\n\n};\n\n/**\n* Subtracts the coordinates of two points to create a new point.\n*\n* @method Phaser.Point.subtract\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.subtract = function (a, b, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    out.x = a.x - b.x;\n    out.y = a.y - b.y;\n\n    return out;\n\n};\n\n/**\n* Multiplies the coordinates of two points to create a new point.\n*\n* @method Phaser.Point.multiply\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.multiply = function (a, b, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    out.x = a.x * b.x;\n    out.y = a.y * b.y;\n\n    return out;\n\n};\n\n/**\n* Divides the coordinates of two points to create a new point.\n*\n* @method Phaser.Point.divide\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.divide = function (a, b, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    out.x = a.x / b.x;\n    out.y = a.y / b.y;\n\n    return out;\n\n};\n\n/**\n* Determines whether the two given Point objects are equal. They are considered equal if they have the same x and y values.\n*\n* @method Phaser.Point.equals\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @return {boolean} A value of true if the Points are equal, otherwise false.\n*/\nPhaser.Point.equals = function (a, b) {\n\n    return (a.x === b.x && a.y === b.y);\n\n};\n\n/**\n* Returns the angle between two Point objects.\n*\n* @method Phaser.Point.angle\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @return {number} The angle between the two Points.\n*/\nPhaser.Point.angle = function (a, b) {\n\n    return Math.atan2(a.x * b.y - a.y * b.x, a.x * b.x + a.y * b.y);\n\n};\n\n/**\n* Returns the angle squared between two Point objects.\n*\n* @method Phaser.Point.angleSq\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @return {number} The angle squared between the two Points.\n*/\nPhaser.Point.angleSq = function (a, b) {\n\n    return a.subtract(b).angle(b.subtract(a));\n\n};\n\n/**\n* Creates a negative Point.\n*\n* @method Phaser.Point.negative\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.negative = function (a, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    return out.setTo(-a.x, -a.y);\n\n};\n\n/**\n* Adds two 2D Points together and multiplies the result by the given scalar.\n* \n* @method Phaser.Point.multiplyAdd\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {number} s - The scaling value.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.multiplyAdd = function (a, b, s, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    return out.setTo(a.x + b.x * s, a.y + b.y * s);\n\n};\n\n/**\n* Interpolates the two given Points, based on the `f` value (between 0 and 1) and returns a new Point.\n* \n* @method Phaser.Point.interpolate\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {number} f - The level of interpolation between the two points. Indicates where the new point will be, along the line between pt1 and pt2. If f=1, pt1 is returned; if f=0, pt2 is returned.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.interpolate = function (a, b, f, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    return out.setTo(a.x + (b.x - a.x) * f, a.y + (b.y - a.y) * f);\n\n};\n\n/**\n* Return a perpendicular vector (90 degrees rotation)\n*\n* @method Phaser.Point.perp\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.perp = function (a, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    return out.setTo(-a.y, a.x);\n\n};\n\n/**\n* Return a perpendicular vector (-90 degrees rotation)\n*\n* @method Phaser.Point.rperp\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.rperp = function (a, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    return out.setTo(a.y, -a.x);\n\n};\n\n/**\n* Returns the distance of this Point object to the given object (can be a Circle, Point or anything with x/y properties).\n*\n* @method Phaser.Point.distance\n* @param {object} a - The target object. Must have visible x and y properties that represent the center of the object.\n* @param {object} b - The target object. Must have visible x and y properties that represent the center of the object.\n* @param {boolean} [round] - Round the distance to the nearest integer (default false).\n* @return {number} The distance between this Point object and the destination Point object.\n*/\nPhaser.Point.distance = function (a, b, round) {\n\n    if (typeof round === \"undefined\") { round = false; }\n\n    if (round)\n    {\n        return Phaser.Math.distanceRounded(a.x, a.y, b.x, b.y);\n    }\n    else\n    {\n        return Phaser.Math.distance(a.x, a.y, b.x, b.y);\n    }\n\n};\n\n/**\n* Project two Points onto another Point.\n* \n* @method Phaser.Point.project\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.project = function (a, b, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    var amt = a.dot(b) / b.getMagnitudeSq();\n\n    if (amt !== 0)\n    {\n        out.setTo(amt * b.x, amt * b.y);\n    }\n\n    return out;\n\n};\n\n/**\n* Project two Points onto a Point of unit length.\n* \n* @method Phaser.Point.projectUnit\n* @param {Phaser.Point} a - The first Point object.\n* @param {Phaser.Point} b - The second Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.projectUnit = function (a, b, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    var amt = a.dot(b);\n\n    if (amt !== 0)\n    {\n        out.setTo(amt * b.x, amt * b.y);\n    }\n\n    return out;\n\n};\n\n/**\n* Right-hand normalize (make unit length) a Point.\n*\n* @method Phaser.Point.normalRightHand\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.normalRightHand = function (a, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    return out.setTo(a.y * -1, a.x);\n\n};\n\n/**\n* Normalize (make unit length) a Point.\n*\n* @method Phaser.Point.normalize\n* @param {Phaser.Point} a - The Point object.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.normalize = function (a, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    var m = a.getMagnitude();\n\n    if (m !== 0)\n    {\n        out.setTo(a.x / m, a.y / m);\n    }\n\n    return out;\n\n};\n\n/**\n* Rotates a Point around the x/y coordinates given to the desired angle.\n*\n* @method Phaser.Point.rotate\n* @param {Phaser.Point} a - The Point object to rotate.\n* @param {number} x - The x coordinate of the anchor point\n* @param {number} y - The y coordinate of the anchor point\n* @param {number} angle - The angle in radians (unless asDegrees is true) to rotate the Point to.\n* @param {boolean} [asDegrees=false] - Is the given rotation in radians (false) or degrees (true)?\n* @param {number} [distance] - An optional distance constraint between the Point and the anchor.\n* @return {Phaser.Point} The modified point object.\n*/\nPhaser.Point.rotate = function (a, x, y, angle, asDegrees, distance) {\n\n    asDegrees = asDegrees || false;\n    distance = distance || null;\n\n    if (asDegrees)\n    {\n        angle = Phaser.Math.degToRad(angle);\n    }\n\n    //  Get distance from origin (cx/cy) to this point\n    if (distance === null)\n    {\n        distance = Math.sqrt(((x - a.x) * (x - a.x)) + ((y - a.y) * (y - a.y)));\n    }\n\n    return a.setTo(x + distance * Math.cos(angle), y + distance * Math.sin(angle));\n\n};\n\n/**\n* Calculates centroid (or midpoint) from an array of points. If only one point is provided, that point is returned.\n*\n* @method Phaser.Point.centroid\n* @param {Phaser.Point[]} points - The array of one or more points.\n* @param {Phaser.Point} [out] - Optional Point to store the value in, if not supplied a new Point object will be created.\n* @return {Phaser.Point} The new Point object.\n*/\nPhaser.Point.centroid = function (points, out) {\n\n    if (typeof out === \"undefined\") { out = new Phaser.Point(); }\n\n    if (Object.prototype.toString.call(points) !== '[object Array]')\n    {\n        throw new Error(\"Phaser.Point. Parameter 'points' must be an array\");\n    }\n\n    var pointslength = points.length;\n\n    if (pointslength < 1)\n    {\n        throw new Error(\"Phaser.Point. Parameter 'points' array must not be empty\");\n    }\n\n    if (pointslength === 1)\n    {\n        out.copyFrom(points[0]);\n        return out;\n    }\n\n    for (var i = 0; i < pointslength; i++)\n    {\n        Phaser.Point.add(out, points[i], out);\n    }\n\n    out.divide(pointslength, pointslength);\n\n    return out;\n\n};\n\n//   Because PIXI uses its own Point, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Point = Phaser.Point;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Rectangle object with the top-left corner specified by the x and y parameters and with the specified width and height parameters. If you call this function without parameters, a Rectangle with x, y, width, and height properties set to 0 is created.\n*\n* @class Phaser.Rectangle\n* @constructor\n* @param {number} x - The x coordinate of the top-left corner of the Rectangle.\n* @param {number} y - The y coordinate of the top-left corner of the Rectangle.\n* @param {number} width - The width of the Rectangle.\n* @param {number} height - The height of the Rectangle.\n* @return {Phaser.Rectangle} This Rectangle object.\n*/\nPhaser.Rectangle = function (x, y, width, height) {\n\n    x = x || 0;\n    y = y || 0;\n    width = width || 0;\n    height = height || 0;\n\n    /**\n    * @property {number} x - The x coordinate of the top-left corner of the Rectangle.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y coordinate of the top-left corner of the Rectangle.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} width - The width of the Rectangle.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height of the Rectangle.\n    */\n    this.height = height;\n\n};\n\nPhaser.Rectangle.prototype = {\n\n    /**\n    * Adjusts the location of the Rectangle object, as determined by its top-left corner, by the specified amounts.\n    * @method Phaser.Rectangle#offset\n    * @param {number} dx - Moves the x value of the Rectangle object by this amount.\n    * @param {number} dy - Moves the y value of the Rectangle object by this amount.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    offset: function (dx, dy) {\n\n        this.x += dx;\n        this.y += dy;\n\n        return this;\n\n    },\n\n    /**\n    * Adjusts the location of the Rectangle object using a Point object as a parameter. This method is similar to the Rectangle.offset() method, except that it takes a Point object as a parameter.\n    * @method Phaser.Rectangle#offsetPoint\n    * @param {Phaser.Point} point - A Point object to use to offset this Rectangle object.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    offsetPoint: function (point) {\n\n        return this.offset(point.x, point.y);\n\n    },\n\n    /**\n    * Sets the members of Rectangle to the specified values.\n    * @method Phaser.Rectangle#setTo\n    * @param {number} x - The x coordinate of the top-left corner of the Rectangle.\n    * @param {number} y - The y coordinate of the top-left corner of the Rectangle.\n    * @param {number} width - The width of the Rectangle in pixels.\n    * @param {number} height - The height of the Rectangle in pixels.\n    * @return {Phaser.Rectangle} This Rectangle object\n    */\n    setTo: function (x, y, width, height) {\n\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        return this;\n\n    },\n\n    /**\n    * Runs Math.floor() on both the x and y values of this Rectangle.\n    * @method Phaser.Rectangle#floor\n    */\n    floor: function () {\n\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n\n    },\n\n    /**\n    * Runs Math.floor() on the x, y, width and height values of this Rectangle.\n    * @method Phaser.Rectangle#floorAll\n    */\n    floorAll: function () {\n\n        this.x = Math.floor(this.x);\n        this.y = Math.floor(this.y);\n        this.width = Math.floor(this.width);\n        this.height = Math.floor(this.height);\n\n    },\n\n    /**\n    * Copies the x, y, width and height properties from any given object to this Rectangle.\n    * @method Phaser.Rectangle#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y, source.width, source.height);\n\n    },\n\n    /**\n    * Copies the x, y, width and height properties from this Rectangle to any given object.\n    * @method Phaser.Rectangle#copyTo\n    * @param {any} source - The object to copy to.\n    * @return {object} This object.\n    */\n    copyTo: function (dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n        dest.width = this.width;\n        dest.height = this.height;\n\n        return dest;\n\n    },\n\n    /**\n    * Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.\n    * @method Phaser.Rectangle#inflate\n    * @param {number} dx - The amount to be added to the left side of the Rectangle.\n    * @param {number} dy - The amount to be added to the bottom side of the Rectangle.\n    * @return {Phaser.Rectangle} This Rectangle object.\n    */\n    inflate: function (dx, dy) {\n\n        return Phaser.Rectangle.inflate(this, dx, dy);\n\n    },\n\n    /**\n    * The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.\n    * @method Phaser.Rectangle#size\n    * @param {Phaser.Point} [output] - Optional Point object. If given the values will be set into the object, otherwise a brand new Point object will be created and returned.\n    * @return {Phaser.Point} The size of the Rectangle object.\n    */\n    size: function (output) {\n\n        return Phaser.Rectangle.size(this, output);\n\n    },\n\n    /**\n    * Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.\n    * @method Phaser.Rectangle#clone\n    * @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.\n    * @return {Phaser.Rectangle}\n    */\n    clone: function (output) {\n\n        return Phaser.Rectangle.clone(this, output);\n\n    },\n\n    /**\n    * Determines whether the specified coordinates are contained within the region defined by this Rectangle object.\n    * @method Phaser.Rectangle#contains\n    * @param {number} x - The x coordinate of the point to test.\n    * @param {number} y - The y coordinate of the point to test.\n    * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n    */\n    contains: function (x, y) {\n\n        return Phaser.Rectangle.contains(this, x, y);\n\n    },\n\n    /**\n    * Determines whether the first Rectangle object is fully contained within the second Rectangle object.\n    * A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.\n    * @method Phaser.Rectangle#containsRect\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n    */\n    containsRect: function (b) {\n\n        return Phaser.Rectangle.containsRect(this, b);\n\n    },\n\n    /**\n    * Determines whether the two Rectangles are equal.\n    * This method compares the x, y, width and height properties of each Rectangle.\n    * @method Phaser.Rectangle#equals\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @return {boolean} A value of true if the two Rectangles have exactly the same values for the x, y, width and height properties; otherwise false.\n    */\n    equals: function (b) {\n\n        return Phaser.Rectangle.equals(this, b);\n\n    },\n\n    /**\n    * If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.\n    * @method Phaser.Rectangle#intersection\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @param {Phaser.Rectangle} out - Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n    * @return {Phaser.Rectangle} A Rectangle object that equals the area of intersection. If the Rectangles do not intersect, this method returns an empty Rectangle object; that is, a Rectangle with its x, y, width, and height properties set to 0.\n    */\n    intersection: function (b, out) {\n\n        return Phaser.Rectangle.intersection(this, b, out);\n\n    },\n\n    /**\n    * Determines whether the two Rectangles intersect with each other.\n    * This method checks the x, y, width, and height properties of the Rectangles.\n    * @method Phaser.Rectangle#intersects\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0.\n    * @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.\n    */\n    intersects: function (b, tolerance) {\n\n        return Phaser.Rectangle.intersects(this, b, tolerance);\n\n    },\n\n    /**\n    * Determines whether the object specified intersects (overlaps) with the given values.\n    * @method Phaser.Rectangle#intersectsRaw\n    * @param {number} left - Description.\n    * @param {number} right - Description.\n    * @param {number} top - Description.\n    * @param {number} bottomt - Description.\n    * @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0\n    * @return {boolean} A value of true if the specified object intersects with the Rectangle; otherwise false.\n    */\n    intersectsRaw: function (left, right, top, bottom, tolerance) {\n\n        return Phaser.Rectangle.intersectsRaw(this, left, right, top, bottom, tolerance);\n\n    },\n\n    /**\n    * Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.\n    * @method Phaser.Rectangle#union\n    * @param {Phaser.Rectangle} b - The second Rectangle object.\n    * @param {Phaser.Rectangle} [out] - Optional Rectangle object. If given the new values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n    * @return {Phaser.Rectangle} A Rectangle object that is the union of the two Rectangles.\n    */\n    union: function (b, out) {\n\n        return Phaser.Rectangle.union(this, b, out);\n\n    },\n\n    /**\n    * Returns a string representation of this object.\n    * @method Phaser.Rectangle#toString\n    * @return {string} A string representation of the instance.\n    */\n    toString: function () {\n\n        return \"[{Rectangle (x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \" empty=\" + this.empty + \")}]\";\n\n    }\n\n};\n\n/**\n* @name Phaser.Rectangle#halfWidth\n* @property {number} halfWidth - Half of the width of the Rectangle.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"halfWidth\", {\n\n    get: function () {\n        return Math.round(this.width / 2);\n    }\n\n});\n\n/**\n* @name Phaser.Rectangle#halfHeight\n* @property {number} halfHeight - Half of the height of the Rectangle.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"halfHeight\", {\n\n    get: function () {\n        return Math.round(this.height / 2);\n    }\n\n});\n\n/**\n* The sum of the y and height properties. Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.\n* @name Phaser.Rectangle#bottom\n* @property {number} bottom - The sum of the y and height properties.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"bottom\", {\n\n    get: function () {\n        return this.y + this.height;\n    },\n\n    set: function (value) {\n        if (value <= this.y) {\n            this.height = 0;\n        } else {\n            this.height = (this.y - value);\n        }\n    }\n\n});\n\n/**\n* The location of the Rectangles bottom right corner as a Point object.\n* @name Phaser.Rectangle#bottom\n* @property {Phaser.Point} bottomRight - Gets or sets the location of the Rectangles bottom right corner as a Point object.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"bottomRight\", {\n\n    get: function () {\n        return new Phaser.Point(this.right, this.bottom);\n    },\n\n    set: function (value) {\n        this.right = value.x;\n        this.bottom = value.y;\n    }\n\n});\n\n/**\n* The x coordinate of the left of the Rectangle. Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.\n* @name Phaser.Rectangle#left\n* @property {number} left - The x coordinate of the left of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"left\", {\n\n    get: function () {\n        return this.x;\n    },\n\n    set: function (value) {\n        if (value >= this.right) {\n            this.width = 0;\n        } else {\n            this.width = this.right - value;\n        }\n        this.x = value;\n    }\n\n});\n\n/**\n* The sum of the x and width properties. Changing the right property of a Rectangle object has no effect on the x, y and height properties, however it does affect the width property.\n* @name Phaser.Rectangle#right\n* @property {number} right - The sum of the x and width properties.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"right\", {\n\n    get: function () {\n        return this.x + this.width;\n    },\n\n    set: function (value) {\n        if (value <= this.x) {\n            this.width = 0;\n        } else {\n            this.width = this.x + value;\n        }\n    }\n\n});\n\n/**\n* The volume of the Rectangle derived from width * height.\n* @name Phaser.Rectangle#volume\n* @property {number} volume - The volume of the Rectangle derived from width * height.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"volume\", {\n\n    get: function () {\n        return this.width * this.height;\n    }\n\n});\n\n/**\n* The perimeter size of the Rectangle. This is the sum of all 4 sides.\n* @name Phaser.Rectangle#perimeter\n* @property {number} perimeter - The perimeter size of the Rectangle. This is the sum of all 4 sides.\n* @readonly\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"perimeter\", {\n\n    get: function () {\n        return (this.width * 2) + (this.height * 2);\n    }\n\n});\n\n/**\n* The x coordinate of the center of the Rectangle.\n* @name Phaser.Rectangle#centerX\n* @property {number} centerX - The x coordinate of the center of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"centerX\", {\n\n    get: function () {\n        return this.x + this.halfWidth;\n    },\n\n    set: function (value) {\n        this.x = value - this.halfWidth;\n    }\n\n});\n\n/**\n* The y coordinate of the center of the Rectangle.\n* @name Phaser.Rectangle#centerY\n* @property {number} centerY - The y coordinate of the center of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"centerY\", {\n\n    get: function () {\n        return this.y + this.halfHeight;\n    },\n\n    set: function (value) {\n        this.y = value - this.halfHeight;\n    }\n\n});\n\n/**\n* The y coordinate of the top of the Rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties.\n* However it does affect the height property, whereas changing the y value does not affect the height property.\n* @name Phaser.Rectangle#top\n* @property {number} top - The y coordinate of the top of the Rectangle.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"top\", {\n\n    get: function () {\n        return this.y;\n    },\n\n    set: function (value) {\n        if (value >= this.bottom) {\n            this.height = 0;\n            this.y = value;\n        } else {\n            this.height = (this.bottom - value);\n        }\n    }\n\n});\n\n/**\n* The location of the Rectangles top left corner as a Point object.\n* @name Phaser.Rectangle#topLeft\n* @property {Phaser.Point} topLeft - The location of the Rectangles top left corner as a Point object.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"topLeft\", {\n\n    get: function () {\n        return new Phaser.Point(this.x, this.y);\n    },\n\n    set: function (value) {\n        this.x = value.x;\n        this.y = value.y;\n    }\n\n});\n\n/**\n* Determines whether or not this Rectangle object is empty. A Rectangle object is empty if its width or height is less than or equal to 0.\n* If set to true then all of the Rectangle properties are set to 0.\n* @name Phaser.Rectangle#empty\n* @property {boolean} empty - Gets or sets the Rectangles empty state.\n*/\nObject.defineProperty(Phaser.Rectangle.prototype, \"empty\", {\n\n    get: function () {\n        return (!this.width || !this.height);\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            this.setTo(0, 0, 0, 0);\n        }\n\n    }\n\n});\n\nPhaser.Rectangle.prototype.constructor = Phaser.Rectangle;\n\n/**\n* Increases the size of the Rectangle object by the specified amounts. The center point of the Rectangle object stays the same, and its size increases to the left and right by the dx value, and to the top and the bottom by the dy value.\n* @method Phaser.Rectangle.inflate\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {number} dx - The amount to be added to the left side of the Rectangle.\n* @param {number} dy - The amount to be added to the bottom side of the Rectangle.\n* @return {Phaser.Rectangle} This Rectangle object.\n*/\nPhaser.Rectangle.inflate = function (a, dx, dy) {\n\n    a.x -= dx;\n    a.width += 2 * dx;\n    a.y -= dy;\n    a.height += 2 * dy;\n\n    return a;\n\n};\n\n/**\n* Increases the size of the Rectangle object. This method is similar to the Rectangle.inflate() method except it takes a Point object as a parameter.\n* @method Phaser.Rectangle.inflatePoint\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Point} point - The x property of this Point object is used to increase the horizontal dimension of the Rectangle object. The y property is used to increase the vertical dimension of the Rectangle object.\n* @return {Phaser.Rectangle} The Rectangle object.\n*/\nPhaser.Rectangle.inflatePoint = function (a, point) {\n\n    return Phaser.Rectangle.inflate(a, point.x, point.y);\n\n};\n\n/**\n* The size of the Rectangle object, expressed as a Point object with the values of the width and height properties.\n* @method Phaser.Rectangle.size\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Point} [output] - Optional Point object. If given the values will be set into the object, otherwise a brand new Point object will be created and returned.\n* @return {Phaser.Point} The size of the Rectangle object\n*/\nPhaser.Rectangle.size = function (a, output) {\n\n    if (typeof output === \"undefined\")\n    {\n        output = new Phaser.Point(a.width, a.height);\n    }\n    else\n    {\n        output.setTo(a.width, a.height);\n    }\n\n    return output;\n\n};\n\n/**\n* Returns a new Rectangle object with the same values for the x, y, width, and height properties as the original Rectangle object.\n* @method Phaser.Rectangle.clone\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the values will be set into the object, otherwise a brand new Rectangle object will be created and returned.\n* @return {Phaser.Rectangle}\n*/\nPhaser.Rectangle.clone = function (a, output) {\n\n    if (typeof output === \"undefined\")\n    {\n        output = new Phaser.Rectangle(a.x, a.y, a.width, a.height);\n    }\n    else\n    {\n        output.setTo(a.x, a.y, a.width, a.height);\n    }\n\n    return output;\n\n};\n\n/**\n* Determines whether the specified coordinates are contained within the region defined by this Rectangle object.\n* @method Phaser.Rectangle.contains\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {number} x - The x coordinate of the point to test.\n* @param {number} y - The y coordinate of the point to test.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.contains = function (a, x, y) {\n\n    if (a.width <= 0 || a.height <= 0)\n    {\n        return false;\n    }\n\n    return (x >= a.x && x <= a.right && y >= a.y && y <= a.bottom);\n\n};\n\n/**\n* Determines whether the specified coordinates are contained within the region defined by the given raw values.\n* @method Phaser.Rectangle.containsRaw\n* @param {number} rx - The x coordinate of the top left of the area.\n* @param {number} ry - The y coordinate of the top left of the area.\n* @param {number} rw - The width of the area.\n* @param {number} rh - The height of the area.\n* @param {number} x - The x coordinate of the point to test.\n* @param {number} y - The y coordinate of the point to test.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.containsRaw = function (rx, ry, rw, rh, x, y) {\n\n    return (x >= rx && x <= (rx + rw) && y >= ry && y <= (ry + rh));\n\n};\n\n/**\n* Determines whether the specified point is contained within the rectangular region defined by this Rectangle object. This method is similar to the Rectangle.contains() method, except that it takes a Point object as a parameter.\n* @method Phaser.Rectangle.containsPoint\n* @param {Phaser.Rectangle} a - The Rectangle object.\n* @param {Phaser.Point} point - The point object being checked. Can be Point or any object with .x and .y values.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.containsPoint = function (a, point) {\n\n    return Phaser.Rectangle.contains(a, point.x, point.y);\n\n};\n\n/**\n* Determines whether the first Rectangle object is fully contained within the second Rectangle object.\n* A Rectangle object is said to contain another if the second Rectangle object falls entirely within the boundaries of the first.\n* @method Phaser.Rectangle.containsRect\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @return {boolean} A value of true if the Rectangle object contains the specified point; otherwise false.\n*/\nPhaser.Rectangle.containsRect = function (a, b) {\n\n    //  If the given rect has a larger volume than this one then it can never contain it\n    if (a.volume > b.volume)\n    {\n        return false;\n    }\n\n    return (a.x >= b.x && a.y >= b.y && a.right <= b.right && a.bottom <= b.bottom);\n\n};\n\n/**\n* Determines whether the two Rectangles are equal.\n* This method compares the x, y, width and height properties of each Rectangle.\n* @method Phaser.Rectangle.equals\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @return {boolean} A value of true if the two Rectangles have exactly the same values for the x, y, width and height properties; otherwise false.\n*/\nPhaser.Rectangle.equals = function (a, b) {\n\n    return (a.x == b.x && a.y == b.y && a.width == b.width && a.height == b.height);\n\n};\n\n/**\n* If the Rectangle object specified in the toIntersect parameter intersects with this Rectangle object, returns the area of intersection as a Rectangle object. If the Rectangles do not intersect, this method returns an empty Rectangle object with its properties set to 0.\n* @method Phaser.Rectangle.intersection\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the intersection values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n* @return {Phaser.Rectangle} A Rectangle object that equals the area of intersection. If the Rectangles do not intersect, this method returns an empty Rectangle object; that is, a Rectangle with its x, y, width, and height properties set to 0.\n*/\nPhaser.Rectangle.intersection = function (a, b, output) {\n\n    if (typeof output === \"undefined\")\n    {\n        output = new Phaser.Rectangle();\n    }\n\n    if (Phaser.Rectangle.intersects(a, b))\n    {\n        output.x = Math.max(a.x, b.x);\n        output.y = Math.max(a.y, b.y);\n        output.width = Math.min(a.right, b.right) - output.x;\n        output.height = Math.min(a.bottom, b.bottom) - output.y;\n    }\n\n    return output;\n\n};\n\n/**\n* Determines whether the two Rectangles intersect with each other.\n* This method checks the x, y, width, and height properties of the Rectangles.\n* @method Phaser.Rectangle.intersects\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @return {boolean} A value of true if the specified object intersects with this Rectangle object; otherwise false.\n*/\nPhaser.Rectangle.intersects = function (a, b) {\n\n    if (a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0)\n    {\n        return false;\n    }\n\n    return !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom);\n\n};\n\n/**\n* Determines whether the object specified intersects (overlaps) with the given values.\n* @method Phaser.Rectangle.intersectsRaw\n* @param {number} left - Description.\n* @param {number} right - Description.\n* @param {number} top - Description.\n* @param {number} bottom - Description.\n* @param {number} tolerance - A tolerance value to allow for an intersection test with padding, default to 0\n* @return {boolean} A value of true if the specified object intersects with the Rectangle; otherwise false.\n*/\nPhaser.Rectangle.intersectsRaw = function (a, left, right, top, bottom, tolerance) {\n\n    if (typeof tolerance === \"undefined\") { tolerance = 0; }\n\n    return !(left > a.right + tolerance || right < a.left - tolerance || top > a.bottom + tolerance || bottom < a.top - tolerance);\n\n};\n\n/**\n* Adds two Rectangles together to create a new Rectangle object, by filling in the horizontal and vertical space between the two Rectangles.\n* @method Phaser.Rectangle.union\n* @param {Phaser.Rectangle} a - The first Rectangle object.\n* @param {Phaser.Rectangle} b - The second Rectangle object.\n* @param {Phaser.Rectangle} [output] - Optional Rectangle object. If given the new values will be set into this object, otherwise a brand new Rectangle object will be created and returned.\n* @return {Phaser.Rectangle} A Rectangle object that is the union of the two Rectangles.\n*/\nPhaser.Rectangle.union = function (a, b, output) {\n\n    if (typeof output === \"undefined\")\n    {\n        output = new Phaser.Rectangle();\n    }\n\n    return output.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top));\n\n};\n\n//   Because PIXI uses its own Rectangle, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Rectangle = Phaser.Rectangle;\nPIXI.EmptyRectangle = new Phaser.Rectangle(0, 0, 0, 0);\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Line object with a start and an end point.\n* @class Line\n* @classdesc Phaser - Line\n* @constructor\n* @param {number} [x1=0] - The x coordinate of the start of the line.\n* @param {number} [y1=0] - The y coordinate of the start of the line.\n* @param {number} [x2=0] - The x coordinate of the end of the line.\n* @param {number} [y2=0] - The y coordinate of the end of the line.\n* @return {Phaser.Line} This line object\n*/\nPhaser.Line = function (x1, y1, x2, y2) {\n\n    x1 = x1 || 0;\n    y1 = y1 || 0;\n    x2 = x2 || 0;\n    y2 = y2 || 0;\n\n    /**\n    * @property {Phaser.Point} start - The start point of the line.\n    */\n    this.start = new Phaser.Point(x1, y1);\n\n    /**\n    * @property {Phaser.Point} end - The end point of the line.\n    */\n    this.end = new Phaser.Point(x2, y2);\n\n};\n\nPhaser.Line.prototype = {\n\n    /**\n    * Sets the components of the Line to the specified values.\n    * @method Phaser.Line#setTo\n    * @param {number} [x1=0] - The x coordinate of the start of the line.\n    * @param {number} [y1=0] - The y coordinate of the start of the line.\n    * @param {number} [x2=0] - The x coordinate of the end of the line.\n    * @param {number} [y2=0] - The y coordinate of the end of the line.\n    * @return {Phaser.Line} This line object\n    */\n    setTo: function (x1, y1, x2, y2) {\n\n        this.start.setTo(x1, y1);\n        this.end.setTo(x2, y2);\n\n        return this;\n\n    },\n\n    /**\n    * Sets the line to match the x/y coordinates of the two given sprites.\n    * Can optionally be calculated from their center coordinates.\n    * @method Phaser.Line#fromSprite\n    * @param {Phaser.Sprite} startSprite - The coordinates of this Sprite will be set to the Line.start point.\n    * @param {Phaser.Sprite} endSprite - The coordinates of this Sprite will be set to the Line.start point.\n    * @param {boolean} [useCenter=false] - If true it will use startSprite.center.x, if false startSprite.x. Note that Sprites don't have a center property by default, so only enable if you've over-ridden your Sprite with a custom class.\n    * @return {Phaser.Line} This line object\n    */\n    fromSprite: function (startSprite, endSprite, useCenter) {\n\n        if (typeof useCenter === 'undefined') { useCenter = false; }\n\n        if (useCenter)\n        {\n            return this.setTo(startSprite.center.x, startSprite.center.y, endSprite.center.x, endSprite.center.y);\n        }\n        else\n        {\n            return this.setTo(startSprite.x, startSprite.y, endSprite.x, endSprite.y);\n        }\n\n    },\n\n    /**\n    * Checks for intersection between this line and another Line.\n    * If asSegment is true it will check for segment intersection. If asSegment is false it will check for line intersection.\n    * Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.\n    *\n    * @method Phaser.Line#intersects\n    * @param {Phaser.Line} line - The line to check against this one.\n    * @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.\n    * @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.\n    * @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.\n    */\n    intersects: function (line, asSegment, result) {\n\n        return Phaser.Line.intersectsPoints(this.start, this.end, line.start, line.end, asSegment, result);\n\n    },\n\n    /**\n    * Tests if the given coordinates fall on this line. See pointOnSegment to test against just the line segment.\n    * @method Phaser.Line#pointOnLine\n    * @param {number} x - The line to check against this one.\n    * @param {number} y - The line to check against this one.\n    * @return {boolean} True if the point is on the line, false if not.\n    */\n    pointOnLine: function (x, y) {\n\n        return ((x - this.start.x) * (this.end.y - this.end.y) === (this.end.x - this.start.x) * (y - this.end.y));\n\n    },\n\n    /**\n    * Tests if the given coordinates fall on this line and within the segment. See pointOnLine to test against just the line.\n    * @method Phaser.Line#pointOnSegment\n    * @param {number} x - The line to check against this one.\n    * @param {number} y - The line to check against this one.\n    * @return {boolean} True if the point is on the line and segment, false if not.\n    */\n    pointOnSegment: function (x, y) {\n\n        var xMin = Math.min(this.start.x, this.end.x);\n        var xMax = Math.max(this.start.x, this.end.x);\n        var yMin = Math.min(this.start.y, this.end.y);\n        var yMax = Math.max(this.start.y, this.end.y);\n\n        return (this.pointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax));\n\n    },\n\n    /**\n    * Using Bresenham's line algorithm this will return an array of all coordinates on this line.\n    * The start and end points are rounded before this runs as the algorithm works on integers.\n    *\n    * @method Phaser.Line#coordinatesOnLine\n    * @param {number} [stepRate=1] - How many steps will we return? 1 = every coordinate on the line, 2 = every other coordinate, etc.\n    * @param {array} [results] - The array to store the results in. If not provided a new one will be generated.\n    * @return {array} An array of coordinates.\n    */\n    coordinatesOnLine: function (stepRate, results) {\n\n        if (typeof stepRate === 'undefined') { stepRate = 1; }\n        if (typeof results === 'undefined') { results = []; }\n\n        var x1 = Math.round(this.start.x);\n        var y1 = Math.round(this.start.y);\n        var x2 = Math.round(this.end.x);\n        var y2 = Math.round(this.end.y);\n\n        var dx = Math.abs(x2 - x1);\n        var dy = Math.abs(y2 - y1);\n        var sx = (x1 < x2) ? 1 : -1;\n        var sy = (y1 < y2) ? 1 : -1;\n        var err = dx - dy;\n\n        results.push([x1, y1]);\n\n        var i = 1;\n\n        while (!((x1 == x2) && (y1 == y2)))\n        {\n            var e2 = err << 1;\n\n            if (e2 > -dy)\n            {\n                err -= dy;\n                x1 += sx;\n            }\n\n            if (e2 < dx)\n            {\n                err += dx;\n                y1 += sy;\n            }\n\n            if (i % stepRate === 0)\n            {\n                results.push([x1, y1]);\n            }\n\n            i++;\n\n        }\n\n        return results;\n\n    }\n\n};\n\n/**\n* @name Phaser.Line#length\n* @property {number} length - Gets the length of the line segment.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"length\", {\n\n    get: function () {\n        return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y));\n    }\n\n});\n\n/**\n* @name Phaser.Line#angle\n* @property {number} angle - Gets the angle of the line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"angle\", {\n\n    get: function () {\n        return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#slope\n* @property {number} slope - Gets the slope of the line (y/x).\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"slope\", {\n\n    get: function () {\n        return (this.end.y - this.start.y) / (this.end.x - this.start.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#perpSlope\n* @property {number} perpSlope - Gets the perpendicular slope of the line (x/y).\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"perpSlope\", {\n\n    get: function () {\n        return -((this.end.x - this.start.x) / (this.end.y - this.start.y));\n    }\n\n});\n\n/**\n* @name Phaser.Line#x\n* @property {number} x - Gets the x coordinate of the top left of the bounds around this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"x\", {\n\n    get: function () {\n        return Math.min(this.start.x, this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#y\n* @property {number} y - Gets the y coordinate of the top left of the bounds around this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"y\", {\n\n    get: function () {\n        return Math.min(this.start.y, this.end.y);\n    }\n\n});\n\n/**\n* @name Phaser.Line#left\n* @property {number} left - Gets the left-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"left\", {\n\n    get: function () {\n        return Math.min(this.start.x, this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#right\n* @property {number} right - Gets the right-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"right\", {\n\n    get: function () {\n        return Math.max(this.start.x, this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#top\n* @property {number} top - Gets the top-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"top\", {\n\n    get: function () {\n        return Math.min(this.start.y, this.end.y);\n    }\n\n});\n\n/**\n* @name Phaser.Line#bottom\n* @property {number} bottom - Gets the bottom-most point of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"bottom\", {\n\n    get: function () {\n        return Math.max(this.start.y, this.end.y);\n    }\n\n});\n\n/**\n* @name Phaser.Line#width\n* @property {number} width - Gets the width of this bounds of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"width\", {\n\n    get: function () {\n        return Math.abs(this.start.x - this.end.x);\n    }\n\n});\n\n/**\n* @name Phaser.Line#height\n* @property {number} height - Gets the height of this bounds of this line.\n* @readonly\n*/\nObject.defineProperty(Phaser.Line.prototype, \"height\", {\n\n    get: function () {\n        return Math.abs(this.start.y - this.end.y);\n    }\n\n});\n\n/**\n* Checks for intersection between two lines as defined by the given start and end points.\n* If asSegment is true it will check for line segment intersection. If asSegment is false it will check for line intersection.\n* Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.\n* Adapted from code by Keith Hair\n*\n* @method Phaser.Line.intersectsPoints\n* @param {Phaser.Point} a - The start of the first Line to be checked.\n* @param {Phaser.Point} b - The end of the first line to be checked.\n* @param {Phaser.Point} e - The start of the second Line to be checked.\n* @param {Phaser.Point} f - The end of the second line to be checked.\n* @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.\n* @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.\n* @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.\n*/\nPhaser.Line.intersectsPoints = function (a, b, e, f, asSegment, result) {\n\n    if (typeof asSegment === 'undefined') { asSegment = true; }\n    if (typeof result === 'undefined') { result = new Phaser.Point(); }\n\n    var a1 = b.y - a.y;\n    var a2 = f.y - e.y;\n    var b1 = a.x - b.x;\n    var b2 = e.x - f.x;\n    var c1 = (b.x * a.y) - (a.x * b.y);\n    var c2 = (f.x * e.y) - (e.x * f.y);\n    var denom = (a1 * b2) - (a2 * b1);\n\n    if (denom === 0)\n    {\n        return null;\n    }\n\n    result.x = ((b1 * c2) - (b2 * c1)) / denom;\n    result.y = ((a2 * c1) - (a1 * c2)) / denom;\n\n    if (asSegment)\n    {\n        if (Math.pow((result.x - b.x) + (result.y - b.y), 2) > Math.pow((a.x - b.x) + (a.y - b.y), 2))\n        {\n            return null;\n        }\n\n        if (Math.pow((result.x - a.x) + (result.y - a.y), 2) > Math.pow((a.x - b.x) + (a.y - b.y), 2))\n        {\n            return null;\n        }\n\n        if (Math.pow((result.x - f.x) + (result.y - f.y), 2) > Math.pow((e.x - f.x) + (e.y - f.y), 2))\n        {\n            return null;\n        }\n\n        if (Math.pow((result.x - e.x) + (result.y - e.y), 2) > Math.pow((e.x - f.x) + (e.y - f.y), 2))\n        {\n            return null;\n        }\n    }\n\n    return result;\n\n};\n\n/**\n* Checks for intersection between two lines.\n* If asSegment is true it will check for segment intersection.\n* If asSegment is false it will check for line intersection.\n* Returns the intersection segment of AB and EF as a Point, or null if there is no intersection.\n* Adapted from code by Keith Hair\n*\n* @method Phaser.Line.intersects\n* @param {Phaser.Line} a - The first Line to be checked.\n* @param {Phaser.Line} b - The second Line to be checked.\n* @param {boolean} [asSegment=true] - If true it will check for segment intersection, otherwise full line intersection.\n* @param {Phaser.Point} [result] - A Point object to store the result in, if not given a new one will be created.\n* @return {Phaser.Point} The intersection segment of the two lines as a Point, or null if there is no intersection.\n*/\nPhaser.Line.intersects = function (a, b, asSegment, result) {\n\n    return Phaser.Line.intersectsPoints(a.start, a.end, b.start, b.end, asSegment, result);\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @author       Chad Engler <chad@pantherdev.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a Ellipse object. A curve on a plane surrounding two focal points.\n* @class Ellipse\n* @classdesc Phaser - Ellipse\n* @constructor\n* @param {number} [x=0] - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.\n* @param {number} [y=0] - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.\n* @param {number} [width=0] - The overall width of this ellipse.\n* @param {number} [height=0] - The overall height of this ellipse.\n* @return {Phaser.Ellipse} This Ellipse object\n*/\nPhaser.Ellipse = function (x, y, width, height) {\n\n    this.type = Phaser.ELLIPSE;\n\n    x = x || 0;\n    y = y || 0;\n    width = width || 0;\n    height = height || 0;\n\n    /**\n    * @property {number} x - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} width - The overall width of this ellipse.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The overall height of this ellipse.\n    */\n    this.height = height;\n\n};\n\nPhaser.Ellipse.prototype = {\n\n    /**\n    * Sets the members of the Ellipse to the specified values.\n    * @method Phaser.Ellipse#setTo\n    * @param {number} x - The X coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    * @param {number} y - The Y coordinate of the upper-left corner of the framing rectangle of this ellipse.\n    * @param {number} width - The overall width of this ellipse.\n    * @param {number} height - The overall height of this ellipse.\n    * @return {Phaser.Ellipse} This Ellipse object.\n    */\n    setTo: function (x, y, width, height) {\n\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n\n        return this;\n\n    },\n\n    /**\n    * Copies the x, y, width and height properties from any given object to this Ellipse.\n    * @method Phaser.Ellipse#copyFrom\n    * @param {any} source - The object to copy from.\n    * @return {Phaser.Ellipse} This Ellipse object.\n    */\n    copyFrom: function (source) {\n\n        return this.setTo(source.x, source.y, source.width, source.height);\n\n    },\n\n    /**\n    * Copies the x, y and diameter properties from this Circle to any given object.\n    * @method Phaser.Ellipse#copyTo\n    * @param {any} dest - The object to copy to.\n    * @return {Object} This dest object.\n    */\n    copyTo: function(dest) {\n\n        dest.x = this.x;\n        dest.y = this.y;\n        dest.width = this.width;\n        dest.height = this.height;\n\n        return dest;\n\n    },\n\n    /**\n    * Returns a new Ellipse object with the same values for the x, y, width, and height properties as this Ellipse object.\n    * @method Phaser.Ellipse#clone\n    * @param {Phaser.Ellipse} out - Optional Ellipse object. If given the values will be set into the object, otherwise a brand new Ellipse object will be created and returned.\n    * @return {Phaser.Ellipse} The cloned Ellipse object.\n    */\n    clone: function(out) {\n\n        if (typeof out === \"undefined\")\n        {\n            out = new Phaser.Ellipse(this.x, this.y, this.width, this.height);\n        }\n        else\n        {\n            out.setTo(this.x, this.y, this.width, this.height);\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Return true if the given x/y coordinates are within this Ellipse object.\n    * @method Phaser.Ellipse#contains\n    * @param {number} x - The X value of the coordinate to test.\n    * @param {number} y - The Y value of the coordinate to test.\n    * @return {boolean} True if the coordinates are within this ellipse, otherwise false.\n    */\n    contains: function (x, y) {\n\n        return Phaser.Ellipse.contains(this, x, y);\n\n    },\n\n    /**\n    * Returns a string representation of this object.\n    * @method Phaser.Ellipse#toString\n    * @return {string} A string representation of the instance.\n    */\n    toString: function () {\n        return \"[{Phaser.Ellipse (x=\" + this.x + \" y=\" + this.y + \" width=\" + this.width + \" height=\" + this.height + \")}]\";\n    }\n\n};\n\nPhaser.Ellipse.prototype.constructor = Phaser.Ellipse;\n\n/**\n* The left coordinate of the Ellipse. The same as the X coordinate.\n* @name Phaser.Ellipse#left\n* @propety {number} left - Gets or sets the value of the leftmost point of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"left\", {\n\n    get: function () {\n        return this.x;\n    },\n\n    set: function (value) {\n\n        this.x = value;\n\n    }\n\n});\n\n/**\n* The x coordinate of the rightmost point of the Ellipse. Changing the right property of an Ellipse object has no effect on the x property, but does adjust the width.\n* @name Phaser.Ellipse#right\n* @property {number} right - Gets or sets the value of the rightmost point of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"right\", {\n\n    get: function () {\n        return this.x + this.width;\n    },\n\n    set: function (value) {\n\n        if (value < this.x)\n        {\n            this.width = 0;\n        }\n        else\n        {\n            this.width = this.x + value;\n        }\n    }\n\n});\n\n/**\n* The top of the Ellipse. The same as its y property.\n* @name Phaser.Ellipse#top\n* @property {number} top - Gets or sets the top of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"top\", {\n\n    get: function () {\n        return this.y;\n    },\n\n    set: function (value) {\n        this.y = value;\n    }\n\n});\n\n/**\n* The sum of the y and height properties. Changing the bottom property of an Ellipse doesn't adjust the y property, but does change the height.\n* @name Phaser.Ellipse#bottom\n* @property {number} bottom - Gets or sets the bottom of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"bottom\", {\n\n    get: function () {\n        return this.y + this.height;\n    },\n\n    set: function (value) {\n\n        if (value < this.y)\n        {\n            this.height = 0;\n        }\n        else\n        {\n            this.height = this.y + value;\n        }\n    }\n\n});\n\n/**\n* Determines whether or not this Ellipse object is empty. Will return a value of true if the Ellipse objects dimensions are less than or equal to 0; otherwise false.\n* If set to true it will reset all of the Ellipse objects properties to 0. An Ellipse object is empty if its width or height is less than or equal to 0.\n* @name Phaser.Ellipse#empty\n* @property {boolean} empty - Gets or sets the empty state of the ellipse.\n*/\nObject.defineProperty(Phaser.Ellipse.prototype, \"empty\", {\n\n    get: function () {\n        return (this.width === 0 || this.height === 0);\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            this.setTo(0, 0, 0, 0);\n        }\n\n    }\n\n});\n\n/**\n* Return true if the given x/y coordinates are within the Ellipse object.\n* @method Phaser.Ellipse.contains\n* @param {Phaser.Ellipse} a - The Ellipse to be checked.\n* @param {number} x - The X value of the coordinate to test.\n* @param {number} y - The Y value of the coordinate to test.\n* @return {boolean} True if the coordinates are within this ellipse, otherwise false.\n*/\nPhaser.Ellipse.contains = function (a, x, y) {\n\n    if (a.width <= 0 || a.height <= 0)\n    {\n        return false;\n    }\n\n    //  Normalize the coords to an ellipse with center 0,0 and a radius of 0.5\n    var normx = ((x - a.x) / a.width) - 0.5;\n    var normy = ((y - a.y) / a.height) - 0.5;\n\n    normx *= normx;\n    normy *= normy;\n\n    return (normx + normy < 0.25);\n\n};\n\n/**\n* Returns the framing rectangle of the ellipse as a Phaser.Rectangle object.\n*\n* @method Phaser.Ellipse.getBounds\n* @return {Phaser.Rectangle} The framing rectangle\n*/\nPhaser.Ellipse.prototype.getBounds = function() {\n\n    return new Phaser.Rectangle(this.x, this.y, this.width, this.height);\n\n};\n\n//   Because PIXI uses its own Ellipse, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Ellipse = Phaser.Ellipse;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @author       Adrien Brault <adrien.brault@gmail.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Polygon. You have to provide a list of points.\n* This can be an array of Points that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...],\n* or the arguments passed can be all the points of the polygon e.g. `new Phaser.Polygon(new Phaser.Point(), new Phaser.Point(), ...)`, or the\n* arguments passed can be flat x,y values e.g. `new Phaser.Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are numbers.\n*\n* @class Phaser.Polygon\n* @classdesc The polygon represents a list of orderded points in space\n* @constructor\n* @param {Array<Phaser.Point>|Array<number>} points - The array of Points.\n*/\nPhaser.Polygon = function (points) {\n\n    /**\n    * @property {number} type - The base object type.\n    */\n    this.type = Phaser.POLYGON;\n\n    //if points isn't an array, use arguments as the array\n    if (!(points instanceof Array))\n    {\n        points = Array.prototype.slice.call(arguments);\n    }\n\n    //if this is a flat array of numbers, convert it to points\n    if (typeof points[0] === 'number')\n    {\n        var p = [];\n\n        for (var i = 0, len = points.length; i < len; i += 2)\n        {\n            p.push(new Phaser.Point(points[i], points[i + 1]));\n        }\n\n        points = p;\n    }\n\n    /**\n    * @property {array<Phaser.Point>|array<number>} points - The array of Points.\n    */\n    this.points = points;\n\n};\n\nPhaser.Polygon.prototype = {\n\n    /**\n    * Creates a clone of this polygon.\n    *\n    * @method Phaser.Polygon#clone\n    * @return {Phaser.Polygon} A copy of the polygon.\n    */\n    clone: function () {\n\n        var points = [];\n\n        for (var i=0; i < this.points.length; i++)\n        {\n            points.push(this.points[i].clone());\n        }\n\n        return new Phaser.Polygon(points);\n\n    },\n\n    /**\n    * Checks whether the x and y coordinates are contained within this polygon.\n    *\n    * @method Phaser.Polygon#contains\n    * @param {number} x - The X value of the coordinate to test.\n    * @param {number} y - The Y value of the coordinate to test.\n    * @return {boolean} True if the coordinates are within this polygon, otherwise false.\n    */\n    contains: function (x, y) {\n\n        var inside = false;\n\n        // use some raycasting to test hits https://github.com/substack/point-in-polygon/blob/master/index.js\n        for (var i = 0, j = this.points.length - 1; i < this.points.length; j = i++)\n        {\n            var xi = this.points[i].x;\n            var yi = this.points[i].y;\n            var xj = this.points[j].x;\n            var yj = this.points[j].y;\n\n            var intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n\n    }\n\n};\n\nPhaser.Polygon.prototype.constructor = Phaser.Polygon;\n\n//   Because PIXI uses its own Polygon, we'll replace it with ours to avoid duplicating code or confusion.\nPIXI.Polygon = Phaser.Polygon;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Camera is your view into the game world. It has a position and size and renders only those objects within its field of view.\n* The game automatically creates a single Stage sized camera on boot. Move the camera around the world with Phaser.Camera.x/y\n*\n* @class Phaser.Camera\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n* @param {number} id - Not being used at the moment, will be when Phaser supports multiple camera\n* @param {number} x - Position of the camera on the X axis\n* @param {number} y - Position of the camera on the Y axis\n* @param {number} width - The width of the view rectangle\n* @param {number} height - The height of the view rectangle\n*/\nPhaser.Camera = function (game, id, x, y, width, height) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world.\n    */\n    this.world = game.world;\n\n    /**\n    * @property {number} id - Reserved for future multiple camera set-ups.\n    * @default\n    */\n    this.id = 0;\n\n    /**\n    * Camera view.\n    * The view into the world we wish to render (by default the game dimensions).\n    * The x/y values are in world coordinates, not screen coordinates, the width/height is how many pixels to render.\n    * Objects outside of this view are not rendered if set to camera cull.\n    * @property {Phaser.Rectangle} view\n    */\n    this.view = new Phaser.Rectangle(x, y, width, height);\n\n    /**\n    * @property {Phaser.Rectangle} screenView - Used by Sprites to work out Camera culling.\n    */\n    this.screenView = new Phaser.Rectangle(x, y, width, height);\n\n    /**\n    * The Camera is bound to this Rectangle and cannot move outside of it. By default it is enabled and set to the size of the World.\n    * The Rectangle can be located anywhere in the world and updated as often as you like. If you don't wish the Camera to be bound\n    * at all then set this to null. The values can be anything and are in World coordinates, with 0,0 being the center of the world.\n    * @property {Phaser.Rectangle} bounds - The Rectangle in which the Camera is bounded. Set to null to allow for movement anywhere.\n    */\n    this.bounds = new Phaser.Rectangle(x, y, width, height);\n\n    /**\n    * @property {Phaser.Rectangle} deadzone - Moving inside this Rectangle will not cause camera moving.\n    */\n    this.deadzone = null;\n\n    /**\n    * @property {boolean} visible - Whether this camera is visible or not.\n    * @default\n    */\n    this.visible = true;\n\n    /**\n    * @property {boolean} atLimit - Whether this camera is flush with the World Bounds or not.\n    */\n    this.atLimit = { x: false, y: false };\n\n    /**\n    * @property {Phaser.Sprite} target - If the camera is tracking a Sprite, this is a reference to it, otherwise null.\n    * @default\n    */\n    this.target = null;\n\n    /**\n    * @property {number} edge - Edge property.\n    * @private\n    * @default\n    */\n    this._edge = 0;\n\n    /**\n    * @property {PIXI.DisplayObject} displayObject - The display object to which all game objects are added. Set by World.boot\n    */\n    this.displayObject = null;\n\n    /**\n    * @property {Phaser.Point} scale - The scale of the display object to which all game objects are added. Set by World.boot\n    */\n    this.scale = null;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_LOCKON = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_PLATFORMER = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_TOPDOWN = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Camera.FOLLOW_TOPDOWN_TIGHT = 3;\n\nPhaser.Camera.prototype = {\n\n    /**\n    * Tells this camera which sprite to follow.\n    * @method Phaser.Camera#follow\n    * @param {Phaser.Sprite|Phaser.Image|Phaser.Text} target - The object you want the camera to track. Set to null to not follow anything.\n    * @param {number} [style] - Leverage one of the existing \"deadzone\" presets. If you use a custom deadzone, ignore this parameter and manually specify the deadzone after calling follow().\n    */\n    follow: function (target, style) {\n\n        if (typeof style === \"undefined\") { style = Phaser.Camera.FOLLOW_LOCKON; }\n\n        this.target = target;\n\n        var helper;\n\n        switch (style) {\n\n            case Phaser.Camera.FOLLOW_PLATFORMER:\n                var w = this.width / 8;\n                var h = this.height / 3;\n                this.deadzone = new Phaser.Rectangle((this.width - w) / 2, (this.height - h) / 2 - h * 0.25, w, h);\n                break;\n\n            case Phaser.Camera.FOLLOW_TOPDOWN:\n                helper = Math.max(this.width, this.height) / 4;\n                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);\n                break;\n\n            case Phaser.Camera.FOLLOW_TOPDOWN_TIGHT:\n                helper = Math.max(this.width, this.height) / 8;\n                this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper);\n                break;\n\n            case Phaser.Camera.FOLLOW_LOCKON:\n                this.deadzone = null;\n                break;\n\n            default:\n                this.deadzone = null;\n                break;\n        }\n\n    },\n\n    /**\n    * Sets the Camera follow target to null, stopping it from following an object if it's doing so.\n    *\n    * @method Phaser.Camera#unfollow\n    */\n    unfollow: function () {\n\n        this.target = null;\n\n    },\n\n    /**\n    * Move the camera focus on a display object instantly.\n    * @method Phaser.Camera#focusOn\n    * @param {any} displayObject - The display object to focus the camera on. Must have visible x/y properties.\n    */\n    focusOn: function (displayObject) {\n\n        this.setPosition(Math.round(displayObject.x - this.view.halfWidth), Math.round(displayObject.y - this.view.halfHeight));\n\n    },\n\n    /**\n    * Move the camera focus on a location instantly.\n    * @method Phaser.Camera#focusOnXY\n    * @param {number} x - X position.\n    * @param {number} y - Y position.\n    */\n    focusOnXY: function (x, y) {\n\n        this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight));\n\n    },\n\n    /**\n    * Update focusing and scrolling.\n    * @method Phaser.Camera#update\n    */\n    update: function () {\n\n        if (this.target)\n        {\n            this.updateTarget();\n        }\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n\n        this.displayObject.position.x = -this.view.x;\n        this.displayObject.position.y = -this.view.y;\n\n    },\n\n    /**\n    * Internal method\n    * @method Phaser.Camera#updateTarget\n    * @private\n    */\n    updateTarget: function () {\n\n        if (this.deadzone)\n        {\n            this._edge = this.target.x - this.deadzone.x;\n\n            if (this.view.x > this._edge)\n            {\n                this.view.x = this._edge;\n            }\n\n            this._edge = this.target.x + this.target.width - this.deadzone.x - this.deadzone.width;\n\n            if (this.view.x < this._edge)\n            {\n                this.view.x = this._edge;\n            }\n\n            this._edge = this.target.y - this.deadzone.y;\n\n            if (this.view.y > this._edge)\n            {\n                this.view.y = this._edge;\n            }\n\n            this._edge = this.target.y + this.target.height - this.deadzone.y - this.deadzone.height;\n\n            if (this.view.y < this._edge)\n            {\n                this.view.y = this._edge;\n            }\n        }\n        else\n        {\n            this.focusOnXY(this.target.x, this.target.y);\n        }\n\n    },\n\n    /**\n    * Update the Camera bounds to match the game world.\n    * @method Phaser.Camera#setBoundsToWorld\n    */\n    setBoundsToWorld: function () {\n\n        this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);\n\n    },\n\n    /**\n    * Method called to ensure the camera doesn't venture outside of the game world.\n    * @method Phaser.Camera#checkWorldBounds\n    */\n    checkBounds: function () {\n\n        this.atLimit.x = false;\n        this.atLimit.y = false;\n\n        //  Make sure we didn't go outside the cameras bounds\n        if (this.view.x <= this.bounds.x)\n        {\n            this.atLimit.x = true;\n            this.view.x = this.bounds.x;\n        }\n\n        if (this.view.right >= this.bounds.right)\n        {\n            this.atLimit.x = true;\n            this.view.x = this.bounds.right - this.width;\n        }\n\n        if (this.view.y <= this.bounds.top)\n        {\n            this.atLimit.y = true;\n            this.view.y = this.bounds.top;\n        }\n\n        if (this.view.bottom >= this.bounds.bottom)\n        {\n            this.atLimit.y = true;\n            this.view.y = this.bounds.bottom - this.height;\n        }\n\n        this.view.floor();\n\n    },\n\n    /**\n    * A helper function to set both the X and Y properties of the camera at once\n    * without having to use game.camera.x and game.camera.y.\n    *\n    * @method Phaser.Camera#setPosition\n    * @param {number} x - X position.\n    * @param {number} y - Y position.\n    */\n    setPosition: function (x, y) {\n\n        this.view.x = x;\n        this.view.y = y;\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n\n    },\n\n    /**\n    * Sets the size of the view rectangle given the width and height in parameters.\n    *\n    * @method Phaser.Camera#setSize\n    * @param {number} width - The desired width.\n    * @param {number} height - The desired height.\n    */\n    setSize: function (width, height) {\n\n        this.view.width = width;\n        this.view.height = height;\n\n    },\n\n    /**\n    * Resets the camera back to 0,0 and un-follows any object it may have been tracking.\n    *\n    * @method Phaser.Camera#reset\n    */\n    reset: function () {\n\n        this.target = null;\n        this.view.x = 0;\n        this.view.y = 0;\n\n    }\n\n};\n\nPhaser.Camera.prototype.constructor = Phaser.Camera;\n\n/**\n* The Cameras x coordinate. This value is automatically clamped if it falls outside of the World bounds.\n* @name Phaser.Camera#x\n* @property {number} x - Gets or sets the cameras x position.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"x\", {\n\n    get: function () {\n        return this.view.x;\n    },\n\n    set: function (value) {\n\n        this.view.x = value;\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n    }\n\n});\n\n/**\n* The Cameras y coordinate. This value is automatically clamped if it falls outside of the World bounds.\n* @name Phaser.Camera#y\n* @property {number} y - Gets or sets the cameras y position.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"y\", {\n\n    get: function () {\n        return this.view.y;\n    },\n\n    set: function (value) {\n\n        this.view.y = value;\n\n        if (this.bounds)\n        {\n            this.checkBounds();\n        }\n    }\n\n});\n\n/**\n* The Cameras width. By default this is the same as the Game size and should not be adjusted for now.\n* @name Phaser.Camera#width\n* @property {number} width - Gets or sets the cameras width.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"width\", {\n\n    get: function () {\n        return this.view.width;\n    },\n\n    set: function (value) {\n        this.view.width = value;\n    }\n\n});\n\n/**\n* The Cameras height. By default this is the same as the Game size and should not be adjusted for now.\n* @name Phaser.Camera#height\n* @property {number} height - Gets or sets the cameras height.\n*/\nObject.defineProperty(Phaser.Camera.prototype, \"height\", {\n\n    get: function () {\n        return this.view.height;\n    },\n\n    set: function (value) {\n        this.view.height = value;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is a base State class which can be extended if you are creating your own game.\n* It provides quick access to common functions such as the camera, cache, input, match, sound and more.\n*\n* @class Phaser.State\n* @constructor\n*/\n\nPhaser.State = function () {\n\n    /**\n    * @property {Phaser.Game} game - This is a reference to the currently running Game.\n    */\n    this.game = null;\n\n    /**\n    * @property {Phaser.GameObjectFactory} add - A reference to the GameObjectFactory which can be used to add new objects to the World.\n    */\n    this.add = null;\n\n    /**\n    * @property {Phaser.GameObjectCreator} make - A reference to the GameObjectCreator which can be used to make new objects.\n    */\n    this.make = null;\n\n    /**\n    * @property {Phaser.Camera} camera - A handy reference to World.camera.\n    */\n    this.camera = null;\n\n    /**\n    * @property {Phaser.Cache} cache - A reference to the game cache which contains any loaded or generated assets, such as images, sound and more.\n    */\n    this.cache = null;\n\n    /**\n    * @property {Phaser.Input} input - A reference to the Input Manager.\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Loader} load - A reference to the Loader, which you mostly use in the preload method of your state to load external assets.\n    */\n    this.load = null;\n\n    /**\n    * @property {Phaser.Math} math - A reference to Math class with lots of helpful functions.\n    */\n    this.math = null;\n\n    /**\n    * @property {Phaser.SoundManager} sound - A reference to the Sound Manager which can create, play and stop sounds, as well as adjust global volume.\n    */\n    this.sound = null;\n\n    /**\n    * @property {Phaser.ScaleManager} scale - A reference to the Scale Manager which controls the way the game scales on different displays.\n    */\n    this.scale = null;\n\n    /**\n    * @property {Phaser.Stage} stage - A reference to the Stage.\n    */\n    this.stage = null;\n\n    /**\n    * @property {Phaser.Time} time - A reference to the game clock and timed events system.\n    */\n    this.time = null;\n\n    /**\n    * @property {Phaser.TweenManager} tweens - A reference to the tween manager.\n    */\n    this.tweens = null;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world. All objects live in the Game World and its size is not bound by the display resolution.\n    */\n    this.world = null;\n\n    /**\n    * @property {Phaser.Particles} particles - The Particle Manager. It is called during the core gameloop and updates any Particle Emitters it has created.\n    */\n    this.particles = null;\n\n    /**\n    * @property {Phaser.Physics} physics - A reference to the physics manager which looks after the different physics systems available within Phaser.\n    */\n    this.physics = null;\n\n    /**\n    * @property {Phaser.RandomDataGenerator} rnd - A reference to the seeded and repeatable random data generator.\n    */\n    this.rnd = null;\n\n};\n\nPhaser.State.prototype = {\n\n    /**\n    * preload is called first. Normally you'd use this to load your game assets (or those needed for the current State)\n    * You shouldn't create any objects in this method that require assets that you're also loading in this method, as\n    * they won't yet be available.\n    *\n    * @method Phaser.State#preload\n    */\n    preload: function () {\n    },\n\n    /**\n    * loadUpdate is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.\n    *\n    * @method Phaser.State#loadUpdate\n    */\n    loadUpdate: function () {\n    },\n\n    /**\n    * loadRender is called during the Loader process. This only happens if you've set one or more assets to load in the preload method.\n    * The difference between loadRender and render is that any objects you render in this method you must be sure their assets exist.\n    *\n    * @method Phaser.State#loadRender\n    */\n    loadRender: function () {\n    },\n\n    /**\n    * create is called once preload has completed, this includes the loading of any assets from the Loader.\n    * If you don't have a preload method then create is the first method called in your State.\n    *\n    * @method Phaser.State#create\n    */\n    create: function () {\n    },\n\n    /**\n    * The update method is left empty for your own use.\n    * It is called during the core game loop AFTER debug, physics, plugins and the Stage have had their preUpdate methods called.\n    * If is called BEFORE Stage, Tweens, Sounds, Input, Physics, Particles and Plugins have had their postUpdate methods called.\n    *\n    * @method Phaser.State#update\n    */\n    update: function () {\n    },\n\n    /**\n    * Nearly all display objects in Phaser render automatically, you don't need to tell them to render.\n    * However the render method is called AFTER the game renderer and plugins have rendered, so you're able to do any\n    * final post-processing style effects here. Note that this happens before plugins postRender takes place.\n    *\n    * @method Phaser.State#render\n    */\n    render: function () {\n    },\n\n    /**\n    * This method will be called if the core game loop is paused.\n    *\n    * @method Phaser.State#paused\n    */\n    paused: function () {\n    },\n\n    /**\n    * pauseUpdate is called while the game is paused instead of preUpdate, update and postUpdate.\n    *\n    * @method Phaser.State#pauseUpdate\n    */\n    pauseUpdate: function () {\n    },\n\n    /**\n    * This method will be called when the State is shutdown (i.e. you switch to another state from this one).\n    *\n    * @method Phaser.State#shutdown\n    */\n    shutdown: function () {\n    }\n\n};\n\nPhaser.State.prototype.constructor = Phaser.State;\n\n/* jshint newcap: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The State Manager is responsible for loading, setting up and switching game states.\n*\n* @class Phaser.StateManager\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Phaser.State|Object} [pendingState=null] - A State object to seed the manager with.\n*/\nPhaser.StateManager = function (game, pendingState) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Object} states - The object containing Phaser.States.\n    */\n    this.states = {};\n\n    /**\n    * @property {Phaser.State} _pendingState - The state to be switched to in the next frame.\n    * @private\n    */\n    this._pendingState = null;\n\n    if (typeof pendingState !== 'undefined' && pendingState !== null)\n    {\n        this._pendingState = pendingState;\n    }\n\n    /**\n    * @property {boolean} _clearWorld - Clear the world when we switch state?\n    * @private\n    */\n    this._clearWorld = false;\n\n    /**\n    * @property {boolean} _clearCache - Clear the cache when we switch state?\n    * @private\n    */\n    this._clearCache = false;\n\n    /**\n    * @property {boolean} _created - Flag that sets if the State has been created or not.\n    * @private\n    */\n    this._created = false;\n\n    /**\n    * @property {array} _args - Temporary container when you pass vars from one State to another.\n    * @private\n    */\n    this._args = [];\n\n    /**\n    * @property {string} current - The current active State object (defaults to null).\n    */\n    this.current = '';\n\n    /**\n    * @property {function} onInitCallback - This will be called when the state is started (i.e. set as the current active state).\n    */\n    this.onInitCallback = null;\n\n    /**\n    * @property {function} onPreloadCallback - This will be called when init states (loading assets...).\n    */\n    this.onPreloadCallback = null;\n\n    /**\n    * @property {function} onCreateCallback - This will be called when create states (setup states...).\n    */\n    this.onCreateCallback = null;\n\n    /**\n    * @property {function} onUpdateCallback - This will be called when State is updated, this doesn't happen during load (@see onLoadUpdateCallback).\n    */\n    this.onUpdateCallback = null;\n\n    /**\n    * @property {function} onRenderCallback - This will be called when the State is rendered, this doesn't happen during load (see onLoadRenderCallback).\n    */\n    this.onRenderCallback = null;\n\n    /**\n    * @property {function} onPreRenderCallback - This will be called before the State is rendered and before the stage is cleared.\n    */\n    this.onPreRenderCallback = null;\n\n    /**\n    * @property {function} onLoadUpdateCallback - This will be called when the State is updated but only during the load process.\n    */\n    this.onLoadUpdateCallback = null;\n\n    /**\n    * @property {function} onLoadRenderCallback - This will be called when the State is rendered but only during the load process.\n    */\n    this.onLoadRenderCallback = null;\n\n    /**\n    * @property {function} onPausedCallback - This will be called once each time the game is paused.\n    */\n    this.onPausedCallback = null;\n\n    /**\n    * @property {function} onResumedCallback - This will be called once each time the game is resumed from a paused state.\n    */\n    this.onResumedCallback = null;\n\n    /**\n    * @property {function} onPauseUpdateCallback - This will be called every frame while the game is paused.\n    */\n    this.onPauseUpdateCallback = null;\n\n    /**\n    * @property {function} onShutDownCallback - This will be called when the state is shut down (i.e. swapped to another state).\n    */\n    this.onShutDownCallback = null;\n\n};\n\nPhaser.StateManager.prototype = {\n\n    /**\n    * The Boot handler is called by Phaser.Game when it first starts up.\n    * @method Phaser.StateManager#boot\n    * @private\n    */\n    boot: function () {\n\n        this.game.onPause.add(this.pause, this);\n        this.game.onResume.add(this.resume, this);\n        this.game.load.onLoadComplete.add(this.loadComplete, this);\n\n        if (this._pendingState !== null)\n        {\n            if (typeof this._pendingState === 'string')\n            {\n                //  State was already added, so just start it\n                this.start(this._pendingState, false, false);\n            }\n            else\n            {\n                this.add('default', this._pendingState, true);\n            }\n        }\n\n    },\n\n    /**\n    * Adds a new State into the StateManager. You must give each State a unique key by which you'll identify it.\n    * The State can be either a Phaser.State object (or an object that extends it), a plain JavaScript object or a function.\n    * If a function is given a new state object will be created by calling it.\n    *\n    * @method Phaser.StateManager#add\n    * @param {string} key - A unique key you use to reference this state, i.e. \"MainMenu\", \"Level1\".\n    * @param {Phaser.State|object|function} state  - The state you want to switch to.\n    * @param {boolean} [autoStart=false]  - If true the State will be started immediately after adding it.\n    */\n    add: function (key, state, autoStart) {\n\n        if (typeof autoStart === \"undefined\") { autoStart = false; }\n\n        var newState;\n\n        if (state instanceof Phaser.State)\n        {\n            newState = state;\n        }\n        else if (typeof state === 'object')\n        {\n            newState = state;\n            newState.game = this.game;\n        }\n        else if (typeof state === 'function')\n        {\n            newState = new state(this.game);\n        }\n\n        this.states[key] = newState;\n\n        if (autoStart)\n        {\n            if (this.game.isBooted)\n            {\n                this.start(key);\n            }\n            else\n            {\n                this._pendingState = key;\n            }\n        }\n\n        return newState;\n\n    },\n\n    /**\n    * Delete the given state.\n    * @method Phaser.StateManager#remove\n    * @param {string} key - A unique key you use to reference this state, i.e. \"MainMenu\", \"Level1\".\n    */\n    remove: function (key) {\n\n        if (this.current === key)\n        {\n            this.callbackContext = null;\n\n            this.onInitCallback = null;\n            this.onShutDownCallback = null;\n\n            this.onPreloadCallback = null;\n            this.onLoadRenderCallback = null;\n            this.onLoadUpdateCallback = null;\n            this.onCreateCallback = null;\n            this.onUpdateCallback = null;\n            this.onRenderCallback = null;\n            this.onPausedCallback = null;\n            this.onResumedCallback = null;\n            this.onPauseUpdateCallback = null;\n        }\n\n        delete this.states[key];\n\n    },\n\n    /**\n    * Start the given State. If a State is already running then State.shutDown will be called (if it exists) before switching to the new State.\n    *\n    * @method Phaser.StateManager#start\n    * @param {string} key - The key of the state you want to start.\n    * @param {boolean} [clearWorld=true] - Clear everything in the world? This clears the World display list fully (but not the Stage, so if you've added your own objects to the Stage they will need managing directly)\n    * @param {boolean} [clearCache=false] - Clear the Game.Cache? This purges out all loaded assets. The default is false and you must have clearWorld=true if you want to clearCache as well.\n    * @param {...*} parameter - Additional parameters that will be passed to the State.init function (if it has one).\n    */\n    start: function (key, clearWorld, clearCache) {\n\n        if (typeof clearWorld === \"undefined\") { clearWorld = true; }\n        if (typeof clearCache === \"undefined\") { clearCache = false; }\n\n        if (this.checkState(key))\n        {\n            //  Place the state in the queue. It will be started the next time the game loop starts.\n            this._pendingState = key;\n            this._clearWorld = clearWorld;\n            this._clearCache = clearCache;\n\n            if (arguments.length > 3)\n            {\n                this._args = Array.prototype.splice.call(arguments, 3);\n            }\n        }\n\n    },\n\n    /**\n    * Restarts the current State. State.shutDown will be called (if it exists) before the State is restarted.\n    *\n    * @method Phaser.StateManager#restart\n    * @param {boolean} [clearWorld=true] - Clear everything in the world? This clears the World display list fully (but not the Stage, so if you've added your own objects to the Stage they will need managing directly)\n    * @param {boolean} [clearCache=false] - Clear the Game.Cache? This purges out all loaded assets. The default is false and you must have clearWorld=true if you want to clearCache as well.\n    * @param {...*} parameter - Additional parameters that will be passed to the State.init function if it has one.\n    */\n    restart: function (clearWorld, clearCache) {\n\n        if (typeof clearWorld === \"undefined\") { clearWorld = true; }\n        if (typeof clearCache === \"undefined\") { clearCache = false; }\n\n        //  Place the state in the queue. It will be started the next time the game loop starts.\n        this._pendingState = this.current;\n        this._clearWorld = clearWorld;\n        this._clearCache = clearCache;\n\n        if (arguments.length > 2)\n        {\n            this._args = Array.prototype.splice.call(arguments, 2);\n        }\n\n    },\n\n    /**\n    * Used by onInit and onShutdown when those functions don't exist on the state\n    * @method Phaser.StateManager#dummy\n    * @private\n    */\n    dummy: function () {\n    },\n\n    /**\n    * preUpdate is called right at the start of the game loop. It is responsible for changing to a new state that was requested previously.\n    *\n    * @method Phaser.StateManager#preUpdate\n    */\n    preUpdate: function () {\n\n        if (this._pendingState && this.game.isBooted)\n        {\n            //  Already got a state running?\n            if (this.current)\n            {\n                this.onShutDownCallback.call(this.callbackContext, this.game);\n\n                this.game.tweens.removeAll();\n\n                this.game.camera.reset();\n\n                this.game.input.reset(true);\n\n                this.game.physics.clear();\n\n                this.game.time.removeAll();\n\n                if (this._clearWorld)\n                {\n                    this.game.world.shutdown();\n\n                    if (this._clearCache === true)\n                    {\n                        this.game.cache.destroy();\n                    }\n                }\n            }\n\n            this.setCurrentState(this._pendingState);\n\n            if (this.onPreloadCallback)\n            {\n                this.game.load.reset();\n                this.onPreloadCallback.call(this.callbackContext, this.game);\n\n                //  Is the loader empty?\n                if (this.game.load.totalQueuedFiles() === 0)\n                {\n                    this.loadComplete();\n                }\n                else\n                {\n                    //  Start the loader going as we have something in the queue\n                    this.game.load.start();\n                }\n            }\n            else\n            {\n                //  No init? Then there was nothing to load either\n                this.loadComplete();\n            }\n\n            if (this.current === this._pendingState)\n            {\n                this._pendingState = null;\n            }\n        }\n\n    },\n\n    /**\n    * Checks if a given phaser state is valid. A State is considered valid if it has at least one of the core functions: preload, create, update or render.\n    *\n    * @method Phaser.StateManager#checkState\n    * @param {string} key - The key of the state you want to check.\n    * @return {boolean} true if the State has the required functions, otherwise false.\n    */\n    checkState: function (key) {\n\n        if (this.states[key])\n        {\n            var valid = false;\n\n            if (this.states[key]['preload']) { valid = true; }\n            if (this.states[key]['create']) { valid = true; }\n            if (this.states[key]['update']) { valid = true; }\n            if (this.states[key]['render']) { valid = true; }\n\n            if (valid === false)\n            {\n                console.warn(\"Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render\");\n                return false;\n            }\n\n            return true;\n        }\n        else\n        {\n            console.warn(\"Phaser.StateManager - No state found with the key: \" + key);\n            return false;\n        }\n\n    },\n\n    /**\n    * Links game properties to the State given by the key.\n    *\n    * @method Phaser.StateManager#link\n    * @param {string} key - State key.\n    * @protected\n    */\n    link: function (key) {\n\n        this.states[key].game = this.game;\n        this.states[key].add = this.game.add;\n        this.states[key].make = this.game.make;\n        this.states[key].camera = this.game.camera;\n        this.states[key].cache = this.game.cache;\n        this.states[key].input = this.game.input;\n        this.states[key].load = this.game.load;\n        this.states[key].math = this.game.math;\n        this.states[key].sound = this.game.sound;\n        this.states[key].scale = this.game.scale;\n        this.states[key].state = this;\n        this.states[key].stage = this.game.stage;\n        this.states[key].time = this.game.time;\n        this.states[key].tweens = this.game.tweens;\n        this.states[key].world = this.game.world;\n        this.states[key].particles = this.game.particles;\n        this.states[key].rnd = this.game.rnd;\n        this.states[key].physics = this.game.physics;\n\n    },\n\n    /**\n    * Sets the current State. Should not be called directly (use StateManager.start)\n    *\n    * @method Phaser.StateManager#setCurrentState\n    * @param {string} key - State key.\n    * @private\n    */\n    setCurrentState: function (key) {\n\n        this.callbackContext = this.states[key];\n\n        this.link(key);\n\n        //  Used when the state is set as being the current active state\n        this.onInitCallback = this.states[key]['init'] || this.dummy;\n\n        this.onPreloadCallback = this.states[key]['preload'] || null;\n        this.onLoadRenderCallback = this.states[key]['loadRender'] || null;\n        this.onLoadUpdateCallback = this.states[key]['loadUpdate'] || null;\n        this.onCreateCallback = this.states[key]['create'] || null;\n        this.onUpdateCallback = this.states[key]['update'] || null;\n        this.onPreRenderCallback = this.states[key]['preRender'] || null;\n        this.onRenderCallback = this.states[key]['render'] || null;\n        this.onPausedCallback = this.states[key]['paused'] || null;\n        this.onResumedCallback = this.states[key]['resumed'] || null;\n        this.onPauseUpdateCallback = this.states[key]['pauseUpdate'] || null;\n\n        //  Used when the state is no longer the current active state\n        this.onShutDownCallback = this.states[key]['shutdown'] || this.dummy;\n\n        this.current = key;\n        this._created = false;\n\n        this.onInitCallback.apply(this.callbackContext, this._args);\n\n        this._args = [];\n\n    },\n\n    /**\n     * Gets the current State.\n     *\n     * @method Phaser.StateManager#getCurrentState\n     * @return Phaser.State\n     * @public\n     */\n    getCurrentState: function() {\n        return this.states[this.current];\n    },\n\n    /**\n    * @method Phaser.StateManager#loadComplete\n    * @protected\n    */\n    loadComplete: function () {\n\n        if (this._created === false && this.onCreateCallback)\n        {\n            this._created = true;\n            this.onCreateCallback.call(this.callbackContext, this.game);\n        }\n        else\n        {\n            this._created = true;\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#pause\n    * @protected\n    */\n    pause: function () {\n\n        if (this._created && this.onPausedCallback)\n        {\n            this.onPausedCallback.call(this.callbackContext, this.game);\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#resume\n    * @protected\n    */\n    resume: function () {\n\n        if (this._created && this.onResumedCallback)\n        {\n            this.onResumedCallback.call(this.callbackContext, this.game);\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#update\n    * @protected\n    */\n    update: function () {\n\n        if (this._created && this.onUpdateCallback)\n        {\n            this.onUpdateCallback.call(this.callbackContext, this.game);\n        }\n        else\n        {\n            if (this.onLoadUpdateCallback)\n            {\n                this.onLoadUpdateCallback.call(this.callbackContext, this.game);\n            }\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#pauseUpdate\n    * @protected\n    */\n    pauseUpdate: function () {\n\n        if (this._created && this.onPauseUpdateCallback)\n        {\n            this.onPauseUpdateCallback.call(this.callbackContext, this.game);\n        }\n        else\n        {\n            if (this.onLoadUpdateCallback)\n            {\n                this.onLoadUpdateCallback.call(this.callbackContext, this.game);\n            }\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#preRender\n    * @protected\n    */\n    preRender: function () {\n\n        if (this.onPreRenderCallback)\n        {\n            this.onPreRenderCallback.call(this.callbackContext, this.game);\n        }\n\n    },\n\n    /**\n    * @method Phaser.StateManager#render\n    * @protected\n    */\n    render: function () {\n\n        if (this._created && this.onRenderCallback)\n        {\n            if (this.game.renderType === Phaser.CANVAS)\n            {\n                this.game.context.save();\n                this.game.context.setTransform(1, 0, 0, 1, 0, 0);\n            }\n\n            this.onRenderCallback.call(this.callbackContext, this.game);\n\n            if (this.game.renderType === Phaser.CANVAS)\n            {\n                this.game.context.restore();\n            }\n        }\n        else\n        {\n            if (this.onLoadRenderCallback)\n            {\n                this.onLoadRenderCallback.call(this.callbackContext, this.game);\n            }\n        }\n\n    },\n\n    /**\n    * Removes all StateManager callback references to the State object, nulls the game reference and clears the States object.\n    * You don't recover from this without rebuilding the Phaser instance again.\n    * @method Phaser.StateManager#destroy\n    */\n    destroy: function () {\n\n        this.callbackContext = null;\n\n        this.onInitCallback = null;\n        this.onShutDownCallback = null;\n\n        this.onPreloadCallback = null;\n        this.onLoadRenderCallback = null;\n        this.onLoadUpdateCallback = null;\n        this.onCreateCallback = null;\n        this.onUpdateCallback = null;\n        this.onRenderCallback = null;\n        this.onPausedCallback = null;\n        this.onResumedCallback = null;\n        this.onPauseUpdateCallback = null;\n\n        this.game = null;\n        this.states = {};\n        this._pendingState = null;\n\n    }\n\n};\n\nPhaser.StateManager.prototype.constructor = Phaser.StateManager;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A basic linked list data structure.\n*\n* @class Phaser.LinkedList\n* @constructor\n*/\nPhaser.LinkedList = function () {\n\n    /**\n    * @property {object} next - Next element in the list.\n    * @default\n    */\n    this.next = null;\n\n    /**\n    * @property {object} prev - Previous element in the list.\n    * @default\n    */\n    this.prev = null;\n\n    /**\n    * @property {object} first - First element in the list.\n    * @default\n    */\n    this.first = null;\n\n    /**\n    * @property {object} last - Last element in the list.\n    * @default\n    */\n    this.last = null;\n\n    /**\n    * @property {number} total - Number of elements in the list.\n    * @default\n    */\n    this.total = 0;\n\n};\n\nPhaser.LinkedList.prototype = {\n\n    /**\n    * Adds a new element to this linked list.\n    *\n    * @method Phaser.LinkedList#add\n    * @param {object} child - The element to add to this list. Can be a Phaser.Sprite or any other object you need to quickly iterate through.\n    * @return {object} The child that was added.\n    */\n    add: function (child) {\n\n        //  If the list is empty\n        if (this.total === 0 && this.first === null && this.last === null)\n        {\n            this.first = child;\n            this.last = child;\n            this.next = child;\n            child.prev = this;\n            this.total++;\n            return child;\n        }\n\n        //  Gets appended to the end of the list, regardless of anything, and it won't have any children of its own (non-nested list)\n        this.last.next = child;\n\n        child.prev = this.last;\n\n        this.last = child;\n\n        this.total++;\n\n        return child;\n\n    },\n\n    /**\n    * Resets the first, last, next and previous node pointers in this list.\n    *\n    * @method Phaser.LinkedList#reset\n    */\n    reset: function () {\n\n        this.first = null;\n        this.last = null;\n        this.next = null;\n        this.prev = null;\n        this.total = 0;\n\n    },\n\n    /**\n    * Removes the given element from this linked list if it exists.\n    *\n    * @method Phaser.LinkedList#remove\n    * @param {object} child - The child to be removed from the list.\n    */\n    remove: function (child) {\n\n        if (this.total === 1)\n        {\n            this.reset();\n            child.next = child.prev = null;\n            return;\n        }\n\n        if (child === this.first)\n        {\n            // It was 'first', make 'first' point to first.next\n            this.first = this.first.next;\n        }\n        else if (child === this.last)\n        {\n            // It was 'last', make 'last' point to last.prev\n            this.last = this.last.prev;\n        }\n\n        if (child.prev)\n        {\n            // make child.prev.next point to childs.next instead of child\n            child.prev.next = child.next;\n        }\n\n        if (child.next)\n        {\n            // make child.next.prev point to child.prev instead of child\n            child.next.prev = child.prev;\n        }\n\n        child.next = child.prev = null;\n\n        if (this.first === null )\n        {\n            this.last = null;\n        }\n\n        this.total--;\n\n    },\n\n    /**\n    * Calls a function on all members of this list, using the member as the context for the callback.\n    * The function must exist on the member.\n    *\n    * @method Phaser.LinkedList#callAll\n    * @param {function} callback - The function to call.\n    */\n    callAll: function (callback) {\n\n        if (!this.first || !this.last)\n        {\n            return;\n        }\n\n        var entity = this.first;\n\n        do\n        {\n            if (entity && entity[callback])\n            {\n                entity[callback].call(entity);\n            }\n\n            entity = entity.next;\n\n        }\n        while(entity != this.last.next);\n\n    }\n\n};\n\nPhaser.LinkedList.prototype.constructor = Phaser.LinkedList;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A set data structure. Allows items to add themselves to and remove themselves from the set. Items can only exist once in the set.\n*\n* @class Phaser.ArrayList\n* @constructor\n*/\nPhaser.ArrayList = function () {\n\n    /**\n    * @property {number} total - Number of objects in the list.\n    * @default\n    */\n    this.total = 0;\n\n    /**\n    * @property {number} position - Current cursor position.\n    * @default\n    */\n    this.position = 0;\n\n    /**\n    * @property {array} list - The list.\n    */\n    this.list = [];\n\n};\n\nPhaser.ArrayList.prototype = {\n\n    /**\n    * Adds a new element to this list. The item can only exist in the list once.\n    *\n    * @method Phaser.ArrayList#add\n    * @param {object} child - The element to add to this list. Can be a Phaser.Sprite or any other object you need to quickly iterate through.\n    * @return {object} The child that was added.\n    */\n    add: function (child) {\n\n        if (!this.exists(child))\n        {\n            this.list.push(child);\n            this.total++;\n        }\n\n        return child;\n\n    },\n\n    /**\n    * Gets the index of the child in the list, or -1 if it isn't in the list.\n    *\n    * @method Phaser.ArrayList#getIndex\n    * @param {object} child - The element to get the list index for.\n    * @return {number} The index of the child or -1 if not found.\n    */\n    getIndex: function (child) {\n\n        return this.list.indexOf(child);\n\n    },\n\n    /**\n    * Checks for the child within this list.\n    *\n    * @method Phaser.ArrayList#exists\n    * @param {object} child - The element to get the list index for.\n    * @return {boolean} True if the child is found in the list, otherwise false.\n    */\n    exists: function (child) {\n\n        return (this.list.indexOf(child) > -1);\n\n    },\n\n    /**\n    * Resets the list length and drops all items in the list.\n    *\n    * @method Phaser.ArrayList#reset\n    */\n    reset: function () {\n\n        this.list.length = 0;\n        this.total = 0;\n\n    },\n\n    /**\n    * Removes the given element from this list if it exists.\n    *\n    * @method Phaser.ArrayList#remove\n    * @param {object} child - The child to be removed from the list.\n    * @return {object} child - The child that was removed.\n    */\n    remove: function (child) {\n\n        var idx = this.list.indexOf(child);\n\n        if (idx > -1)\n        {\n            this.list.splice(idx, 1);\n            this.total--;\n            return child;\n        }\n\n    },\n\n    /**\n    * Calls a function on all members of this list, using the member as the context for the callback.\n    * The function must exist on the member.\n    *\n    * @method Phaser.ArrayList#callAll\n    * @param {function} callback - The function to call.\n    * @param {...*} parameter - Additional parameters that will be passed to the callback.\n    */\n    callAll: function (callback) {\n\n        var args = Array.prototype.splice.call(arguments, 1);\n\n        var i = this.list.length;\n\n        while (i--)\n        {\n            if (this.list[i] && this.list[i][callback])\n            {\n                this.list[i][callback].apply(this.list[i], args);\n            }\n        }\n\n    }\n\n};\n\n/**\n* Resets the cursor to the first item in the list and returns it.\n*\n* @name Phaser.ArrayList#first\n* @property {object} first - The first item in the list.\n*/\nObject.defineProperty(Phaser.ArrayList.prototype, \"first\", {\n\n    get: function () {\n\n        this.position = 0;\n\n        if (this.total > 0)\n        {\n            return this.list[0];\n        }\n        else\n        {\n            return null;\n        }\n\n    }\n\n});\n\n/**\n* Gets the next item in the list and returns it, advancing the cursor.\n*\n* @name Phaser.ArrayList#next\n* @property {object} next - Advanced the cursor and return.\n*/\nObject.defineProperty(Phaser.ArrayList.prototype, \"next\", {\n\n    get: function () {\n\n        if (this.position < this.total)\n        {\n            this.position++;\n\n            return this.list[this.position];\n        }\n        else\n        {\n            return null;\n        }\n\n    }\n\n});\n\nPhaser.ArrayList.prototype.constructor = Phaser.ArrayList;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Signal\n* @classdesc A Signal is used for object communication via a custom broadcaster instead of Events.\n* @author Miller Medeiros http://millermedeiros.github.com/js-signals/\n* @constructor\n*/\nPhaser.Signal = function () {\n\n    /**\n    * @property {Array.<Phaser.SignalBinding>} _bindings - Internal variable.\n    * @private\n    */\n    this._bindings = [];\n\n    /**\n    * @property {any} _prevParams - Internal variable.\n    * @private\n    */\n    this._prevParams = null;\n\n    // enforce dispatch to aways work on same context (#47)\n    var self = this;\n\n    /**\n    * @property {function} dispatch - The dispatch function is what sends the Signal out.\n    */\n    this.dispatch = function(){\n        Phaser.Signal.prototype.dispatch.apply(self, arguments);\n    };\n\n};\n\nPhaser.Signal.prototype = {\n\n    /**\n    * If Signal should keep record of previously dispatched parameters and\n    * automatically execute listener during `add()`/`addOnce()` if Signal was\n    * already dispatched before.\n    * @property {boolean} memorize\n    */\n    memorize: false,\n\n    /**\n    * @property {boolean} _shouldPropagate\n    * @private\n    */\n    _shouldPropagate: true,\n\n    /**\n    * If Signal is active and should broadcast events.\n    * <p><strong>IMPORTANT:</strong> Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.</p>\n    * @property {boolean} active\n    * @default\n    */\n    active: true,\n\n    /**\n    * @method Phaser.Signal#validateListener\n    * @param {function} listener - Signal handler function.\n    * @param {string} fnName - Function name.\n    * @private\n    */\n    validateListener: function (listener, fnName) {\n        if (typeof listener !== 'function') {\n            throw new Error('listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));\n        }\n    },\n\n    /**\n    * @method Phaser.Signal#_registerListener\n    * @param {function} listener - Signal handler function.\n    * @param {boolean} isOnce - Description.\n    * @param {object} [listenerContext] - Description.\n    * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0).\n    * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.\n    * @private\n    */\n    _registerListener: function (listener, isOnce, listenerContext, priority) {\n\n        var prevIndex = this._indexOfListener(listener, listenerContext),\n            binding;\n\n        if (prevIndex !== -1) {\n            binding = this._bindings[prevIndex];\n            if (binding.isOnce() !== isOnce) {\n                throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');\n            }\n        } else {\n            binding = new Phaser.SignalBinding(this, listener, isOnce, listenerContext, priority);\n            this._addBinding(binding);\n        }\n\n        if (this.memorize && this._prevParams) {\n            binding.execute(this._prevParams);\n        }\n\n        return binding;\n    },\n\n    /**\n    * @method Phaser.Signal#_addBinding\n    * @param {Phaser.SignalBinding} binding - An Object representing the binding between the Signal and listener.\n    * @private\n    */\n    _addBinding: function (binding) {\n        //simplified insertion sort\n        var n = this._bindings.length;\n        do { --n; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);\n        this._bindings.splice(n + 1, 0, binding);\n    },\n\n    /**\n    * @method Phaser.Signal#_indexOfListener\n    * @param {function} listener - Signal handler function.\n    * @return {number} Description.\n    * @private\n    */\n    _indexOfListener: function (listener, context) {\n        var n = this._bindings.length,\n            cur;\n        while (n--) {\n            cur = this._bindings[n];\n            if (cur._listener === listener && cur.context === context) {\n                return n;\n            }\n        }\n        return -1;\n    },\n\n    /**\n    * Check if listener was attached to Signal.\n    *\n    * @method Phaser.Signal#has\n    * @param {Function} listener - Signal handler function.\n    * @param {Object} [context] - Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n    * @return {boolean} If Signal has the specified listener.\n    */\n    has: function (listener, context) {\n        return this._indexOfListener(listener, context) !== -1;\n    },\n\n    /**\n    * Add a listener to the signal.\n    *\n    * @method Phaser.Signal#add\n    * @param {function} listener - Signal handler function.\n    * @param {object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n    * @param {number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0).\n    * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.\n    */\n    add: function (listener, listenerContext, priority) {\n        this.validateListener(listener, 'add');\n        return this._registerListener(listener, false, listenerContext, priority);\n    },\n\n    /**\n    * Add listener to the signal that should be removed after first execution (will be executed only once).\n    *\n    * @method Phaser.Signal#addOnce\n    * @param {function} listener Signal handler function.\n    * @param {object} [listenerContext] Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n    * @param {number} [priority] The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0)\n    * @return {Phaser.SignalBinding} An Object representing the binding between the Signal and listener.\n    */\n    addOnce: function (listener, listenerContext, priority) {\n        this.validateListener(listener, 'addOnce');\n        return this._registerListener(listener, true, listenerContext, priority);\n    },\n\n    /**\n    * Remove a single listener from the dispatch queue.\n    *\n    * @method Phaser.Signal#remove\n    * @param {function} listener Handler function that should be removed.\n    * @param {object} [context] Execution context (since you can add the same handler multiple times if executing in a different context).\n    * @return {function} Listener handler function.\n    */\n    remove: function (listener, context) {\n\n        this.validateListener(listener, 'remove');\n\n        var i = this._indexOfListener(listener, context);\n\n        if (i !== -1)\n        {\n            this._bindings[i]._destroy(); //no reason to a Phaser.SignalBinding exist if it isn't attached to a signal\n            this._bindings.splice(i, 1);\n        }\n\n        return listener;\n\n    },\n\n    /**\n    * Remove all listeners from the Signal.\n    *\n    * @method Phaser.Signal#removeAll\n    */\n    removeAll: function () {\n        var n = this._bindings.length;\n        while (n--) {\n            this._bindings[n]._destroy();\n        }\n        this._bindings.length = 0;\n    },\n\n    /**\n    * Gets the total number of listeneres attached to ths Signal.\n    *\n    * @method Phaser.Signal#getNumListeners\n    * @return {number} Number of listeners attached to the Signal.\n    */\n    getNumListeners: function () {\n        return this._bindings.length;\n    },\n\n    /**\n    * Stop propagation of the event, blocking the dispatch to next listeners on the queue.\n    * IMPORTANT: should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.\n    * @see Signal.prototype.disable\n    *\n    * @method Phaser.Signal#halt\n    */\n    halt: function () {\n        this._shouldPropagate = false;\n    },\n\n    /**\n    * Dispatch/Broadcast Signal to all listeners added to the queue.\n    *\n    * @method Phaser.Signal#dispatch\n    * @param {any} [params] - Parameters that should be passed to each handler.\n    */\n    dispatch: function () {\n\n        if (!this.active)\n        {\n            return;\n        }\n\n        var paramsArr = Array.prototype.slice.call(arguments);\n        var n = this._bindings.length;\n        var bindings;\n\n        if (this.memorize)\n        {\n            this._prevParams = paramsArr;\n        }\n\n        if (!n)\n        {\n            //  Should come after memorize\n            return;\n        }\n\n        bindings = this._bindings.slice(); //clone array in case add/remove items during dispatch\n        this._shouldPropagate = true; //in case `halt` was called before dispatch or during the previous dispatch.\n\n        //execute all callbacks until end of the list or until a callback returns `false` or stops propagation\n        //reverse loop since listeners with higher priority will be added at the end of the list\n        do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);\n\n    },\n\n    /**\n    * Forget memorized arguments.\n    * @see Signal.memorize\n    *\n    * @method Phaser.Signal#forget\n    */\n    forget: function(){\n        this._prevParams = null;\n    },\n\n    /**\n    * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).\n    * IMPORTANT: calling any method on the signal instance after calling dispose will throw errors.\n    *\n    * @method Phaser.Signal#dispose\n    */\n    dispose: function () {\n        this.removeAll();\n        delete this._bindings;\n        delete this._prevParams;\n    },\n\n    /**\n    *\n    * @method Phaser.Signal#toString\n    * @return {string} String representation of the object.\n    */\n    toString: function () {\n        return '[Phaser.Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']';\n    }\n\n};\n\nPhaser.Signal.prototype.constructor = Phaser.Signal;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.SignalBinding\n* @classdesc Object that represents a binding between a Signal and a listener function.\n* This is an internal constructor and shouldn't be called by regular users.\n* Inspired by Joa Ebert AS3 SignalBinding and Robert Penner's Slot classes.\n*\n* @author Miller Medeiros http://millermedeiros.github.com/js-signals/\n* @constructor\n* @param {Phaser.Signal} signal - Reference to Signal object that listener is currently bound to.\n* @param {function} listener - Handler function bound to the signal.\n* @param {boolean} isOnce - If binding should be executed just once.\n* @param {object} [listenerContext] - Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n* @param {number} [priority] - The priority level of the event listener. (default = 0).\n*/\nPhaser.SignalBinding = function (signal, listener, isOnce, listenerContext, priority) {\n\n    /**\n    * @property {Phaser.Game} _listener - Handler function bound to the signal.\n    * @private\n    */\n    this._listener = listener;\n\n    /**\n    * @property {boolean} _isOnce - If binding should be executed just once.\n    * @private\n    */\n    this._isOnce = isOnce;\n\n    /**\n    * @property {object|undefined|null} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).\n    */\n    this.context = listenerContext;\n\n    /**\n    * @property {Phaser.Signal} _signal - Reference to Signal object that listener is currently bound to.\n    * @private\n    */\n    this._signal = signal;\n\n    /**\n    * @property {number} _priority - Listener priority.\n    * @private\n    */\n    this._priority = priority || 0;\n\n};\n\nPhaser.SignalBinding.prototype = {\n\n    /**\n    * If binding is active and should be executed.\n    * @property {boolean} active\n    * @default\n    */\n    active: true,\n\n    /**\n    * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute` (curried parameters).\n    * @property {array|null} params\n    * @default\n    */\n    params: null,\n\n    /**\n    * Call listener passing arbitrary parameters.\n    * If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.\n    * @method Phaser.SignalBinding#execute\n    * @param {array} [paramsArr] - Array of parameters that should be passed to the listener.\n    * @return {any} Value returned by the listener.\n    */\n    execute: function(paramsArr) {\n\n        var handlerReturn, params;\n\n        if (this.active && !!this._listener)\n        {\n            params = this.params ? this.params.concat(paramsArr) : paramsArr;\n            handlerReturn = this._listener.apply(this.context, params);\n\n            if (this._isOnce)\n            {\n                this.detach();\n            }\n        }\n\n        return handlerReturn;\n\n    },\n\n    /**\n    * Detach binding from signal.\n    * alias to: @see mySignal.remove(myBinding.getListener());\n    * @method Phaser.SignalBinding#detach\n    * @return {function|null} Handler function bound to the signal or `null` if binding was previously detached.\n    */\n    detach: function () {\n        return this.isBound() ? this._signal.remove(this._listener, this.context) : null;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#isBound\n    * @return {boolean} True if binding is still bound to the signal and has a listener.\n    */\n    isBound: function () {\n        return (!!this._signal && !!this._listener);\n    },\n\n    /**\n    * @method Phaser.SignalBinding#isOnce\n    * @return {boolean} If SignalBinding will only be executed once.\n    */\n    isOnce: function () {\n        return this._isOnce;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#getListener\n    * @return {Function} Handler function bound to the signal.\n    */\n    getListener: function () {\n        return this._listener;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#getSignal\n    * @return {Signal} Signal that listener is currently bound to.\n    */\n    getSignal: function () {\n        return this._signal;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#_destroy\n    * Delete instance properties\n    * @private\n    */\n    _destroy: function () {\n        delete this._signal;\n        delete this._listener;\n        delete this.context;\n    },\n\n    /**\n    * @method Phaser.SignalBinding#toString\n    * @return {string} String representation of the object.\n    */\n    toString: function () {\n        return '[Phaser.SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']';\n    }\n\n};\n\nPhaser.SignalBinding.prototype.constructor = Phaser.SignalBinding;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is a base Filter template to use for any Phaser filter development.\n*\n* @class Phaser.Filter\n* @classdesc Phaser - Filter\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Object} uniforms - Uniform mappings object\n* @param {Array} fragmentSrc - The fragment shader code.\n*/\nPhaser.Filter = function (game, uniforms, fragmentSrc) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {number} type - The const type of this object, either Phaser.WEBGL_FILTER or Phaser.CANVAS_FILTER.\n    * @default\n    */\n    this.type = Phaser.WEBGL_FILTER;\n\n    /**\n    * An array of passes - some filters contain a few steps this array simply stores the steps in a linear fashion.\n    * For example the blur filter has two passes blurX and blurY.\n    * @property {array} passes - An array of filter objects.\n    * @private\n    */\n    this.passes = [this];\n\n    /**\n    * @property {array} shaders - Array an array of shaders.\n    * @private\n    */\n    this.shaders = [];\n\n    /**\n    * @property {boolean} dirty - Internal PIXI var.\n    * @default\n    */\n    this.dirty = true;\n\n    /**\n    * @property {number} padding - Internal PIXI var.\n    * @default\n    */\n    this.padding = 0;\n\n    /**\n    * @property {object} uniforms - Default uniform mappings.\n    */\n    this.uniforms = {\n\n        time: { type: '1f', value: 0 },\n        resolution: { type: '2f', value: { x: 256, y: 256 }},\n        mouse: { type: '2f', value: { x: 0.0, y: 0.0 }}\n\n    };\n\n    /**\n    * @property {array} fragmentSrc - The fragment shader code.\n    */\n    this.fragmentSrc = fragmentSrc || [];\n\n};\n\nPhaser.Filter.prototype = {\n\n    /**\n    * Should be over-ridden.\n    * @method Phaser.Filter#init\n    */\n    init: function () {\n        //  This should be over-ridden. Will receive a variable number of arguments.\n    },\n\n    /**\n    * Set the resolution uniforms on the filter.\n    * @method Phaser.Filter#setResolution\n    * @param {number} width - The width of the display.\n    * @param {number} height - The height of the display.\n    */\n    setResolution: function (width, height) {\n\n        this.uniforms.resolution.value.x = width;\n        this.uniforms.resolution.value.y = height;\n\n    },\n\n    /**\n    * Updates the filter.\n    * @method Phaser.Filter#update\n    * @param {Phaser.Pointer} [pointer] - A Pointer object to use for the filter. The coordinates are mapped to the mouse uniform.\n    */\n    update: function (pointer) {\n\n        if (typeof pointer !== 'undefined')\n        {\n            if (pointer.x > 0)\n            {\n                this.uniforms.mouse.x = pointer.x.toFixed(2);\n            }\n\n            if (pointer.y > 0)\n            {\n                this.uniforms.mouse.y = pointer.y.toFixed(2);\n            }\n        }\n\n        this.uniforms.time.value = this.game.time.totalElapsedSeconds();\n\n    },\n\n    /**\n    * Clear down this Filter and null out references\n    * @method Phaser.Filter#destroy\n    */\n    destroy: function () {\n\n        this.game = null;\n\n    }\n\n};\n\nPhaser.Filter.prototype.constructor = Phaser.Filter;\n\n/**\n* @name Phaser.Filter#width\n* @property {number} width - The width (resolution uniform)\n*/\nObject.defineProperty(Phaser.Filter.prototype, 'width', {\n\n    get: function() {\n        return this.uniforms.resolution.value.x;\n    },\n\n    set: function(value) {\n        this.uniforms.resolution.value.x = value;\n    }\n\n});\n\n/**\n* @name Phaser.Filter#height\n* @property {number} height - The height (resolution uniform)\n*/\nObject.defineProperty(Phaser.Filter.prototype, 'height', {\n\n    get: function() {\n        return this.uniforms.resolution.value.y;\n    },\n\n    set: function(value) {\n        this.uniforms.resolution.value.y = value;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* This is a base Plugin template to use for any Phaser plugin development.\n*\n* @class Phaser.Plugin\n* @classdesc Phaser - Plugin\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Any} parent - The object that owns this plugin, usually Phaser.PluginManager.\n*/\nPhaser.Plugin = function (game, parent) {\n\n    if (typeof parent === 'undefined') { parent = null; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Any} parent - The parent of this plugin. If added to the PluginManager the parent will be set to that, otherwise it will be null.\n    */\n    this.parent = parent;\n\n    /**\n    * @property {boolean} active - A Plugin with active=true has its preUpdate and update methods called by the parent, otherwise they are skipped.\n    * @default\n    */\n    this.active = false;\n\n    /**\n    * @property {boolean} visible - A Plugin with visible=true has its render and postRender methods called by the parent, otherwise they are skipped.\n    * @default\n    */\n    this.visible = false;\n\n    /**\n    * @property {boolean} hasPreUpdate - A flag to indicate if this plugin has a preUpdate method.\n    * @default\n    */\n    this.hasPreUpdate = false;\n\n    /**\n    * @property {boolean} hasUpdate - A flag to indicate if this plugin has an update method.\n    * @default\n    */\n    this.hasUpdate = false;\n\n    /**\n    * @property {boolean} hasPostUpdate - A flag to indicate if this plugin has a postUpdate method.\n    * @default\n    */\n    this.hasPostUpdate = false;\n\n    /**\n    * @property {boolean} hasRender - A flag to indicate if this plugin has a render method.\n    * @default\n    */\n    this.hasRender = false;\n\n    /**\n    * @property {boolean} hasPostRender - A flag to indicate if this plugin has a postRender method.\n    * @default\n    */\n    this.hasPostRender = false;\n\n};\n\nPhaser.Plugin.prototype = {\n\n    /**\n    * Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).\n    * It is only called if active is set to true.\n    * @method Phaser.Plugin#preUpdate\n    */\n    preUpdate: function () {\n    },\n\n    /**\n    * Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.\n    * It is only called if active is set to true.\n    * @method Phaser.Plugin#update\n    */\n    update: function () {\n    },\n\n    /**\n    * Render is called right after the Game Renderer completes, but before the State.render.\n    * It is only called if visible is set to true.\n    * @method Phaser.Plugin#render\n    */\n    render: function () {\n    },\n\n    /**\n    * Post-render is called after the Game Renderer and State.render have run.\n    * It is only called if visible is set to true.\n    * @method Phaser.Plugin#postRender\n    */\n    postRender: function () {\n    },\n\n    /**\n    * Clear down this Plugin and null out references\n    * @method Phaser.Plugin#destroy\n    */\n    destroy: function () {\n\n        this.game = null;\n        this.parent = null;\n        this.active = false;\n        this.visible = false;\n\n    }\n\n};\n\nPhaser.Plugin.prototype.constructor = Phaser.Plugin;\n\n/* jshint newcap: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Plugin Manager is responsible for the loading, running and unloading of Phaser Plugins.\n*\n* @class Phaser.PluginManager\n* @classdesc Phaser - PluginManager\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.PluginManager = function(game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {array} plugins - An array of all the plugins being managed by this PluginManager.\n    */\n    this.plugins = [];\n\n    /**\n    * @property {number} _len - Internal cache var.\n    * @private\n    */\n    this._len = 0;\n\n    /**\n    * @property {number} _i - Internal cache var.\n    * @private\n    */\n    this._i = 0;\n\n};\n\nPhaser.PluginManager.prototype = {\n\n    /**\n    * Add a new Plugin into the PluginManager.\n    * The Plugin must have 2 properties: game and parent. Plugin.game is set to ths game reference the PluginManager uses, and parent is set to the PluginManager.\n    *\n    * @method Phaser.PluginManager#add\n    * @param {object|Phaser.Plugin} plugin - The Plugin to add into the PluginManager. This can be a function or an existing object.\n    * @return {Phaser.Plugin} The Plugin that was added to the manager.\n    */\n    add: function (plugin) {\n\n        var result = false;\n\n        //  Prototype?\n        if (typeof plugin === 'function')\n        {\n            plugin = new plugin(this.game, this._parent);\n        }\n        else\n        {\n            plugin.game = this.game;\n            plugin.parent = this;\n        }\n\n        //  Check for methods now to avoid having to do this every loop\n        if (typeof plugin['preUpdate'] === 'function')\n        {\n            plugin.hasPreUpdate = true;\n            result = true;\n        }\n\n        if (typeof plugin['update'] === 'function')\n        {\n            plugin.hasUpdate = true;\n            result = true;\n        }\n\n        if (typeof plugin['postUpdate'] === 'function')\n        {\n            plugin.hasPostUpdate = true;\n            result = true;\n        }\n\n        if (typeof plugin['render'] === 'function')\n        {\n            plugin.hasRender = true;\n            result = true;\n        }\n\n        if (typeof plugin['postRender'] === 'function')\n        {\n            plugin.hasPostRender = true;\n            result = true;\n        }\n\n        //  The plugin must have at least one of the above functions to be added to the PluginManager.\n        if (result)\n        {\n            if (plugin.hasPreUpdate || plugin.hasUpdate || plugin.hasPostUpdate)\n            {\n                plugin.active = true;\n            }\n\n            if (plugin.hasRender || plugin.hasPostRender)\n            {\n                plugin.visible = true;\n            }\n\n            this._len = this.plugins.push(plugin);\n\n            // Allows plugins to run potentially destructive code outside of the constructor, and only if being added to the PluginManager\n            if (typeof plugin['init'] === 'function')\n            {\n                plugin.init();\n            }\n\n            return plugin;\n        }\n        else\n        {\n            return null;\n        }\n    },\n\n    /**\n    * Remove a Plugin from the PluginManager. It calls Plugin.destroy on the plugin before removing it from the manager.\n    *\n    * @method Phaser.PluginManager#remove\n    * @param {Phaser.Plugin} plugin - The plugin to be removed.\n    */\n    remove: function (plugin) {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i] === plugin)\n            {\n                plugin.destroy();\n                this.plugins.splice(this._i, 1);\n                this._len--;\n                return;\n            }\n        }\n\n    },\n\n    /**\n    * Remove all Plugins from the PluginManager. It calls Plugin.destroy on every plugin before removing it from the manager.\n    *\n    * @method Phaser.PluginManager#removeAll\n    */\n    removeAll: function() {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            this.plugins[this._i].destroy();\n        }\n\n        this.plugins.length = 0;\n        this._len = 0;\n\n    },\n\n    /**\n    * Pre-update is called at the very start of the update cycle, before any other subsystems have been updated (including Physics).\n    * It only calls plugins who have active=true.\n    *\n    * @method Phaser.PluginManager#preUpdate\n    */\n    preUpdate: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate)\n            {\n                this.plugins[this._i].preUpdate();\n            }\n        }\n\n    },\n\n    /**\n    * Update is called after all the core subsystems (Input, Tweens, Sound, etc) and the State have updated, but before the render.\n    * It only calls plugins who have active=true.\n    *\n    * @method Phaser.PluginManager#update\n    */\n    update: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate)\n            {\n                this.plugins[this._i].update();\n            }\n        }\n\n    },\n\n    /**\n    * PostUpdate is the last thing to be called before the world render.\n    * In particular, it is called after the world postUpdate, which means the camera has been adjusted.\n    * It only calls plugins who have active=true.\n    *\n    * @method Phaser.PluginManager#postUpdate\n    */\n    postUpdate: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate)\n            {\n                this.plugins[this._i].postUpdate();\n            }\n        }\n\n    },\n\n    /**\n    * Render is called right after the Game Renderer completes, but before the State.render.\n    * It only calls plugins who have visible=true.\n    *\n    * @method Phaser.PluginManager#render\n    */\n    render: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].visible && this.plugins[this._i].hasRender)\n            {\n                this.plugins[this._i].render();\n            }\n        }\n\n    },\n\n    /**\n    * Post-render is called after the Game Renderer and State.render have run.\n    * It only calls plugins who have visible=true.\n    *\n    * @method Phaser.PluginManager#postRender\n    */\n    postRender: function () {\n\n        this._i = this._len;\n\n        while (this._i--)\n        {\n            if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender)\n            {\n                this.plugins[this._i].postRender();\n            }\n        }\n\n    },\n\n    /**\n    * Clear down this PluginManager, calls destroy on every plugin and nulls out references.\n    *\n    * @method Phaser.PluginManager#destroy\n    */\n    destroy: function () {\n\n        this.removeAll();\n\n        this.game = null;\n\n    }\n\n};\n\nPhaser.PluginManager.prototype.constructor = Phaser.PluginManager;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Stage controls the canvas on which everything is displayed. It handles display within the browser,\n* focus handling, game resizing, scaling and the pause, boot and orientation screens.\n*\n* @class Phaser.Stage\n* @extends PIXI.Stage\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n* @param {number} width - Width of the canvas element.\n* @param {number} height - Height of the canvas element.\n */\nPhaser.Stage = function (game, width, height) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Point} offset - Holds the offset coordinates of the Game.canvas from the top-left of the browser window (used by Input and other classes)\n    */\n    this.offset = new Phaser.Point();\n\n    PIXI.Stage.call(this, 0x000000, false);\n\n    /**\n    * @property {string} name - The name of this object.\n    * @default\n    */\n    this.name = '_stage_root';\n\n    this.interactive = false;\n\n    /**\n    * @property {boolean} disableVisibilityChange - By default if the browser tab loses focus the game will pause. You can stop that behaviour by setting this property to true.\n    * @default\n    */\n    this.disableVisibilityChange = false;\n\n    /**\n    * @property {number|false} checkOffsetInterval - The time (in ms) between which the stage should check to see if it has moved.\n    * @default\n    */\n    this.checkOffsetInterval = 2500;\n\n    /**\n    * @property {boolean} exists - If exists is true the Stage and all children are updated, otherwise it is skipped.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * @property {number} currentRenderOrderID - Reset each frame, keeps a count of the total number of objects updated.\n    */\n    this.currentRenderOrderID = 0;\n\n    /**\n    * @property {string} hiddenVar - The page visibility API event name.\n    * @private\n    */\n    this._hiddenVar = 'hidden';\n\n    /**\n    * @property {number} _nextOffsetCheck - The time to run the next offset check.\n    * @private\n    */\n    this._nextOffsetCheck = 0;\n\n    /**\n    * @property {number} _backgroundColor - Stage background color.\n    * @private\n    */\n    this._backgroundColor = 0x000000;\n\n    if (game.config)\n    {\n        this.parseConfig(game.config);\n    }\n    else\n    {\n        this.game.canvas = Phaser.Canvas.create(width, height);\n        this.game.canvas.style['-webkit-full-screen'] = 'width: 100%; height: 100%';\n    }\n\n};\n\nPhaser.Stage.prototype = Object.create(PIXI.Stage.prototype);\nPhaser.Stage.prototype.constructor = Phaser.Stage;\n\n/**\n* This is called automatically after the plugins preUpdate and before the State.update.\n* Most objects have preUpdate methods and it's where initial movement and positioning is done.\n*\n* @method Phaser.Stage#preUpdate\n*/\nPhaser.Stage.prototype.preUpdate = function () {\n\n    this.currentRenderOrderID = 0;\n\n    //  This can't loop in reverse, we need the orderID to be in sequence\n    var len = this.children.length;\n\n    for (var i = 0; i < len; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n};\n\n/**\n* This is called automatically after the State.update, but before particles or plugins update.\n*\n* @method Phaser.Stage#update\n*/\nPhaser.Stage.prototype.update = function () {\n\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].update();\n    }\n\n};\n\n/**\n* This is called automatically before the renderer runs and after the plugins have updated.\n* In postUpdate this is where all the final physics calculatations and object positioning happens.\n* The objects are processed in the order of the display list.\n* The only exception to this is if the camera is following an object, in which case that is updated first.\n*\n* @method Phaser.Stage#postUpdate\n*/\nPhaser.Stage.prototype.postUpdate = function () {\n\n    if (this.game.world.camera.target)\n    {\n        this.game.world.camera.target.postUpdate();\n\n        this.game.world.camera.update();\n\n        var i = this.children.length;\n\n        while (i--)\n        {\n            if (this.children[i] !== this.game.world.camera.target)\n            {\n                this.children[i].postUpdate();\n            }\n        }\n    }\n    else\n    {\n        this.game.world.camera.update();\n\n        var i = this.children.length;\n\n        while (i--)\n        {\n            this.children[i].postUpdate();\n        }\n    }\n\n    if (this.checkOffsetInterval !== false)\n    {\n        if (this.game.time.now > this._nextOffsetCheck)\n        {\n            Phaser.Canvas.getOffset(this.game.canvas, this.offset);\n            this._nextOffsetCheck = this.game.time.now + this.checkOffsetInterval;\n        }\n    }\n\n};\n\n/**\n* Parses a Game configuration object.\n*\n* @method Phaser.Stage#parseConfig\n* @protected\n*/\nPhaser.Stage.prototype.parseConfig = function (config) {\n\n    if (config['canvasID'])\n    {\n        this.game.canvas = Phaser.Canvas.create(this.game.width, this.game.height, config['canvasID']);\n    }\n    else\n    {\n        this.game.canvas = Phaser.Canvas.create(this.game.width, this.game.height);\n    }\n\n    if (config['canvasStyle'])\n    {\n        this.game.canvas.stlye = config['canvasStyle'];\n    }\n    else\n    {\n        this.game.canvas.style['-webkit-full-screen'] = 'width: 100%; height: 100%';\n    }\n\n    if (config['checkOffsetInterval'])\n    {\n        this.checkOffsetInterval = config['checkOffsetInterval'];\n    }\n\n    if (config['disableVisibilityChange'])\n    {\n        this.disableVisibilityChange = config['disableVisibilityChange'];\n    }\n\n    if (config['fullScreenScaleMode'])\n    {\n        this.fullScreenScaleMode = config['fullScreenScaleMode'];\n    }\n\n    if (config['scaleMode'])\n    {\n        this.scaleMode = config['scaleMode'];\n    }\n\n    if (config['backgroundColor'])\n    {\n        this.backgroundColor = config['backgroundColor'];\n    }\n\n};\n\n/**\n* Initialises the stage and adds the event listeners.\n* @method Phaser.Stage#boot\n* @private\n*/\nPhaser.Stage.prototype.boot = function () {\n\n    Phaser.Canvas.getOffset(this.game.canvas, this.offset);\n\n    this.bounds = new Phaser.Rectangle(this.offset.x, this.offset.y, this.game.width, this.game.height);\n\n    var _this = this;\n\n    this._onChange = function (event) {\n        return _this.visibilityChange(event);\n    };\n\n    Phaser.Canvas.setUserSelect(this.game.canvas, 'none');\n    Phaser.Canvas.setTouchAction(this.game.canvas, 'none');\n\n    this.checkVisibility();\n\n};\n\n/**\n* Starts a page visibility event listener running, or window.blur/focus if not supported by the browser.\n* @method Phaser.Stage#checkVisibility\n*/\nPhaser.Stage.prototype.checkVisibility = function () {\n\n    if (document.webkitHidden !== undefined)\n    {\n        this._hiddenVar = 'webkitvisibilitychange';\n    }\n    else if (document.mozHidden !== undefined)\n    {\n        this._hiddenVar = 'mozvisibilitychange';\n    }\n    else if (document.msHidden !== undefined)\n    {\n        this._hiddenVar = 'msvisibilitychange';\n    }\n    else if (document.hidden !== undefined)\n    {\n        this._hiddenVar = 'visibilitychange';\n    }\n    else\n    {\n        this._hiddenVar = null;\n    }\n\n    //  Does browser support it? If not (like in IE9 or old Android) we need to fall back to blur/focus\n    if (this._hiddenVar)\n    {\n        document.addEventListener(this._hiddenVar, this._onChange, false);\n    }\n\n    window.onpagehide = this._onChange;\n    window.onpageshow = this._onChange;\n\n    window.onblur = this._onChange;\n    window.onfocus = this._onChange;\n\n};\n\n/**\n* This method is called when the document visibility is changed.\n* @method Phaser.Stage#visibilityChange\n* @param {Event} event - Its type will be used to decide whether the game should be paused or not.\n*/\nPhaser.Stage.prototype.visibilityChange = function (event) {\n\n    if (this.disableVisibilityChange)\n    {\n        return;\n    }\n\n    if (event.type === 'pagehide' || event.type === 'blur' || event.type === 'pageshow' || event.type === 'focus')\n    {\n        if (event.type === 'pagehide' || event.type === 'blur')\n        {\n            this.game.focusLoss(event);\n        }\n        else if (event.type === 'pageshow' || event.type === 'focus')\n        {\n            this.game.focusGain(event);\n        }\n\n        return;\n    }\n\n    if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden)\n    {\n        this.game.gamePaused(event);\n    }\n    else\n    {\n        this.game.gameResumed(event);\n    }\n\n};\n\n/**\n* Sets the background color for the stage.\n*\n* @name Phaser.Stage#setBackgroundColor\n* @param {number} backgroundColor - The color of the background, easiest way to pass this in is in hex format like: 0xFFFFFF for white.\n*/\nPhaser.Stage.prototype.setBackgroundColor = function(backgroundColor)\n{\n    this._backgroundColor = backgroundColor || 0x000000;\n    this.backgroundColorSplit = PIXI.hex2rgb(this.backgroundColor);\n    var hex = this._backgroundColor.toString(16);\n    hex = '000000'.substr(0, 6 - hex.length) + hex;\n    this.backgroundColorString = '#' + hex;\n};\n\n/**\n* @name Phaser.Stage#backgroundColor\n* @property {number|string} backgroundColor - Gets and sets the background color of the stage. The color can be given as a number: 0xff0000 or a hex string: '#ff0000'\n*/\nObject.defineProperty(Phaser.Stage.prototype, \"backgroundColor\", {\n\n    get: function () {\n        return this._backgroundColor;\n    },\n\n    set: function (color) {\n\n        this._backgroundColor = color;\n\n        if (this.game.transparent === false)\n        {\n            if (typeof color === 'string')\n            {\n                color = Phaser.Color.hexToRGB(color);\n            }\n\n            this.setBackgroundColor(color);\n        }\n\n    }\n\n});\n\n/**\n* Enable or disable texture smoothing for all objects on this Stage. Only works for bitmap/image textures. Smoothing is enabled by default.\n*\n* @name Phaser.Stage#smoothed\n* @property {boolean} smoothed - Set to true to smooth all sprites rendered on this Stage, or false to disable smoothing (great for pixel art)\n*/\nObject.defineProperty(Phaser.Stage.prototype, \"smoothed\", {\n\n    get: function () {\n\n        return !PIXI.scaleModes.LINEAR;\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            PIXI.scaleModes.LINEAR = 0;\n        }\n        else\n        {\n            PIXI.scaleModes.LINEAR = 1;\n        }\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser Group constructor.\n* @class Phaser.Group\n* @classdesc A Group is a container for display objects that allows for fast pooling and object recycling. Groups can be nested within other Groups and have their own local transforms.\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Phaser.Group|Phaser.Sprite|null} parent - The parent Group, DisplayObject or DisplayObjectContainer that this Group will be added to. If undefined it will use game.world. If null it won't be added to anything.\n* @param {string} [name=group] - A name for this Group. Not used internally but useful for debugging.\n* @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n* @param {boolean} [enableBody=false] - If true all Sprites created with `Group.create` or `Group.createMulitple` will have a physics body created on them. Change the body type with physicsBodyType.\n* @param {number} [physicsBodyType=0] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.\n*/\nPhaser.Group = function (game, parent, name, addToStage, enableBody, physicsBodyType) {\n\n    if (typeof addToStage === 'undefined') { addToStage = false; }\n    if (typeof enableBody === 'undefined') { enableBody = false; }\n    if (typeof physicsBodyType === 'undefined') { physicsBodyType = Phaser.Physics.ARCADE; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    if (typeof parent === 'undefined')\n    {\n        parent = game.world;\n    }\n\n    /**\n    * @property {string} name - A name for this Group. Not used internally but useful for debugging.\n    */\n    this.name = name || 'group';\n\n    PIXI.DisplayObjectContainer.call(this);\n\n    if (addToStage)\n    {\n        this.game.stage.addChild(this);\n    }\n    else\n    {\n        if (parent)\n        {\n            parent.addChild(this);\n        }\n    }\n\n    /**\n    * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.\n    */\n    this.z = 0;\n\n    /**\n    * @property {number} type - Internal Phaser Type value.\n    * @protected\n    */\n    this.type = Phaser.GROUP;\n\n    /**\n    * @property {boolean} alive - The alive property is useful for Groups that are children of other Groups and need to be included/excluded in checks like forEachAlive.\n    * @default\n    */\n    this.alive = true;\n\n    /**\n    * @property {boolean} exists - If exists is true the Group is updated, otherwise it is skipped.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * The type of objects that will be created when you use Group.create or Group.createMultiple. Defaults to Phaser.Sprite.\n    * When a new object is created it is passed the following parameters to its constructor: game, x, y, key, frame.\n    * @property {object} classType\n    * @default\n    */\n    this.classType = Phaser.Sprite;\n\n    /**\n    * @property {Phaser.Group|Phaser.Sprite} parent - The parent of this Group.\n    */\n\n    /**\n    * @property {Phaser.Point} scale - The scale of the Group container.\n    */\n    this.scale = new Phaser.Point(1, 1);\n\n    /**\n    * @property {Phaser.Point} pivot - The pivot point of the Group container.\n    */\n\n    /**\n    * The cursor is a simple way to iterate through the objects in a Group using the Group.next and Group.previous functions.\n    * The cursor is set to the first child added to the Group and doesn't change unless you call next, previous or set it directly with Group.cursor.\n    * @property {any} cursor - The current display object that the Group cursor is pointing to.\n    */\n    this.cursor = null;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    /**\n    * @property {boolean} enableBody - If true all Sprites created by, or added to this Group, will have a physics body enabled on them. Change the body type with `Group.physicsBodyType`.\n    * @default\n    */\n    this.enableBody = enableBody;\n\n    /**\n    * @property {boolean} enableBodyDebug - If true when a physics body is created (via Group.enableBody) it will create a physics debug object as well. Only works for P2 bodies.\n    */\n    this.enableBodyDebug = false;\n\n    /**\n    * @property {number} physicsBodyType - If Group.enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.\n    */\n    this.physicsBodyType = physicsBodyType;\n\n    /**\n    * @property {string} _sortProperty - The property on which children are sorted.\n    * @private\n    */\n    this._sortProperty = 'z';\n\n    /**\n    * A small internal cache:\n    * 0 = previous position.x\n    * 1 = previous position.y\n    * 2 = previous rotation\n    * 3 = renderID\n    * 4 = fresh? (0 = no, 1 = yes)\n    * 5 = outOfBoundsFired (0 = no, 1 = yes)\n    * 6 = exists (0 = no, 1 = yes)\n    * 7 = fixed to camera (0 = no, 1 = yes)\n    * 8 = cursor index\n    * 9 = sort order\n    * @property {Array} _cache\n    * @private\n    */\n    this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0, 0 ];\n\n};\n\nPhaser.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPhaser.Group.prototype.constructor = Phaser.Group;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Group.RETURN_NONE = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Group.RETURN_TOTAL = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Group.RETURN_CHILD = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Group.SORT_ASCENDING = -1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Group.SORT_DESCENDING = 1;\n\n/**\n* Adds an existing object to this Group. The object can be an instance of Phaser.Sprite, Phaser.Button or any other display object.\n* The child is automatically added to the top of the Group, so renders on-top of everything else within the Group. If you need to control\n* that then see the addAt method.\n*\n* @see Phaser.Group#create\n* @see Phaser.Group#addAt\n* @method Phaser.Group#add\n* @param {*} child - An instance of Phaser.Sprite, Phaser.Button or any other display object..\n* @return {*} The child that was added to the Group.\n*/\nPhaser.Group.prototype.add = function (child) {\n\n    if (child.parent !== this)\n    {\n        if (this.enableBody)\n        {\n            this.game.physics.enable(child, this.physicsBodyType);\n        }\n\n        this.addChild(child);\n\n        child.z = this.children.length;\n\n        if (child.events)\n        {\n            child.events.onAddedToGroup.dispatch(child, this);\n        }\n\n        if (this.cursor === null)\n        {\n            this.cursor = child;\n        }\n    }\n\n    return child;\n\n};\n\n/**\n* Adds an existing object to this Group. The object can be an instance of Phaser.Sprite, Phaser.Button or any other display object.\n* The child is added to the Group at the location specified by the index value, this allows you to control child ordering.\n*\n* @method Phaser.Group#addAt\n* @param {*} child - An instance of Phaser.Sprite, Phaser.Button or any other display object..\n* @param {number} index - The index within the Group to insert the child to.\n* @return {*} The child that was added to the Group.\n*/\nPhaser.Group.prototype.addAt = function (child, index) {\n\n    if (child.parent !== this)\n    {\n        if (this.enableBody)\n        {\n            this.game.physics.enable(child, this.physicsBodyType);\n        }\n\n        this.addChildAt(child, index);\n\n        this.updateZ();\n\n        if (child.events)\n        {\n            child.events.onAddedToGroup.dispatch(child, this);\n        }\n\n        if (this.cursor === null)\n        {\n            this.cursor = child;\n        }\n    }\n\n    return child;\n\n};\n\n/**\n* Returns the child found at the given index within this Group.\n*\n* @method Phaser.Group#getAt\n* @param {number} index - The index to return the child from.\n* @return {*} The child that was found at the given index. If the index was out of bounds then this will return -1.\n*/\nPhaser.Group.prototype.getAt = function (index) {\n\n    if (index < 0 || index >= this.children.length)\n    {\n        return -1;\n    }\n    else\n    {\n        return this.getChildAt(index);\n    }\n\n};\n\n/**\n* Automatically creates a new Phaser.Sprite object and adds it to the top of this Group.\n* You can change Group.classType to any object and this call will create an object of that type instead, but it should extend either Sprite or Image.\n*\n* @method Phaser.Group#create\n* @param {number} x - The x coordinate to display the newly created Sprite at. The value is in relation to the Group.x point.\n* @param {number} y - The y coordinate to display the newly created Sprite at. The value is in relation to the Group.y point.\n* @param {string} key - The Game.cache key of the image that this Sprite will use.\n* @param {number|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.\n* @param {boolean} [exists=true] - The default exists state of the Sprite.\n* @return {Phaser.Sprite|object} The child that was created. Will be a Phaser.Sprite unless Group.classType has been changed.\n*/\nPhaser.Group.prototype.create = function (x, y, key, frame, exists) {\n\n    if (typeof exists === 'undefined') { exists = true; }\n\n    var child = new this.classType(this.game, x, y, key, frame);\n\n    if (this.enableBody)\n    {\n        this.game.physics.enable(child, this.physicsBodyType);\n    }\n\n    child.exists = exists;\n    child.visible = exists;\n    child.alive = exists;\n\n    this.addChild(child);\n\n    child.z = this.children.length;\n\n    if (child.events)\n    {\n        child.events.onAddedToGroup.dispatch(child, this);\n    }\n\n    if (this.cursor === null)\n    {\n        this.cursor = child;\n    }\n\n    return child;\n\n};\n\n/**\n* Automatically creates multiple Phaser.Sprite objects and adds them to the top of this Group.\n* Useful if you need to quickly generate a pool of identical sprites, such as bullets. By default the sprites will be set to not exist\n* and will be positioned at 0, 0 (relative to the Group.x/y)\n* You can change Group.classType to any object and this call will create an object of that type instead, but it should extend either Sprite or Image.\n*\n* @method Phaser.Group#createMultiple\n* @param {number} quantity - The number of Sprites to create.\n* @param {string} key - The Game.cache key of the image that this Sprite will use.\n* @param {number|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.\n* @param {boolean} [exists=false] - The default exists state of the Sprite.\n*/\nPhaser.Group.prototype.createMultiple = function (quantity, key, frame, exists) {\n\n    if (typeof exists === 'undefined') { exists = false; }\n\n    for (var i = 0; i < quantity; i++)\n    {\n        this.create(0, 0, key, frame, exists);\n    }\n\n};\n\n/**\n* Internal method that re-applies all of the childrens Z values.\n*\n* @method Phaser.Group#updateZ\n* @protected\n*/\nPhaser.Group.prototype.updateZ = function () {\n\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].z = i;\n    }\n\n};\n\n/**\n* Sets the Group cursor to the first object in the Group. If the optional index parameter is given it sets the cursor to the object at that index instead.\n*\n* @method Phaser.Group#resetCursor\n* @param {number} [index=0] - Set the cursor to point to a specific index.\n* @return {*} The child the cursor now points to.\n*/\nPhaser.Group.prototype.resetCursor = function (index) {\n\n    if (typeof index === 'undefined') { index = 0; }\n\n    if (index > this.children.length - 1)\n    {\n        index = 0;\n    }\n\n    if (this.cursor)\n    {\n        this._cache[8] = index;\n        this.cursor = this.children[this._cache[8]];\n        return this.cursor;\n    }\n\n};\n\n/**\n* Advances the Group cursor to the next object in the Group. If it's at the end of the Group it wraps around to the first object.\n*\n* @method Phaser.Group#next\n* @return {*} The child the cursor now points to.\n*/\nPhaser.Group.prototype.next = function () {\n\n    if (this.cursor)\n    {\n        //  Wrap the cursor?\n        if (this._cache[8] >= this.children.length - 1)\n        {\n            this._cache[8] = 0;\n        }\n        else\n        {\n            this._cache[8]++;\n        }\n\n        this.cursor = this.children[this._cache[8]];\n\n        return this.cursor;\n    }\n\n};\n\n/**\n* Moves the Group cursor to the previous object in the Group. If it's at the start of the Group it wraps around to the last object.\n*\n* @method Phaser.Group#previous\n* @return {*} The child the cursor now points to.\n*/\nPhaser.Group.prototype.previous = function () {\n\n    if (this.cursor)\n    {\n        //  Wrap the cursor?\n        if (this._cache[8] === 0)\n        {\n            this._cache[8] = this.children.length - 1;\n        }\n        else\n        {\n            this._cache[8]--;\n        }\n\n        this.cursor = this.children[this._cache[8]];\n\n        return this.cursor;\n    }\n\n};\n\n/**\n* Swaps the position of two children in this Group. Both children must be in this Group.\n* You cannot swap a child with itself, or swap un-parented children, doing so will return false.\n*\n* @method Phaser.Group#swap\n* @param {*} child1 - The first child to swap.\n* @param {*} child2 - The second child to swap.\n*/\nPhaser.Group.prototype.swap = function (child1, child2) {\n\n    var result = this.swapChildren(child1, child2);\n\n    if (result)\n    {\n        this.updateZ();\n    }\n\n    return result;\n\n};\n\n/**\n* Brings the given child to the top of this Group so it renders above all other children.\n*\n* @method Phaser.Group#bringToTop\n* @param {*} child - The child to bring to the top of this Group.\n* @return {*} The child that was moved.\n*/\nPhaser.Group.prototype.bringToTop = function (child) {\n\n    if (child.parent === this && this.getIndex(child) < this.children.length)\n    {\n        this.remove(child);\n        this.add(child);\n    }\n\n    return child;\n\n};\n\n/**\n* Sends the given child to the bottom of this Group so it renders below all other children.\n*\n* @method Phaser.Group#sendToBack\n* @param {*} child - The child to send to the bottom of this Group.\n* @return {*} The child that was moved.\n*/\nPhaser.Group.prototype.sendToBack = function (child) {\n\n    if (child.parent === this && this.getIndex(child) > 0)\n    {\n        this.remove(child);\n        this.addAt(child, 0);\n    }\n\n    return child;\n\n};\n\n/**\n* Moves the given child up one place in this Group unless it's already at the top.\n*\n* @method Phaser.Group#moveUp\n* @param {*} child - The child to move up in the Group.\n* @return {*} The child that was moved.\n*/\nPhaser.Group.prototype.moveUp = function (child) {\n\n    if (child.parent === this && this.getIndex(child) < this.children.length - 1)\n    {\n        var a = this.getIndex(child);\n        var b = this.getAt(a + 1);\n\n        if (b)\n        {\n            this.swap(child, b);\n        }\n    }\n\n    return child;\n\n};\n\n/**\n* Moves the given child down one place in this Group unless it's already at the top.\n*\n* @method Phaser.Group#moveDown\n* @param {*} child - The child to move down in the Group.\n* @return {*} The child that was moved.\n*/\nPhaser.Group.prototype.moveDown = function (child) {\n\n    if (child.parent === this && this.getIndex(child) > 0)\n    {\n        var a = this.getIndex(child);\n        var b = this.getAt(a - 1);\n\n        if (b)\n        {\n            this.swap(child, b);\n        }\n    }\n\n    return child;\n\n};\n\n/**\n* Positions the child found at the given index within this Group to the given x and y coordinates.\n*\n* @method Phaser.Group#xy\n* @param {number} index - The index of the child in the Group to set the position of.\n* @param {number} x - The new x position of the child.\n* @param {number} y - The new y position of the child.\n*/\nPhaser.Group.prototype.xy = function (index, x, y) {\n\n    if (index < 0 || index > this.children.length)\n    {\n        return -1;\n    }\n    else\n    {\n        this.getChildAt(index).x = x;\n        this.getChildAt(index).y = y;\n    }\n\n};\n\n/**\n* Reverses all children in this Group. Note that this does not propagate, only direct children are re-ordered.\n*\n* @method Phaser.Group#reverse\n*/\nPhaser.Group.prototype.reverse = function () {\n\n    this.children.reverse();\n    this.updateZ();\n\n};\n\n/**\n* Get the index position of the given child in this Group. This should always match the childs z property.\n*\n* @method Phaser.Group#getIndex\n* @param {*} child - The child to get the index for.\n* @return {number} The index of the child or -1 if it's not a member of this Group.\n*/\nPhaser.Group.prototype.getIndex = function (child) {\n\n    return this.children.indexOf(child);\n\n};\n\n/**\n* Replaces a child of this Group with the given newChild. The newChild cannot be a member of this Group.\n*\n* @method Phaser.Group#replace\n* @param {*} oldChild - The child in this Group that will be replaced.\n* @param {*} newChild - The child to be inserted into this Group.\n* @return {*} Returns the oldChild that was replaced within this Group.\n*/\nPhaser.Group.prototype.replace = function (oldChild, newChild) {\n\n    var index = this.getIndex(oldChild);\n\n    if (index !== -1)\n    {\n        if (newChild.parent !== undefined)\n        {\n            newChild.events.onRemovedFromGroup.dispatch(newChild, this);\n            newChild.parent.removeChild(newChild);\n\n            if (newChild.parent instanceof Phaser.Group)\n            {\n                newChild.parent.updateZ();\n            }\n        }\n\n        var temp = oldChild;\n\n        this.remove(temp);\n\n        this.addAt(newChild, index);\n\n        return temp;\n    }\n\n};\n\n/**\n* Sets the given property to the given value on the child. The operation controls the assignment of the value.\n*\n* @method Phaser.Group#setProperty\n* @param {*} child - The child to set the property value on.\n* @param {array} key - An array of strings that make up the property that will be set.\n* @param {*} value - The value that will be set.\n* @param {number} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n*/\nPhaser.Group.prototype.setProperty = function (child, key, value, operation) {\n\n    operation = operation || 0;\n\n    //  As ugly as this approach looks, and although it's limited to a depth of only 4, it's much faster than a for loop or object iteration.\n\n    //  0 = Equals\n    //  1 = Add\n    //  2 = Subtract\n    //  3 = Multiply\n    //  4 = Divide\n\n    var len = key.length;\n\n    if (len === 1 && child.hasOwnProperty(key[0]))\n    {\n        if (operation === 0) { child[key[0]] = value; }\n        else if (operation == 1) { child[key[0]] += value; }\n        else if (operation == 2) { child[key[0]] -= value; }\n        else if (operation == 3) { child[key[0]] *= value; }\n        else if (operation == 4) { child[key[0]] /= value; }\n    }\n    else if (len === 2 && child.hasOwnProperty(key[0]) && child[key[0]].hasOwnProperty(key[1]))\n    {\n        if (operation === 0) { child[key[0]][key[1]] = value; }\n        else if (operation == 1) { child[key[0]][key[1]] += value; }\n        else if (operation == 2) { child[key[0]][key[1]] -= value; }\n        else if (operation == 3) { child[key[0]][key[1]] *= value; }\n        else if (operation == 4) { child[key[0]][key[1]] /= value; }\n    }\n    else if (len === 3 && child.hasOwnProperty(key[0]) && child[key[0]].hasOwnProperty(key[1]) && child[key[0]][key[1]].hasOwnProperty(key[2]))\n    {\n        if (operation === 0) { child[key[0]][key[1]][key[2]] = value; }\n        else if (operation == 1) { child[key[0]][key[1]][key[2]] += value; }\n        else if (operation == 2) { child[key[0]][key[1]][key[2]] -= value; }\n        else if (operation == 3) { child[key[0]][key[1]][key[2]] *= value; }\n        else if (operation == 4) { child[key[0]][key[1]][key[2]] /= value; }\n    }\n    else if (len === 4 && child.hasOwnProperty(key[0]) && child[key[0]].hasOwnProperty(key[1]) && child[key[0]][key[1]].hasOwnProperty(key[2]) && child[key[0]][key[1]][key[2]].hasOwnProperty(key[3]))\n    {\n        if (operation === 0) { child[key[0]][key[1]][key[2]][key[3]] = value; }\n        else if (operation == 1) { child[key[0]][key[1]][key[2]][key[3]] += value; }\n        else if (operation == 2) { child[key[0]][key[1]][key[2]][key[3]] -= value; }\n        else if (operation == 3) { child[key[0]][key[1]][key[2]][key[3]] *= value; }\n        else if (operation == 4) { child[key[0]][key[1]][key[2]][key[3]] /= value; }\n    }\n\n};\n\n/**\n* This function allows you to quickly set a property on a single child of this Group to a new value.\n* The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.\n*\n* @method Phaser.Group#set\n* @param {Phaser.Sprite} child - The child to set the property on.\n* @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'\n* @param {*} value - The value that will be set.\n* @param {boolean} [checkAlive=false] - If set then the child will only be updated if alive=true.\n* @param {boolean} [checkVisible=false] - If set then the child will only be updated if visible=true.\n* @param {number} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n*/\nPhaser.Group.prototype.set = function (child, key, value, checkAlive, checkVisible, operation) {\n\n    key = key.split('.');\n\n    if (typeof checkAlive === 'undefined') { checkAlive = false; }\n    if (typeof checkVisible === 'undefined') { checkVisible = false; }\n\n    if ((checkAlive === false || (checkAlive && child.alive)) && (checkVisible === false || (checkVisible && child.visible)))\n    {\n        this.setProperty(child, key, value, operation);\n    }\n\n};\n\n/**\n* This function allows you to quickly set the same property across all children of this Group to a new value.\n* This call doesn't descend down children, so if you have a Group inside of this Group, the property will be set on the Group but not its children.\n* If you need that ability please see `Group.setAllChildren`.\n*\n* The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.\n*\n* @method Phaser.Group#setAll\n* @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'\n* @param {*} value - The value that will be set.\n* @param {boolean} [checkAlive=false] - If set then only children with alive=true will be updated. This includes any Groups that are children.\n* @param {boolean} [checkVisible=false] - If set then only children with visible=true will be updated. This includes any Groups that are children.\n* @param {number} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n*/\nPhaser.Group.prototype.setAll = function (key, value, checkAlive, checkVisible, operation) {\n\n    key = key.split('.');\n\n    if (typeof checkAlive === 'undefined') { checkAlive = false; }\n    if (typeof checkVisible === 'undefined') { checkVisible = false; }\n\n    operation = operation || 0;\n\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible)))\n        {\n            this.setProperty(this.children[i], key, value, operation);\n        }\n    }\n\n};\n\n/**\n* This function allows you to quickly set the same property across all children of this Group, and any child Groups, to a new value.\n*\n* If this Group contains other Groups then the same property is set across their children as well, iterating down until it reaches the bottom.\n* Unlike with Group.setAll the property is NOT set on child Groups itself.\n*\n* The operation parameter controls how the new value is assigned to the property, from simple replacement to addition and multiplication.\n*\n* @method Phaser.Group#setAllChildren\n* @param {string} key - The property, as a string, to be set. For example: 'body.velocity.x'\n* @param {*} value - The value that will be set.\n* @param {boolean} [checkAlive=false] - If set then only children with alive=true will be updated. This includes any Groups that are children.\n* @param {boolean} [checkVisible=false] - If set then only children with visible=true will be updated. This includes any Groups that are children.\n* @param {number} [operation=0] - Controls how the value is assigned. A value of 0 replaces the value with the new one. A value of 1 adds it, 2 subtracts it, 3 multiplies it and 4 divides it.\n*/\nPhaser.Group.prototype.setAllChildren = function (key, value, checkAlive, checkVisible, operation) {\n\n    if (typeof checkAlive === 'undefined') { checkAlive = false; }\n    if (typeof checkVisible === 'undefined') { checkVisible = false; }\n\n    operation = operation || 0;\n\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible)))\n        {\n            if (this.children[i] instanceof Phaser.Group)\n            {\n                this.children[i].setAllChildren(key, value, checkAlive, checkVisible, operation);\n            }\n            else\n            {\n                this.setProperty(this.children[i], key.split('.'), value, operation);\n            }\n        }\n    }\n\n};\n\n/**\n* Adds the amount to the given property on all children in this Group.\n* Group.addAll('x', 10) will add 10 to the child.x value.\n*\n* @method Phaser.Group#addAll\n* @param {string} property - The property to increment, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to increment the property by. If child.x = 10 then addAll('x', 40) would make child.x = 50.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.addAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 1);\n\n};\n\n/**\n* Subtracts the amount from the given property on all children in this Group.\n* Group.subAll('x', 10) will minus 10 from the child.x value.\n*\n* @method Phaser.Group#subAll\n* @param {string} property - The property to decrement, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to subtract from the property. If child.x = 50 then subAll('x', 40) would make child.x = 10.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.subAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 2);\n\n};\n\n/**\n* Multiplies the given property by the amount on all children in this Group.\n* Group.multiplyAll('x', 2) will x2 the child.x value.\n*\n* @method Phaser.Group#multiplyAll\n* @param {string} property - The property to multiply, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to multiply the property by. If child.x = 10 then multiplyAll('x', 2) would make child.x = 20.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.multiplyAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 3);\n\n};\n\n/**\n* Divides the given property by the amount on all children in this Group.\n* Group.divideAll('x', 2) will half the child.x value.\n*\n* @method Phaser.Group#divideAll\n* @param {string} property - The property to divide, for example 'body.velocity.x' or 'angle'.\n* @param {number} amount - The amount to divide the property by. If child.x = 100 then divideAll('x', 2) would make child.x = 50.\n* @param {boolean} checkAlive - If true the property will only be changed if the child is alive.\n* @param {boolean} checkVisible - If true the property will only be changed if the child is visible.\n*/\nPhaser.Group.prototype.divideAll = function (property, amount, checkAlive, checkVisible) {\n\n    this.setAll(property, amount, checkAlive, checkVisible, 4);\n\n};\n\n/**\n* Calls a function on all of the children that have exists=true in this Group.\n* After the existsValue parameter you can add as many parameters as you like, which will all be passed to the child callback.\n*\n* @method Phaser.Group#callAllExists\n* @param {function} callback - The function that exists on the children that will be called.\n* @param {boolean} existsValue - Only children with exists=existsValue will be called.\n* @param {...*} parameter - Additional parameters that will be passed to the callback.\n*/\nPhaser.Group.prototype.callAllExists = function (callback, existsValue) {\n\n    var args = Array.prototype.splice.call(arguments, 2);\n\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        if (this.children[i].exists === existsValue && this.children[i][callback])\n        {\n            this.children[i][callback].apply(this.children[i], args);\n        }\n    }\n\n};\n\n/**\n* Returns a reference to a function that exists on a child of the Group based on the given callback array.\n*\n* @method Phaser.Group#callbackFromArray\n* @param {object} child - The object to inspect.\n* @param {array} callback - The array of function names.\n* @param {number} length - The size of the array (pre-calculated in callAll).\n* @protected\n*/\nPhaser.Group.prototype.callbackFromArray = function (child, callback, length) {\n\n    //  Kinda looks like a Christmas tree\n\n    if (length == 1)\n    {\n        if (child[callback[0]])\n        {\n            return child[callback[0]];\n        }\n    }\n    else if (length == 2)\n    {\n        if (child[callback[0]][callback[1]])\n        {\n            return child[callback[0]][callback[1]];\n        }\n    }\n    else if (length == 3)\n    {\n        if (child[callback[0]][callback[1]][callback[2]])\n        {\n            return child[callback[0]][callback[1]][callback[2]];\n        }\n    }\n    else if (length == 4)\n    {\n        if (child[callback[0]][callback[1]][callback[2]][callback[3]])\n        {\n            return child[callback[0]][callback[1]][callback[2]][callback[3]];\n        }\n    }\n    else\n    {\n        if (child[callback])\n        {\n            return child[callback];\n        }\n    }\n\n    return false;\n\n};\n\n/**\n* Calls a function on all of the children regardless if they are dead or alive (see callAllExists if you need control over that)\n* After the method parameter and context you can add as many extra parameters as you like, which will all be passed to the child.\n*\n* @method Phaser.Group#callAll\n* @param {string} method - A string containing the name of the function that will be called. The function must exist on the child.\n* @param {string} [context=null] - A string containing the context under which the method will be executed. Set to null to default to the child.\n* @param {...*} parameter - Additional parameters that will be passed to the method.\n*/\nPhaser.Group.prototype.callAll = function (method, context) {\n\n    if (typeof method === 'undefined')\n    {\n        return;\n    }\n\n    //  Extract the method into an array\n    method = method.split('.');\n\n    var methodLength = method.length;\n\n    if (typeof context === 'undefined' || context === null || context === '')\n    {\n        context = null;\n    }\n    else\n    {\n        //  Extract the context into an array\n        if (typeof context === 'string')\n        {\n            context = context.split('.');\n            var contextLength = context.length;\n        }\n    }\n\n    var args = Array.prototype.splice.call(arguments, 2);\n    var callback = null;\n    var callbackContext = null;\n\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        callback = this.callbackFromArray(this.children[i], method, methodLength);\n\n        if (context && callback)\n        {\n            callbackContext = this.callbackFromArray(this.children[i], context, contextLength);\n\n            if (callback)\n            {\n                callback.apply(callbackContext, args);\n            }\n        }\n        else if (callback)\n        {\n            callback.apply(this.children[i], args);\n        }\n    }\n\n};\n\n/**\n* The core preUpdate - as called by World.\n* @method Phaser.Group#preUpdate\n* @protected\n*/\nPhaser.Group.prototype.preUpdate = function () {\n\n    if (!this.exists || !this.parent.exists)\n    {\n        this.renderOrderID = -1;\n        return false;\n    }\n\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].preUpdate();\n    }\n\n    return true;\n\n};\n\n/**\n* The core update - as called by World.\n* @method Phaser.Group#update\n* @protected\n*/\nPhaser.Group.prototype.update = function () {\n\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].update();\n    }\n\n};\n\n/**\n* The core postUpdate - as called by World.\n* @method Phaser.Group#postUpdate\n* @protected\n*/\nPhaser.Group.prototype.postUpdate = function () {\n\n    //  Fixed to Camera?\n    if (this._cache[7] === 1)\n    {\n        this.x = this.game.camera.view.x + this.cameraOffset.x;\n        this.y = this.game.camera.view.y + this.cameraOffset.y;\n    }\n\n    var i = this.children.length;\n\n    while (i--)\n    {\n        this.children[i].postUpdate();\n    }\n\n};\n\n/**\n* Allows you to call your own function on each member of this Group. You must pass the callback and context in which it will run.\n* After the checkExists parameter you can add as many parameters as you like, which will all be passed to the callback along with the child.\n* For example: Group.forEach(awardBonusGold, this, true, 100, 500)\n* Note: Currently this will skip any children which are Groups themselves.\n*\n* @method Phaser.Group#forEach\n* @param {function} callback - The function that will be called. Each child of the Group will be passed to it as its first parameter.\n* @param {Object} callbackContext - The context in which the function should be called (usually 'this').\n* @param {boolean} [checkExists=false] - If set only children with exists=true will be passed to the callback, otherwise all children will be passed.\n*/\nPhaser.Group.prototype.forEach = function (callback, callbackContext, checkExists) {\n\n    if (typeof checkExists === 'undefined') { checkExists = false; }\n\n    var args = Array.prototype.splice.call(arguments, 3);\n    args.unshift(null);\n\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        if (!checkExists || (checkExists && this.children[i].exists))\n        {\n            args[0] = this.children[i];\n            callback.apply(callbackContext, args);\n        }\n    }\n\n};\n\n/**\n* Allows you to call your own function on each member of this Group where child.exists=true. You must pass the callback and context in which it will run.\n* You can add as many parameters as you like, which will all be passed to the callback along with the child.\n* For example: Group.forEachExists(causeDamage, this, 500)\n*\n* @method Phaser.Group#forEachExists\n* @param {function} callback - The function that will be called. Each child of the Group will be passed to it as its first parameter.\n* @param {Object} callbackContext - The context in which the function should be called (usually 'this').\n*/\nPhaser.Group.prototype.forEachExists = function (callback, callbackContext) {\n\n    var args = Array.prototype.splice.call(arguments, 2);\n    args.unshift(null);\n\n    this.iterate('exists', true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);\n\n};\n\n/**\n* Allows you to call your own function on each alive member of this Group (where child.alive=true). You must pass the callback and context in which it will run.\n* You can add as many parameters as you like, which will all be passed to the callback along with the child.\n* For example: Group.forEachAlive(causeDamage, this, 500)\n*\n* @method Phaser.Group#forEachAlive\n* @param {function} callback - The function that will be called. Each child of the Group will be passed to it as its first parameter.\n* @param {Object} callbackContext - The context in which the function should be called (usually 'this').\n*/\nPhaser.Group.prototype.forEachAlive = function (callback, callbackContext) {\n\n    var args = Array.prototype.splice.call(arguments, 2);\n    args.unshift(null);\n\n    this.iterate('alive', true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);\n\n};\n\n/**\n* Allows you to call your own function on each dead member of this Group (where alive=false). You must pass the callback and context in which it will run.\n* You can add as many parameters as you like, which will all be passed to the callback along with the child.\n* For example: Group.forEachDead(bringToLife, this)\n*\n* @method Phaser.Group#forEachDead\n* @param {function} callback - The function that will be called. Each child of the Group will be passed to it as its first parameter.\n* @param {Object} callbackContext - The context in which the function should be called (usually 'this').\n*/\nPhaser.Group.prototype.forEachDead = function (callback, callbackContext) {\n\n    var args = Array.prototype.splice.call(arguments, 2);\n    args.unshift(null);\n\n    this.iterate('alive', false, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args);\n\n};\n\n/**\n* Call this function to sort the group according to a particular value and order.\n* For example to depth sort Sprites for Zelda-style game you might call `group.sort('y', Phaser.Group.SORT_ASCENDING)` at the bottom of your `State.update()`.\n*\n* @method Phaser.Group#sort\n* @param {string} [index='z'] - The `string` name of the property you want to sort on. Defaults to the objects z-depth value.\n* @param {number} [order=Phaser.Group.SORT_ASCENDING] - The `Group` constant that defines the sort order. Possible values are Phaser.Group.SORT_ASCENDING and Phaser.Group.SORT_DESCENDING.\n*/\nPhaser.Group.prototype.sort = function (index, order) {\n\n    if (this.children.length < 2)\n    {\n        //  Nothing to swap\n        return;\n    }\n\n    if (typeof index === 'undefined') { index = 'z'; }\n    if (typeof order === 'undefined') { order = Phaser.Group.SORT_ASCENDING; }\n\n    this._sortProperty = index;\n\n    if (order === Phaser.Group.SORT_ASCENDING)\n    {\n        this.children.sort(this.ascendingSortHandler.bind(this));\n    }\n    else\n    {\n        this.children.sort(this.descendingSortHandler.bind(this));\n    }\n\n    this.updateZ();\n\n};\n\n/**\n* This allows you to use your own sort handler function.\n* It will be sent two parameters: the two children involved in the comparison (a and b). It should return -1 if a > b, 1 if a < b or 0 if a === b.\n*\n* @method Phaser.Group#customSort\n* @param {function} sortHandler - Your sort handler function. It will be sent two parameters: the two children involved in the comparison. It must return -1, 1 or 0.\n* @param {object} context - The scope in which the sortHandler is called.\n*/\nPhaser.Group.prototype.customSort = function (sortHandler, context) {\n\n    if (this.children.length < 2)\n    {\n        //  Nothing to swap\n        return;\n    }\n\n    this.children.sort(sortHandler.bind(context));\n\n    this.updateZ();\n\n};\n\n/**\n* An internal helper function for the sort process.\n*\n* @method Phaser.Group#ascendingSortHandler\n* @param {object} a - The first object being sorted.\n* @param {object} b - The second object being sorted.\n*/\nPhaser.Group.prototype.ascendingSortHandler = function (a, b) {\n\n    if (a[this._sortProperty] < b[this._sortProperty])\n    {\n        return -1;\n    }\n    else if (a[this._sortProperty] > b[this._sortProperty])\n    {\n        return 1;\n    }\n    else\n    {\n        if (a.z < b.z)\n        {\n            return -1;\n        }\n        else\n        {\n            return 1;\n        }\n    }\n\n};\n\n/**\n* An internal helper function for the sort process.\n*\n* @method Phaser.Group#descendingSortHandler\n* @param {object} a - The first object being sorted.\n* @param {object} b - The second object being sorted.\n*/\nPhaser.Group.prototype.descendingSortHandler = function (a, b) {\n\n    if (a[this._sortProperty] < b[this._sortProperty])\n    {\n        return 1;\n    }\n    else if (a[this._sortProperty] > b[this._sortProperty])\n    {\n        return -1;\n    }\n    else\n    {\n        return 0;\n    }\n\n};\n\n/**\n* Iterates over the children of the Group. When a child has a property matching key that equals the given value, it is considered as a match.\n* Matched children can be sent to the optional callback, or simply returned or counted.\n* You can add as many callback parameters as you like, which will all be passed to the callback along with the child, after the callbackContext parameter.\n*\n* @method Phaser.Group#iterate\n* @param {string} key - The child property to check, i.e. 'exists', 'alive', 'health'\n* @param {any} value - If child.key === this value it will be considered a match. Note that a strict comparison is used.\n* @param {number} returnType - How to return the data from this method. Either Phaser.Group.RETURN_NONE, Phaser.Group.RETURN_TOTAL or Phaser.Group.RETURN_CHILD.\n* @param {function} [callback=null] - Optional function that will be called on each matching child. Each child of the Group will be passed to it as its first parameter.\n* @param {Object} [callbackContext] - The context in which the function should be called (usually 'this').\n* @return {any} Returns either a numeric total (if RETURN_TOTAL was specified) or the child object.\n*/\nPhaser.Group.prototype.iterate = function (key, value, returnType, callback, callbackContext, args) {\n\n    if (returnType === Phaser.Group.RETURN_TOTAL && this.children.length === 0)\n    {\n        return 0;\n    }\n\n    if (typeof callback === 'undefined')\n    {\n        callback = false;\n    }\n\n    var total = 0;\n\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        if (this.children[i][key] === value)\n        {\n            total++;\n\n            if (callback)\n            {\n                args[0] = this.children[i];\n                callback.apply(callbackContext, args);\n            }\n\n            if (returnType === Phaser.Group.RETURN_CHILD)\n            {\n                return this.children[i];\n            }\n        }\n    }\n\n    if (returnType === Phaser.Group.RETURN_TOTAL)\n    {\n        return total;\n    }\n    else if (returnType === Phaser.Group.RETURN_CHILD)\n    {\n        return null;\n    }\n\n};\n\n/**\n* Call this function to retrieve the first object with exists == (the given state) in the Group.\n*\n* @method Phaser.Group#getFirstExists\n* @param {boolean} state - True or false.\n* @return {Any} The first child, or null if none found.\n*/\nPhaser.Group.prototype.getFirstExists = function (state) {\n\n    if (typeof state !== 'boolean')\n    {\n        state = true;\n    }\n\n    return this.iterate('exists', state, Phaser.Group.RETURN_CHILD);\n\n};\n\n/**\n* Call this function to retrieve the first object with alive === true in the group.\n* This is handy for checking if everything has been wiped out, or choosing a squad leader, etc.\n*\n* @method Phaser.Group#getFirstAlive\n* @return {Any} The first alive child, or null if none found.\n*/\nPhaser.Group.prototype.getFirstAlive = function () {\n\n    return this.iterate('alive', true, Phaser.Group.RETURN_CHILD);\n\n};\n\n/**\n* Call this function to retrieve the first object with alive === false in the group.\n* This is handy for checking if everything has been wiped out, or choosing a squad leader, etc.\n*\n* @method Phaser.Group#getFirstDead\n* @return {Any} The first dead child, or null if none found.\n*/\nPhaser.Group.prototype.getFirstDead = function () {\n\n    return this.iterate('alive', false, Phaser.Group.RETURN_CHILD);\n\n};\n\n/**\n* Returns the child at the top of this Group. The top is the one being displayed (rendered) above every other child.\n*\n* @method Phaser.Group#getTop\n* @return {Any} The child at the top of the Group.\n*/\nPhaser.Group.prototype.getTop = function () {\n\n    if (this.children.length > 0)\n    {\n        return this.children[this.children.length - 1];\n    }\n\n};\n\n/**\n* Returns the child at the bottom of this Group. The bottom is the one being displayed (rendered) below every other child.\n*\n* @method Phaser.Group#getBottom\n* @return {Any} The child at the bottom of the Group.\n*/\nPhaser.Group.prototype.getBottom = function () {\n\n    if (this.children.length > 0)\n    {\n        return this.children[0];\n    }\n\n};\n\n/**\n* Call this function to find out how many members of the group are alive.\n*\n* @method Phaser.Group#countLiving\n* @return {number} The number of children flagged as alive.\n*/\nPhaser.Group.prototype.countLiving = function () {\n\n    return this.iterate('alive', true, Phaser.Group.RETURN_TOTAL);\n\n};\n\n/**\n* Call this function to find out how many members of the group are dead.\n*\n* @method Phaser.Group#countDead\n* @return {number} The number of children flagged as dead.\n*/\nPhaser.Group.prototype.countDead = function () {\n\n    return this.iterate('alive', false, Phaser.Group.RETURN_TOTAL);\n\n};\n\n/**\n* Returns a member at random from the group.\n*\n* @method Phaser.Group#getRandom\n* @param {number} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.\n* @param {number} length - Optional restriction on the number of values you want to randomly select from.\n* @return {Any} A random child of this Group.\n*/\nPhaser.Group.prototype.getRandom = function (startIndex, length) {\n\n    if (this.children.length === 0)\n    {\n        return null;\n    }\n\n    startIndex = startIndex || 0;\n    length = length || this.children.length;\n\n    return this.game.math.getRandom(this.children, startIndex, length);\n\n};\n\n/**\n* Removes the given child from this Group. This will dispatch an onRemovedFromGroup event from the child (if it has one),\n* reset the Group cursor and optionally destroy the child.\n*\n* @method Phaser.Group#remove\n* @param {Any} child - The child to remove.\n* @param {boolean} [destroy=false] - You can optionally call destroy on the child that was removed.\n* @return {boolean} true if the child was removed from this Group, otherwise false.\n*/\nPhaser.Group.prototype.remove = function (child, destroy) {\n\n    if (typeof destroy === 'undefined') { destroy = false; }\n\n    if (this.children.length === 0 || this.children.indexOf(child) === -1)\n    {\n        return false;\n    }\n\n    if (child.events && !child.destroyPhase)\n    {\n        child.events.onRemovedFromGroup.dispatch(child, this);\n    }\n\n    var removed = this.removeChild(child);\n\n    this.updateZ();\n\n    if (this.cursor === child)\n    {\n        this.next();\n    }\n\n    if (destroy && removed)\n    {\n        removed.destroy(true);\n    }\n\n    return true;\n\n};\n\n/**\n* Removes all children from this Group, setting all group properties to null.\n* The Group container remains on the display list.\n*\n* @method Phaser.Group#removeAll\n* @param {boolean} [destroy=false] - You can optionally call destroy on the child that was removed.\n*/\nPhaser.Group.prototype.removeAll = function (destroy) {\n\n    if (typeof destroy === 'undefined') { destroy = false; }\n\n    if (this.children.length === 0)\n    {\n        return;\n    }\n\n    do\n    {\n        if (this.children[0].events)\n        {\n            this.children[0].events.onRemovedFromGroup.dispatch(this.children[0], this);\n        }\n\n        var removed = this.removeChild(this.children[0]);\n\n        if (destroy && removed)\n        {\n            removed.destroy(true);\n        }\n    }\n    while (this.children.length > 0);\n\n    this.cursor = null;\n\n};\n\n/**\n* Removes all children from this Group whos index falls beteen the given startIndex and endIndex values.\n*\n* @method Phaser.Group#removeBetween\n* @param {number} startIndex - The index to start removing children from.\n* @param {number} [endIndex] - The index to stop removing children at. Must be higher than startIndex. If undefined this method will remove all children between startIndex and the end of the Group.\n* @param {boolean} [destroy=false] - You can optionally call destroy on the child that was removed.\n*/\nPhaser.Group.prototype.removeBetween = function (startIndex, endIndex, destroy) {\n\n    if (typeof endIndex === 'undefined') { endIndex = this.children.length; }\n    if (typeof destroy === 'undefined') { destroy = false; }\n\n    if (this.children.length === 0)\n    {\n        return;\n    }\n\n    if (startIndex > endIndex || startIndex < 0 || endIndex > this.children.length)\n    {\n        return false;\n    }\n\n    var i = endIndex;\n\n    while (i >= startIndex)\n    {\n        if (this.children[i].events)\n        {\n            this.children[i].events.onRemovedFromGroup.dispatch(this.children[i], this);\n        }\n\n        var removed = this.removeChild(this.children[i]);\n\n        if (destroy && removed)\n        {\n            removed.destroy(true);\n        }\n\n        if (this.cursor === this.children[i])\n        {\n            this.cursor = null;\n        }\n\n        i--;\n    }\n\n    this.updateZ();\n\n};\n\n/**\n* Destroys this Group. Removes all children, then removes the container from the display list and nulls references.\n*\n* @method Phaser.Group#destroy\n* @param {boolean} [destroyChildren=true] - Should every child of this Group have its destroy method called?\n* @param {boolean} [soft=false] - A 'soft destroy' (set to true) doesn't remove this Group from its parent or null the game reference. Set to false and it does.\n*/\nPhaser.Group.prototype.destroy = function (destroyChildren, soft) {\n\n    if (this.game === null) { return; }\n\n    if (typeof destroyChildren === 'undefined') { destroyChildren = true; }\n    if (typeof soft === 'undefined') { soft = false; }\n\n    this.removeAll(destroyChildren);\n\n    this.cursor = null;\n\n    if (!soft)\n    {\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n\n        this.game = null;\n        this.exists = false;\n    }\n\n};\n\n/**\n* @name Phaser.Group#total\n* @property {number} total - The total number of children in this Group who have a state of exists = true.\n* @readonly\n*/\nObject.defineProperty(Phaser.Group.prototype, \"total\", {\n\n    get: function () {\n\n        return this.iterate('exists', true, Phaser.Group.RETURN_TOTAL);\n\n    }\n\n});\n\n/**\n* @name Phaser.Group#length\n* @property {number} length - The total number of children in this Group, regardless of their exists/alive status.\n* @readonly\n*/\nObject.defineProperty(Phaser.Group.prototype, \"length\", {\n\n    get: function () {\n\n        return this.children.length;\n\n    }\n\n});\n\n/**\n* The angle of rotation of the Group container. This will adjust the Group container itself by modifying its rotation.\n* This will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.\n* @name Phaser.Group#angle\n* @property {number} angle - The angle of rotation given in degrees, where 0 degrees = to the right.\n*/\nObject.defineProperty(Phaser.Group.prototype, \"angle\", {\n\n    get: function() {\n        return Phaser.Math.radToDeg(this.rotation);\n    },\n\n    set: function(value) {\n        this.rotation = Phaser.Math.degToRad(value);\n    }\n\n});\n\n/**\n* A Group that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Group.cameraOffset.\n* Note that the cameraOffset values are in addition to any parent in the display list.\n* So if this Group was in a Group that has x: 200, then this will be added to the cameraOffset.x\n*\n* @name Phaser.Group#fixedToCamera\n* @property {boolean} fixedToCamera - Set to true to fix this Group to the Camera at its current world coordinates.\n*/\nObject.defineProperty(Phaser.Group.prototype, \"fixedToCamera\", {\n\n    get: function () {\n\n        return !!this._cache[7];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            this._cache[7] = 1;\n            this.cameraOffset.set(this.x, this.y);\n        }\n        else\n        {\n            this._cache[7] = 0;\n        }\n    }\n\n});\n\n//  Documentation stubs\n\n/**\n* The x coordinate of the Group container. You can adjust the Group container itself by modifying its coordinates.\n* This will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.\n* @name Phaser.Group#x\n* @property {number} x - The x coordinate of the Group container.\n*/\n\n/**\n* The y coordinate of the Group container. You can adjust the Group container itself by modifying its coordinates.\n* This will have no impact on the x/y coordinates of its children, but it will update their worldTransform and on-screen position.\n* @name Phaser.Group#y\n* @property {number} y - The y coordinate of the Group container.\n*/\n\n/**\n* The angle of rotation of the Group container. This will adjust the Group container itself by modifying its rotation.\n* This will have no impact on the rotation value of its children, but it will update their worldTransform and on-screen position.\n* @name Phaser.Group#rotation\n* @property {number} rotation - The angle of rotation given in radians.\n*/\n\n/**\n* @name Phaser.Group#visible\n* @property {boolean} visible - The visible state of the Group. Non-visible Groups and all of their children are not rendered.\n*/\n\n/**\n* @name Phaser.Group#alpha\n* @property {number} alpha - The alpha value of the Group container.\n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* \"This world is but a canvas to our imagination.\" - Henry David Thoreau\n*\n* A game has only one world. The world is an abstract place in which all game objects live. It is not bound\n* by stage limits and can be any size. You look into the world via cameras. All game objects live within\n* the world at world-based coordinates. By default a world is created the same size as your Stage.\n*\n* @class Phaser.World\n* @extends Phaser.Group\n* @constructor\n* @param {Phaser.Game} game - Reference to the current game instance.\n*/\nPhaser.World = function (game) {\n\n    Phaser.Group.call(this, game, null, '__world', false);\n\n    /**\n    * The World has no fixed size, but it does have a bounds outside of which objects are no longer considered as being \"in world\" and you should use this to clean-up the display list and purge dead objects.\n    * By default we set the Bounds to be from 0,0 to Game.width,Game.height. I.e. it will match the size given to the game constructor with 0,0 representing the top-left of the display.\n    * However 0,0 is actually the center of the world, and if you rotate or scale the world all of that will happen from 0,0.\n    * So if you want to make a game in which the world itself will rotate you should adjust the bounds so that 0,0 is the center point, i.e. set them to -1000,-1000,2000,2000 for a 2000x2000 sized world centered around 0,0.\n    * @property {Phaser.Rectangle} bounds - Bound of this world that objects can not escape from.\n    */\n    this.bounds = new Phaser.Rectangle(0, 0, game.width, game.height);\n\n    /**\n    * @property {Phaser.Camera} camera - Camera instance.\n    */\n    this.camera = null;\n\n};\n\nPhaser.World.prototype = Object.create(Phaser.Group.prototype);\nPhaser.World.prototype.constructor = Phaser.World;\n\n/**\n* Initialises the game world.\n*\n* @method Phaser.World#boot\n* @protected\n*/\nPhaser.World.prototype.boot = function () {\n\n    this.camera = new Phaser.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);\n\n    this.camera.displayObject = this;\n\n    this.camera.scale = this.scale;\n\n    this.game.camera = this.camera;\n\n    this.game.stage.addChild(this);\n\n};\n\n/**\n* Updates the size of this world. Note that this doesn't modify the world x/y coordinates, just the width and height.\n*\n* @method Phaser.World#setBounds\n* @param {number} x - Top left most corner of the world.\n* @param {number} y - Top left most corner of the world.\n* @param {number} width - New width of the world. Can never be smaller than the Game.width.\n* @param {number} height - New height of the world. Can never be smaller than the Game.height.\n*/\nPhaser.World.prototype.setBounds = function (x, y, width, height) {\n\n    if (width < this.game.width)\n    {\n        width = this.game.width;\n    }\n\n    if (height < this.game.height)\n    {\n        height = this.game.height;\n    }\n\n    this.bounds.setTo(x, y, width, height);\n\n    if (this.camera.bounds)\n    {\n        //  The Camera can never be smaller than the game size\n        this.camera.bounds.setTo(x, y, width, height);\n    }\n\n    this.game.physics.setBoundsToWorld();\n\n};\n\n/**\n* Destroyer of worlds.\n*\n* @method Phaser.World#shutdown\n*/\nPhaser.World.prototype.shutdown = function () {\n\n    //  World is a Group, so run a soft destruction on this and all children.\n    this.destroy(true, true);\n\n};\n\n/**\n* This will take the given game object and check if its x/y coordinates fall outside of the world bounds.\n* If they do it will reposition the object to the opposite side of the world, creating a wrap-around effect.\n*\n* @method Phaser.World#wrap\n* @param {Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Text} sprite - The object you wish to wrap around the world bounds.\n* @param {number} [padding=0] - Extra padding added equally to the sprite.x and y coordinates before checking if within the world bounds. Ignored if useBounds is true.\n* @param {boolean} [useBounds=false] - If useBounds is false wrap checks the object.x/y coordinates. If true it does a more accurate bounds check, which is more expensive.\n*/\nPhaser.World.prototype.wrap = function (sprite, padding, useBounds) {\n\n    if (typeof padding === 'undefined') { padding = 0; }\n    if (typeof useBounds === 'undefined') { useBounds = false; }\n\n    if (!useBounds)\n    {\n        if (sprite.x + padding < this.bounds.x)\n        {\n            sprite.x = this.bounds.right + padding;\n        }\n        else if (sprite.x - padding > this.bounds.right)\n        {\n            sprite.x = this.bounds.left - padding;\n        }\n\n        if (sprite.y + padding < this.bounds.top)\n        {\n            sprite.y = this.bounds.bottom + padding;\n        }\n        else if (sprite.y - padding > this.bounds.bottom)\n        {\n            sprite.y = this.bounds.top - padding;\n        }\n    }\n    else\n    {\n        sprite.getBounds();\n\n        if (sprite._currentBounds.right < this.bounds.x)\n        {\n            sprite.x = this.bounds.right;\n        }\n        else if (sprite._currentBounds.x > this.bounds.right)\n        {\n            sprite.x = this.bounds.left;\n        }\n\n        if (sprite._currentBounds.bottom < this.bounds.top)\n        {\n            sprite.y = this.bounds.bottom;\n        }\n        else if (sprite._currentBounds.top > this.bounds.bottom)\n        {\n            sprite.y = this.bounds.top;\n        }\n    }\n\n};\n\n/**\n* @name Phaser.World#width\n* @property {number} width - Gets or sets the current width of the game world.\n*/\nObject.defineProperty(Phaser.World.prototype, \"width\", {\n\n    get: function () {\n        return this.bounds.width;\n    },\n\n    set: function (value) {\n        this.bounds.width = value;\n    }\n\n});\n\n/**\n* @name Phaser.World#height\n* @property {number} height - Gets or sets the current height of the game world.\n*/\nObject.defineProperty(Phaser.World.prototype, \"height\", {\n\n    get: function () {\n        return this.bounds.height;\n    },\n\n    set: function (value) {\n        this.bounds.height = value;\n    }\n\n});\n\n/**\n* @name Phaser.World#centerX\n* @property {number} centerX - Gets the X position corresponding to the center point of the world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"centerX\", {\n\n    get: function () {\n        return this.bounds.halfWidth;\n    }\n\n});\n\n/**\n* @name Phaser.World#centerY\n* @property {number} centerY - Gets the Y position corresponding to the center point of the world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"centerY\", {\n\n    get: function () {\n        return this.bounds.halfHeight;\n    }\n\n});\n\n/**\n* @name Phaser.World#randomX\n* @property {number} randomX - Gets a random integer which is lesser than or equal to the current width of the game world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"randomX\", {\n\n    get: function () {\n\n        if (this.bounds.x < 0)\n        {\n            return this.game.rnd.integerInRange(this.bounds.x, (this.bounds.width - Math.abs(this.bounds.x)));\n        }\n        else\n        {\n            return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width);\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.World#randomY\n* @property {number} randomY - Gets a random integer which is lesser than or equal to the current height of the game world.\n* @readonly\n*/\nObject.defineProperty(Phaser.World.prototype, \"randomY\", {\n\n    get: function () {\n\n        if (this.bounds.y < 0)\n        {\n            return this.game.rnd.integerInRange(this.bounds.y, (this.bounds.height - Math.abs(this.bounds.y)));\n        }\n        else\n        {\n            return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height);\n        }\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The ScaleManager object is responsible for helping you manage the scaling, resizing and alignment of your game within the browser.\n*\n* @class Phaser.ScaleManager\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} width - The native width of the game.\n* @param {number} height - The native height of the game.\n*/\nPhaser.ScaleManager = function (game, width, height) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {number} width - Width of the stage after calculation.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - Height of the stage after calculation.\n    */\n    this.height = height;\n\n    /**\n    * @property {number} minWidth - Minimum width the canvas should be scaled to (in pixels).\n    */\n    this.minWidth = null;\n\n    /**\n    * @property {number} maxWidth - Maximum width the canvas should be scaled to (in pixels). If null it will scale to whatever width the browser can handle.\n    */\n    this.maxWidth = null;\n\n    /**\n    * @property {number} minHeight - Minimum height the canvas should be scaled to (in pixels).\n    */\n    this.minHeight = null;\n\n    /**\n    * @property {number} maxHeight - Maximum height the canvas should be scaled to (in pixels). If null it will scale to whatever height the browser can handle.\n    */\n    this.maxHeight = null;\n\n    /**\n    * @property {boolean} forceLandscape - If the game should be forced to use Landscape mode, this is set to true by Game.Stage\n    * @default\n    */\n    this.forceLandscape = false;\n\n    /**\n    * @property {boolean} forcePortrait - If the game should be forced to use Portrait mode, this is set to true by Game.Stage\n    * @default\n    */\n    this.forcePortrait = false;\n\n    /**\n    * @property {boolean} incorrectOrientation - If the game should be forced to use a specific orientation and the device currently isn't in that orientation this is set to true.\n    * @default\n    */\n    this.incorrectOrientation = false;\n\n    /**\n    * @property {boolean} pageAlignHorizontally - If you wish to align your game in the middle of the page then you can set this value to true.\n    * It will place a re-calculated margin-left pixel value onto the canvas element which is updated on orientation/resizing.\n    * It doesn't care about any other DOM element that may be on the page, it literally just sets the margin.\n    * @default\n    */\n    this.pageAlignHorizontally = false;\n\n    /**\n    * @property {boolean} pageAlignVertically - If you wish to align your game in the middle of the page then you can set this value to true.\n    * It will place a re-calculated margin-left pixel value onto the canvas element which is updated on orientation/resizing.\n    * It doesn't care about any other DOM element that may be on the page, it literally just sets the margin.\n    * @default\n    */\n    this.pageAlignVertically = false;\n\n    /**\n    * @property {number} maxIterations - The maximum number of times it will try to resize the canvas to fill the browser.\n    * @default\n    */\n    this.maxIterations = 5;\n\n    /**\n    * @property {PIXI.Sprite} orientationSprite - The Sprite that is optionally displayed if the browser enters an unsupported orientation.\n    */\n    this.orientationSprite = null;\n\n    /**\n    * @property {Phaser.Signal} enterLandscape - The event that is dispatched when the browser enters landscape orientation.\n    */\n    this.enterLandscape = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} enterPortrait - The event that is dispatched when the browser enters horizontal orientation.\n    */\n    this.enterPortrait = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} enterIncorrectOrientation - The event that is dispatched when the browser enters an incorrect orientation, as defined by forceOrientation.\n    */\n    this.enterIncorrectOrientation = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} leaveIncorrectOrientation - The event that is dispatched when the browser leaves an incorrect orientation, as defined by forceOrientation.\n    */\n    this.leaveIncorrectOrientation = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} hasResized - The event that is dispatched when the game scale changes.\n    */\n    this.hasResized = new Phaser.Signal();\n\n    /**\n    * This is the DOM element that will have the Full Screen mode called on it. It defaults to the game canvas, but can be retargetted to any valid DOM element.\n    * If you adjust this property it's up to you to see it has the correct CSS applied, and that you have contained the game canvas correctly.\n    * Note that if you use a scale property of EXACT_FIT then fullScreenTarget will have its width and height style set to 100%.\n    * @property {any} fullScreenTarget\n    */\n    this.fullScreenTarget = this.game.canvas;\n\n    /**\n    * @property {Phaser.Signal} enterFullScreen - The event that is dispatched when the browser enters full screen mode (if it supports the FullScreen API).\n    */\n    this.enterFullScreen = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} leaveFullScreen - The event that is dispatched when the browser leaves full screen mode (if it supports the FullScreen API).\n    */\n    this.leaveFullScreen = new Phaser.Signal();\n\n    /**\n    * @property {number} orientation - The orientation value of the game (as defined by window.orientation if set). 90 = landscape. 0 = portrait.\n    */\n    this.orientation = 0;\n\n    if (window['orientation'])\n    {\n        this.orientation = window['orientation'];\n    }\n    else\n    {\n        if (window.outerWidth > window.outerHeight)\n        {\n            this.orientation = 90;\n        }\n    }\n\n    /**\n    * @property {Phaser.Point} scaleFactor - The scale factor based on the game dimensions vs. the scaled dimensions.\n    * @readonly\n    */\n    this.scaleFactor = new Phaser.Point(1, 1);\n\n    /**\n    * @property {Phaser.Point} scaleFactorInversed - The inversed scale factor. The displayed dimensions divided by the game dimensions.\n    * @readonly\n    */\n    this.scaleFactorInversed = new Phaser.Point(1, 1);\n\n    /**\n    * @property {Phaser.Point} margin - If the game canvas is set to align by adjusting the margin, the margin calculation values are stored in this Point.\n    * @readonly\n    */\n    this.margin = new Phaser.Point(0, 0);\n\n    /**\n    * @property {number} aspectRatio - The aspect ratio of the scaled game.\n    * @readonly\n    */\n    this.aspectRatio = 0;\n\n    /**\n    * @property {number} sourceAspectRatio - The aspect ratio (width / height) of the original game dimensions.\n    * @readonly\n    */\n    this.sourceAspectRatio = width / height;\n\n    /**\n    * @property {any} event- The native browser events from full screen API changes.\n    */\n    this.event = null;\n\n    /**\n    * @property {number} scaleMode - The current scaleMode.\n    */\n    this.scaleMode = Phaser.ScaleManager.NO_SCALE;\n\n    /*\n    * @property {number} fullScreenScaleMode - Scale mode to be used in fullScreen\n    */\n    this.fullScreenScaleMode = Phaser.ScaleManager.NO_SCALE;\n\n    /**\n    * @property {number} _startHeight - Internal cache var. Stage height when starting the game.\n    * @private\n    */\n    this._startHeight = 0;\n\n    /**\n    * @property {number} _width - Cached stage width for full screen mode.\n    * @private\n    */\n    this._width = 0;\n\n    /**\n    * @property {number} _height - Cached stage height for full screen mode.\n    * @private\n    */\n    this._height = 0;\n\n    /**\n    * @property {number} _check - Cached size interval var.\n    * @private\n    */\n    this._check = null;\n\n    var _this = this;\n\n    window.addEventListener('orientationchange', function (event) {\n        return _this.checkOrientation(event);\n    }, false);\n\n    window.addEventListener('resize', function (event) {\n        return _this.checkResize(event);\n    }, false);\n\n    document.addEventListener('webkitfullscreenchange', function (event) {\n        return _this.fullScreenChange(event);\n    }, false);\n\n    document.addEventListener('mozfullscreenchange', function (event) {\n        return _this.fullScreenChange(event);\n    }, false);\n\n    document.addEventListener('fullscreenchange', function (event) {\n        return _this.fullScreenChange(event);\n    }, false);\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.ScaleManager.EXACT_FIT = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.ScaleManager.NO_SCALE = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.ScaleManager.SHOW_ALL = 2;\n\nPhaser.ScaleManager.prototype = {\n\n    /**\n    * Tries to enter the browser into full screen mode.\n    * Please note that this needs to be supported by the web browser and isn't the same thing as setting your game to fill the browser.\n    * @method Phaser.ScaleManager#startFullScreen\n    * @param {boolean} antialias - You can toggle the anti-alias feature of the canvas before jumping in to full screen (false = retain pixel art, true = smooth art)\n    */\n    startFullScreen: function (antialias) {\n\n        if (this.isFullScreen || !this.game.device.fullscreen)\n        {\n            return;\n        }\n\n        if (typeof antialias !== 'undefined' && this.game.renderType === Phaser.CANVAS)\n        {\n            this.game.stage.smoothed = antialias;\n        }\n\n        this._width = this.width;\n        this._height = this.height;\n\n        if (this.game.device.fullscreenKeyboard)\n        {\n            this.fullScreenTarget[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT);\n        }\n        else\n        {\n            this.fullScreenTarget[this.game.device.requestFullscreen]();\n        }\n\n    },\n\n    /**\n    * Stops full screen mode if the browser is in it.\n    * @method Phaser.ScaleManager#stopFullScreen\n    */\n    stopFullScreen: function () {\n\n        this.fullScreenTarget[this.game.device.cancelFullscreen]();\n\n    },\n\n    /**\n    * Called automatically when the browser enters of leaves full screen mode.\n    * @method Phaser.ScaleManager#fullScreenChange\n    * @param {Event} event - The fullscreenchange event\n    * @protected\n    */\n    fullScreenChange: function (event) {\n\n        this.event = event;\n\n        if (this.isFullScreen)\n        {\n            if (this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT)\n            {\n                this.fullScreenTarget.style['width'] = '100%';\n                this.fullScreenTarget.style['height'] = '100%';\n\n                this.width = window.outerWidth;\n                this.height = window.outerHeight;\n\n                this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);\n\n                this.aspectRatio = this.width / this.height;\n                this.scaleFactor.x = this.game.width / this.width;\n                this.scaleFactor.y = this.game.height / this.height;\n\n                this.checkResize();\n            }\n            else if (this.fullScreenScaleMode === Phaser.ScaleManager.SHOW_ALL)\n            {\n                this.setShowAll();\n                this.refresh();\n            }\n\n            this.enterFullScreen.dispatch(this.width, this.height);\n        }\n        else\n        {\n            this.fullScreenTarget.style['width'] = this.game.width + 'px';\n            this.fullScreenTarget.style['height'] = this.game.height + 'px';\n\n            this.width = this._width;\n            this.height = this._height;\n\n            this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);\n\n            this.aspectRatio = this.width / this.height;\n            this.scaleFactor.x = this.game.width / this.width;\n            this.scaleFactor.y = this.game.height / this.height;\n\n            this.leaveFullScreen.dispatch(this.width, this.height);\n        }\n\n    },\n\n    /**\n    * If you need your game to run in only one orientation you can force that to happen.\n    * The optional orientationImage is displayed when the game is in the incorrect orientation.\n    * @method Phaser.ScaleManager#forceOrientation\n    * @param {boolean} forceLandscape - true if the game should run in landscape mode only.\n    * @param {boolean} [forcePortrait=false] - true if the game should run in portrait mode only.\n    * @param {string} [orientationImage=''] - The string of an image in the Phaser.Cache to display when this game is in the incorrect orientation.\n    */\n    forceOrientation: function (forceLandscape, forcePortrait, orientationImage) {\n\n        if (typeof forcePortrait === 'undefined') { forcePortrait = false; }\n\n        this.forceLandscape = forceLandscape;\n        this.forcePortrait = forcePortrait;\n\n        if (typeof orientationImage !== 'undefined')\n        {\n            if (orientationImage === null || this.game.cache.checkImageKey(orientationImage) === false)\n            {\n                orientationImage = '__default';\n            }\n\n            this.orientationSprite = new Phaser.Image(this.game, this.game.width / 2, this.game.height / 2, PIXI.TextureCache[orientationImage]);\n            this.orientationSprite.anchor.set(0.5);\n\n            this.checkOrientationState();\n\n            if (this.incorrectOrientation)\n            {\n                this.orientationSprite.visible = true;\n                this.game.world.visible = false;\n            }\n            else\n            {\n                this.orientationSprite.visible = false;\n                this.game.world.visible = true;\n            }\n\n            this.game.stage.addChild(this.orientationSprite);\n        }\n\n    },\n\n    /**\n    * Checks if the browser is in the correct orientation for your game (if forceLandscape or forcePortrait have been set)\n    * @method Phaser.ScaleManager#checkOrientationState\n    */\n    checkOrientationState: function () {\n\n        //  They are in the wrong orientation\n        if (this.incorrectOrientation)\n        {\n            if ((this.forceLandscape && window.innerWidth > window.innerHeight) || (this.forcePortrait && window.innerHeight > window.innerWidth))\n            {\n                //  Back to normal\n                this.incorrectOrientation = false;\n                this.leaveIncorrectOrientation.dispatch();\n\n                if (this.orientationSprite)\n                {\n                    this.orientationSprite.visible = false;\n                    this.game.world.visible = true;\n                }\n\n                if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE)\n                {\n                    this.refresh();\n                }\n            }\n        }\n        else\n        {\n            if ((this.forceLandscape && window.innerWidth < window.innerHeight) || (this.forcePortrait && window.innerHeight < window.innerWidth))\n            {\n                //  Show orientation screen\n                this.incorrectOrientation = true;\n                this.enterIncorrectOrientation.dispatch();\n\n                if (this.orientationSprite && this.orientationSprite.visible === false)\n                {\n                    this.orientationSprite.visible = true;\n                    this.game.world.visible = false;\n                }\n\n                if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE)\n                {\n                    this.refresh();\n                }\n            }\n        }\n    },\n\n    /**\n    * Handle window.orientationchange events\n    * @method Phaser.ScaleManager#checkOrientation\n    * @param {Event} event - The orientationchange event data.\n    */\n    checkOrientation: function (event) {\n\n        this.event = event;\n\n        this.orientation = window['orientation'];\n\n        if (this.isLandscape)\n        {\n            this.enterLandscape.dispatch(this.orientation, true, false);\n        }\n        else\n        {\n            this.enterPortrait.dispatch(this.orientation, false, true);\n        }\n\n        if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE)\n        {\n            this.refresh();\n        }\n\n    },\n\n    /**\n    * Handle window.resize events\n    * @method Phaser.ScaleManager#checkResize\n    * @param {Event} event - The resize event data.\n    */\n    checkResize: function (event) {\n\n        this.event = event;\n\n        if (window.outerWidth > window.outerHeight)\n        {\n            this.orientation = 90;\n        }\n        else\n        {\n            this.orientation = 0;\n        }\n\n        if (this.isLandscape)\n        {\n            this.enterLandscape.dispatch(this.orientation, true, false);\n        }\n        else\n        {\n            this.enterPortrait.dispatch(this.orientation, false, true);\n        }\n\n        if (this.scaleMode !== Phaser.ScaleManager.NO_SCALE)\n        {\n            this.refresh();\n        }\n\n        this.checkOrientationState();\n\n    },\n\n    /**\n    * Re-calculate scale mode and update screen size.\n    * @method Phaser.ScaleManager#refresh\n    */\n    refresh: function () {\n\n        //  We can't do anything about the status bars in iPads, web apps or desktops\n        if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop)\n        {\n            //  TODO - Test this\n            // this._startHeight = window.innerHeight;\n\n            if (this.game.device.android && !this.game.device.chrome)\n            {\n                window.scrollTo(0, 1);\n            }\n            else\n            {\n                window.scrollTo(0, 0);\n            }\n        }\n\n        if (this._check === null && this.maxIterations > 0)\n        {\n            this._iterations = this.maxIterations;\n\n            var _this = this;\n\n            this._check = window.setInterval(function () {\n                return _this.setScreenSize();\n            }, 10);\n\n            this.setScreenSize();\n        }\n\n    },\n\n    /**\n    * Set screen size automatically based on the scaleMode.\n    * @param {boolean} force - If force is true it will try to resize the game regardless of the document dimensions.\n    */\n    setScreenSize: function (force) {\n\n        if (typeof force === 'undefined')\n        {\n            force = false;\n        }\n\n        if (!this.game.device.iPad && !this.game.device.webApp && !this.game.device.desktop)\n        {\n            if (this.game.device.android && !this.game.device.chrome)\n            {\n                window.scrollTo(0, 1);\n            }\n            else\n            {\n                window.scrollTo(0, 0);\n            }\n        }\n\n        this._iterations--;\n\n        if (force || window.innerHeight > this._startHeight || this._iterations < 0)\n        {\n            // Set minimum height of content to new window height\n            document.documentElement['style'].minHeight = window.innerHeight + 'px';\n\n            if (this.incorrectOrientation)\n            {\n                this.setMaximum();\n            }\n            else if (!this.isFullScreen)\n            {\n                if (this.scaleMode === Phaser.ScaleManager.EXACT_FIT)\n                {\n                    this.setExactFit();\n                }\n                else if (this.scaleMode === Phaser.ScaleManager.SHOW_ALL)\n                {\n                    this.setShowAll();\n                }\n            }\n            else\n            {\n                if (this.fullScreenScaleMode === Phaser.ScaleManager.EXACT_FIT)\n                {\n                    this.setExactFit();\n                }\n                else if (this.fullScreenScaleMode === Phaser.ScaleManager.SHOW_ALL)\n                {\n                    this.setShowAll();\n                }\n            }\n\n            this.setSize();\n            clearInterval(this._check);\n            this._check = null;\n        }\n\n    },\n\n    /**\n    * Sets the canvas style width and height values based on minWidth/Height and maxWidth/Height.\n    * @method Phaser.ScaleManager#setSize\n    */\n    setSize: function () {\n\n        if (!this.incorrectOrientation)\n        {\n            if (this.maxWidth && this.width > this.maxWidth)\n            {\n                this.width = this.maxWidth;\n            }\n\n            if (this.maxHeight && this.height > this.maxHeight)\n            {\n                this.height = this.maxHeight;\n            }\n\n            if (this.minWidth && this.width < this.minWidth)\n            {\n                this.width = this.minWidth;\n            }\n\n            if (this.minHeight && this.height < this.minHeight)\n            {\n                this.height = this.minHeight;\n            }\n        }\n\n        this.game.canvas.style.width = this.width + 'px';\n        this.game.canvas.style.height = this.height + 'px';\n\n        this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);\n\n        if (this.pageAlignHorizontally)\n        {\n            if (this.width < window.innerWidth && !this.incorrectOrientation)\n            {\n                this.margin.x = Math.round((window.innerWidth - this.width) / 2);\n                this.game.canvas.style.marginLeft = this.margin.x + 'px';\n            }\n            else\n            {\n                this.margin.x = 0;\n                this.game.canvas.style.marginLeft = '0px';\n            }\n        }\n\n        if (this.pageAlignVertically)\n        {\n            if (this.height < window.innerHeight && !this.incorrectOrientation)\n            {\n                this.margin.y = Math.round((window.innerHeight - this.height) / 2);\n                this.game.canvas.style.marginTop = this.margin.y + 'px';\n            }\n            else\n            {\n                this.margin.y = 0;\n                this.game.canvas.style.marginTop = '0px';\n            }\n        }\n\n        Phaser.Canvas.getOffset(this.game.canvas, this.game.stage.offset);\n\n        this.aspectRatio = this.width / this.height;\n\n        this.scaleFactor.x = this.game.width / this.width;\n        this.scaleFactor.y = this.game.height / this.height;\n\n        this.scaleFactorInversed.x = this.width / this.game.width;\n        this.scaleFactorInversed.y = this.height / this.game.height;\n\n        this.hasResized.dispatch(this.width, this.height);\n\n        this.checkOrientationState();\n\n    },\n\n    /**\n    * Sets this.width equal to window.innerWidth and this.height equal to window.innerHeight\n    * @method Phaser.ScaleManager#setMaximum\n    */\n    setMaximum: function () {\n\n        this.width = window.innerWidth;\n        this.height = window.innerHeight;\n\n    },\n\n    /**\n    * Calculates the multiplier needed to scale the game proportionally.\n    * @method Phaser.ScaleManager#setShowAll\n    */\n    setShowAll: function () {\n\n        var multiplier = Math.min((window.innerHeight / this.game.height), (window.innerWidth / this.game.width));\n\n        this.width = Math.round(this.game.width * multiplier);\n        this.height = Math.round(this.game.height * multiplier);\n\n    },\n\n    /**\n    * Sets the width and height values of the canvas, no larger than the maxWidth/Height.\n    * @method Phaser.ScaleManager#setExactFit\n    */\n    setExactFit: function () {\n\n        var availableWidth = window.innerWidth;\n        var availableHeight = window.innerHeight;\n\n        if (this.maxWidth && availableWidth > this.maxWidth)\n        {\n            this.width = this.maxWidth;\n        }\n        else\n        {\n            this.width = availableWidth;\n        }\n\n        if (this.maxHeight && availableHeight > this.maxHeight)\n        {\n            this.height = this.maxHeight;\n        }\n        else\n        {\n            this.height = availableHeight;\n        }\n\n    }\n\n};\n\nPhaser.ScaleManager.prototype.constructor = Phaser.ScaleManager;\n\n/**\n* @name Phaser.ScaleManager#isFullScreen\n* @property {boolean} isFullScreen - Returns true if the browser is in full screen mode, otherwise false.\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isFullScreen\", {\n\n    get: function () {\n\n        return (document['fullscreenElement'] || document['mozFullScreenElement'] || document['webkitFullscreenElement']);\n\n    }\n\n});\n\n/**\n* @name Phaser.ScaleManager#isPortrait\n* @property {boolean} isPortrait - Returns true if the browser dimensions match a portrait display.\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isPortrait\", {\n\n    get: function () {\n        return (this.orientation === 0 || this.orientation === 180);\n    }\n\n});\n\n/**\n* @name Phaser.ScaleManager#isLandscape\n* @property {boolean} isLandscape - Returns true if the browser dimensions match a landscape display.\n* @readonly\n*/\nObject.defineProperty(Phaser.ScaleManager.prototype, \"isLandscape\", {\n\n    get: function () {\n        return (this.orientation === 90 || this.orientation === -90);\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Game constructor\n*\n* Instantiate a new <code>Phaser.Game</code> object.\n* @class Phaser.Game\n* @classdesc This is where the magic happens. The Game object is the heart of your game,\n* providing quick access to common functions and handling the boot process.\n* \"Hell, there are no rules here - we're trying to accomplish something.\"\n*                                                       Thomas A. Edison\n* @constructor\n* @param {number} [width=800] - The width of your game in game pixels.\n* @param {number} [height=600] - The height of your game in game pixels.\n* @param {number} [renderer=Phaser.AUTO] - Which renderer to use: Phaser.AUTO will auto-detect, Phaser.WEBGL, Phaser.CANVAS or Phaser.HEADLESS (no rendering at all).\n* @param {string|HTMLElement} [parent=''] - The DOM element into which this games canvas will be injected. Either a DOM ID (string) or the element itself.\n* @param {object} [state=null] - The default state object. A object consisting of Phaser.State functions (preload, create, update, render) or null.\n* @param {boolean} [transparent=false] - Use a transparent canvas background or not.\n* @param  {boolean} [antialias=true] - Draw all image textures anti-aliased or not. The default is for smooth textures, but disable if your game features pixel art.\n* @param {object} [physicsConfig=null] - A physics configuration object to pass to the Physics world on creation.\n*/\nPhaser.Game = function (width, height, renderer, parent, state, transparent, antialias, physicsConfig) {\n\n    /**\n    * @property {number} id - Phaser Game ID (for when Pixi supports multiple instances).\n    */\n    this.id = Phaser.GAMES.push(this) - 1;\n\n    /**\n    * @property {object} config - The Phaser.Game configuration object.\n    */\n    this.config = null;\n\n    /**\n    * @property {object} physicsConfig - The Phaser.Physics.World configuration object.\n    */\n    this.physicsConfig = physicsConfig;\n\n    /**\n    * @property {string|HTMLElement} parent - The Games DOM parent.\n    * @default\n    */\n    this.parent = '';\n\n    /**\n    * @property {number} width - The Game width (in pixels).\n    * @default\n    */\n    this.width = 800;\n\n    /**\n    * @property {number} height - The Game height (in pixels).\n    * @default\n    */\n    this.height = 600;\n\n    /**\n    * @property {boolean} transparent - Use a transparent canvas background or not.\n    * @default\n    */\n    this.transparent = false;\n\n    /**\n    * @property {boolean} antialias - Anti-alias graphics. By default scaled images are smoothed in Canvas and WebGL, set anti-alias to false to disable this globally.\n    * @default\n    */\n    this.antialias = true;\n\n    /**\n    * @property {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - The Pixi Renderer.\n    */\n    this.renderer = null;\n\n    /**\n    * @property {number} renderType - The Renderer this game will use. Either Phaser.AUTO, Phaser.CANVAS or Phaser.WEBGL.\n    */\n    this.renderType = Phaser.AUTO;\n\n    /**\n    * @property {Phaser.StateManager} state - The StateManager.\n    */\n    this.state = null;\n\n    /**\n    * @property {boolean} isBooted - Whether the game engine is booted, aka available.\n    * @default\n    */\n    this.isBooted = false;\n\n    /**\n    * @property {boolean} id -Is game running or paused?\n    * @default\n    */\n    this.isRunning = false;\n\n    /**\n    * @property {Phaser.RequestAnimationFrame} raf - Automatically handles the core game loop via requestAnimationFrame or setTimeout\n    */\n    this.raf = null;\n\n    /**\n    * @property {Phaser.GameObjectFactory} add - Reference to the Phaser.GameObjectFactory.\n    */\n    this.add = null;\n\n    /**\n    * @property {Phaser.GameObjectCreator} make - Reference to the GameObject Creator.\n    */\n    this.make = null;\n\n    /**\n    * @property {Phaser.Cache} cache - Reference to the assets cache.\n    */\n    this.cache = null;\n\n    /**\n    * @property {Phaser.Input} input - Reference to the input manager\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Loader} load - Reference to the assets loader.\n    */\n    this.load = null;\n\n    /**\n    * @property {Phaser.Math} math - Reference to the math helper.\n    */\n    this.math = null;\n\n    /**\n    * @property {Phaser.Net} net - Reference to the network class.\n    */\n    this.net = null;\n\n    /**\n    * @property {Phaser.ScaleManager} scale - The game scale manager.\n    */\n    this.scale = null;\n\n    /**\n    * @property {Phaser.SoundManager} sound - Reference to the sound manager.\n    */\n    this.sound = null;\n\n    /**\n    * @property {Phaser.Stage} stage - Reference to the stage.\n    */\n    this.stage = null;\n\n    /**\n    * @property {Phaser.Time} time - Reference to the core game clock.\n    */\n    this.time = null;\n\n    /**\n    * @property {Phaser.TweenManager} tweens - Reference to the tween manager.\n    */\n    this.tweens = null;\n\n    /**\n    * @property {Phaser.World} world - Reference to the world.\n    */\n    this.world = null;\n\n    /**\n    * @property {Phaser.Physics} physics - Reference to the physics manager.\n    */\n    this.physics = null;\n\n    /**\n    * @property {Phaser.RandomDataGenerator} rnd - Instance of repeatable random data generator helper.\n    */\n    this.rnd = null;\n\n    /**\n    * @property {Phaser.Device} device - Contains device information and capabilities.\n    */\n    this.device = null;\n\n    /**\n    * @property {Phaser.Camera} camera - A handy reference to world.camera.\n    */\n    this.camera = null;\n\n    /**\n    * @property {HTMLCanvasElement} canvas - A handy reference to renderer.view, the canvas that the game is being rendered in to.\n    */\n    this.canvas = null;\n\n    /**\n    * @property {CanvasRenderingContext2D} context - A handy reference to renderer.context (only set for CANVAS games, not WebGL)\n    */\n    this.context = null;\n\n    /**\n    * @property {Phaser.Utils.Debug} debug - A set of useful debug utilitie.\n    */\n    this.debug = null;\n\n    /**\n    * @property {Phaser.Particles} particles - The Particle Manager.\n    */\n    this.particles = null;\n\n    /**\n    * @property {boolean} stepping - Enable core loop stepping with Game.enableStep().\n    * @default\n    * @readonly\n    */\n    this.stepping = false;\n\n    /**\n    * @property {boolean} pendingStep - An internal property used by enableStep, but also useful to query from your own game objects.\n    * @default\n    * @readonly\n    */\n    this.pendingStep = false;\n\n    /**\n    * @property {number} stepCount - When stepping is enabled this contains the current step cycle.\n    * @default\n    * @readonly\n    */\n    this.stepCount = 0;\n\n    /**\n    * @property {Phaser.Signal} onPause - This event is fired when the game pauses.\n    */\n    this.onPause = null;\n\n    /**\n    * @property {Phaser.Signal} onResume - This event is fired when the game resumes from a paused state.\n    */\n    this.onResume = null;\n\n    /**\n    * @property {Phaser.Signal} onBlur - This event is fired when the game no longer has focus (typically on page hide).\n    */\n    this.onBlur = null;\n\n    /**\n    * @property {Phaser.Signal} onFocus - This event is fired when the game has focus (typically on page show).\n    */\n    this.onFocus = null;\n\n    /**\n    * @property {boolean} _paused - Is game paused?\n    * @private\n    */\n    this._paused = false;\n\n    /**\n    * @property {boolean} _codePaused - Was the game paused via code or a visibility change?\n    * @private\n    */\n    this._codePaused = false;\n\n    //  Parse the configuration object (if any)\n    if (arguments.length === 1 && typeof arguments[0] === 'object')\n    {\n        this.parseConfig(arguments[0]);\n    }\n    else\n    {\n        if (typeof width !== 'undefined')\n        {\n            this.width = width;\n        }\n\n        if (typeof height !== 'undefined')\n        {\n            this.height = height;\n        }\n\n        if (typeof renderer !== 'undefined')\n        {\n            this.renderer = renderer;\n            this.renderType = renderer;\n        }\n\n        if (typeof parent !== 'undefined')\n        {\n            this.parent = parent;\n        }\n\n        if (typeof transparent !== 'undefined')\n        {\n            this.transparent = transparent;\n        }\n\n        if (typeof antialias !== 'undefined')\n        {\n            this.antialias = antialias;\n        }\n\n        this.rnd = new Phaser.RandomDataGenerator([(Date.now() * Math.random()).toString()]);\n\n        this.state = new Phaser.StateManager(this, state);\n    }\n\n    var _this = this;\n\n    this._onBoot = function () {\n        return _this.boot();\n    };\n\n    if (document.readyState === 'complete' || document.readyState === 'interactive')\n    {\n        window.setTimeout(this._onBoot, 0);\n    }\n    else\n    {\n        document.addEventListener('DOMContentLoaded', this._onBoot, false);\n        window.addEventListener('load', this._onBoot, false);\n    }\n\n    return this;\n\n};\n\nPhaser.Game.prototype = {\n\n    /**\n    * Parses a Game configuration object.\n    *\n    * @method Phaser.Game#parseConfig\n    * @protected\n    */\n    parseConfig: function (config) {\n\n        this.config = config;\n\n        if (config['width'])\n        {\n            this.width = Phaser.Utils.parseDimension(config['width'], 0);\n        }\n\n        if (config['height'])\n        {\n            this.height = Phaser.Utils.parseDimension(config['height'], 1);\n        }\n\n        if (config['renderer'])\n        {\n            this.renderer = config['renderer'];\n            this.renderType = config['renderer'];\n        }\n\n        if (config['parent'])\n        {\n            this.parent = config['parent'];\n        }\n\n        if (config['transparent'])\n        {\n            this.transparent = config['transparent'];\n        }\n\n        if (config['antialias'])\n        {\n            this.antialias = config['antialias'];\n        }\n\n        if (config['physicsConfig'])\n        {\n            this.physicsConfig = config['physicsConfig'];\n        }\n\n        var seed = [(Date.now() * Math.random()).toString()];\n\n        if (config['seed'])\n        {\n            seed = config['seed'];\n        }\n\n        this.rnd = new Phaser.RandomDataGenerator(seed);\n\n        var state = null;\n\n        if (config['state'])\n        {\n            state = config['state'];\n        }\n\n        this.state = new Phaser.StateManager(this, state);\n\n    },\n\n\n    /**\n    * Initialize engine sub modules and start the game.\n    *\n    * @method Phaser.Game#boot\n    * @protected\n    */\n    boot: function () {\n\n        if (this.isBooted)\n        {\n            return;\n        }\n\n        if (!document.body)\n        {\n            window.setTimeout(this._onBoot, 20);\n        }\n        else\n        {\n            document.removeEventListener('DOMContentLoaded', this._onBoot);\n            window.removeEventListener('load', this._onBoot);\n\n            this.onPause = new Phaser.Signal();\n            this.onResume = new Phaser.Signal();\n            this.onBlur = new Phaser.Signal();\n            this.onFocus = new Phaser.Signal();\n\n            this.isBooted = true;\n\n            this.device = new Phaser.Device(this);\n            this.math = Phaser.Math;\n\n            this.stage = new Phaser.Stage(this, this.width, this.height);\n            this.scale = new Phaser.ScaleManager(this, this.width, this.height);\n\n            this.setUpRenderer();\n\n            this.device.checkFullScreenSupport();\n\n            this.world = new Phaser.World(this);\n            this.add = new Phaser.GameObjectFactory(this);\n            this.make = new Phaser.GameObjectCreator(this);\n            this.cache = new Phaser.Cache(this);\n            this.load = new Phaser.Loader(this);\n            this.time = new Phaser.Time(this);\n            this.tweens = new Phaser.TweenManager(this);\n            this.input = new Phaser.Input(this);\n            this.sound = new Phaser.SoundManager(this);\n            this.physics = new Phaser.Physics(this, this.physicsConfig);\n            this.particles = new Phaser.Particles(this);\n            this.plugins = new Phaser.PluginManager(this);\n            this.net = new Phaser.Net(this);\n            this.debug = new Phaser.Utils.Debug(this);\n            this.scratch = new Phaser.BitmapData(this, '__root', 1024, 1024);\n\n            this.time.boot();\n            this.stage.boot();\n            this.world.boot();\n            this.input.boot();\n            this.sound.boot();\n            this.state.boot();\n            this.debug.boot();\n\n            this.showDebugHeader();\n\n            this.isRunning = true;\n\n            if (this.config && this.config['forceSetTimeOut'])\n            {\n                this.raf = new Phaser.RequestAnimationFrame(this, this.config['forceSetTimeOut']);\n            }\n            else\n            {\n                this.raf = new Phaser.RequestAnimationFrame(this, false);\n            }\n\n            this.raf.start();\n        }\n\n    },\n\n    /**\n    * Displays a Phaser version debug header in the console.\n    *\n    * @method Phaser.Game#showDebugHeader\n    * @protected\n    */\n    showDebugHeader: function () {\n\n        var v = Phaser.VERSION;\n        var r = 'Canvas';\n        var a = 'HTML Audio';\n        var c = 1;\n\n        if (this.renderType === Phaser.WEBGL)\n        {\n            r = 'WebGL';\n            c++;\n        }\n        else if (this.renderType == Phaser.HEADLESS)\n        {\n            r = 'Headless';\n        }\n\n        if (this.device.webAudio)\n        {\n            a = 'WebAudio';\n            c++;\n        }\n\n        if (this.device.chrome)\n        {\n            var args = [\n                '%c %c %c Phaser v' + v + ' - ' + r + ' - ' + a + '  %c %c ' + ' http://phaser.io  %c %c %c%c ',\n                'background: #0cf300',\n                'background: #00bc17',\n                'color: #ffffff; background: #00711f;',\n                'background: #00bc17',\n                'background: #0cf300',\n                'background: #00bc17'\n            ];\n\n            for (var i = 0; i < 3; i++)\n            {\n                if (i < c)\n                {\n                    args.push('color: #ff2424; background: #fff');\n                }\n                else\n                {\n                    args.push('color: #959595; background: #fff');\n                }\n            }\n\n            console.log.apply(console, args);\n        }\n        else if (window['console'])\n        {\n            console.log('Phaser v' + v + ' - Renderer: ' + r + ' - Audio: ' + a + ' - http://phaser.io');\n        }\n\n    },\n\n    /**\n    * Checks if the device is capable of using the requested renderer and sets it up or an alternative if not.\n    *\n    * @method Phaser.Game#setUpRenderer\n    * @protected\n    */\n    setUpRenderer: function () {\n\n        if (this.device.trident)\n        {\n            //  Pixi WebGL renderer on IE11 doesn't work correctly at the moment, the pre-multiplied alpha gets all washed out.\n            //  So we're forcing canvas for now until this is fixed, sorry. It's got to be better than no game appearing at all, right?\n            this.renderType = Phaser.CANVAS;\n        }\n\n        if (this.renderType === Phaser.HEADLESS || this.renderType === Phaser.CANVAS || (this.renderType === Phaser.AUTO && this.device.webGL === false))\n        {\n            if (this.device.canvas)\n            {\n                if (this.renderType === Phaser.AUTO)\n                {\n                    this.renderType = Phaser.CANVAS;\n                }\n\n                this.renderer = new PIXI.CanvasRenderer(this.width, this.height, this.canvas, this.transparent);\n                this.context = this.renderer.context;\n            }\n            else\n            {\n                throw new Error('Phaser.Game - cannot create Canvas or WebGL context, aborting.');\n            }\n        }\n        else\n        {\n            //  They requested WebGL, and their browser supports it\n            this.renderType = Phaser.WEBGL;\n            this.renderer = new PIXI.WebGLRenderer(this.width, this.height, this.canvas, this.transparent, this.antialias);\n            this.context = null;\n        }\n\n        if (this.renderType !== Phaser.HEADLESS)\n        {\n            this.stage.smoothed = this.antialias;\n\n            Phaser.Canvas.addToDOM(this.canvas, this.parent, true);\n            Phaser.Canvas.setTouchAction(this.canvas);\n        }\n\n    },\n\n    /**\n    * The core game loop when in a paused state.\n    *\n    * @method Phaser.Game#update\n    * @protected\n    * @param {number} time - The current time as provided by RequestAnimationFrame.\n    */\n    update: function (time) {\n\n        this.time.update(time);\n\n        if (!this._paused && !this.pendingStep)\n        {\n            if (this.stepping)\n            {\n                this.pendingStep = true;\n            }\n\n            this.debug.preUpdate();\n            this.physics.preUpdate();\n            this.state.preUpdate();\n            this.plugins.preUpdate();\n            this.stage.preUpdate();\n\n            this.state.update();\n            this.stage.update();\n            this.tweens.update();\n            this.sound.update();\n            this.input.update();\n            this.physics.update();\n            this.particles.update();\n            this.plugins.update();\n\n            this.stage.postUpdate();\n            this.plugins.postUpdate();\n        }\n        else\n        {\n            this.state.pauseUpdate();\n            // this.input.update();\n            this.debug.preUpdate();\n        }\n\n        if (this.renderType != Phaser.HEADLESS)\n        {\n            this.renderer.render(this.stage);\n            this.plugins.render();\n            this.state.render();\n            this.plugins.postRender();\n        }\n\n    },\n\n    /**\n    * Enable core game loop stepping. When enabled you must call game.step() directly (perhaps via a DOM button?)\n    * Calling step will advance the game loop by one frame. This is extremely useful for hard to track down errors!\n    *\n    * @method Phaser.Game#enableStep\n    */\n    enableStep: function () {\n\n        this.stepping = true;\n        this.pendingStep = false;\n        this.stepCount = 0;\n\n    },\n\n    /**\n    * Disables core game loop stepping.\n    *\n    * @method Phaser.Game#disableStep\n    */\n    disableStep: function () {\n\n        this.stepping = false;\n        this.pendingStep = false;\n\n    },\n\n    /**\n    * When stepping is enabled you must call this function directly (perhaps via a DOM button?) to advance the game loop by one frame.\n    * This is extremely useful to hard to track down errors! Use the internal stepCount property to monitor progress.\n    *\n    * @method Phaser.Game#step\n    */\n    step: function () {\n\n        this.pendingStep = false;\n        this.stepCount++;\n\n    },\n\n    /**\n    * Nuke the entire game from orbit\n    *\n    * @method Phaser.Game#destroy\n    */\n    destroy: function () {\n\n        this.raf.stop();\n\n        this.input.destroy();\n        this.state.destroy();\n        this.physics.destroy();\n\n        this.state = null;\n        this.cache = null;\n        this.input = null;\n        this.load = null;\n        this.sound = null;\n        this.stage = null;\n        this.time = null;\n        this.world = null;\n        this.isBooted = false;\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#gamePaused\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    gamePaused: function (event) {\n\n        //   If the game is already paused it was done via game code, so don't re-pause it\n        if (!this._paused)\n        {\n            this._paused = true;\n            this.time.gamePaused();\n            this.sound.setMute();\n            this.onPause.dispatch(event);\n        }\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#gameResumed\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    gameResumed: function (event) {\n\n        //  Game is paused, but wasn't paused via code, so resume it\n        if (this._paused && !this._codePaused)\n        {\n            this._paused = false;\n            this.time.gameResumed();\n            this.input.reset();\n            this.sound.unsetMute();\n            this.onResume.dispatch(event);\n        }\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#focusLoss\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    focusLoss: function (event) {\n\n        this.onBlur.dispatch(event);\n\n        this.gamePaused(event);\n\n    },\n\n    /**\n    * Called by the Stage visibility handler.\n    *\n    * @method Phaser.Game#focusGain\n    * @param {object} event - The DOM event that caused the game to pause, if any.\n    * @protected\n    */\n    focusGain: function (event) {\n\n        this.onFocus.dispatch(event);\n\n        this.gameResumed(event);\n\n    }\n\n};\n\nPhaser.Game.prototype.constructor = Phaser.Game;\n\n/**\n* The paused state of the Game. A paused game doesn't update any of its subsystems.\n* When a game is paused the onPause event is dispatched. When it is resumed the onResume event is dispatched.\n* @name Phaser.Game#paused\n* @property {boolean} paused - Gets and sets the paused state of the Game.\n*/\nObject.defineProperty(Phaser.Game.prototype, \"paused\", {\n\n    get: function () {\n        return this._paused;\n    },\n\n    set: function (value) {\n\n        if (value === true)\n        {\n            if (this._paused === false)\n            {\n                this._paused = true;\n                this._codePaused = true;\n                this.sound.setMute();\n                this.time.gamePaused();\n                this.onPause.dispatch(this);\n            }\n        }\n        else\n        {\n            if (this._paused)\n            {\n                this._paused = false;\n                this._codePaused = false;\n                this.input.reset();\n                this.sound.unsetMute();\n                this.time.gameResumed();\n                this.onResume.dispatch(this);\n            }\n        }\n\n    }\n\n});\n\n/**\n* \"Deleted code is debugged code.\" - Jeff Sickel\n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Input is the Input Manager for all types of Input across Phaser, including mouse, keyboard, touch and MSPointer.\n* The Input manager is updated automatically by the core game loop.\n*\n* @class Phaser.Input\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n*/\nPhaser.Input = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {HTMLCanvasElement} hitCanvas - The canvas to which single pixels are drawn in order to perform pixel-perfect hit detection.\n    * @default\n    */\n    this.hitCanvas = null;\n\n    /**\n    * @property {CanvasRenderingContext2D} hitContext - The context of the pixel perfect hit canvas.\n    * @default\n    */\n    this.hitContext = null;\n\n    /**\n    * @property {function} moveCallback - An optional callback that will be fired every time the activePointer receives a move event from the DOM. Set to null to disable.\n    */\n    this.moveCallback = null;\n\n    /**\n    * @property {object} moveCallbackContext - The context in which the moveCallback will be sent. Defaults to Phaser.Input but can be set to any valid JS object.\n    */\n    this.moveCallbackContext = this;\n\n    /**\n    * @property {number} pollRate - How often should the input pointers be checked for updates? A value of 0 means every single frame (60fps); a value of 1 means every other frame (30fps) and so on.\n    * @default\n    */\n    this.pollRate = 0;\n\n    /**\n    * You can disable all Input by setting Input.disabled = true. While set all new input related events will be ignored.\n    * If you need to disable just one type of input; for example mouse; use Input.mouse.disabled = true instead\n    * @property {boolean} disabled\n    * @default\n    */\n    this.disabled = false;\n\n    /**\n    * @property {number} multiInputOverride - Controls the expected behaviour when using a mouse and touch together on a multi-input device.\n    * @default\n    */\n    this.multiInputOverride = Phaser.Input.MOUSE_TOUCH_COMBINE;\n\n    /**\n    * @property {Phaser.Point} position - A point object representing the current position of the Pointer.\n    * @default\n    */\n    this.position = null;\n\n    /**\n    * @property {Phaser.Point} speed - A point object representing the speed of the Pointer. Only really useful in single Pointer games; otherwise see the Pointer objects directly.\n    */\n    this.speed = null;\n\n    /**\n    * A Circle object centered on the x/y screen coordinates of the Input.\n    * Default size of 44px (Apples recommended \"finger tip\" size) but can be changed to anything.\n    * @property {Phaser.Circle} circle\n    */\n    this.circle = null;\n\n    /**\n    * @property {Phaser.Point} scale - The scale by which all input coordinates are multiplied; calculated by the ScaleManager. In an un-scaled game the values will be x = 1 and y = 1.\n    */\n    this.scale = null;\n\n    /**\n    * @property {number} maxPointers - The maximum number of Pointers allowed to be active at any one time. For lots of games it's useful to set this to 1.\n    * @default\n    */\n    this.maxPointers = 10;\n\n    /**\n    * @property {number} currentPointers - The current number of active Pointers.\n    * @default\n    */\n    this.currentPointers = 0;\n\n    /**\n    * @property {number} tapRate - The number of milliseconds that the Pointer has to be pressed down and then released to be considered a tap or click.\n    * @default\n    */\n    this.tapRate = 200;\n\n    /**\n    * @property {number} doubleTapRate - The number of milliseconds between taps of the same Pointer for it to be considered a double tap / click.\n    * @default\n    */\n    this.doubleTapRate = 300;\n\n    /**\n    * @property {number} holdRate - The number of milliseconds that the Pointer has to be pressed down for it to fire a onHold event.\n    * @default\n    */\n    this.holdRate = 2000;\n\n    /**\n    * @property {number} justPressedRate - The number of milliseconds below which the Pointer is considered justPressed.\n    * @default\n    */\n    this.justPressedRate = 200;\n\n    /**\n    * @property {number} justReleasedRate - The number of milliseconds below which the Pointer is considered justReleased .\n    * @default\n    */\n    this.justReleasedRate = 200;\n\n    /**\n    * Sets if the Pointer objects should record a history of x/y coordinates they have passed through.\n    * The history is cleared each time the Pointer is pressed down.\n    * The history is updated at the rate specified in Input.pollRate\n    * @property {boolean} recordPointerHistory\n    * @default\n    */\n    this.recordPointerHistory = false;\n\n    /**\n    * @property {number} recordRate - The rate in milliseconds at which the Pointer objects should update their tracking history.\n    * @default\n    */\n    this.recordRate = 100;\n\n    /**\n    * The total number of entries that can be recorded into the Pointer objects tracking history.\n    * If the Pointer is tracking one event every 100ms; then a trackLimit of 100 would store the last 10 seconds worth of history.\n    * @property {number} recordLimit\n    * @default\n    */\n    this.recordLimit = 100;\n\n    /**\n    * @property {Phaser.Pointer} pointer1 - A Pointer object.\n    */\n    this.pointer1 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer2 - A Pointer object.\n    */\n    this.pointer2 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer3 - A Pointer object.\n    */\n    this.pointer3 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer4 - A Pointer object.\n    */\n    this.pointer4 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer5 - A Pointer object.\n    */\n    this.pointer5 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer6 - A Pointer object.\n    */\n    this.pointer6 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer7 - A Pointer object.\n    */\n    this.pointer7 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer8 - A Pointer object.\n    */\n    this.pointer8 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer9 - A Pointer object.\n    */\n    this.pointer9 = null;\n\n    /**\n    * @property {Phaser.Pointer} pointer10 - A Pointer object.\n    */\n    this.pointer10 = null;\n\n    /**\n    * The most recently active Pointer object.\n    * When you've limited max pointers to 1 this will accurately be either the first finger touched or mouse.\n    * @property {Phaser.Pointer} activePointer\n    */\n    this.activePointer = null;\n\n    /**\n    * @property {Pointer} mousePointer - The mouse has its own unique Phaser.Pointer object which you can use if making a desktop specific game.\n    */\n    this.mousePointer = null;\n\n    /**\n    * @property {Phaser.Mouse} mouse - The Mouse Input manager.\n    */\n    this.mouse = null;\n\n    /**\n    * @property {Phaser.Keyboard} keyboard - The Keyboard Input manager.\n    */\n    this.keyboard = null;\n\n    /**\n    * @property {Phaser.Touch} touch - the Touch Input manager.\n    */\n    this.touch = null;\n\n    /**\n    * @property {Phaser.MSPointer} mspointer - The MSPointer Input manager.\n    */\n    this.mspointer = null;\n\n    /**\n    * @property {Phaser.Gamepad} gamepad - The Gamepad Input manager.\n    */\n    this.gamepad = null;\n\n    /**\n    * @property {Phaser.Gestures} gestures - The Gestures manager.\n    */\n    // this.gestures = null;\n\n    /**\n    * @property {boolean} resetLocked - If the Input Manager has been reset locked then all calls made to InputManager.reset, such as from a State change, are ignored.\n    * @default\n    */\n    this.resetLocked = false;\n\n    /**\n    * @property {Phaser.Signal} onDown - A Signal that is dispatched each time a pointer is pressed down.\n    */\n    this.onDown = null;\n\n    /**\n    * @property {Phaser.Signal} onUp - A Signal that is dispatched each time a pointer is released.\n    */\n    this.onUp = null;\n\n    /**\n    * @property {Phaser.Signal} onTap - A Signal that is dispatched each time a pointer is tapped.\n    */\n    this.onTap = null;\n\n    /**\n    * @property {Phaser.Signal} onHold - A Signal that is dispatched each time a pointer is held down.\n    */\n    this.onHold = null;\n\n    /**\n    * A list of interactive objects. Te InputHandler components add and remove themselves from this.\n    * @property {Phaser.ArrayList} interactiveItems\n    */\n    this.interactiveItems = new Phaser.ArrayList();\n\n    /**\n    * @property {Phaser.Point} _localPoint - Internal cache var.\n    * @private\n    */\n    this._localPoint = new Phaser.Point();\n\n    /**\n    * @property {number} _pollCounter - Internal var holding the current poll counter.\n    * @private\n    */\n    this._pollCounter = 0;\n\n    /**\n    * @property {Phaser.Point} _oldPosition - A point object representing the previous position of the Pointer.\n    * @private\n    */\n    this._oldPosition = null;\n\n    /**\n    * @property {number} _x - x coordinate of the most recent Pointer event\n    * @private\n    */\n    this._x = 0;\n\n    /**\n    * @property {number} _y - Y coordinate of the most recent Pointer event\n    * @private\n    */\n    this._y = 0;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Input.MOUSE_OVERRIDES_TOUCH = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Input.TOUCH_OVERRIDES_MOUSE = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Input.MOUSE_TOUCH_COMBINE = 2;\n\nPhaser.Input.prototype = {\n\n    /**\n    * Starts the Input Manager running.\n    * @method Phaser.Input#boot\n    * @protected\n    */\n    boot: function () {\n\n        this.mousePointer = new Phaser.Pointer(this.game, 0);\n        this.pointer1 = new Phaser.Pointer(this.game, 1);\n        this.pointer2 = new Phaser.Pointer(this.game, 2);\n\n        this.mouse = new Phaser.Mouse(this.game);\n        this.keyboard = new Phaser.Keyboard(this.game);\n        this.touch = new Phaser.Touch(this.game);\n        this.mspointer = new Phaser.MSPointer(this.game);\n        this.gamepad = new Phaser.Gamepad(this.game);\n        // this.gestures = new Phaser.Gestures(this.game);\n\n        this.onDown = new Phaser.Signal();\n        this.onUp = new Phaser.Signal();\n        this.onTap = new Phaser.Signal();\n        this.onHold = new Phaser.Signal();\n\n        this.scale = new Phaser.Point(1, 1);\n        this.speed = new Phaser.Point();\n        this.position = new Phaser.Point();\n        this._oldPosition = new Phaser.Point();\n\n        this.circle = new Phaser.Circle(0, 0, 44);\n\n        this.activePointer = this.mousePointer;\n        this.currentPointers = 0;\n\n        this.hitCanvas = document.createElement('canvas');\n        this.hitCanvas.width = 1;\n        this.hitCanvas.height = 1;\n        this.hitContext = this.hitCanvas.getContext('2d');\n\n        this.mouse.start();\n        this.keyboard.start();\n        this.touch.start();\n        this.mspointer.start();\n        this.mousePointer.active = true;\n\n    },\n\n    /**\n    * Stops all of the Input Managers from running.\n    * @method Phaser.Input#destroy\n    */\n    destroy: function () {\n\n        this.mouse.stop();\n        this.keyboard.stop();\n        this.touch.stop();\n        this.mspointer.stop();\n        this.gamepad.stop();\n        // this.gestures.stop();\n\n        this.moveCallback = null;\n\n    },\n\n    /**\n    * Sets a callback that is fired every time the activePointer receives a DOM move event such as a mousemove or touchmove.\n    * It will be called every time the activePointer moves, which in a multi-touch game can be a lot of times, so this is best\n    * to only use if you've limited input to a single pointer (i.e. mouse or touch)\n    * @method Phaser.Input#setMoveCallback\n    * @param {function} callback - The callback that will be called each time the activePointer receives a DOM move event.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    */\n    setMoveCallback: function (callback, callbackContext) {\n\n        this.moveCallback = callback;\n        this.moveCallbackContext = callbackContext;\n\n    },\n\n    /**\n    * Add a new Pointer object to the Input Manager. By default Input creates 3 pointer objects: mousePointer, pointer1 and pointer2.\n    * If you need more then use this to create a new one, up to a maximum of 10.\n    * @method Phaser.Input#addPointer\n    * @return {Phaser.Pointer} A reference to the new Pointer object that was created.\n    */\n    addPointer: function () {\n\n        var next = 0;\n\n        for (var i = 10; i > 0; i--)\n        {\n            if (this['pointer' + i] === null)\n            {\n                next = i;\n            }\n        }\n\n        if (next === 0)\n        {\n            console.warn(\"You can only have 10 Pointer objects\");\n            return null;\n        }\n        else\n        {\n            this['pointer' + next] = new Phaser.Pointer(this.game, next);\n            return this['pointer' + next];\n        }\n\n    },\n\n    /**\n    * Updates the Input Manager. Called by the core Game loop.\n    * @method Phaser.Input#update\n    * @protected\n    */\n    update: function () {\n\n        this.keyboard.update();\n\n        if (this.pollRate > 0 && this._pollCounter < this.pollRate)\n        {\n            this._pollCounter++;\n            return;\n        }\n\n        this.speed.x = this.position.x - this._oldPosition.x;\n        this.speed.y = this.position.y - this._oldPosition.y;\n\n        this._oldPosition.copyFrom(this.position);\n        this.mousePointer.update();\n\n        if (this.gamepad.active) { this.gamepad.update(); }\n\n        this.pointer1.update();\n        this.pointer2.update();\n\n        if (this.pointer3) { this.pointer3.update(); }\n        if (this.pointer4) { this.pointer4.update(); }\n        if (this.pointer5) { this.pointer5.update(); }\n        if (this.pointer6) { this.pointer6.update(); }\n        if (this.pointer7) { this.pointer7.update(); }\n        if (this.pointer8) { this.pointer8.update(); }\n        if (this.pointer9) { this.pointer9.update(); }\n        if (this.pointer10) { this.pointer10.update(); }\n\n        this._pollCounter = 0;\n\n        // if (this.gestures.active) { this.gestures.update(); }\n\n    },\n\n    /**\n    * Reset all of the Pointers and Input states. The optional `hard` parameter will reset any events or callbacks that may be bound.\n    * Input.reset is called automatically during a State change or if a game loses focus / visibility. If you wish to control the reset\n    * directly yourself then set InputManager.resetLocked to `true`.\n    *\n    * @method Phaser.Input#reset\n    * @param {boolean} [hard=false] - A soft reset won't reset any events or callbacks that are bound. A hard reset will.\n    */\n    reset: function (hard) {\n\n        if (!this.game.isBooted || this.resetLocked)\n        {\n            return;\n        }\n\n        if (typeof hard === 'undefined') { hard = false; }\n\n        this.keyboard.reset(hard);\n        this.mousePointer.reset();\n        this.gamepad.reset();\n\n        for (var i = 1; i <= 10; i++)\n        {\n            if (this['pointer' + i])\n            {\n                this['pointer' + i].reset();\n            }\n        }\n\n        this.currentPointers = 0;\n\n        if (this.game.canvas.style.cursor !== 'none')\n        {\n            this.game.canvas.style.cursor = 'inherit';\n        }\n\n        if (hard)\n        {\n            this.onDown.dispose();\n            this.onUp.dispose();\n            this.onTap.dispose();\n            this.onHold.dispose();\n            this.onDown = new Phaser.Signal();\n            this.onUp = new Phaser.Signal();\n            this.onTap = new Phaser.Signal();\n            this.onHold = new Phaser.Signal();\n        }\n\n        this._pollCounter = 0;\n\n    },\n\n    /**\n    * Resets the speed and old position properties.\n    * @method Phaser.Input#resetSpeed\n    * @param {number} x - Sets the oldPosition.x value.\n    * @param {number} y - Sets the oldPosition.y value.\n    */\n    resetSpeed: function (x, y) {\n\n        this._oldPosition.setTo(x, y);\n        this.speed.setTo(0, 0);\n\n    },\n\n    /**\n    * Find the first free Pointer object and start it, passing in the event data. This is called automatically by Phaser.Touch and Phaser.MSPointer.\n    * @method Phaser.Input#startPointer\n    * @param {Any} event - The event data from the Touch event.\n    * @return {Phaser.Pointer} The Pointer object that was started or null if no Pointer object is available.\n    */\n    startPointer: function (event) {\n\n        if (this.maxPointers < 10 && this.totalActivePointers == this.maxPointers)\n        {\n            return null;\n        }\n\n        if (this.pointer1.active === false)\n        {\n            return this.pointer1.start(event);\n        }\n        else if (this.pointer2.active === false)\n        {\n            return this.pointer2.start(event);\n        }\n        else\n        {\n            for (var i = 3; i <= 10; i++)\n            {\n                if (this['pointer' + i] && this['pointer' + i].active === false)\n                {\n                    return this['pointer' + i].start(event);\n                }\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Updates the matching Pointer object, passing in the event data. This is called automatically and should not normally need to be invoked.\n    * @method Phaser.Input#updatePointer\n    * @param {Any} event - The event data from the Touch event.\n    * @return {Phaser.Pointer} The Pointer object that was updated or null if no Pointer object is available.\n    */\n    updatePointer: function (event) {\n\n        if (this.pointer1.active && this.pointer1.identifier == event.identifier)\n        {\n            return this.pointer1.move(event);\n        }\n        else if (this.pointer2.active && this.pointer2.identifier == event.identifier)\n        {\n            return this.pointer2.move(event);\n        }\n        else\n        {\n            for (var i = 3; i <= 10; i++)\n            {\n                if (this['pointer' + i] && this['pointer' + i].active && this['pointer' + i].identifier == event.identifier)\n                {\n                    return this['pointer' + i].move(event);\n                }\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Stops the matching Pointer object, passing in the event data.\n    * @method Phaser.Input#stopPointer\n    * @param {Any} event - The event data from the Touch event.\n    * @return {Phaser.Pointer} The Pointer object that was stopped or null if no Pointer object is available.\n    */\n    stopPointer: function (event) {\n\n        if (this.pointer1.active && this.pointer1.identifier == event.identifier)\n        {\n            return this.pointer1.stop(event);\n        }\n        else if (this.pointer2.active && this.pointer2.identifier == event.identifier)\n        {\n            return this.pointer2.stop(event);\n        }\n        else\n        {\n            for (var i = 3; i <= 10; i++)\n            {\n                if (this['pointer' + i] && this['pointer' + i].active && this['pointer' + i].identifier == event.identifier)\n                {\n                    return this['pointer' + i].stop(event);\n                }\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Get the next Pointer object whos active property matches the given state\n    * @method Phaser.Input#getPointer\n    * @param {boolean} state - The state the Pointer should be in (false for inactive, true for active).\n    * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested state.\n    */\n    getPointer: function (state) {\n\n        state = state || false;\n\n        if (this.pointer1.active == state)\n        {\n            return this.pointer1;\n        }\n        else if (this.pointer2.active == state)\n        {\n            return this.pointer2;\n        }\n        else\n        {\n            for (var i = 3; i <= 10; i++)\n            {\n                if (this['pointer' + i] && this['pointer' + i].active == state)\n                {\n                    return this['pointer' + i];\n                }\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Get the Pointer object whos identified property matches the given identifier value.\n    * @method Phaser.Input#getPointerFromIdentifier\n    * @param {number} identifier - The Pointer.identifier value to search for.\n    * @return {Phaser.Pointer} A Pointer object or null if no Pointer object matches the requested identifier.\n    */\n    getPointerFromIdentifier: function (identifier) {\n\n        if (this.pointer1.identifier == identifier)\n        {\n            return this.pointer1;\n        }\n        else if (this.pointer2.identifier == identifier)\n        {\n            return this.pointer2;\n        }\n        else\n        {\n            for (var i = 3; i <= 10; i++)\n            {\n                if (this['pointer' + i] && this['pointer' + i].identifier == identifier)\n                {\n                    return this['pointer' + i];\n                }\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * This will return the local coordinates of the specified displayObject based on the given Pointer.\n    * @method Phaser.Input#getLocalPosition\n    * @param {Phaser.Sprite|Phaser.Image} displayObject - The DisplayObject to get the local coordinates for.\n    * @param {Phaser.Pointer} pointer - The Pointer to use in the check against the displayObject.\n    * @return {Phaser.Point} A point containing the coordinates of the Pointer position relative to the DisplayObject.\n    */\n    getLocalPosition: function (displayObject, pointer, output) {\n\n        if (typeof output === 'undefined') { output = new Phaser.Point(); }\n\n        var wt = displayObject.worldTransform;\n        var id = 1 / (wt.a * wt.d + wt.b * -wt.c);\n\n        return output.setTo(\n            wt.d * id * pointer.x + -wt.b * id * pointer.y + (wt.ty * wt.b - wt.tx * wt.d) * id,\n            wt.a * id * pointer.y + -wt.c * id * pointer.x + (-wt.ty * wt.a + wt.tx * wt.c) * id\n        );\n\n    },\n\n    /**\n    * Tests if the pointer hits the given object.\n    *\n    * @method Phaser.Input#hitTest\n    * @param {DisplayObject} displayObject - The displayObject to test for a hit.\n    * @param {Phaser.Pointer} pointer - The pointer to use for the test.\n    * @param {Phaser.Point} localPoint - The local translated point.\n    */\n    hitTest: function (displayObject, pointer, localPoint) {\n\n        if (!displayObject.worldVisible)\n        {\n            return false;\n        }\n\n        this.getLocalPosition(displayObject, pointer, this._localPoint);\n\n        localPoint.copyFrom(this._localPoint);\n\n        if (displayObject.hitArea && displayObject.hitArea.contains)\n        {\n            if (displayObject.hitArea.contains(this._localPoint.x, this._localPoint.y))\n            {\n                return true;\n            }\n\n            return false;\n        }\n        else if (displayObject instanceof Phaser.TileSprite)\n        {\n            var width = displayObject.width;\n            var height = displayObject.height;\n            var x1 = -width * displayObject.anchor.x;\n\n            if (this._localPoint.x > x1 && this._localPoint.x < x1 + width)\n            {\n                var y1 = -height * displayObject.anchor.y;\n\n                if (this._localPoint.y > y1 && this._localPoint.y < y1 + height)\n                {\n                    return true;\n                }\n            }\n        }\n        else if (displayObject instanceof PIXI.Sprite)\n        {\n            var width = displayObject.texture.frame.width;\n            var height = displayObject.texture.frame.height;\n            var x1 = -width * displayObject.anchor.x;\n\n            if (this._localPoint.x > x1 && this._localPoint.x < x1 + width)\n            {\n                var y1 = -height * displayObject.anchor.y;\n\n                if (this._localPoint.y > y1 && this._localPoint.y < y1 + height)\n                {\n                    return true;\n                }\n            }\n        }\n\n        for (var i = 0, len = displayObject.children.length; i < len; i++)\n        {\n            if (this.hitTest(displayObject.children[i], pointer, localPoint))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n};\n\nPhaser.Input.prototype.constructor = Phaser.Input;\n\n/**\n* The X coordinate of the most recently active pointer. This value takes game scaling into account automatically. See Pointer.screenX/clientX for source values.\n* @name Phaser.Input#x\n* @property {number} x - The X coordinate of the most recently active pointer.\n*/\nObject.defineProperty(Phaser.Input.prototype, \"x\", {\n\n    get: function () {\n        return this._x;\n    },\n\n    set: function (value) {\n        this._x = Math.floor(value);\n    }\n\n});\n\n/**\n* The Y coordinate of the most recently active pointer. This value takes game scaling into account automatically. See Pointer.screenY/clientY for source values.\n* @name Phaser.Input#y\n* @property {number} y - The Y coordinate of the most recently active pointer.\n*/\nObject.defineProperty(Phaser.Input.prototype, \"y\", {\n\n    get: function () {\n        return this._y;\n    },\n\n    set: function (value) {\n        this._y = Math.floor(value);\n    }\n\n});\n\n/**\n* @name Phaser.Input#pollLocked\n* @property {boolean} pollLocked - True if the Input is currently poll rate locked.\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"pollLocked\", {\n\n    get: function () {\n        return (this.pollRate > 0 && this._pollCounter < this.pollRate);\n    }\n\n});\n\n/**\n* The total number of inactive Pointers\n* @name Phaser.Input#totalInactivePointers\n* @property {number} totalInactivePointers - The total number of inactive Pointers.\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"totalInactivePointers\", {\n\n    get: function () {\n        return 10 - this.currentPointers;\n    }\n\n});\n\n/**\n* The total number of active Pointers\n* @name Phaser.Input#totalActivePointers\n* @property {number} totalActivePointers - The total number of active Pointers.\n* @readonly\n*/\nObject.defineProperty(Phaser.Input.prototype, \"totalActivePointers\", {\n\n    get: function () {\n\n        this.currentPointers = 0;\n\n        for (var i = 1; i <= 10; i++)\n        {\n            if (this['pointer' + i] && this['pointer' + i].active)\n            {\n                this.currentPointers++;\n            }\n        }\n\n        return this.currentPointers;\n\n    }\n\n});\n\n/**\n* The world X coordinate of the most recently active pointer.\n* @name Phaser.Input#worldX\n* @property {number} worldX - The world X coordinate of the most recently active pointer.\n*/\nObject.defineProperty(Phaser.Input.prototype, \"worldX\", {\n\n    get: function () {\n        return this.game.camera.view.x + this.x;\n    }\n\n});\n\n/**\n* The world Y coordinate of the most recently active pointer.\n* @name Phaser.Input#worldY\n* @property {number} worldY - The world Y coordinate of the most recently active pointer.\n*/\nObject.defineProperty(Phaser.Input.prototype, \"worldY\", {\n\n    get: function () {\n        return this.game.camera.view.y + this.y;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Key\n* @classdesc If you need more fine-grained control over the handling of specific keys you can create and use Phaser.Key objects.\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n* @param {number} keycode - The key code this Key is responsible for.\n*/\nPhaser.Key = function (game, keycode) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} enabled - An enabled key processes its update and dispatches events. You can toggle this at run-time to disable a key without deleting it.\n    * @default\n    */\n    this.enabled = true;\n\n    /**\n    * @property {object} event - Stores the most recent DOM event.\n    * @readonly\n    */\n    this.event = null;\n\n    /**\n    * @property {boolean} isDown - The \"down\" state of the key.\n    * @default\n    */\n    this.isDown = false;\n\n    /**\n    * @property {boolean} isUp - The \"up\" state of the key.\n    * @default\n    */\n    this.isUp = true;\n\n    /**\n    * @property {boolean} altKey - The down state of the ALT key, if pressed at the same time as this key.\n    * @default\n    */\n    this.altKey = false;\n\n    /**\n    * @property {boolean} ctrlKey - The down state of the CTRL key, if pressed at the same time as this key.\n    * @default\n    */\n    this.ctrlKey = false;\n\n    /**\n    * @property {boolean} shiftKey - The down state of the SHIFT key, if pressed at the same time as this key.\n    * @default\n    */\n    this.shiftKey = false;\n\n    /**\n    * @property {number} timeDown - The timestamp when the key was last pressed down. This is based on Game.time.now.\n    */\n    this.timeDown = 0;\n\n    /**\n    * If the key is down this value holds the duration of that key press and is constantly updated.\n    * If the key is up it holds the duration of the previous down session.\n    * @property {number} duration - The number of milliseconds this key has been held down for.\n    * @default\n    */\n    this.duration = 0;\n\n    /**\n    * @property {number} timeUp - The timestamp when the key was last released. This is based on Game.time.now.\n    * @default\n    */\n    this.timeUp = -2500;\n\n    /**\n    * @property {number} repeats - If a key is held down this holds down the number of times the key has 'repeated'.\n    * @default\n    */\n    this.repeats = 0;\n\n    /**\n    * @property {number} keyCode - The keycode of this key.\n    */\n    this.keyCode = keycode;\n\n    /**\n    * @property {Phaser.Signal} onDown - This Signal is dispatched every time this Key is pressed down. It is only dispatched once (until the key is released again).\n    */\n    this.onDown = new Phaser.Signal();\n\n    /**\n    * @property {function} onHoldCallback - A callback that is called while this Key is held down. Warning: Depending on refresh rate that could be 60+ times per second.\n    */\n    this.onHoldCallback = null;\n\n    /**\n    * @property {object} onHoldContext - The context under which the onHoldCallback will be called.\n    */\n    this.onHoldContext = null;\n\n    /**\n    * @property {Phaser.Signal} onUp - This Signal is dispatched every time this Key is pressed down. It is only dispatched once (until the key is released again).\n    */\n    this.onUp = new Phaser.Signal();\n\n};\n\nPhaser.Key.prototype = {\n\n    update: function () {\n\n        if (!this.enabled) { return; }\n\n        if (this.isDown)\n        {\n            this.duration = this.game.time.now - this.timeDown;\n            this.repeats++;\n\n            if (this.onHoldCallback)\n            {\n                this.onHoldCallback.call(this.onHoldContext, this);\n            }\n        }\n\n    },\n\n    /**\n    * Called automatically by Phaser.Keyboard.\n    * @method Phaser.Key#processKeyDown\n    * @param {KeyboardEvent} event.\n    * @protected\n    */\n    processKeyDown: function (event) {\n\n        if (!this.enabled) { return; }\n\n        this.event = event;\n\n        if (this.isDown)\n        {\n            return;\n        }\n\n        this.altKey = event.altKey;\n        this.ctrlKey = event.ctrlKey;\n        this.shiftKey = event.shiftKey;\n\n        this.isDown = true;\n        this.isUp = false;\n        this.timeDown = this.game.time.now;\n        this.duration = 0;\n        this.repeats = 0;\n\n        this.onDown.dispatch(this);\n\n    },\n\n    /**\n    * Called automatically by Phaser.Keyboard.\n    * @method Phaser.Key#processKeyUp\n    * @param {KeyboardEvent} event.\n    * @protected\n    */\n    processKeyUp: function (event) {\n\n        if (!this.enabled) { return; }\n\n        this.event = event;\n\n        if (this.isUp)\n        {\n            return;\n        }\n\n        this.isDown = false;\n        this.isUp = true;\n        this.timeUp = this.game.time.now;\n        this.duration = this.game.time.now - this.timeDown;\n\n        this.onUp.dispatch(this);\n\n    },\n\n    /**\n    * Resets the state of this Key. This sets isDown to false, isUp to true, resets the time to be the current time and clears any callbacks\n    * associated with the onDown and onUp events and nulls the onHoldCallback if set.\n    *\n    * @method Phaser.Key#reset\n    * @param {boolean} [hard=true] - A soft reset won't reset any events or callbacks that are bound to this Key. A hard reset will.\n    */\n    reset: function (hard) {\n\n        if (typeof hard === 'undefined') { hard = true; }\n\n        this.isDown = false;\n        this.isUp = true;\n        this.timeUp = this.game.time.now;\n        this.duration = this.game.time.now - this.timeDown;\n        this.enabled = true;\n\n        if (hard)\n        {\n            this.onDown.removeAll();\n            this.onUp.removeAll();\n            this.onHoldCallback = null;\n            this.onHoldContext = null;\n        }\n\n    },\n\n    /**\n    * Returns the \"just pressed\" state of the Key. Just pressed is considered true if the key was pressed down within the duration given (default 250ms)\n    * @method Phaser.Key#justPressed\n    * @param {number} [duration=250] - The duration below which the key is considered as being just pressed.\n    * @return {boolean} True if the key is just pressed otherwise false.\n    */\n    justPressed: function (duration) {\n\n        if (typeof duration === \"undefined\") { duration = 2500; }\n\n        return (this.isDown && this.duration < duration);\n\n    },\n\n    /**\n    * Returns the \"just released\" state of the Key. Just released is considered as being true if the key was released within the duration given (default 250ms)\n    * @method Phaser.Key#justReleased\n    * @param {number} [duration=250] - The duration below which the key is considered as being just released.\n    * @return {boolean} True if the key is just released otherwise false.\n    */\n    justReleased: function (duration) {\n\n        if (typeof duration === \"undefined\") { duration = 2500; }\n\n        return (!this.isDown && ((this.game.time.now - this.timeUp) < duration));\n\n    }\n\n};\n\nPhaser.Key.prototype.constructor = Phaser.Key;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Keyboard class handles looking after keyboard input for your game.\n* It will recognise and respond to key presses and dispatch the required events.\n* Please be aware that lots of keyboards are unable to process certain combinations of keys due to hardware\n* limitations known as ghosting. Full details here: http://www.html5gamedevs.com/topic/4876-impossible-to-use-more-than-2-keyboard-input-buttons-at-the-same-time/\n*\n* @class Phaser.Keyboard\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Keyboard = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * You can disable all Keyboard Input by setting disabled to true. While true all new input related events will be ignored.\n    * @property {boolean} disabled - The disabled state of the Keyboard.\n    * @default\n    */\n    this.disabled = false;\n\n    /**\n    * @property {Object} event - The most recent DOM event. This is updated every time a new key is pressed or released.\n    */\n    this.event = null;\n\n    /**\n    * @property {Object} callbackContext - The context under which the callbacks are run.\n    */\n    this.callbackContext = this;\n\n    /**\n    * @property {function} onDownCallback - This callback is invoked every time a key is pressed down.\n    */\n    this.onDownCallback = null;\n\n    /**\n    * @property {function} onUpCallback - This callback is invoked every time a key is released.\n    */\n    this.onUpCallback = null;\n\n    /**\n    * @property {array<Phaser.Key>} _keys - The array the Phaser.Key objects are stored in.\n    * @private\n    */\n    this._keys = [];\n\n    /**\n    * @property {array} _capture - The array the key capture values are stored in.\n    * @private\n    */\n    this._capture = [];\n\n    /**\n    * @property {function} _onKeyDown\n    * @private\n    * @default\n    */\n    this._onKeyDown = null;\n\n    /**\n    * @property {function} _onKeyUp\n    * @private\n    * @default\n    */\n    this._onKeyUp = null;\n\n    /**\n    * @property {number} _i - Internal cache var\n    * @private\n    */\n    this._i = 0;\n\n};\n\nPhaser.Keyboard.prototype = {\n\n    /**\n    * Add callbacks to the Keyboard handler so that each time a key is pressed down or released the callbacks are activated.\n    *\n    * @method Phaser.Keyboard#addCallbacks\n    * @param {Object} context - The context under which the callbacks are run.\n    * @param {function} onDown - This callback is invoked every time a key is pressed down.\n    * @param {function} [onUp=null] - This callback is invoked every time a key is released.\n    */\n    addCallbacks: function (context, onDown, onUp) {\n\n        this.callbackContext = context;\n        this.onDownCallback = onDown;\n\n        if (typeof onUp !== 'undefined')\n        {\n            this.onUpCallback = onUp;\n        }\n\n    },\n\n    /**\n    * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.\n    * The Key object can then be polled, have events attached to it, etc.\n    *\n    * @method Phaser.Keyboard#addKey\n    * @param {number} keycode - The keycode of the key, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR\n    * @return {Phaser.Key} The Key object which you can store locally and reference directly.\n    */\n    addKey: function (keycode) {\n\n        if (!this._keys[keycode])\n        {\n            this._keys[keycode] = new Phaser.Key(this.game, keycode);\n\n            this.addKeyCapture(keycode);\n        }\n\n        return this._keys[keycode];\n\n    },\n\n    /**\n    * Removes a Key object from the Keyboard manager.\n    *\n    * @method Phaser.Keyboard#removeKey\n    * @param {number} keycode - The keycode of the key to remove, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR\n    */\n    removeKey: function (keycode) {\n\n        if (this._keys[keycode])\n        {\n            this._keys[keycode] = null;\n\n            this.removeKeyCapture(keycode);\n        }\n\n    },\n\n    /**\n    * Creates and returns an object containing 4 hotkeys for Up, Down, Left and Right.\n    *\n    * @method Phaser.Keyboard#createCursorKeys\n    * @return {object} An object containing properties: up, down, left and right. Which can be polled like any other Phaser.Key object.\n    */\n    createCursorKeys: function () {\n\n        return {\n            up: this.addKey(Phaser.Keyboard.UP),\n            down: this.addKey(Phaser.Keyboard.DOWN),\n            left: this.addKey(Phaser.Keyboard.LEFT),\n            right: this.addKey(Phaser.Keyboard.RIGHT)\n        };\n\n    },\n\n    /**\n    * Starts the Keyboard event listeners running (keydown and keyup). They are attached to the window.\n    * This is called automatically by Phaser.Input and should not normally be invoked directly.\n    *\n    * @method Phaser.Keyboard#start\n    */\n    start: function () {\n\n        if (this._onKeyDown !== null)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        var _this = this;\n\n        this._onKeyDown = function (event) {\n            return _this.processKeyDown(event);\n        };\n\n        this._onKeyUp = function (event) {\n            return _this.processKeyUp(event);\n        };\n\n        window.addEventListener('keydown', this._onKeyDown, false);\n        window.addEventListener('keyup', this._onKeyUp, false);\n\n    },\n\n    /**\n    * Stops the Keyboard event listeners from running (keydown and keyup). They are removed from the window.\n    *\n    * @method Phaser.Keyboard#stop\n    */\n    stop: function () {\n\n        window.removeEventListener('keydown', this._onKeyDown);\n        window.removeEventListener('keyup', this._onKeyUp);\n\n        this._onKeyDown = null;\n        this._onKeyUp = null;\n\n    },\n\n    /**\n    * Stops the Keyboard event listeners from running (keydown and keyup). They are removed from the window.\n    * Also clears all key captures and currently created Key objects.\n    *\n    * @method Phaser.Keyboard#destroy\n    */\n    destroy: function () {\n\n        this.stop();\n\n        this.clearCaptures();\n\n        this._keys.length = 0;\n        this._i = 0;\n\n    },\n\n    /**\n    * By default when a key is pressed Phaser will not stop the event from propagating up to the browser.\n    * There are some keys this can be annoying for, like the arrow keys or space bar, which make the browser window scroll.\n    * You can use addKeyCapture to consume the keyboard event for specific keys so it doesn't bubble up to the the browser.\n    * Pass in either a single keycode or an array/hash of keycodes.\n    *\n    * @method Phaser.Keyboard#addKeyCapture\n    * @param {Any} keycode - Either a single numeric keycode or an array/hash of keycodes: [65, 67, 68].\n    */\n    addKeyCapture: function (keycode) {\n\n        if (typeof keycode === 'object')\n        {\n            for (var key in keycode)\n            {\n                this._capture[keycode[key]] = true;\n            }\n        }\n        else\n        {\n            this._capture[keycode] = true;\n        }\n    },\n\n    /**\n    * Removes an existing key capture.\n    *\n    * @method Phaser.Keyboard#removeKeyCapture\n    * @param {number} keycode\n    */\n    removeKeyCapture: function (keycode) {\n\n        delete this._capture[keycode];\n\n    },\n\n    /**\n    * Clear all set key captures.\n    *\n    * @method Phaser.Keyboard#clearCaptures\n    */\n    clearCaptures: function () {\n\n        this._capture = {};\n\n    },\n\n    /**\n    * Updates all currently defined keys.\n    *\n    * @method Phaser.Keyboard#update\n    */\n    update: function () {\n\n        this._i = this._keys.length;\n\n        while (this._i--)\n        {\n            if (this._keys[this._i])\n            {\n                this._keys[this._i].update();\n            }\n        }\n\n    },\n\n    /**\n    * Process the keydown event.\n    *\n    * @method Phaser.Keyboard#processKeyDown\n    * @param {KeyboardEvent} event\n    * @protected\n    */\n    processKeyDown: function (event) {\n\n        this.event = event;\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        //   The event is being captured but another hotkey may need it\n        if (this._capture[event.keyCode])\n        {\n            event.preventDefault();\n        }\n\n        if (this.onDownCallback)\n        {\n            this.onDownCallback.call(this.callbackContext, event);\n        }\n\n        if (!this._keys[event.keyCode])\n        {\n            this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);\n        }\n\n        this._keys[event.keyCode].processKeyDown(event);\n\n    },\n\n    /**\n    * Process the keyup event.\n    *\n    * @method Phaser.Keyboard#processKeyUp\n    * @param {KeyboardEvent} event\n    * @protected\n    */\n    processKeyUp: function (event) {\n\n        this.event = event;\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        if (this._capture[event.keyCode])\n        {\n            event.preventDefault();\n        }\n\n        if (this.onUpCallback)\n        {\n            this.onUpCallback.call(this.callbackContext, event);\n        }\n\n        if (!this._keys[event.keyCode])\n        {\n            this._keys[event.keyCode] = new Phaser.Key(this.game, event.keyCode);\n        }\n\n        this._keys[event.keyCode].processKeyUp(event);\n\n    },\n\n    /**\n    * Resets all Keys.\n    *\n    * @method Phaser.Keyboard#reset\n    * @param {boolean} [hard=true] - A soft reset won't reset any events or callbacks that are bound to the Keys. A hard reset will.\n    */\n    reset: function (hard) {\n\n        if (typeof hard === 'undefined') { hard = true; }\n\n        this.event = null;\n\n        var i = this._keys.length;\n\n        while (i--)\n        {\n            if (this._keys[i])\n            {\n                this._keys[i].reset(hard);\n            }\n        }\n\n    },\n\n    /**\n    * Returns the \"just pressed\" state of the key. Just pressed is considered true if the key was pressed down within the duration given (default 250ms)\n    *\n    * @method Phaser.Keyboard#justPressed\n    * @param {number} keycode - The keycode of the key to remove, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR\n    * @param {number} [duration=250] - The duration below which the key is considered as being just pressed.\n    * @return {boolean} True if the key is just pressed otherwise false.\n    */\n    justPressed: function (keycode, duration) {\n\n        if (this._keys[keycode])\n        {\n            return this._keys[keycode].justPressed(duration);\n        }\n        else\n        {\n            return false;\n        }\n\n    },\n\n    /**\n    * Returns the \"just released\" state of the Key. Just released is considered as being true if the key was released within the duration given (default 250ms)\n    *\n    * @method Phaser.Keyboard#justReleased\n    * @param {number} keycode - The keycode of the key to remove, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR\n    * @param {number} [duration=250] - The duration below which the key is considered as being just released.\n    * @return {boolean} True if the key is just released otherwise false.\n    */\n    justReleased: function (keycode, duration) {\n\n        if (this._keys[keycode])\n        {\n            return this._keys[keycode].justReleased(duration);\n        }\n        else\n        {\n            return false;\n        }\n\n    },\n\n    /**\n    * Returns true of the key is currently pressed down. Note that it can only detect key presses on the web browser.\n    *\n    * @method Phaser.Keyboard#isDown\n    * @param {number} keycode - The keycode of the key to remove, i.e. Phaser.Keyboard.UP or Phaser.Keyboard.SPACEBAR\n    * @return {boolean} True if the key is currently down.\n    */\n    isDown: function (keycode) {\n\n        if (this._keys[keycode])\n        {\n            return this._keys[keycode].isDown;\n        }\n\n        return false;\n\n    }\n\n};\n\nPhaser.Keyboard.prototype.constructor = Phaser.Keyboard;\n\nPhaser.Keyboard.A = \"A\".charCodeAt(0);\nPhaser.Keyboard.B = \"B\".charCodeAt(0);\nPhaser.Keyboard.C = \"C\".charCodeAt(0);\nPhaser.Keyboard.D = \"D\".charCodeAt(0);\nPhaser.Keyboard.E = \"E\".charCodeAt(0);\nPhaser.Keyboard.F = \"F\".charCodeAt(0);\nPhaser.Keyboard.G = \"G\".charCodeAt(0);\nPhaser.Keyboard.H = \"H\".charCodeAt(0);\nPhaser.Keyboard.I = \"I\".charCodeAt(0);\nPhaser.Keyboard.J = \"J\".charCodeAt(0);\nPhaser.Keyboard.K = \"K\".charCodeAt(0);\nPhaser.Keyboard.L = \"L\".charCodeAt(0);\nPhaser.Keyboard.M = \"M\".charCodeAt(0);\nPhaser.Keyboard.N = \"N\".charCodeAt(0);\nPhaser.Keyboard.O = \"O\".charCodeAt(0);\nPhaser.Keyboard.P = \"P\".charCodeAt(0);\nPhaser.Keyboard.Q = \"Q\".charCodeAt(0);\nPhaser.Keyboard.R = \"R\".charCodeAt(0);\nPhaser.Keyboard.S = \"S\".charCodeAt(0);\nPhaser.Keyboard.T = \"T\".charCodeAt(0);\nPhaser.Keyboard.U = \"U\".charCodeAt(0);\nPhaser.Keyboard.V = \"V\".charCodeAt(0);\nPhaser.Keyboard.W = \"W\".charCodeAt(0);\nPhaser.Keyboard.X = \"X\".charCodeAt(0);\nPhaser.Keyboard.Y = \"Y\".charCodeAt(0);\nPhaser.Keyboard.Z = \"Z\".charCodeAt(0);\nPhaser.Keyboard.ZERO = \"0\".charCodeAt(0);\nPhaser.Keyboard.ONE = \"1\".charCodeAt(0);\nPhaser.Keyboard.TWO = \"2\".charCodeAt(0);\nPhaser.Keyboard.THREE = \"3\".charCodeAt(0);\nPhaser.Keyboard.FOUR = \"4\".charCodeAt(0);\nPhaser.Keyboard.FIVE = \"5\".charCodeAt(0);\nPhaser.Keyboard.SIX = \"6\".charCodeAt(0);\nPhaser.Keyboard.SEVEN = \"7\".charCodeAt(0);\nPhaser.Keyboard.EIGHT = \"8\".charCodeAt(0);\nPhaser.Keyboard.NINE = \"9\".charCodeAt(0);\nPhaser.Keyboard.NUMPAD_0 = 96;\nPhaser.Keyboard.NUMPAD_1 = 97;\nPhaser.Keyboard.NUMPAD_2 = 98;\nPhaser.Keyboard.NUMPAD_3 = 99;\nPhaser.Keyboard.NUMPAD_4 = 100;\nPhaser.Keyboard.NUMPAD_5 = 101;\nPhaser.Keyboard.NUMPAD_6 = 102;\nPhaser.Keyboard.NUMPAD_7 = 103;\nPhaser.Keyboard.NUMPAD_8 = 104;\nPhaser.Keyboard.NUMPAD_9 = 105;\nPhaser.Keyboard.NUMPAD_MULTIPLY = 106;\nPhaser.Keyboard.NUMPAD_ADD = 107;\nPhaser.Keyboard.NUMPAD_ENTER = 108;\nPhaser.Keyboard.NUMPAD_SUBTRACT = 109;\nPhaser.Keyboard.NUMPAD_DECIMAL = 110;\nPhaser.Keyboard.NUMPAD_DIVIDE = 111;\nPhaser.Keyboard.F1 = 112;\nPhaser.Keyboard.F2 = 113;\nPhaser.Keyboard.F3 = 114;\nPhaser.Keyboard.F4 = 115;\nPhaser.Keyboard.F5 = 116;\nPhaser.Keyboard.F6 = 117;\nPhaser.Keyboard.F7 = 118;\nPhaser.Keyboard.F8 = 119;\nPhaser.Keyboard.F9 = 120;\nPhaser.Keyboard.F10 = 121;\nPhaser.Keyboard.F11 = 122;\nPhaser.Keyboard.F12 = 123;\nPhaser.Keyboard.F13 = 124;\nPhaser.Keyboard.F14 = 125;\nPhaser.Keyboard.F15 = 126;\nPhaser.Keyboard.COLON = 186;\nPhaser.Keyboard.EQUALS = 187;\nPhaser.Keyboard.UNDERSCORE = 189;\nPhaser.Keyboard.QUESTION_MARK = 191;\nPhaser.Keyboard.TILDE = 192;\nPhaser.Keyboard.OPEN_BRACKET = 219;\nPhaser.Keyboard.BACKWARD_SLASH = 220;\nPhaser.Keyboard.CLOSED_BRACKET = 221;\nPhaser.Keyboard.QUOTES = 222;\nPhaser.Keyboard.BACKSPACE = 8;\nPhaser.Keyboard.TAB = 9;\nPhaser.Keyboard.CLEAR = 12;\nPhaser.Keyboard.ENTER = 13;\nPhaser.Keyboard.SHIFT = 16;\nPhaser.Keyboard.CONTROL = 17;\nPhaser.Keyboard.ALT = 18;\nPhaser.Keyboard.CAPS_LOCK = 20;\nPhaser.Keyboard.ESC = 27;\nPhaser.Keyboard.SPACEBAR = 32;\nPhaser.Keyboard.PAGE_UP = 33;\nPhaser.Keyboard.PAGE_DOWN = 34;\nPhaser.Keyboard.END = 35;\nPhaser.Keyboard.HOME = 36;\nPhaser.Keyboard.LEFT = 37;\nPhaser.Keyboard.UP = 38;\nPhaser.Keyboard.RIGHT = 39;\nPhaser.Keyboard.DOWN = 40;\nPhaser.Keyboard.INSERT = 45;\nPhaser.Keyboard.DELETE = 46;\nPhaser.Keyboard.HELP = 47;\nPhaser.Keyboard.NUM_LOCK = 144;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Mouse is responsible for handling all aspects of mouse interaction with the browser. It captures and processes mouse events.\n*\n* @class Phaser.Mouse\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Mouse = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Object} callbackContext - The context under which callbacks are called.\n    */\n    this.callbackContext = this.game;\n\n    /**\n    * @property {function} mouseDownCallback - A callback that can be fired when the mouse is pressed down.\n    */\n    this.mouseDownCallback = null;\n\n    /**\n    * @property {function} mouseMoveCallback - A callback that can be fired when the mouse is moved while pressed down.\n    */\n    this.mouseMoveCallback = null;\n\n    /**\n    * @property {function} mouseUpCallback - A callback that can be fired when the mouse is released from a pressed down state.\n    */\n    this.mouseUpCallback = null;\n\n    /**\n    * @property {boolean} capture - If true the DOM mouse events will have event.preventDefault applied to them, if false they will propogate fully.\n    */\n    this.capture = false;\n\n    /**\n    * @property {number} button- The type of click, either: Phaser.Mouse.NO_BUTTON, Phaser.Mouse.LEFT_BUTTON, Phaser.Mouse.MIDDLE_BUTTON or Phaser.Mouse.RIGHT_BUTTON.\n    * @default\n    */\n    this.button = -1;\n\n    /**\n    * @property {boolean} disabled - You can disable all Input by setting disabled = true. While set all new input related events will be ignored.\n    * @default\n    */\n    this.disabled = false;\n\n    /**\n    * @property {boolean} locked - If the mouse has been Pointer Locked successfully this will be set to true.\n    * @default\n    */\n    this.locked = false;\n\n    /**\n    * @property {Phaser.Signal} pointerLock - This event is dispatched when the browser enters or leaves pointer lock state.\n    * @default\n    */\n    this.pointerLock = new Phaser.Signal();\n\n    /**\n    * @property {MouseEvent} event - The browser mouse DOM event. Will be set to null if no mouse event has ever been received.\n    * @default\n    */\n    this.event = null;\n\n    /**\n    * @property {function} _onMouseDown - Internal event handler reference.\n    * @private\n    */\n    this._onMouseDown = null;\n\n    /**\n    * @property {function} _onMouseMove - Internal event handler reference.\n    * @private\n    */\n    this._onMouseMove = null;\n\n    /**\n    * @property {function} _onMouseUp - Internal event handler reference.\n    * @private\n    */\n    this._onMouseUp = null;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.NO_BUTTON = -1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.LEFT_BUTTON = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.MIDDLE_BUTTON = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Mouse.RIGHT_BUTTON = 2;\n\nPhaser.Mouse.prototype = {\n\n    /**\n    * Starts the event listeners running.\n    * @method Phaser.Mouse#start\n    */\n    start: function () {\n\n        if (this.game.device.android && this.game.device.chrome === false)\n        {\n            //  Android stock browser fires mouse events even if you preventDefault on the touchStart, so ...\n            return;\n        }\n\n        if (this._onMouseDown !== null)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        var _this = this;\n\n        this._onMouseDown = function (event) {\n            return _this.onMouseDown(event);\n        };\n\n        this._onMouseMove = function (event) {\n            return _this.onMouseMove(event);\n        };\n\n        this._onMouseUp = function (event) {\n            return _this.onMouseUp(event);\n        };\n\n        this.game.canvas.addEventListener('mousedown', this._onMouseDown, true);\n        this.game.canvas.addEventListener('mousemove', this._onMouseMove, true);\n        this.game.canvas.addEventListener('mouseup', this._onMouseUp, true);\n\n    },\n\n    /**\n    * The internal method that handles the mouse down event from the browser.\n    * @method Phaser.Mouse#onMouseDown\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseDown: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        this.button = event.button;\n\n        if (this.mouseDownCallback)\n        {\n            this.mouseDownCallback.call(this.callbackContext, event);\n        }\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        event['identifier'] = 0;\n\n        this.game.input.mousePointer.start(event);\n\n    },\n\n    /**\n    * The internal method that handles the mouse move event from the browser.\n    * @method Phaser.Mouse#onMouseMove\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseMove: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        if (this.mouseMoveCallback)\n        {\n            this.mouseMoveCallback.call(this.callbackContext, event);\n        }\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        event['identifier'] = 0;\n\n        this.game.input.mousePointer.move(event);\n\n    },\n\n    /**\n    * The internal method that handles the mouse up event from the browser.\n    * @method Phaser.Mouse#onMouseUp\n    * @param {MouseEvent} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    onMouseUp: function (event) {\n\n        this.event = event;\n\n        if (this.capture)\n        {\n            event.preventDefault();\n        }\n\n        this.button = Phaser.Mouse.NO_BUTTON;\n\n        if (this.mouseUpCallback)\n        {\n            this.mouseUpCallback.call(this.callbackContext, event);\n        }\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        event['identifier'] = 0;\n\n        this.game.input.mousePointer.stop(event);\n\n    },\n\n    /**\n    * If the browser supports it you can request that the pointer be locked to the browser window.\n    * This is classically known as 'FPS controls', where the pointer can't leave the browser until the user presses an exit key.\n    * If the browser successfully enters a locked state the event Phaser.Mouse.pointerLock will be dispatched and the first parameter will be 'true'.\n    * @method Phaser.Mouse#requestPointerLock\n    */\n    requestPointerLock: function () {\n\n        if (this.game.device.pointerLock)\n        {\n            var element = this.game.canvas;\n\n            element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;\n\n            element.requestPointerLock();\n\n            var _this = this;\n\n            this._pointerLockChange = function (event) {\n                return _this.pointerLockChange(event);\n            };\n\n            document.addEventListener('pointerlockchange', this._pointerLockChange, true);\n            document.addEventListener('mozpointerlockchange', this._pointerLockChange, true);\n            document.addEventListener('webkitpointerlockchange', this._pointerLockChange, true);\n        }\n\n    },\n\n    /**\n    * Internal pointerLockChange handler.\n    * @method Phaser.Mouse#pointerLockChange\n    * @param {pointerlockchange} event - The native event from the browser. This gets stored in Mouse.event.\n    */\n    pointerLockChange: function (event) {\n\n        var element = this.game.canvas;\n\n        if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element)\n        {\n            //  Pointer was successfully locked\n            this.locked = true;\n            this.pointerLock.dispatch(true, event);\n        }\n        else\n        {\n            //  Pointer was unlocked\n            this.locked = false;\n            this.pointerLock.dispatch(false, event);\n        }\n\n    },\n\n    /**\n    * Internal release pointer lock handler.\n    * @method Phaser.Mouse#releasePointerLock\n    */\n    releasePointerLock: function () {\n\n        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;\n\n        document.exitPointerLock();\n\n        document.removeEventListener('pointerlockchange', this._pointerLockChange, true);\n        document.removeEventListener('mozpointerlockchange', this._pointerLockChange, true);\n        document.removeEventListener('webkitpointerlockchange', this._pointerLockChange, true);\n\n    },\n\n    /**\n    * Stop the event listeners.\n    * @method Phaser.Mouse#stop\n    */\n    stop: function () {\n\n        this.game.canvas.removeEventListener('mousedown', this._onMouseDown, true);\n        this.game.canvas.removeEventListener('mousemove', this._onMouseMove, true);\n        this.game.canvas.removeEventListener('mouseup', this._onMouseUp, true);\n\n    }\n\n};\n\nPhaser.Mouse.prototype.constructor = Phaser.Mouse;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser - MSPointer constructor.\n*\n* @class Phaser.MSPointer\n* @classdesc The MSPointer class handles touch interactions with the game and the resulting Pointer objects.\n* It will work only in Internet Explorer 10 and Windows Store or Windows Phone 8 apps using JavaScript.\n* http://msdn.microsoft.com/en-us/library/ie/hh673557(v=vs.85).aspx\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.MSPointer = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Object} callbackContext - The context under which callbacks are called (defaults to game).\n    */\n    this.callbackContext = this.game;\n\n    /**\n    * You can disable all Input by setting disabled = true. While set all new input related events will be ignored.\n    * @property {boolean} disabled\n    */\n    this.disabled = false;\n\n    /**\n    * @property {function} _onMSPointerDown - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerDown = null;\n\n    /**\n    * @property {function} _onMSPointerMove - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerMove = null;\n\n    /**\n    * @property {function} _onMSPointerUp - Internal function to handle MSPointer events.\n    * @private\n    */\n    this._onMSPointerUp = null;\n\n};\n\nPhaser.MSPointer.prototype = {\n\n    /**\n    * Starts the event listeners running.\n    * @method Phaser.MSPointer#start\n    */\n    start: function () {\n\n        if (this._onMSPointerDown !== null)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        var _this = this;\n\n        if (this.game.device.mspointer === true)\n        {\n            this._onMSPointerDown = function (event) {\n                return _this.onPointerDown(event);\n            };\n\n            this._onMSPointerMove = function (event) {\n                return _this.onPointerMove(event);\n            };\n\n            this._onMSPointerUp = function (event) {\n                return _this.onPointerUp(event);\n            };\n\n            this.game.renderer.view.addEventListener('MSPointerDown', this._onMSPointerDown, false);\n            this.game.renderer.view.addEventListener('MSPointerMove', this._onMSPointerMove, false);\n            this.game.renderer.view.addEventListener('MSPointerUp', this._onMSPointerUp, false);\n\n            //  IE11+ uses non-prefix events\n            this.game.renderer.view.addEventListener('pointerDown', this._onMSPointerDown, false);\n            this.game.renderer.view.addEventListener('pointerMove', this._onMSPointerMove, false);\n            this.game.renderer.view.addEventListener('pointerUp', this._onMSPointerUp, false);\n\n            this.game.renderer.view.style['-ms-content-zooming'] = 'none';\n            this.game.renderer.view.style['-ms-touch-action'] = 'none';\n\n        }\n\n    },\n\n    /**\n    * The function that handles the PointerDown event.\n    * @method Phaser.MSPointer#onPointerDown\n    * @param {PointerEvent} event\n    */\n    onPointerDown: function (event) {\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        event.preventDefault();\n        event.identifier = event.pointerId;\n\n        this.game.input.startPointer(event);\n\n    },\n\n    /**\n    * The function that handles the PointerMove event.\n    * @method Phaser.MSPointer#onPointerMove\n    * @param {PointerEvent } event\n    */\n    onPointerMove: function (event) {\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        event.preventDefault();\n        event.identifier = event.pointerId;\n\n        this.game.input.updatePointer(event);\n\n    },\n\n    /**\n    * The function that handles the PointerUp event.\n    * @method Phaser.MSPointer#onPointerUp\n    * @param {PointerEvent} event\n    */\n    onPointerUp: function (event) {\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        event.preventDefault();\n        event.identifier = event.pointerId;\n\n        this.game.input.stopPointer(event);\n\n    },\n\n    /**\n    * Stop the event listeners.\n    * @method Phaser.MSPointer#stop\n    */\n    stop: function () {\n\n        this.game.canvas.removeEventListener('MSPointerDown', this._onMSPointerDown);\n        this.game.canvas.removeEventListener('MSPointerMove', this._onMSPointerMove);\n        this.game.canvas.removeEventListener('MSPointerUp', this._onMSPointerUp);\n\n        this.game.canvas.removeEventListener('pointerDown', this._onMSPointerDown);\n        this.game.canvas.removeEventListener('pointerMove', this._onMSPointerMove);\n        this.game.canvas.removeEventListener('pointerUp', this._onMSPointerUp);\n\n    }\n\n};\n\nPhaser.MSPointer.prototype.constructor = Phaser.MSPointer;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser - Pointer constructor.\n*\n* @class Phaser.Pointer\n* @classdesc A Pointer object is used by the Mouse, Touch and MSPoint managers and represents a single finger on the touch screen.\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} id - The ID of the Pointer object within the game. Each game can have up to 10 active pointers.\n*/\nPhaser.Pointer = function (game, id) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {number} id - The ID of the Pointer object within the game. Each game can have up to 10 active pointers.\n    */\n    this.id = id;\n\n    /**\n    * @property {boolean} _holdSent - Local private variable to store the status of dispatching a hold event.\n    * @private\n    * @default\n    */\n    this._holdSent = false;\n\n    /**\n    * @property {array} _history - Local private variable storing the short-term history of pointer movements.\n    * @private\n    */\n    this._history = [];\n\n    /**\n    * @property {number} _lastDrop - Local private variable storing the time at which the next history drop should occur.\n    * @private\n    * @default\n    */\n    this._nextDrop = 0;\n\n    /**\n    * @property {boolean} _stateReset - Monitor events outside of a state reset loop.\n    * @private\n    * @default\n    */\n    this._stateReset = false;\n\n    /**\n    * @property {boolean} withinGame - true if the Pointer is within the game area, otherwise false.\n    */\n    this.withinGame = false;\n\n    /**\n    * @property {number} clientX - The horizontal coordinate of point relative to the viewport in pixels, excluding any scroll offset.\n    * @default\n    */\n    this.clientX = -1;\n\n    /**\n    * @property {number} clientY - The vertical coordinate of point relative to the viewport in pixels, excluding any scroll offset.\n    * @default\n    */\n    this.clientY = -1;\n\n    /**\n    * @property {number} pageX - The horizontal coordinate of point relative to the viewport in pixels, including any scroll offset.\n    * @default\n    */\n    this.pageX = -1;\n\n    /**\n    * @property {number} pageY - The vertical coordinate of point relative to the viewport in pixels, including any scroll offset.\n    * @default\n    */\n    this.pageY = -1;\n\n    /**\n    * @property {number} screenX - The horizontal coordinate of point relative to the screen in pixels.\n    * @default\n    */\n    this.screenX = -1;\n\n    /**\n    * @property {number} screenY - The vertical coordinate of point relative to the screen in pixels.\n    * @default\n    */\n    this.screenY = -1;\n\n    /**\n    * @property {number} x - The horizontal coordinate of point relative to the game element. This value is automatically scaled based on game size.\n    * @default\n    */\n    this.x = -1;\n\n    /**\n    * @property {number} y - The vertical coordinate of point relative to the game element. This value is automatically scaled based on game size.\n    * @default\n    */\n    this.y = -1;\n\n    /**\n    * @property {boolean} isMouse - If the Pointer is a mouse this is true, otherwise false.\n    * @default\n    */\n    this.isMouse = false;\n\n    /**\n    * @property {boolean} isDown - If the Pointer is touching the touchscreen, or the mouse button is held down, isDown is set to true.\n    * @default\n    */\n    this.isDown = false;\n\n    /**\n    * @property {boolean} isUp - If the Pointer is not touching the touchscreen, or the mouse button is up, isUp is set to true.\n    * @default\n    */\n    this.isUp = true;\n\n    /**\n    * @property {number} timeDown - A timestamp representing when the Pointer first touched the touchscreen.\n    * @default\n    */\n    this.timeDown = 0;\n\n    /**\n    * @property {number} timeUp - A timestamp representing when the Pointer left the touchscreen.\n    * @default\n    */\n    this.timeUp = 0;\n\n    /**\n    * @property {number} previousTapTime - A timestamp representing when the Pointer was last tapped or clicked.\n    * @default\n    */\n    this.previousTapTime = 0;\n\n    /**\n    * @property {number} totalTouches - The total number of times this Pointer has been touched to the touchscreen.\n    * @default\n    */\n    this.totalTouches = 0;\n\n    /**\n    * @property {number} msSinceLastClick - The number of miliseconds since the last click.\n    * @default\n    */\n    this.msSinceLastClick = Number.MAX_VALUE;\n\n    /**\n    * @property {any} targetObject - The Game Object this Pointer is currently over / touching / dragging.\n    * @default\n    */\n    this.targetObject = null;\n\n    /**\n    * @property {boolean} active - An active pointer is one that is currently pressed down on the display. A Mouse is always active.\n    * @default\n    */\n    this.active = false;\n\n    /**\n    * @property {Phaser.Point} position - A Phaser.Point object containing the current x/y values of the pointer on the display.\n    */\n    this.position = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} positionDown - A Phaser.Point object containing the x/y values of the pointer when it was last in a down state on the display.\n    */\n    this.positionDown = new Phaser.Point();\n    \n    /**\n    * @property {Phaser.Point} positionUp - A Phaser.Point object containing the x/y values of the pointer when it was last released.\n    */\n    this.positionUp = new Phaser.Point();\n\n    /**\n    * A Phaser.Circle that is centered on the x/y coordinates of this pointer, useful for hit detection.\n    * The Circle size is 44px (Apples recommended \"finger tip\" size).\n    * @property {Phaser.Circle} circle\n    */\n    this.circle = new Phaser.Circle(0, 0, 44);\n\n    if (id === 0)\n    {\n        this.isMouse = true;\n    }\n\n};\n\nPhaser.Pointer.prototype = {\n\n    /**\n    * Called when the Pointer is pressed onto the touchscreen.\n    * @method Phaser.Pointer#start\n    * @param {Any} event\n    */\n    start: function (event) {\n\n        this.identifier = event.identifier;\n        this.target = event.target;\n\n        if (typeof event.button !== 'undefined')\n        {\n            this.button = event.button;\n        }\n\n        this._history = [];\n        this.active = true;\n        this.withinGame = true;\n        this.isDown = true;\n        this.isUp = false;\n\n        //  Work out how long it has been since the last click\n        this.msSinceLastClick = this.game.time.now - this.timeDown;\n        this.timeDown = this.game.time.now;\n        this._holdSent = false;\n\n        //  This sets the x/y and other local values\n        this.move(event, true);\n\n        // x and y are the old values here?\n        this.positionDown.setTo(this.x, this.y);\n\n        if (this.game.input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0))\n        {\n            this.game.input.x = this.x;\n            this.game.input.y = this.y;\n            this.game.input.position.setTo(this.x, this.y);\n            this.game.input.onDown.dispatch(this, event);\n            this.game.input.resetSpeed(this.x, this.y);\n        }\n\n        this._stateReset = false;\n        this.totalTouches++;\n\n        if (!this.isMouse)\n        {\n            this.game.input.currentPointers++;\n        }\n\n        if (this.targetObject !== null)\n        {\n            this.targetObject._touchedHandler(this);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Called by the Input Manager.\n    * @method Phaser.Pointer#update\n    */\n    update: function () {\n\n        if (this.active)\n        {\n            if (this._holdSent === false && this.duration >= this.game.input.holdRate)\n            {\n                if (this.game.input.multiInputOverride == Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == Phaser.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride == Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0))\n                {\n                    this.game.input.onHold.dispatch(this);\n                }\n\n                this._holdSent = true;\n            }\n\n            //  Update the droppings history\n            if (this.game.input.recordPointerHistory && this.game.time.now >= this._nextDrop)\n            {\n                this._nextDrop = this.game.time.now + this.game.input.recordRate;\n\n                this._history.push({\n                    x: this.position.x,\n                    y: this.position.y\n                });\n\n                if (this._history.length > this.game.input.recordLimit)\n                {\n                    this._history.shift();\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Called when the Pointer is moved.\n    * @method Phaser.Pointer#move\n    * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.\n    * @param {boolean} [fromClick=false] - Was this called from the click event?\n    */\n    move: function (event, fromClick) {\n\n        if (this.game.input.pollLocked)\n        {\n            return;\n        }\n\n        if (typeof fromClick === 'undefined') { fromClick = false; }\n\n        if (typeof event.button !== 'undefined')\n        {\n            this.button = event.button;\n        }\n\n        this.clientX = event.clientX;\n        this.clientY = event.clientY;\n\n        this.pageX = event.pageX;\n        this.pageY = event.pageY;\n\n        this.screenX = event.screenX;\n        this.screenY = event.screenY;\n\n        this.x = (this.pageX - this.game.stage.offset.x) * this.game.input.scale.x;\n        this.y = (this.pageY - this.game.stage.offset.y) * this.game.input.scale.y;\n\n        this.position.setTo(this.x, this.y);\n        this.circle.x = this.x;\n        this.circle.y = this.y;\n\n        if (this.game.input.multiInputOverride == Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == Phaser.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride == Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0))\n        {\n            this.game.input.activePointer = this;\n            this.game.input.x = this.x;\n            this.game.input.y = this.y;\n            this.game.input.position.setTo(this.game.input.x, this.game.input.y);\n            this.game.input.circle.x = this.game.input.x;\n            this.game.input.circle.y = this.game.input.y;\n        }\n\n        //  If the game is paused we don't process any target objects or callbacks\n        if (this.game.paused)\n        {\n            return this;\n        }\n\n        if (this.game.input.moveCallback)\n        {\n            this.game.input.moveCallback.call(this.game.input.moveCallbackContext, this, this.x, this.y);\n        }\n\n        //  Easy out if we're dragging something and it still exists\n        if (this.targetObject !== null && this.targetObject.isDragged === true)\n        {\n            if (this.targetObject.update(this) === false)\n            {\n                this.targetObject = null;\n            }\n\n            return this;\n        }\n\n        //  Work out which object is on the top\n        this._highestRenderOrderID = Number.MAX_SAFE_INTEGER;\n        this._highestRenderObject = null;\n        this._highestInputPriorityID = -1;\n\n        //  Run through the list\n        if (this.game.input.interactiveItems.total > 0)\n        {\n            var currentNode = this.game.input.interactiveItems.first;\n\n            do\n            {\n                //  If the object is using pixelPerfect checks, or has a higher InputManager.PriorityID OR if the priority ID is the same as the current highest AND it has a higher renderOrderID, then set it to the top\n                if (currentNode && currentNode.validForInput(this._highestInputPriorityID, this._highestRenderOrderID))\n                {\n                    if ((!fromClick && currentNode.checkPointerOver(this)) || (fromClick && currentNode.checkPointerDown(this)))\n                    {\n                        this._highestRenderOrderID = currentNode.sprite._cache[3]; // renderOrderID\n                        this._highestInputPriorityID = currentNode.priorityID;\n                        this._highestRenderObject = currentNode;\n                    }\n                }\n                currentNode = this.game.input.interactiveItems.next;\n            }\n            while (currentNode !== null);\n        }\n\n        if (this._highestRenderObject === null)\n        {\n            //  The pointer isn't currently over anything, check if we've got a lingering previous target\n            if (this.targetObject)\n            {\n                // console.log(\"The pointer isn't currently over anything, check if we've got a lingering previous target\");\n                this.targetObject._pointerOutHandler(this);\n                this.targetObject = null;\n            }\n        }\n        else\n        {\n            if (this.targetObject === null)\n            {\n                //  And now set the new one\n                // console.log('And now set the new one');\n                this.targetObject = this._highestRenderObject;\n                this._highestRenderObject._pointerOverHandler(this);\n            }\n            else\n            {\n                //  We've got a target from the last update\n                // console.log(\"We've got a target from the last update\");\n                if (this.targetObject === this._highestRenderObject)\n                {\n                    //  Same target as before, so update it\n                    // console.log(\"Same target as before, so update it\");\n                    if (this._highestRenderObject.update(this) === false)\n                    {\n                        this.targetObject = null;\n                    }\n                }\n                else\n                {\n                    //  The target has changed, so tell the old one we've left it\n                    // console.log(\"The target has changed, so tell the old one we've left it\");\n                    this.targetObject._pointerOutHandler(this);\n\n                    //  And now set the new one\n                    this.targetObject = this._highestRenderObject;\n                    this.targetObject._pointerOverHandler(this);\n                }\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Called when the Pointer leaves the target area.\n    * @method Phaser.Pointer#leave\n    * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.\n    */\n    leave: function (event) {\n\n        this.withinGame = false;\n        this.move(event, false);\n\n    },\n\n    /**\n    * Called when the Pointer leaves the touchscreen.\n    * @method Phaser.Pointer#stop\n    * @param {MouseEvent|PointerEvent|TouchEvent} event - The event passed up from the input handler.\n    */\n    stop: function (event) {\n\n        if (this._stateReset)\n        {\n            event.preventDefault();\n            return;\n        }\n\n        this.timeUp = this.game.time.now;\n\n        if (this.game.input.multiInputOverride == Phaser.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == Phaser.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride == Phaser.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers === 0))\n        {\n            this.game.input.onUp.dispatch(this, event);\n\n            //  Was it a tap?\n            if (this.duration >= 0 && this.duration <= this.game.input.tapRate)\n            {\n                //  Was it a double-tap?\n                if (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate)\n                {\n                    //  Yes, let's dispatch the signal then with the 2nd parameter set to true\n                    this.game.input.onTap.dispatch(this, true);\n                }\n                else\n                {\n                    //  Wasn't a double-tap, so dispatch a single tap signal\n                    this.game.input.onTap.dispatch(this, false);\n                }\n\n                this.previousTapTime = this.timeUp;\n            }\n        }\n\n        //  Mouse is always active\n        if (this.id > 0)\n        {\n            this.active = false;\n        }\n\n        this.withinGame = false;\n        this.isDown = false;\n        this.isUp = true;\n        \n        this.positionUp.setTo(this.x, this.y);\n        \n        if (this.isMouse === false)\n        {\n            this.game.input.currentPointers--;\n        }\n\n        this.game.input.interactiveItems.callAll('_releasedHandler', this);\n\n        this.targetObject = null;\n\n        return this;\n\n    },\n\n    /**\n    * The Pointer is considered justPressed if the time it was pressed onto the touchscreen or clicked is less than justPressedRate.\n    * Note that calling justPressed doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.\n    * If you wish to check if the Pointer was pressed down just once then see the Sprite.events.onInputDown event.\n    * @method Phaser.Pointer#justPressed\n    * @param {number} [duration] - The time to check against. If none given it will use InputManager.justPressedRate.\n    * @return {boolean} true if the Pointer was pressed down within the duration given.\n    */\n    justPressed: function (duration) {\n\n        duration = duration || this.game.input.justPressedRate;\n\n        return (this.isDown === true && (this.timeDown + duration) > this.game.time.now);\n\n    },\n\n    /**\n    * The Pointer is considered justReleased if the time it left the touchscreen is less than justReleasedRate.\n    * Note that calling justReleased doesn't reset the pressed status of the Pointer, it will return `true` for as long as the duration is valid.\n    * If you wish to check if the Pointer was released just once then see the Sprite.events.onInputUp event.\n    * @method Phaser.Pointer#justReleased\n    * @param {number} [duration] - The time to check against. If none given it will use InputManager.justReleasedRate.\n    * @return {boolean} true if the Pointer was released within the duration given.\n    */\n    justReleased: function (duration) {\n\n        duration = duration || this.game.input.justReleasedRate;\n\n        return (this.isUp === true && (this.timeUp + duration) > this.game.time.now);\n\n    },\n\n    /**\n    * Resets the Pointer properties. Called by InputManager.reset when you perform a State change.\n    * @method Phaser.Pointer#reset\n    */\n    reset: function () {\n\n        if (this.isMouse === false)\n        {\n            this.active = false;\n        }\n\n        this.identifier = null;\n        this.isDown = false;\n        this.isUp = true;\n        this.totalTouches = 0;\n        this._holdSent = false;\n        this._history.length = 0;\n        this._stateReset = true;\n\n        if (this.targetObject)\n        {\n            this.targetObject._releasedHandler(this);\n        }\n\n        this.targetObject = null;\n\n    }\n\n};\n\nPhaser.Pointer.prototype.constructor = Phaser.Pointer;\n\n/**\n* How long the Pointer has been depressed on the touchscreen. If not currently down it returns -1.\n* @name Phaser.Pointer#duration\n* @property {number} duration - How long the Pointer has been depressed on the touchscreen. If not currently down it returns -1.\n* @readonly\n*/\nObject.defineProperty(Phaser.Pointer.prototype, \"duration\", {\n\n    get: function () {\n\n        if (this.isUp)\n        {\n            return -1;\n        }\n\n        return this.game.time.now - this.timeDown;\n\n    }\n\n});\n\n/**\n* Gets the X value of this Pointer in world coordinates based on the world camera.\n* @name Phaser.Pointer#worldX\n* @property {number} duration - The X value of this Pointer in world coordinates based on the world camera.\n* @readonly\n*/\nObject.defineProperty(Phaser.Pointer.prototype, \"worldX\", {\n\n    get: function () {\n\n        return this.game.world.camera.x + this.x;\n\n    }\n\n});\n\n/**\n* Gets the Y value of this Pointer in world coordinates based on the world camera.\n* @name Phaser.Pointer#worldY\n* @property {number} duration - The Y value of this Pointer in world coordinates based on the world camera.\n* @readonly\n*/\nObject.defineProperty(Phaser.Pointer.prototype, \"worldY\", {\n\n    get: function () {\n\n        return this.game.world.camera.y + this.y;\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Touch handles touch events with your game. Note: Android 2.x only supports 1 touch event at once, no multi-touch.\n*\n* @class Phaser.Touch\n* @classdesc The Touch class handles touch interactions with the game and the resulting Pointer objects.\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Touch = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} disabled - You can disable all Touch events by setting disabled = true. While set all new touch events will be ignored.\n    * @return {boolean}\n    */\n    this.disabled = false;\n\n    /**\n    * @property {Object} callbackContext - The context under which callbacks are called.\n    */\n    this.callbackContext = this.game;\n\n    /**\n    * @property {function} touchStartCallback - A callback that can be fired on a touchStart event.\n    */\n    this.touchStartCallback = null;\n\n    /**\n    * @property {function} touchMoveCallback - A callback that can be fired on a touchMove event.\n    */\n    this.touchMoveCallback = null;\n\n    /**\n    * @property {function} touchEndCallback - A callback that can be fired on a touchEnd event.\n    */\n    this.touchEndCallback = null;\n\n    /**\n    * @property {function} touchEnterCallback - A callback that can be fired on a touchEnter event.\n    */\n    this.touchEnterCallback = null;\n\n    /**\n    * @property {function} touchLeaveCallback - A callback that can be fired on a touchLeave event.\n    */\n    this.touchLeaveCallback = null;\n\n    /**\n    * @property {function} touchCancelCallback - A callback that can be fired on a touchCancel event.\n    */\n    this.touchCancelCallback = null;\n\n    /**\n    * @property {boolean} preventDefault - If true the TouchEvent will have prevent.default called on it.\n    * @default\n    */\n    this.preventDefault = true;\n\n    /**\n    * @property {TouchEvent} event - The browser touch DOM event. Will be set to null if no touch event has ever been received.\n    * @default\n    */\n    this.event = null;\n\n    /**\n    * @property {function} _onTouchStart - Internal event handler reference.\n    * @private\n    */\n    this._onTouchStart = null;\n\n    /**\n    * @property {function} _onTouchMove - Internal event handler reference.\n    * @private\n    */\n    this._onTouchMove = null;\n\n    /**\n    * @property {function} _onTouchEnd - Internal event handler reference.\n    * @private\n    */\n    this._onTouchEnd = null;\n\n    /**\n    * @property {function} _onTouchEnter - Internal event handler reference.\n    * @private\n    */\n    this._onTouchEnter = null;\n\n    /**\n    * @property {function} _onTouchLeave - Internal event handler reference.\n    * @private\n    */\n    this._onTouchLeave = null;\n\n    /**\n    * @property {function} _onTouchCancel - Internal event handler reference.\n    * @private\n    */\n    this._onTouchCancel = null;\n\n    /**\n    * @property {function} _onTouchMove - Internal event handler reference.\n    * @private\n    */\n    this._onTouchMove = null;\n\n};\n\nPhaser.Touch.prototype = {\n\n    /**\n    * Starts the event listeners running.\n    * @method Phaser.Touch#start\n    */\n    start: function () {\n\n        if (this._onTouchStart !== null)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        var _this = this;\n\n        if (this.game.device.touch)\n        {\n            this._onTouchStart = function (event) {\n                return _this.onTouchStart(event);\n            };\n\n            this._onTouchMove = function (event) {\n                return _this.onTouchMove(event);\n            };\n\n            this._onTouchEnd = function (event) {\n                return _this.onTouchEnd(event);\n            };\n\n            this._onTouchEnter = function (event) {\n                return _this.onTouchEnter(event);\n            };\n\n            this._onTouchLeave = function (event) {\n                return _this.onTouchLeave(event);\n            };\n\n            this._onTouchCancel = function (event) {\n                return _this.onTouchCancel(event);\n            };\n\n            this.game.canvas.addEventListener('touchstart', this._onTouchStart, false);\n            this.game.canvas.addEventListener('touchmove', this._onTouchMove, false);\n            this.game.canvas.addEventListener('touchend', this._onTouchEnd, false);\n            this.game.canvas.addEventListener('touchenter', this._onTouchEnter, false);\n            this.game.canvas.addEventListener('touchleave', this._onTouchLeave, false);\n            this.game.canvas.addEventListener('touchcancel', this._onTouchCancel, false);\n        }\n\n    },\n\n    /**\n    * Consumes all touchmove events on the document (only enable this if you know you need it!).\n    * @method Phaser.Touch#consumeTouchMove\n    */\n    consumeDocumentTouches: function () {\n\n        this._documentTouchMove = function (event) {\n            event.preventDefault();\n        };\n\n        document.addEventListener('touchmove', this._documentTouchMove, false);\n\n    },\n\n    /**\n    * The internal method that handles the touchstart event from the browser.\n    * @method Phaser.Touch#onTouchStart\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchStart: function (event) {\n\n        this.event = event;\n\n        if (this.touchStartCallback)\n        {\n            this.touchStartCallback.call(this.callbackContext, event);\n        }\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        //  event.targetTouches = list of all touches on the TARGET ELEMENT (i.e. game dom element)\n        //  event.touches = list of all touches on the ENTIRE DOCUMENT, not just the target element\n        //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.startPointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * Touch cancel - touches that were disrupted (perhaps by moving into a plugin or browser chrome).\n    * Occurs for example on iOS when you put down 4 fingers and the app selector UI appears.\n    * @method Phaser.Touch#onTouchCancel\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchCancel: function (event) {\n\n        this.event = event;\n\n        if (this.touchCancelCallback)\n        {\n            this.touchCancelCallback.call(this.callbackContext, event);\n        }\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        //  Touch cancel - touches that were disrupted (perhaps by moving into a plugin or browser chrome)\n        //  http://www.w3.org/TR/touch-events/#dfn-touchcancel\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.stopPointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * For touch enter and leave its a list of the touch points that have entered or left the target.\n    * Doesn't appear to be supported by most browsers on a canvas element yet.\n    * @method Phaser.Touch#onTouchEnter\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchEnter: function (event) {\n\n        this.event = event;\n\n        if (this.touchEnterCallback)\n        {\n            this.touchEnterCallback.call(this.callbackContext, event);\n        }\n\n        if (this.game.input.disabled || this.disabled)\n        {\n            return;\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n    },\n\n    /**\n    * For touch enter and leave its a list of the touch points that have entered or left the target.\n    * Doesn't appear to be supported by most browsers on a canvas element yet.\n    * @method Phaser.Touch#onTouchLeave\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchLeave: function (event) {\n\n        this.event = event;\n\n        if (this.touchLeaveCallback)\n        {\n            this.touchLeaveCallback.call(this.callbackContext, event);\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n    },\n\n    /**\n    * The handler for the touchmove events.\n    * @method Phaser.Touch#onTouchMove\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchMove: function (event) {\n\n        this.event = event;\n\n        if (this.touchMoveCallback)\n        {\n            this.touchMoveCallback.call(this.callbackContext, event);\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.updatePointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * The handler for the touchend events.\n    * @method Phaser.Touch#onTouchEnd\n    * @param {TouchEvent} event - The native event from the browser. This gets stored in Touch.event.\n    */\n    onTouchEnd: function (event) {\n\n        this.event = event;\n\n        if (this.touchEndCallback)\n        {\n            this.touchEndCallback.call(this.callbackContext, event);\n        }\n\n        if (this.preventDefault)\n        {\n            event.preventDefault();\n        }\n\n        //  For touch end its a list of the touch points that have been removed from the surface\n        //  https://developer.mozilla.org/en-US/docs/DOM/TouchList\n        //  event.changedTouches = the touches that CHANGED in this event, not the total number of them\n        for (var i = 0; i < event.changedTouches.length; i++)\n        {\n            this.game.input.stopPointer(event.changedTouches[i]);\n        }\n\n    },\n\n    /**\n    * Stop the event listeners.\n    * @method Phaser.Touch#stop\n    */\n    stop: function () {\n\n        if (this.game.device.touch)\n        {\n            this.game.canvas.removeEventListener('touchstart', this._onTouchStart);\n            this.game.canvas.removeEventListener('touchmove', this._onTouchMove);\n            this.game.canvas.removeEventListener('touchend', this._onTouchEnd);\n            this.game.canvas.removeEventListener('touchenter', this._onTouchEnter);\n            this.game.canvas.removeEventListener('touchleave', this._onTouchLeave);\n            this.game.canvas.removeEventListener('touchcancel', this._onTouchCancel);\n        }\n\n    }\n\n};\n\nPhaser.Touch.prototype.constructor = Phaser.Touch;\n\n/**\n* @author       @karlmacklin <tacklemcclean@gmail.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Gamepad class handles looking after gamepad input for your game.\n* Remember to call gamepad.start(); expecting input!\n*\n* HTML5 GAMEPAD API SUPPORT IS AT AN EXPERIMENTAL STAGE!\n* At moment of writing this (end of 2013) only Chrome supports parts of it out of the box. Firefox supports it\n* via prefs flags (about:config, search gamepad). The browsers map the same controllers differently.\n* This class has constans for Windows 7 Chrome mapping of\n* XBOX 360 controller.\n*\n* @class Phaser.Gamepad\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Gamepad = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Array<Phaser.SinglePad>} _gamepads - The four Phaser Gamepads.\n    * @private\n    */\n    this._gamepads = [\n        new Phaser.SinglePad(game, this),\n        new Phaser.SinglePad(game, this),\n        new Phaser.SinglePad(game, this),\n        new Phaser.SinglePad(game, this)\n    ];\n\n    /**\n    * @property {Object} _gamepadIndexMap - Maps the browsers gamepad indices to our Phaser Gamepads\n    * @private\n    */\n    this._gamepadIndexMap = {};\n\n    /**\n    * @property {Array} _rawPads - The raw state of the gamepads from the browser\n    * @private\n    */\n    this._rawPads = [];\n\n    /**\n    * @property {boolean} _active - Private flag for whether or not the API is polled\n    * @private\n    * @default\n    */\n    this._active = false;\n\n    /**\n    * You can disable all Gamepad Input by setting disabled to true. While true all new input related events will be ignored.\n    * @property {boolean} disabled - The disabled state of the Gamepad.\n    * @default\n    */\n    this.disabled = false;\n\n    /**\n    * Whether or not gamepads are supported in the current browser. Note that as of Dec. 2013 this check is actually not accurate at all due to poor implementation.\n    * @property {boolean} _gamepadSupportAvailable - Are gamepads supported in this browser or not?\n    * @private\n    */\n    this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || (navigator.userAgent.indexOf('Firefox/') != -1) || !!navigator.getGamepads;\n\n    /**\n    * Used to check for differences between earlier polls and current state of gamepads.\n    * @property {Array} _prevRawGamepadTypes\n    * @private\n    * @default\n    */\n    this._prevRawGamepadTypes = [];\n\n    /**\n    * Used to check for differences between earlier polls and current state of gamepads.\n    * @property {Array} _prevTimestamps\n    * @private\n    * @default\n    */\n    this._prevTimestamps = [];\n\n    /**\n    * @property {Object} callbackContext - The context under which the callbacks are run.\n    */\n    this.callbackContext = this;\n\n    /**\n    * @property {function} onConnectCallback - This callback is invoked every time any gamepad is connected\n    */\n    this.onConnectCallback = null;\n\n    /**\n    * @property {function} onDisconnectCallback - This callback is invoked every time any gamepad is disconnected\n    */\n    this.onDisconnectCallback = null;\n\n    /**\n    * @property {function} onDownCallback - This callback is invoked every time any gamepad button is pressed down.\n    */\n    this.onDownCallback = null;\n\n    /**\n    * @property {function} onUpCallback - This callback is invoked every time any gamepad button is released.\n    */\n    this.onUpCallback = null;\n\n    /**\n    * @property {function} onAxisCallback - This callback is invoked every time any gamepad axis is changed.\n    */\n    this.onAxisCallback = null;\n\n    /**\n    * @property {function} onFloatCallback - This callback is invoked every time any gamepad button is changed to a value where value > 0 and value < 1.\n    */\n    this.onFloatCallback = null;\n\n    /**\n    * @property {function} _ongamepadconnected - Private callback for Firefox gamepad connection handling\n    * @private\n    */\n    this._ongamepadconnected = null;\n\n    /**\n    * @property {function} _gamepaddisconnected - Private callback for Firefox gamepad connection handling\n    * @private\n    */\n    this._gamepaddisconnected = null;\n};\n\nPhaser.Gamepad.prototype = {\n\n    /**\n    * Add callbacks to the main Gamepad handler to handle connect/disconnect/button down/button up/axis change/float value buttons\n    * @method Phaser.Gamepad#addCallbacks\n    * @param {Object} context - The context under which the callbacks are run.\n    * @param {Object} callbacks - Object that takes six different callback methods:\n    * onConnectCallback, onDisconnectCallback, onDownCallback, onUpCallback, onAxisCallback, onFloatCallback\n    */\n    addCallbacks: function (context, callbacks) {\n\n        if (typeof callbacks !== 'undefined')\n        {\n            this.onConnectCallback = (typeof callbacks.onConnect === 'function') ? callbacks.onConnect : this.onConnectCallback;\n            this.onDisconnectCallback = (typeof callbacks.onDisconnect === 'function') ? callbacks.onDisconnect : this.onDisconnectCallback;\n            this.onDownCallback = (typeof callbacks.onDown === 'function') ? callbacks.onDown : this.onDownCallback;\n            this.onUpCallback = (typeof callbacks.onUp === 'function') ? callbacks.onUp : this.onUpCallback;\n            this.onAxisCallback = (typeof callbacks.onAxis === 'function') ? callbacks.onAxis : this.onAxisCallback;\n            this.onFloatCallback = (typeof callbacks.onFloat === 'function') ? callbacks.onFloat : this.onFloatCallback;\n        }\n\n    },\n\n    /**\n    * Starts the Gamepad event handling.\n    * This MUST be called manually before Phaser will start polling the Gamepad API.\n    *\n    * @method Phaser.Gamepad#start\n    */\n    start: function () {\n\n        if (this._active)\n        {\n            //  Avoid setting multiple listeners\n            return;\n        }\n\n        this._active = true;\n\n        var _this = this;\n\n        this._ongamepadconnected = function(event) {\n            var newPad = event.gamepad;\n            _this._rawPads.push(newPad);\n            _this._gamepads[newPad.index].connect(newPad);\n        };\n\n        window.addEventListener('gamepadconnected', this._ongamepadconnected, false);\n\n        this._ongamepaddisconnected = function(event) {\n\n            var removedPad = event.gamepad;\n\n            for (var i in _this._rawPads)\n            {\n                if (_this._rawPads[i].index === removedPad.index)\n                {\n                    _this._rawPads.splice(i,1);\n                }\n            }\n            _this._gamepads[removedPad.index].disconnect();\n        };\n\n        window.addEventListener('gamepaddisconnected', this._ongamepaddisconnected, false);\n\n    },\n\n    /**\n    * Main gamepad update loop. Should not be called manually.\n    * @method Phaser.Gamepad#update\n    * @private\n    */\n    update: function () {\n\n        this._pollGamepads();\n\n        for (var i = 0; i < this._gamepads.length; i++)\n        {\n            if (this._gamepads[i]._connected)\n            {\n                this._gamepads[i].pollStatus();\n            }\n        }\n\n    },\n\n    /**\n    * Updating connected gamepads (for Google Chrome).\n    * Should not be called manually.\n    * @method Phaser.Gamepad#_pollGamepads\n    * @private\n    */\n    _pollGamepads: function () {\n\n        var rawGamepads = navigator.getGamepads || (navigator.webkitGetGamepads && navigator.webkitGetGamepads()) || navigator.webkitGamepads;\n\n        if (rawGamepads)\n        {\n            this._rawPads = [];\n\n            var gamepadsChanged = false;\n\n            for (var i = 0; i < rawGamepads.length; i++)\n            {\n                if (typeof rawGamepads[i] !== this._prevRawGamepadTypes[i])\n                {\n                    gamepadsChanged = true;\n                    this._prevRawGamepadTypes[i] = typeof rawGamepads[i];\n                }\n\n                if (rawGamepads[i])\n                {\n                    this._rawPads.push(rawGamepads[i]);\n                }\n\n                // Support max 4 pads at the moment\n                if (i === 3)\n                {\n                    break;\n                }\n            }\n\n            if (gamepadsChanged)\n            {\n                var validConnections = { rawIndices: {}, padIndices: {} };\n                var singlePad;\n\n                for (var j = 0; j < this._gamepads.length; j++)\n                {\n                    singlePad = this._gamepads[j];\n\n                    if (singlePad.connected)\n                    {\n                        for (var k = 0; k < this._rawPads.length; k++)\n                        {\n                            if (this._rawPads[k].index === singlePad.index)\n                            {\n                                validConnections.rawIndices[singlePad.index] = true;\n                                validConnections.padIndices[j] = true;\n                            }\n                        }\n                    }\n                }\n\n                for (var l = 0; l < this._gamepads.length; l++)\n                {\n                    singlePad = this._gamepads[l];\n\n                    if (validConnections.padIndices[l])\n                    {\n                        continue;\n                    }\n\n                    if (this._rawPads.length < 1)\n                    {\n                        singlePad.disconnect();\n                    }\n\n                    for (var m = 0; m < this._rawPads.length; m++)\n                    {\n                        if (validConnections.padIndices[l])\n                        {\n                            break;\n                        }\n\n                        var rawPad = this._rawPads[m];\n\n                        if (rawPad)\n                        {\n                            if (validConnections.rawIndices[rawPad.index])\n                            {\n                                singlePad.disconnect();\n                                continue;\n                            }\n                            else\n                            {\n                                singlePad.connect(rawPad);\n                                validConnections.rawIndices[rawPad.index] = true;\n                                validConnections.padIndices[l] = true;\n                            }\n                        }\n                        else\n                        {\n                            singlePad.disconnect();\n                        }\n                    }\n                }\n            }\n        }\n    },\n\n    /**\n    * Sets the deadZone variable for all four gamepads\n    * @method Phaser.Gamepad#setDeadZones\n    */\n    setDeadZones: function (value) {\n\n        for (var i = 0; i < this._gamepads.length; i++)\n        {\n            this._gamepads[i].deadZone = value;\n        }\n\n    },\n\n    /**\n    * Stops the Gamepad event handling.\n    *\n    * @method Phaser.Gamepad#stop\n    */\n    stop: function () {\n\n        this._active = false;\n\n        window.removeEventListener('gamepadconnected', this._ongamepadconnected);\n        window.removeEventListener('gamepaddisconnected', this._ongamepaddisconnected);\n\n    },\n\n    /**\n    * Reset all buttons/axes of all gamepads\n    * @method Phaser.Gamepad#reset\n    */\n    reset: function () {\n\n        this.update();\n\n        for (var i = 0; i < this._gamepads.length; i++)\n        {\n            this._gamepads[i].reset();\n        }\n\n    },\n\n    /**\n    * Returns the \"just pressed\" state of a button from ANY gamepad connected. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).\n    * @method Phaser.Gamepad#justPressed\n    * @param {number} buttonCode - The buttonCode of the button to check for.\n    * @param {number} [duration=250] - The duration below which the button is considered as being just pressed.\n    * @return {boolean} True if the button is just pressed otherwise false.\n    */\n    justPressed: function (buttonCode, duration) {\n\n        for (var i = 0; i < this._gamepads.length; i++)\n        {\n            if (this._gamepads[i].justPressed(buttonCode, duration) === true)\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Returns the \"just released\" state of a button from ANY gamepad connected. Just released is considered as being true if the button was released within the duration given (default 250ms).\n    * @method Phaser.Gamepad#justPressed\n    * @param {number} buttonCode - The buttonCode of the button to check for.\n    * @param {number} [duration=250] - The duration below which the button is considered as being just released.\n    * @return {boolean} True if the button is just released otherwise false.\n    */\n    justReleased: function (buttonCode, duration) {\n\n        for (var i = 0; i < this._gamepads.length; i++)\n        {\n            if (this._gamepads[i].justReleased(buttonCode, duration) === true)\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Returns true if the button is currently pressed down, on ANY gamepad.\n    * @method Phaser.Gamepad#isDown\n    * @param {number} buttonCode - The buttonCode of the button to check for.\n    * @return {boolean} True if a button is currently down.\n    */\n    isDown: function (buttonCode) {\n\n        for (var i = 0; i < this._gamepads.length; i++)\n        {\n            if (this._gamepads[i].isDown(buttonCode) === true)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n};\n\nPhaser.Gamepad.prototype.constructor = Phaser.Gamepad;\n\n/**\n* If the gamepad input is active or not - if not active it should not be updated from Input.js\n* @name Phaser.Gamepad#active\n* @property {boolean} active - If the gamepad input is active or not.\n* @readonly\n*/\nObject.defineProperty(Phaser.Gamepad.prototype, \"active\", {\n\n    get: function () {\n        return this._active;\n    }\n\n});\n\n/**\n* Whether or not gamepads are supported in current browser.\n* @name Phaser.Gamepad#supported\n* @property {boolean} supported - Whether or not gamepads are supported in current browser.\n* @readonly\n*/\nObject.defineProperty(Phaser.Gamepad.prototype, \"supported\", {\n\n    get: function () {\n        return this._gamepadSupportAvailable;\n    }\n\n});\n\n/**\n* How many live gamepads are currently connected.\n* @name Phaser.Gamepad#padsConnected\n* @property {boolean} padsConnected - How many live gamepads are currently connected.\n* @readonly\n*/\nObject.defineProperty(Phaser.Gamepad.prototype, \"padsConnected\", {\n\n    get: function () {\n        return this._rawPads.length;\n    }\n\n});\n\n/**\n* Gamepad #1\n* @name Phaser.Gamepad#pad1\n* @property {boolean} pad1 - Gamepad #1;\n* @readonly\n*/\nObject.defineProperty(Phaser.Gamepad.prototype, \"pad1\", {\n\n    get: function () {\n        return this._gamepads[0];\n    }\n\n});\n\n/**\n* Gamepad #2\n* @name Phaser.Gamepad#pad2\n* @property {boolean} pad2 - Gamepad #2\n* @readonly\n*/\nObject.defineProperty(Phaser.Gamepad.prototype, \"pad2\", {\n\n    get: function () {\n        return this._gamepads[1];\n    }\n\n});\n\n/**\n* Gamepad #3\n* @name Phaser.Gamepad#pad3\n* @property {boolean} pad3 - Gamepad #3\n* @readonly\n*/\nObject.defineProperty(Phaser.Gamepad.prototype, \"pad3\", {\n\n    get: function () {\n        return this._gamepads[2];\n    }\n\n});\n\n/**\n* Gamepad #4\n* @name Phaser.Gamepad#pad4\n* @property {boolean} pad4 - Gamepad #4\n* @readonly\n*/\nObject.defineProperty(Phaser.Gamepad.prototype, \"pad4\", {\n\n    get: function () {\n        return this._gamepads[3];\n    }\n\n});\n\nPhaser.Gamepad.BUTTON_0 = 0;\nPhaser.Gamepad.BUTTON_1 = 1;\nPhaser.Gamepad.BUTTON_2 = 2;\nPhaser.Gamepad.BUTTON_3 = 3;\nPhaser.Gamepad.BUTTON_4 = 4;\nPhaser.Gamepad.BUTTON_5 = 5;\nPhaser.Gamepad.BUTTON_6 = 6;\nPhaser.Gamepad.BUTTON_7 = 7;\nPhaser.Gamepad.BUTTON_8 = 8;\nPhaser.Gamepad.BUTTON_9 = 9;\nPhaser.Gamepad.BUTTON_10 = 10;\nPhaser.Gamepad.BUTTON_11 = 11;\nPhaser.Gamepad.BUTTON_12 = 12;\nPhaser.Gamepad.BUTTON_13 = 13;\nPhaser.Gamepad.BUTTON_14 = 14;\nPhaser.Gamepad.BUTTON_15 = 15;\n\nPhaser.Gamepad.AXIS_0 = 0;\nPhaser.Gamepad.AXIS_1 = 1;\nPhaser.Gamepad.AXIS_2 = 2;\nPhaser.Gamepad.AXIS_3 = 3;\nPhaser.Gamepad.AXIS_4 = 4;\nPhaser.Gamepad.AXIS_5 = 5;\nPhaser.Gamepad.AXIS_6 = 6;\nPhaser.Gamepad.AXIS_7 = 7;\nPhaser.Gamepad.AXIS_8 = 8;\nPhaser.Gamepad.AXIS_9 = 9;\n\n// Below mapping applies to XBOX 360 Wired and Wireless controller on Google Chrome (tested on Windows 7).\n// - Firefox uses different map! Separate amount of buttons and axes. DPAD = axis and not a button.\n// In other words - discrepancies when using gamepads.\n\nPhaser.Gamepad.XBOX360_A = 0;\nPhaser.Gamepad.XBOX360_B = 1;\nPhaser.Gamepad.XBOX360_X = 2;\nPhaser.Gamepad.XBOX360_Y = 3;\nPhaser.Gamepad.XBOX360_LEFT_BUMPER = 4;\nPhaser.Gamepad.XBOX360_RIGHT_BUMPER = 5;\nPhaser.Gamepad.XBOX360_LEFT_TRIGGER = 6;\nPhaser.Gamepad.XBOX360_RIGHT_TRIGGER = 7;\nPhaser.Gamepad.XBOX360_BACK = 8;\nPhaser.Gamepad.XBOX360_START = 9;\nPhaser.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10;\nPhaser.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11;\n\nPhaser.Gamepad.XBOX360_DPAD_LEFT = 14;\nPhaser.Gamepad.XBOX360_DPAD_RIGHT = 15;\nPhaser.Gamepad.XBOX360_DPAD_UP = 12;\nPhaser.Gamepad.XBOX360_DPAD_DOWN = 13;\n\nPhaser.Gamepad.XBOX360_STICK_LEFT_X = 0;\nPhaser.Gamepad.XBOX360_STICK_LEFT_Y = 1;\nPhaser.Gamepad.XBOX360_STICK_RIGHT_X = 2;\nPhaser.Gamepad.XBOX360_STICK_RIGHT_Y = 3;\n\n/**\n* @author       @karlmacklin <tacklemcclean@gmail.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.SinglePad\n* @classdesc A single Phaser Gamepad\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n* @param {Object} padParent - The parent Phaser.Gamepad object (all gamepads reside under this)\n*/\nPhaser.SinglePad = function (game, padParent) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Gamepad} padParent - Main Phaser Gamepad object\n    */\n    this._padParent = padParent;\n\n    /**\n    * @property {number} index - The gamepad index as per browsers data\n    * @default\n    */\n    this._index = null;\n\n    /**\n    * @property {Object} _rawPad - The 'raw' gamepad data.\n    * @private\n    */\n    this._rawPad = null;\n\n    /**\n    * @property {boolean} _connected - Is this pad connected or not.\n    * @private\n    */\n    this._connected = false;\n\n    /**\n    * @property {number} _prevTimestamp - Used to check for differences between earlier polls and current state of gamepads.\n    * @private\n    */\n    this._prevTimestamp = null;\n\n    /**\n    * @property {Array} _rawButtons - The 'raw' button state.\n    * @private\n    */\n    this._rawButtons = [];\n\n    /**\n    * @property {Array} _buttons - Current Phaser state of the buttons.\n    * @private\n    */\n    this._buttons = [];\n\n    /**\n    * @property {Array} _axes - Current axes state.\n    * @private\n    */\n    this._axes = [];\n\n    /**\n    * @property {Array} _hotkeys - Hotkey buttons.\n    * @private\n    */\n    this._hotkeys = [];\n\n    /**\n    * @property {Object} callbackContext - The context under which the callbacks are run.\n    */\n    this.callbackContext = this;\n\n    /**\n    * @property {function} onConnectCallback - This callback is invoked every time this gamepad is connected\n    */\n    this.onConnectCallback = null;\n\n    /**\n    * @property {function} onDisconnectCallback - This callback is invoked every time this gamepad is disconnected\n    */\n    this.onDisconnectCallback = null;\n\n    /**\n    * @property {function} onDownCallback - This callback is invoked every time a button is pressed down.\n    */\n    this.onDownCallback = null;\n\n    /**\n    * @property {function} onUpCallback - This callback is invoked every time a gamepad button is released.\n    */\n    this.onUpCallback = null;\n\n    /**\n    * @property {function} onAxisCallback - This callback is invoked every time an axis is changed.\n    */\n    this.onAxisCallback = null;\n\n    /**\n    * @property {function} onFloatCallback - This callback is invoked every time a button is changed to a value where value > 0 and value < 1.\n    */\n    this.onFloatCallback = null;\n\n    /**\n    * @property {number} deadZone - Dead zone for axis feedback - within this value you won't trigger updates.\n    */\n    this.deadZone = 0.26;\n\n};\n\nPhaser.SinglePad.prototype = {\n\n    /**\n    * Add callbacks to the this Gamepad to handle connect/disconnect/button down/button up/axis change/float value buttons\n    * @method Phaser.SinglePad#addCallbacks\n    * @param {Object} context - The context under which the callbacks are run.\n    * @param {Object} callbacks - Object that takes six different callbak methods:\n    * onConnectCallback, onDisconnectCallback, onDownCallback, onUpCallback, onAxisCallback, onFloatCallback\n    */\n    addCallbacks: function (context, callbacks) {\n\n        if (typeof callbacks !== 'undefined')\n        {\n            this.onConnectCallback = (typeof callbacks.onConnect === 'function') ? callbacks.onConnect : this.onConnectCallback;\n            this.onDisconnectCallback = (typeof callbacks.onDisconnect === 'function') ? callbacks.onDisconnect : this.onDisconnectCallback;\n            this.onDownCallback = (typeof callbacks.onDown === 'function') ? callbacks.onDown : this.onDownCallback;\n            this.onUpCallback = (typeof callbacks.onUp === 'function') ? callbacks.onUp : this.onUpCallback;\n            this.onAxisCallback = (typeof callbacks.onAxis === 'function') ? callbacks.onAxis : this.onAxisCallback;\n            this.onFloatCallback = (typeof callbacks.onFloat === 'function') ? callbacks.onFloat : this.onFloatCallback;\n        }\n\n    },\n\n    /**\n    * If you need more fine-grained control over a Key you can create a new Phaser.Key object via this method.\n    * The Key object can then be polled, have events attached to it, etc.\n    *\n    * @method Phaser.SinglePad#addButton\n    * @param {number} buttonCode - The buttonCode of the button, i.e. Phaser.Gamepad.BUTTON_0 or Phaser.Gamepad.BUTTON_1\n    * @return {Phaser.GamepadButton} The GamepadButton object which you can store locally and reference directly.\n    */\n    addButton: function (buttonCode) {\n\n        this._hotkeys[buttonCode] = new Phaser.GamepadButton(this.game, buttonCode);\n        return this._hotkeys[buttonCode];\n\n    },\n\n    /**\n    * Main update function, should be called by Phaser.Gamepad\n    * @method Phaser.SinglePad#pollStatus\n    */\n    pollStatus: function () {\n\n        if (this._rawPad.timestamp && (this._rawPad.timestamp == this._prevTimestamp))\n        {\n            return;\n        }\n\n        for (var i = 0; i < this._rawPad.buttons.length; i += 1)\n        {\n            var buttonValue = this._rawPad.buttons[i];\n\n            if (this._rawButtons[i] !== buttonValue)\n            {\n                if (buttonValue === 1)\n                {\n                    this.processButtonDown(i, buttonValue);\n                }\n                else if (buttonValue === 0)\n                {\n                    this.processButtonUp(i, buttonValue);\n                }\n                else\n                {\n                    this.processButtonFloat(i, buttonValue);\n                }\n\n                this._rawButtons[i] = buttonValue;\n            }\n        }\n\n        var axes = this._rawPad.axes;\n\n        for (var j = 0; j < axes.length; j += 1)\n        {\n            var axis = axes[j];\n\n            if (axis > 0 && axis > this.deadZone || axis < 0 && axis < -this.deadZone)\n            {\n                this.processAxisChange({axis: j, value: axis});\n            }\n            else\n            {\n                this.processAxisChange({axis: j, value: 0});\n            }\n        }\n\n        this._prevTimestamp = this._rawPad.timestamp;\n\n    },\n\n    /**\n    * Gamepad connect function, should be called by Phaser.Gamepad\n    * @method Phaser.SinglePad#connect\n    * @param {Object} rawPad - The raw gamepad object\n    */\n    connect: function (rawPad) {\n\n        var triggerCallback = !this._connected;\n\n        this._index = rawPad.index;\n        this._connected = true;\n        this._rawPad = rawPad;\n        this._rawButtons = rawPad.buttons;\n        this._axes = rawPad.axes;\n\n        if (triggerCallback && this._padParent.onConnectCallback)\n        {\n            this._padParent.onConnectCallback.call(this._padParent.callbackContext, this._index);\n        }\n\n        if (triggerCallback && this.onConnectCallback)\n        {\n            this.onConnectCallback.call(this.callbackContext);\n        }\n\n    },\n\n    /**\n    * Gamepad disconnect function, should be called by Phaser.Gamepad\n    * @method Phaser.SinglePad#disconnect\n    */\n    disconnect: function () {\n\n        var triggerCallback = this._connected;\n        this._connected = false;\n        this._rawPad = undefined;\n        this._rawButtons = [];\n        this._buttons = [];\n        var disconnectingIndex = this._index;\n        this._index = null;\n\n        if (triggerCallback && this._padParent.onDisconnectCallback)\n        {\n            this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, disconnectingIndex);\n        }\n\n        if (triggerCallback && this.onDisconnectCallback)\n        {\n            this.onDisconnectCallback.call(this.callbackContext);\n        }\n\n    },\n\n    /**\n    * Handles changes in axis\n    * @method Phaser.SinglePad#processAxisChange\n    * @param {Object} axisState - State of the relevant axis\n    */\n    processAxisChange: function (axisState) {\n\n        if (this.game.input.disabled || this.game.input.gamepad.disabled)\n        {\n            return;\n        }\n\n        if (this._axes[axisState.axis] === axisState.value)\n        {\n            return;\n        }\n\n        this._axes[axisState.axis] = axisState.value;\n\n        if (this._padParent.onAxisCallback)\n        {\n            this._padParent.onAxisCallback.call(this._padParent.callbackContext, axisState, this._index);\n        }\n\n        if (this.onAxisCallback)\n        {\n            this.onAxisCallback.call(this.callbackContext, axisState);\n        }\n\n    },\n\n    /**\n    * Handles button down press\n    * @method Phaser.SinglePad#processButtonDown\n    * @param {number} buttonCode - Which buttonCode of this button\n    * @param {Object} value - Button value\n    */\n    processButtonDown: function (buttonCode, value) {\n\n        if (this.game.input.disabled || this.game.input.gamepad.disabled)\n        {\n            return;\n        }\n\n        if (this._padParent.onDownCallback)\n        {\n            this._padParent.onDownCallback.call(this._padParent.callbackContext, buttonCode, value, this._index);\n        }\n\n        if (this.onDownCallback)\n        {\n            this.onDownCallback.call(this.callbackContext, buttonCode, value);\n        }\n\n        if (this._buttons[buttonCode] && this._buttons[buttonCode].isDown)\n        {\n            //  Key already down and still down, so update\n            this._buttons[buttonCode].duration = this.game.time.now - this._buttons[buttonCode].timeDown;\n        }\n        else\n        {\n            if (!this._buttons[buttonCode])\n            {\n                //  Not used this button before, so register it\n                this._buttons[buttonCode] = {\n                    isDown: true,\n                    timeDown: this.game.time.now,\n                    timeUp: 0,\n                    duration: 0,\n                    value: value\n                };\n            }\n            else\n            {\n                //  Button used before but freshly down\n                this._buttons[buttonCode].isDown = true;\n                this._buttons[buttonCode].timeDown = this.game.time.now;\n                this._buttons[buttonCode].duration = 0;\n                this._buttons[buttonCode].value = value;\n            }\n        }\n\n        if (this._hotkeys[buttonCode])\n        {\n            this._hotkeys[buttonCode].processButtonDown(value);\n        }\n\n    },\n\n    /**\n    * Handles button release\n    * @method Phaser.SinglePad#processButtonUp\n    * @param {number} buttonCode - Which buttonCode of this button\n    * @param {Object} value - Button value\n    */\n    processButtonUp: function (buttonCode, value) {\n\n        if (this.game.input.disabled || this.game.input.gamepad.disabled)\n        {\n            return;\n        }\n\n        if (this._padParent.onUpCallback)\n        {\n            this._padParent.onUpCallback.call(this._padParent.callbackContext, buttonCode, value, this._index);\n        }\n\n        if (this.onUpCallback)\n        {\n            this.onUpCallback.call(this.callbackContext, buttonCode, value);\n        }\n\n        if (this._hotkeys[buttonCode])\n        {\n            this._hotkeys[buttonCode].processButtonUp(value);\n        }\n\n        if (this._buttons[buttonCode])\n        {\n            this._buttons[buttonCode].isDown = false;\n            this._buttons[buttonCode].timeUp = this.game.time.now;\n            this._buttons[buttonCode].value = value;\n        }\n        else\n        {\n            //  Not used this button before, so register it\n            this._buttons[buttonCode] = {\n                isDown: false,\n                timeDown: this.game.time.now,\n                timeUp: this.game.time.now,\n                duration: 0,\n                value: value\n            };\n        }\n\n    },\n\n    /**\n    * Handles buttons with floating values (like analog buttons that acts almost like an axis but still registers like a button)\n    * @method Phaser.SinglePad#processButtonFloat\n    * @param {number} buttonCode - Which buttonCode of this button\n    * @param {Object} value - Button value (will range somewhere between 0 and 1, but not specifically 0 or 1.\n    */\n    processButtonFloat: function (buttonCode, value) {\n\n        if (this.game.input.disabled || this.game.input.gamepad.disabled)\n        {\n            return;\n        }\n\n        if (this._padParent.onFloatCallback)\n        {\n            this._padParent.onFloatCallback.call(this._padParent.callbackContext, buttonCode, value, this._index);\n        }\n\n        if (this.onFloatCallback)\n        {\n            this.onFloatCallback.call(this.callbackContext, buttonCode, value);\n        }\n\n        if (!this._buttons[buttonCode])\n        {\n            //  Not used this button before, so register it\n            this._buttons[buttonCode] = { value: value };\n        }\n        else\n        {\n            //  Button used before but freshly down\n            this._buttons[buttonCode].value = value;\n        }\n\n        if (this._hotkeys[buttonCode])\n        {\n            this._hotkeys[buttonCode].processButtonFloat(value);\n        }\n\n    },\n\n    /**\n    * Returns value of requested axis\n    * @method Phaser.SinglePad#axis\n    * @param {number} axisCode - The index of the axis to check\n    * @return {number} Axis value if available otherwise false\n    */\n    axis: function (axisCode) {\n\n        if (this._axes[axisCode])\n        {\n            return this._axes[axisCode];\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Returns true if the button is currently pressed down.\n    * @method Phaser.SinglePad#isDown\n    * @param {number} buttonCode - The buttonCode of the key to check.\n    * @return {boolean} True if the key is currently down.\n    */\n    isDown: function (buttonCode) {\n\n        if (this._buttons[buttonCode])\n        {\n            return this._buttons[buttonCode].isDown;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Returns the \"just released\" state of a button from this gamepad. Just released is considered as being true if the button was released within the duration given (default 250ms).\n    * @method Phaser.SinglePad#justReleased\n    * @param {number} buttonCode - The buttonCode of the button to check for.\n    * @param {number} [duration=250] - The duration below which the button is considered as being just released.\n    * @return {boolean} True if the button is just released otherwise false.\n    */\n    justReleased: function (buttonCode, duration) {\n\n        if (typeof duration === \"undefined\") { duration = 250; }\n\n        return (this._buttons[buttonCode] && this._buttons[buttonCode].isDown === false && (this.game.time.now - this._buttons[buttonCode].timeUp < duration));\n\n    },\n\n    /**\n    * Returns the \"just pressed\" state of a button from this gamepad. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).\n    * @method Phaser.SinglePad#justPressed\n    * @param {number} buttonCode - The buttonCode of the button to check for.\n    * @param {number} [duration=250] - The duration below which the button is considered as being just pressed.\n    * @return {boolean} True if the button is just pressed otherwise false.\n    */\n    justPressed: function (buttonCode, duration) {\n\n        if (typeof duration === \"undefined\") { duration = 250; }\n\n        return (this._buttons[buttonCode] && this._buttons[buttonCode].isDown && this._buttons[buttonCode].duration < duration);\n\n    },\n\n    /**\n    * Returns the value of a gamepad button. Intended mainly for cases when you have floating button values, for example\n    * analog trigger buttons on the XBOX 360 controller\n    * @method Phaser.SinglePad#buttonValue\n    * @param {number} buttonCode - The buttonCode of the button to check.\n    * @return {boolean} Button value if available otherwise false.\n    */\n    buttonValue: function (buttonCode) {\n\n        if (this._buttons[buttonCode])\n        {\n            return this._buttons[buttonCode].value;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Reset all buttons/axes of this gamepad\n    * @method Phaser.SinglePad#reset\n    */\n    reset: function () {\n\n        for (var i = 0; i < this._buttons.length; i++)\n        {\n            this._buttons[i] = 0;\n        }\n\n        for (var j = 0; j < this._axes.length; j++)\n        {\n            this._axes[j] = 0;\n        }\n\n    }\n\n};\n\nPhaser.SinglePad.prototype.constructor = Phaser.SinglePad;\n\n/**\n * Whether or not this particular gamepad is connected or not.\n * @name Phaser.SinglePad#connected\n * @property {boolean} connected - Whether or not this particular gamepad is connected or not.\n * @readonly\n */\nObject.defineProperty(Phaser.SinglePad.prototype, \"connected\", {\n\n    get: function () {\n        return this._connected;\n    }\n\n});\n\n/**\n * Gamepad index as per browser data\n * @name Phaser.SinglePad#index\n * @property {number} index - The gamepad index, used to identify specific gamepads in the browser\n * @readonly\n */\nObject.defineProperty(Phaser.SinglePad.prototype, \"index\", {\n\n    get: function () {\n        return this._index;\n    }\n\n});\n\n/**\n* @author       @karlmacklin <tacklemcclean@gmail.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.GamepadButton\n* @classdesc If you need more fine-grained control over the handling of specific buttons you can create and use Phaser.GamepadButton objects.\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n* @param {number} buttoncode - The button code this GamepadButton is responsible for.\n*/\nPhaser.GamepadButton = function (game, buttoncode) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} isDown - The \"down\" state of the button.\n    * @default\n    */\n    this.isDown = false;\n\n    /**\n    * @property {boolean} isUp - The \"up\" state of the button.\n    * @default\n    */\n    this.isUp = true;\n\n    /**\n    * @property {number} timeDown - The timestamp when the button was last pressed down.\n    * @default\n    */\n    this.timeDown = 0;\n\n    /**\n    * If the button is down this value holds the duration of that button press and is constantly updated.\n    * If the button is up it holds the duration of the previous down session.\n    * @property {number} duration - The number of milliseconds this button has been held down for.\n    * @default\n    */\n    this.duration = 0;\n\n    /**\n    * @property {number} timeUp - The timestamp when the button was last released.\n    * @default\n    */\n    this.timeUp = 0;\n\n    /**\n    * @property {number} repeats - If a button is held down this holds down the number of times the button has 'repeated'.\n    * @default\n    */\n    this.repeats = 0;\n\n    /**\n    * @property {number} value - Button value. Mainly useful for checking analog buttons (like shoulder triggers)\n    * @default\n    */\n    this.value = 0;\n\n    /**\n    * @property {number} buttonCode - The buttoncode of this button.\n    */\n    this.buttonCode = buttoncode;\n\n    /**\n    * @property {Phaser.Signal} onDown - This Signal is dispatched every time this GamepadButton is pressed down. It is only dispatched once (until the button is released again).\n    */\n    this.onDown = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onUp - This Signal is dispatched every time this GamepadButton is pressed down. It is only dispatched once (until the button is released again).\n    */\n    this.onUp = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onFloat - This Signal is dispatched every time this GamepadButton changes floating value (between (but not exactly) 0 and 1)\n    */\n    this.onFloat = new Phaser.Signal();\n\n};\n\nPhaser.GamepadButton.prototype = {\n\n    /**\n    * Called automatically by Phaser.SinglePad.\n    * @method Phaser.GamepadButton#processButtonDown\n    * @param {Object} value - Button value\n    * @protected\n    */\n    processButtonDown: function (value) {\n\n        if (this.isDown)\n        {\n            this.duration = this.game.time.now - this.timeDown;\n            this.repeats++;\n        }\n        else\n        {\n            this.isDown = true;\n            this.isUp = false;\n            this.timeDown = this.game.time.now;\n            this.duration = 0;\n            this.repeats = 0;\n            this.value = value;\n\n            this.onDown.dispatch(this, value);\n        }\n\n    },\n\n    /**\n    * Called automatically by Phaser.SinglePad.\n    * @method Phaser.GamepadButton#processButtonUp\n    * @param {Object} value - Button value\n    * @protected\n    */\n    processButtonUp: function (value) {\n\n        this.isDown = false;\n        this.isUp = true;\n        this.timeUp = this.game.time.now;\n        this.value = value;\n\n        this.onUp.dispatch(this, value);\n\n    },\n\n    /**\n    * Called automatically by Phaser.Gamepad.\n    * @method Phaser.GamepadButton#processButtonFloat\n    * @param {Object} value - Button value\n    * @protected\n    */\n    processButtonFloat: function (value) {\n\n        this.value = value;\n        this.onFloat.dispatch(this, value);\n\n    },\n\n    /**\n    * Returns the \"just pressed\" state of this button. Just pressed is considered true if the button was pressed down within the duration given (default 250ms).\n    * @method Phaser.GamepadButton#justPressed\n    * @param {number} [duration=250] - The duration below which the button is considered as being just pressed.\n    * @return {boolean} True if the button is just pressed otherwise false.\n    */\n    justPressed: function (duration) {\n\n        if (typeof duration === \"undefined\") { duration = 250; }\n\n        return (this.isDown && this.duration < duration);\n\n    },\n\n    /**\n    * Returns the \"just released\" state of this button. Just released is considered as being true if the button was released within the duration given (default 250ms).\n    * @method Phaser.GamepadButton#justPressed\n    * @param {number} [duration=250] - The duration below which the button is considered as being just released.\n    * @return {boolean} True if the button is just pressed otherwise false.\n    */\n    justReleased: function (duration) {\n\n        if (typeof duration === \"undefined\") { duration = 250; }\n\n        return (this.isDown === false && (this.game.time.now - this.timeUp < duration));\n    }\n\n};\n\nPhaser.GamepadButton.prototype.constructor = Phaser.GamepadButton;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Input Handler is bound to a specific Sprite and is responsible for managing all Input events on that Sprite.\n* @class Phaser.InputHandler\n* @constructor\n* @param {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.\n*/\nPhaser.InputHandler = function (sprite) {\n\n    /**\n    * @property {Phaser.Sprite} sprite - The Sprite object to which this Input Handler belongs.\n    */\n    this.sprite = sprite;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = sprite.game;\n\n    /**\n    * @property {boolean} enabled - If enabled the Input Handler will process input requests and monitor pointer activity.\n    * @default\n    */\n    this.enabled = false;\n\n    /**\n    * The priorityID is used to determine which game objects should get priority when input events occur. For example if you have\n    * several Sprites that overlap, by default the one at the top of the display list is given priority for input events. You can\n    * stop this from happening by controlling the priorityID value. The higher the value, the more important they are considered to the Input events.\n    * @property {number} priorityID\n    * @default\n    */\n    this.priorityID = 0;\n\n    /**\n    * @property {boolean} useHandCursor - On a desktop browser you can set the 'hand' cursor to appear when moving over the Sprite.\n    * @default\n    */\n    this.useHandCursor = false;\n\n    /**\n    * @property {boolean} _setHandCursor - Did this Sprite trigger the hand cursor?\n    * @private\n    */\n    this._setHandCursor = false;\n\n    /**\n    * @property {boolean} isDragged - true if the Sprite is being currently dragged.\n    * @default\n    */\n    this.isDragged = false;\n\n    /**\n    * @property {boolean} allowHorizontalDrag - Controls if the Sprite is allowed to be dragged horizontally.\n    * @default\n    */\n    this.allowHorizontalDrag = true;\n\n    /**\n    * @property {boolean} allowVerticalDrag - Controls if the Sprite is allowed to be dragged vertically.\n    * @default\n    */\n    this.allowVerticalDrag = true;\n\n    /**\n    * @property {boolean} bringToTop - If true when this Sprite is clicked or dragged it will automatically be bought to the top of the Group it is within.\n    * @default\n    */\n    this.bringToTop = false;\n\n    /**\n    * @property {Phaser.Point} snapOffset - A Point object that contains by how far the Sprite snap is offset.\n    * @default\n    */\n    this.snapOffset = null;\n\n    /**\n    * @property {boolean} snapOnDrag - When the Sprite is dragged this controls if the center of the Sprite will snap to the pointer on drag or not.\n    * @default\n    */\n    this.snapOnDrag = false;\n\n    /**\n    * @property {boolean} snapOnRelease - When the Sprite is dragged this controls if the Sprite will be snapped on release.\n    * @default\n    */\n    this.snapOnRelease = false;\n\n    /**\n    * @property {number} snapX - When a Sprite has snapping enabled this holds the width of the snap grid.\n    * @default\n    */\n    this.snapX = 0;\n\n    /**\n    * @property {number} snapY - When a Sprite has snapping enabled this holds the height of the snap grid.\n    * @default\n    */\n    this.snapY = 0;\n\n    /**\n    * @property {number} snapOffsetX - This defines the top-left X coordinate of the snap grid.\n    * @default\n    */\n    this.snapOffsetX = 0;\n\n    /**\n    * @property {number} snapOffsetY - This defines the top-left Y coordinate of the snap grid..\n    * @default\n    */\n    this.snapOffsetY = 0;\n\n    /**\n    * Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite.\n    * The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.\n    * Warning: This is expensive, especially on mobile (where it's not even needed!) so only enable if required. Also see the less-expensive InputHandler.pixelPerfectClick.\n    * @property {number} pixelPerfectOver - Use a pixel perfect check when testing for pointer over.\n    * @default\n    */\n    this.pixelPerfectOver = false;\n\n    /**\n    * Set to true to use pixel perfect hit detection when checking if the pointer is over this Sprite when it's clicked or touched.\n    * The x/y coordinates of the pointer are tested against the image in combination with the InputHandler.pixelPerfectAlpha value.\n    * Warning: This is expensive so only enable if you really need it.\n    * @property {number} pixelPerfectClick - Use a pixel perfect check when testing for clicks or touches on the Sprite.\n    * @default\n    */\n    this.pixelPerfectClick = false;\n\n    /**\n    * @property {number} pixelPerfectAlpha - The alpha tolerance threshold. If the alpha value of the pixel matches or is above this value, it's considered a hit.\n    * @default\n    */\n    this.pixelPerfectAlpha = 255;\n\n    /**\n    * @property {boolean} draggable - Is this sprite allowed to be dragged by the mouse? true = yes, false = no\n    * @default\n    */\n    this.draggable = false;\n\n    /**\n    * @property {Phaser.Rectangle} boundsRect - A region of the game world within which the sprite is restricted during drag.\n    * @default\n    */\n    this.boundsRect = null;\n\n    /**\n    * @property {Phaser.Sprite} boundsSprite - A Sprite the bounds of which this sprite is restricted during drag.\n    * @default\n    */\n    this.boundsSprite = null;\n\n    /**\n    * If this object is set to consume the pointer event then it will stop all propogation from this object on.\n    * For example if you had a stack of 6 sprites with the same priority IDs and one consumed the event, none of the others would receive it.\n    * @property {boolean} consumePointerEvent\n    * @default\n    */\n    this.consumePointerEvent = false;\n\n    /**\n    * @property {boolean} _wasEnabled - Internal cache var.\n    * @private\n    */\n    this._wasEnabled = false;\n\n    /**\n    * @property {Phaser.Point} _tempPoint - Internal cache var.\n    * @private\n    */\n    this._tempPoint = new Phaser.Point();\n\n    /**\n    * @property {array} _pointerData - Internal cache var.\n    * @private\n    */\n    this._pointerData = [];\n\n    this._pointerData.push({\n        id: 0,\n        x: 0,\n        y: 0,\n        isDown: false,\n        isUp: false,\n        isOver: false,\n        isOut: false,\n        timeOver: 0,\n        timeOut: 0,\n        timeDown: 0,\n        timeUp: 0,\n        downDuration: 0,\n        isDragged: false\n    });\n\n};\n\nPhaser.InputHandler.prototype = {\n\n    /**\n    * Starts the Input Handler running. This is called automatically when you enable input on a Sprite, or can be called directly if you need to set a specific priority.\n    * @method Phaser.InputHandler#start\n    * @param {number} priority - Higher priority sprites take click priority over low-priority sprites when they are stacked on-top of each other.\n    * @param {boolean} useHandCursor - If true the Sprite will show the hand cursor on mouse-over (doesn't apply to mobile browsers)\n    * @return {Phaser.Sprite} The Sprite object to which the Input Handler is bound.\n    */\n    start: function (priority, useHandCursor) {\n\n        priority = priority || 0;\n        if (typeof useHandCursor === 'undefined') { useHandCursor = false; }\n\n        //  Turning on\n        if (this.enabled === false)\n        {\n            //  Register, etc\n            this.game.input.interactiveItems.add(this);\n            this.useHandCursor = useHandCursor;\n            this.priorityID = priority;\n\n            for (var i = 0; i < 10; i++)\n            {\n                this._pointerData[i] = {\n                    id: i,\n                    x: 0,\n                    y: 0,\n                    isDown: false,\n                    isUp: false,\n                    isOver: false,\n                    isOut: false,\n                    timeOver: 0,\n                    timeOut: 0,\n                    timeDown: 0,\n                    timeUp: 0,\n                    downDuration: 0,\n                    isDragged: false\n                };\n            }\n\n            this.snapOffset = new Phaser.Point();\n            this.enabled = true;\n            this._wasEnabled = true;\n\n            //  Create the signals the Input component will emit\n            if (this.sprite.events && this.sprite.events.onInputOver === null)\n            {\n                this.sprite.events.onInputOver = new Phaser.Signal();\n                this.sprite.events.onInputOut = new Phaser.Signal();\n                this.sprite.events.onInputDown = new Phaser.Signal();\n                this.sprite.events.onInputUp = new Phaser.Signal();\n                this.sprite.events.onDragStart = new Phaser.Signal();\n                this.sprite.events.onDragStop = new Phaser.Signal();\n            }\n        }\n\n        this.sprite.events.onAddedToGroup.add(this.addedToGroup, this);\n        this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this);\n\n        return this.sprite;\n\n    },\n\n    /**\n    * Handles when the parent Sprite is added to a new Group.\n    *\n    * @method Phaser.InputHandler#addedToGroup\n    * @private\n    */\n    addedToGroup: function () {\n\n        if (this._wasEnabled && !this.enabled)\n        {\n            this.start();\n        }\n\n    },\n\n    /**\n    * Handles when the parent Sprite is removed from a Group.\n    *\n    * @method Phaser.InputHandler#removedFromGroup\n    * @private\n    */\n    removedFromGroup: function () {\n\n        if (this.enabled)\n        {\n            this._wasEnabled = true;\n            this.stop();\n        }\n        else\n        {\n            this._wasEnabled = false;\n        }\n\n    },\n\n    /**\n    * Resets the Input Handler and disables it.\n    * @method Phaser.InputHandler#reset\n    */\n    reset: function () {\n\n        this.enabled = false;\n\n        for (var i = 0; i < 10; i++)\n        {\n            this._pointerData[i] = {\n                id: i,\n                x: 0,\n                y: 0,\n                isDown: false,\n                isUp: false,\n                isOver: false,\n                isOut: false,\n                timeOver: 0,\n                timeOut: 0,\n                timeDown: 0,\n                timeUp: 0,\n                downDuration: 0,\n                isDragged: false\n            };\n        }\n    },\n\n    /**\n    * Stops the Input Handler from running.\n    * @method Phaser.InputHandler#stop\n    */\n    stop: function () {\n\n        //  Turning off\n        if (this.enabled === false)\n        {\n            return;\n        }\n        else\n        {\n            //  De-register, etc\n            this.enabled = false;\n            this.game.input.interactiveItems.remove(this);\n        }\n\n    },\n\n    /**\n    * Clean up memory.\n    * @method Phaser.InputHandler#destroy\n    */\n    destroy: function () {\n\n        if (this.sprite)\n        {\n            if (this._setHandCursor)\n            {\n                this.game.canvas.style.cursor = \"default\";\n                this._setHandCursor = false;\n            }\n\n            this.enabled = false;\n\n            this.game.input.interactiveItems.remove(this);\n\n            this._pointerData.length = 0;\n            this.boundsRect = null;\n            this.boundsSprite = null;\n            this.sprite = null;\n        }\n\n    },\n\n    /**\n    * Checks if the object this InputHandler is bound to is valid for consideration in the Pointer move event.\n    * This is called by Phaser.Pointer and shouldn't typically be called directly.\n    *\n    * @method Phaser.InputHandler#validForInput\n    * @protected\n    * @param {number} highestID - The highest ID currently processed by the Pointer.\n    * @param {number} highestRenderID - The highest Render Order ID currently processed by the Pointer.\n    * @return {boolean} True if the object this InputHandler is bound to should be considered as valid for input detection.\n    */\n    validForInput: function (highestID, highestRenderID) {\n\n        if (this.sprite.scale.x === 0 || this.sprite.scale.y === 0)\n        {\n            return false;\n        }\n\n        if (this.pixelPerfectClick || this.pixelPerfectOver)\n        {\n            return true;\n        }\n\n        if (this.priorityID > highestID || (this.priorityID === highestID && this.sprite._cache[3] < highestRenderID))\n        {\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * The x coordinate of the Input pointer, relative to the top-left of the parent Sprite.\n    * This value is only set when the pointer is over this Sprite.\n    * @method Phaser.InputHandler#pointerX\n    * @param {Phaser.Pointer} pointer\n    * @return {number} The x coordinate of the Input pointer.\n    */\n    pointerX: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].x;\n\n    },\n\n    /**\n    * The y coordinate of the Input pointer, relative to the top-left of the parent Sprite\n    * This value is only set when the pointer is over this Sprite.\n    * @method Phaser.InputHandler#pointerY\n    * @param {Phaser.Pointer} pointer\n    * @return {number} The y coordinate of the Input pointer.\n    */\n    pointerY: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].y;\n\n    },\n\n    /**\n    * If the Pointer is touching the touchscreen, or the mouse button is held down, isDown is set to true.\n    * @method Phaser.InputHandler#pointerDown\n    * @param {Phaser.Pointer} pointer\n    * @return {boolean}\n    */\n    pointerDown: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].isDown;\n\n    },\n\n    /**\n    * If the Pointer is not touching the touchscreen, or the mouse button is up, isUp is set to true\n    * @method Phaser.InputHandler#pointerUp\n    * @param {Phaser.Pointer} pointer\n    * @return {boolean}\n    */\n    pointerUp: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].isUp;\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer first touched the touchscreen.\n    * @method Phaser.InputHandler#pointerTimeDown\n    * @param {Phaser.Pointer} pointer\n    * @return {number}\n    */\n    pointerTimeDown: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].timeDown;\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer left the touchscreen.\n    * @method Phaser.InputHandler#pointerTimeUp\n    * @param {Phaser.Pointer} pointer\n    * @return {number}\n    */\n    pointerTimeUp: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].timeUp;\n\n    },\n\n    /**\n    * Is the Pointer over this Sprite?\n    * @method Phaser.InputHandler#pointerOver\n    * @param {number} [index] - The ID number of a Pointer to check. If you don't provide a number it will check all Pointers.\n    * @return {boolean} True if the given pointer (if a index was given, or any pointer if not) is over this object.\n    */\n    pointerOver: function (index) {\n\n        if (this.enabled)\n        {\n            if (typeof index === 'undefined')\n            {\n                for (var i = 0; i < 10; i++)\n                {\n                    if (this._pointerData[i].isOver)\n                    {\n                        return true;\n                    }\n                }\n            }\n            else\n            {\n                return this._pointerData[index].isOver;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Is the Pointer outside of this Sprite?\n    * @method Phaser.InputHandler#pointerOut\n    * @param {number} [index] - The ID number of a Pointer to check. If you don't provide a number it will check all Pointers.\n    * @return {boolean} True if the given pointer (if a index was given, or any pointer if not) is out of this object.\n    */\n    pointerOut: function (index) {\n\n        if (this.enabled)\n        {\n            if (typeof index === 'undefined')\n            {\n                for (var i = 0; i < 10; i++)\n                {\n                    if (this._pointerData[i].isOut)\n                    {\n                        return true;\n                    }\n                }\n            }\n            else\n            {\n                return this._pointerData[index].isOut;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer first touched the touchscreen.\n    * @method Phaser.InputHandler#pointerTimeOver\n    * @param {Phaser.Pointer} pointer\n    * @return {number}\n    */\n    pointerTimeOver: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].timeOver;\n\n    },\n\n    /**\n    * A timestamp representing when the Pointer left the touchscreen.\n    * @method Phaser.InputHandler#pointerTimeOut\n    * @param {Phaser.Pointer} pointer\n    * @return {number}\n    */\n    pointerTimeOut: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].timeOut;\n\n    },\n\n    /**\n    * Is this sprite being dragged by the mouse or not?\n    * @method Phaser.InputHandler#pointerDragged\n    * @param {Phaser.Pointer} pointer\n    * @return {boolean} True if the pointer is dragging an object, otherwise false.\n    */\n    pointerDragged: function (pointer) {\n\n        pointer = pointer || 0;\n\n        return this._pointerData[pointer].isDragged;\n\n    },\n\n    /**\n    * Checks if the given pointer is over this Sprite and can click it.\n    * @method Phaser.InputHandler#checkPointerDown\n    * @param {Phaser.Pointer} pointer\n    * @return {boolean} True if the pointer is down, otherwise false.\n    */\n    checkPointerDown: function (pointer) {\n\n        if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible)\n        {\n            return false;\n        }\n\n        //  Need to pass it a temp point, in case we need it again for the pixel check\n        if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint))\n        {\n            if (this.pixelPerfectClick)\n            {\n                return this.checkPixel(this._tempPoint.x, this._tempPoint.y);\n            }\n            else\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Checks if the given pointer is over this Sprite.\n    * @method Phaser.InputHandler#checkPointerOver\n    * @param {Phaser.Pointer} pointer\n    * @return {boolean}\n    */\n    checkPointerOver: function (pointer) {\n\n        if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible)\n        {\n            return false;\n        }\n\n        //  Need to pass it a temp point, in case we need it again for the pixel check\n        if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint))\n        {\n            if (this.pixelPerfectOver)\n            {\n                return this.checkPixel(this._tempPoint.x, this._tempPoint.y);\n            }\n            else\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Runs a pixel perfect check against the given x/y coordinates of the Sprite this InputHandler is bound to.\n    * It compares the alpha value of the pixel and if >= InputHandler.pixelPerfectAlpha it returns true.\n    * @method Phaser.InputHandler#checkPixel\n    * @param {number} x - The x coordinate to check.\n    * @param {number} y - The y coordinate to check.\n    * @param {Phaser.Pointer} [pointer] - The pointer to get the x/y coordinate from if not passed as the first two parameters.\n    * @return {boolean} true if there is the alpha of the pixel is >= InputHandler.pixelPerfectAlpha\n    */\n    checkPixel: function (x, y, pointer) {\n\n        //  Grab a pixel from our image into the hitCanvas and then test it\n        if (this.sprite.texture.baseTexture.source)\n        {\n            this.game.input.hitContext.clearRect(0, 0, 1, 1);\n\n            if (x === null && y === null)\n            {\n                //  Use the pointer parameter\n                this.game.input.getLocalPosition(this.sprite, pointer, this._tempPoint);\n\n                var x = this._tempPoint.x;\n                var y = this._tempPoint.y;\n            }\n\n            if (this.sprite.anchor.x !== 0)\n            {\n                x -= -this.sprite.texture.frame.width * this.sprite.anchor.x;\n            }\n\n            if (this.sprite.anchor.y !== 0)\n            {\n                y -= -this.sprite.texture.frame.height * this.sprite.anchor.y;\n            }\n\n            x += this.sprite.texture.frame.x;\n            y += this.sprite.texture.frame.y;\n\n            this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1);\n\n            var rgb = this.game.input.hitContext.getImageData(0, 0, 1, 1);\n\n            if (rgb.data[3] >= this.pixelPerfectAlpha)\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Update.\n    * @method Phaser.InputHandler#update\n    * @protected\n    * @param {Phaser.Pointer} pointer\n    */\n    update: function (pointer) {\n\n        if (this.sprite === null || this.sprite.parent === undefined)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible)\n        {\n            this._pointerOutHandler(pointer);\n            return false;\n        }\n\n        if (this.draggable && this._draggedPointerID == pointer.id)\n        {\n            return this.updateDrag(pointer);\n        }\n        else if (this._pointerData[pointer.id].isOver === true)\n        {\n            if (this.checkPointerOver(pointer))\n            {\n                this._pointerData[pointer.id].x = pointer.x - this.sprite.x;\n                this._pointerData[pointer.id].y = pointer.y - this.sprite.y;\n                return true;\n            }\n            else\n            {\n                this._pointerOutHandler(pointer);\n                return false;\n            }\n        }\n    },\n\n    /**\n    * Internal method handling the pointer over event.\n    * @method Phaser.InputHandler#_pointerOverHandler\n    * @private\n    * @param {Phaser.Pointer} pointer\n    */\n    _pointerOverHandler: function (pointer) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        if (this._pointerData[pointer.id].isOver === false)\n        {\n            this._pointerData[pointer.id].isOver = true;\n            this._pointerData[pointer.id].isOut = false;\n            this._pointerData[pointer.id].timeOver = this.game.time.now;\n            this._pointerData[pointer.id].x = pointer.x - this.sprite.x;\n            this._pointerData[pointer.id].y = pointer.y - this.sprite.y;\n\n            if (this.useHandCursor && this._pointerData[pointer.id].isDragged === false)\n            {\n                this.game.canvas.style.cursor = \"pointer\";\n                this._setHandCursor = true;\n            }\n\n            if (this.sprite && this.sprite.events)\n            {\n                this.sprite.events.onInputOver.dispatch(this.sprite, pointer);\n            }\n        }\n\n    },\n\n    /**\n    * Internal method handling the pointer out event.\n    * @method Phaser.InputHandler#_pointerOutHandler\n    * @private\n    * @param {Phaser.Pointer} pointer\n    */\n    _pointerOutHandler: function (pointer) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        this._pointerData[pointer.id].isOver = false;\n        this._pointerData[pointer.id].isOut = true;\n        this._pointerData[pointer.id].timeOut = this.game.time.now;\n\n        if (this.useHandCursor && this._pointerData[pointer.id].isDragged === false)\n        {\n            this.game.canvas.style.cursor = \"default\";\n            this._setHandCursor = false;\n        }\n\n        if (this.sprite && this.sprite.events)\n        {\n            this.sprite.events.onInputOut.dispatch(this.sprite, pointer);\n        }\n\n    },\n\n    /**\n    * Internal method handling the touched event.\n    * @method Phaser.InputHandler#_touchedHandler\n    * @private\n    * @param {Phaser.Pointer} pointer\n    */\n    _touchedHandler: function (pointer) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        if (this._pointerData[pointer.id].isDown === false && this._pointerData[pointer.id].isOver === true)\n        {\n            if (this.pixelPerfectClick && !this.checkPixel(null, null, pointer))\n            {\n                return;\n            }\n\n            this._pointerData[pointer.id].isDown = true;\n            this._pointerData[pointer.id].isUp = false;\n            this._pointerData[pointer.id].timeDown = this.game.time.now;\n    \n            if (this.sprite && this.sprite.events)\n            {\n                this.sprite.events.onInputDown.dispatch(this.sprite, pointer);\n            }\n\n            //  Start drag\n            if (this.draggable && this.isDragged === false)\n            {\n                this.startDrag(pointer);\n            }\n\n            if (this.bringToTop)\n            {\n                this.sprite.bringToTop();\n            }\n        }\n\n        //  Consume the event?\n        return this.consumePointerEvent;\n\n    },\n\n    /**\n    * Internal method handling the pointer released event.\n    * @method Phaser.InputHandler#_releasedHandler\n    * @private\n    * @param {Phaser.Pointer} pointer\n    */\n    _releasedHandler: function (pointer) {\n\n        if (this.sprite === null)\n        {\n            //  Abort. We've been destroyed.\n            return;\n        }\n\n        //  If was previously touched by this Pointer, check if still is AND still over this item\n        if (this._pointerData[pointer.id].isDown && pointer.isUp)\n        {\n            this._pointerData[pointer.id].isDown = false;\n            this._pointerData[pointer.id].isUp = true;\n            this._pointerData[pointer.id].timeUp = this.game.time.now;\n            this._pointerData[pointer.id].downDuration = this._pointerData[pointer.id].timeUp - this._pointerData[pointer.id].timeDown;\n\n            //  Only release the InputUp signal if the pointer is still over this sprite\n            if (this.checkPointerOver(pointer))\n            {\n                //  Release the inputUp signal and provide optional parameter if pointer is still over the sprite or not\n                if (this.sprite && this.sprite.events)\n                {\n                    this.sprite.events.onInputUp.dispatch(this.sprite, pointer, true);\n                }\n            }\n            else\n            {\n                //  Release the inputUp signal and provide optional parameter if pointer is still over the sprite or not\n                if (this.sprite && this.sprite.events)\n                {\n                    this.sprite.events.onInputUp.dispatch(this.sprite, pointer, false);\n                }\n\n                //  Pointer outside the sprite? Reset the cursor\n                if (this.useHandCursor)\n                {\n                    this.game.canvas.style.cursor = \"default\";\n                    this._setHandCursor = false;\n                }\n            }\n\n            //  Stop drag\n            if (this.draggable && this.isDragged && this._draggedPointerID == pointer.id)\n            {\n                this.stopDrag(pointer);\n            }\n        }\n\n    },\n\n    /**\n    * Updates the Pointer drag on this Sprite.\n    * @method Phaser.InputHandler#updateDrag\n    * @param {Phaser.Pointer} pointer\n    * @return {boolean}\n    */\n    updateDrag: function (pointer) {\n\n        if (pointer.isUp)\n        {\n            this.stopDrag(pointer);\n            return false;\n        }\n\n        if (this.sprite.fixedToCamera)\n        {\n            if (this.allowHorizontalDrag)\n            {\n                this.sprite.cameraOffset.x = pointer.x + this._dragPoint.x + this.dragOffset.x;\n            }\n\n            if (this.allowVerticalDrag)\n            {\n                this.sprite.cameraOffset.y = pointer.y + this._dragPoint.y + this.dragOffset.y;\n            }\n\n            if (this.boundsRect)\n            {\n                this.checkBoundsRect();\n            }\n\n            if (this.boundsSprite)\n            {\n                this.checkBoundsSprite();\n            }\n\n            if (this.snapOnDrag)\n            {\n                this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n            }\n        }\n        else\n        {\n            if (this.allowHorizontalDrag)\n            {\n                this.sprite.x = pointer.x + this._dragPoint.x + this.dragOffset.x;\n            }\n\n            if (this.allowVerticalDrag)\n            {\n                this.sprite.y = pointer.y + this._dragPoint.y + this.dragOffset.y;\n            }\n\n            if (this.boundsRect)\n            {\n                this.checkBoundsRect();\n            }\n\n            if (this.boundsSprite)\n            {\n                this.checkBoundsSprite();\n            }\n\n            if (this.snapOnDrag)\n            {\n                this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n            }\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Returns true if the pointer has entered the Sprite within the specified delay time (defaults to 500ms, half a second)\n    * @method Phaser.InputHandler#justOver\n    * @param {Phaser.Pointer} pointer\n    * @param {number} delay - The time below which the pointer is considered as just over.\n    * @return {boolean}\n    */\n    justOver: function (pointer, delay) {\n\n        pointer = pointer || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointer].isOver && this.overDuration(pointer) < delay);\n\n    },\n\n    /**\n    * Returns true if the pointer has left the Sprite within the specified delay time (defaults to 500ms, half a second)\n    * @method Phaser.InputHandler#justOut\n    * @param {Phaser.Pointer} pointer\n    * @param {number} delay - The time below which the pointer is considered as just out.\n    * @return {boolean}\n    */\n    justOut: function (pointer, delay) {\n\n        pointer = pointer || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointer].isOut && (this.game.time.now - this._pointerData[pointer].timeOut < delay));\n\n    },\n\n    /**\n    * Returns true if the pointer has touched or clicked on the Sprite within the specified delay time (defaults to 500ms, half a second)\n    * @method Phaser.InputHandler#justPressed\n    * @param {Phaser.Pointer} pointer\n    * @param {number} delay - The time below which the pointer is considered as just over.\n    * @return {boolean}\n    */\n    justPressed: function (pointer, delay) {\n\n        pointer = pointer || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointer].isDown && this.downDuration(pointer) < delay);\n\n    },\n\n    /**\n    * Returns true if the pointer was touching this Sprite, but has been released within the specified delay time (defaults to 500ms, half a second)\n    * @method Phaser.InputHandler#justReleased\n    * @param {Phaser.Pointer} pointer\n    * @param {number} delay - The time below which the pointer is considered as just out.\n    * @return {boolean}\n    */\n    justReleased: function (pointer, delay) {\n\n        pointer = pointer || 0;\n        delay = delay || 500;\n\n        return (this._pointerData[pointer].isUp && (this.game.time.now - this._pointerData[pointer].timeUp < delay));\n\n    },\n\n    /**\n    * If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.\n    * @method Phaser.InputHandler#overDuration\n    * @param {Phaser.Pointer} pointer\n    * @return {number} The number of milliseconds the pointer has been over the Sprite, or -1 if not over.\n    */\n    overDuration: function (pointer) {\n\n        pointer = pointer || 0;\n\n        if (this._pointerData[pointer].isOver)\n        {\n            return this.game.time.now - this._pointerData[pointer].timeOver;\n        }\n\n        return -1;\n\n    },\n\n    /**\n    * If the pointer is currently over this Sprite this returns how long it has been there for in milliseconds.\n    * @method Phaser.InputHandler#downDuration\n    * @param {Phaser.Pointer} pointer\n    * @return {number} The number of milliseconds the pointer has been pressed down on the Sprite, or -1 if not over.\n    */\n    downDuration: function (pointer) {\n\n        pointer = pointer || 0;\n\n        if (this._pointerData[pointer].isDown)\n        {\n            return this.game.time.now - this._pointerData[pointer].timeDown;\n        }\n\n        return -1;\n\n    },\n\n    /**\n    * Make this Sprite draggable by the mouse. You can also optionally set mouseStartDragCallback and mouseStopDragCallback\n    * @method Phaser.InputHandler#enableDrag\n    * @param {boolean} [lockCenter=false] - If false the Sprite will drag from where you click it minus the dragOffset. If true it will center itself to the tip of the mouse pointer.\n    * @param {boolean} [bringToTop=false] - If true the Sprite will be bought to the top of the rendering list in its current Group.\n    * @param {boolean} [pixelPerfect=false] - If true it will use a pixel perfect test to see if you clicked the Sprite. False uses the bounding box.\n    * @param {boolean} [alphaThreshold=255] - If using pixel perfect collision this specifies the alpha level from 0 to 255 above which a collision is processed.\n    * @param {Phaser.Rectangle} [boundsRect=null] - If you want to restrict the drag of this sprite to a specific Rectangle, pass the Phaser.Rectangle here, otherwise it's free to drag anywhere.\n    * @param {Phaser.Sprite} [boundsSprite=null] - If you want to restrict the drag of this sprite to within the bounding box of another sprite, pass it here.\n    */\n    enableDrag: function (lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) {\n\n        if (typeof lockCenter == 'undefined') { lockCenter = false; }\n        if (typeof bringToTop == 'undefined') { bringToTop = false; }\n        if (typeof pixelPerfect == 'undefined') { pixelPerfect = false; }\n        if (typeof alphaThreshold == 'undefined') { alphaThreshold = 255; }\n        if (typeof boundsRect == 'undefined') { boundsRect = null; }\n        if (typeof boundsSprite == 'undefined') { boundsSprite = null; }\n\n        this._dragPoint = new Phaser.Point();\n        this.draggable = true;\n        this.bringToTop = bringToTop;\n        this.dragOffset = new Phaser.Point();\n        this.dragFromCenter = lockCenter;\n\n        this.pixelPerfect = pixelPerfect;\n        this.pixelPerfectAlpha = alphaThreshold;\n\n        if (boundsRect)\n        {\n            this.boundsRect = boundsRect;\n        }\n\n        if (boundsSprite)\n        {\n            this.boundsSprite = boundsSprite;\n        }\n\n    },\n\n    /**\n    * Stops this sprite from being able to be dragged. If it is currently the target of an active drag it will be stopped immediately. Also disables any set callbacks.\n    * @method Phaser.InputHandler#disableDrag\n    */\n    disableDrag: function () {\n\n        if (this._pointerData)\n        {\n            for (var i = 0; i < 10; i++)\n            {\n                this._pointerData[i].isDragged = false;\n            }\n        }\n\n        this.draggable = false;\n        this.isDragged = false;\n        this._draggedPointerID = -1;\n\n    },\n\n    /**\n    * Called by Pointer when drag starts on this Sprite. Should not usually be called directly.\n    * @method Phaser.InputHandler#startDrag\n    * @param {Phaser.Pointer} pointer\n    */\n    startDrag: function (pointer) {\n\n        this.isDragged = true;\n        this._draggedPointerID = pointer.id;\n        this._pointerData[pointer.id].isDragged = true;\n\n        if (this.sprite.fixedToCamera)\n        {\n            if (this.dragFromCenter)\n            {\n                this.sprite.centerOn(pointer.x, pointer.y);\n                this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);\n            }\n            else\n            {\n                this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y);\n            }\n        }\n        else\n        {\n            if (this.dragFromCenter)\n            {\n                var bounds = this.sprite.getBounds();\n                this.sprite.x = pointer.x + (this.sprite.x - bounds.centerX);\n                this.sprite.y = pointer.y + (this.sprite.y - bounds.centerY);\n                this._dragPoint.setTo(this.sprite.x - pointer.x, this.sprite.y - pointer.y);\n            }\n            else\n            {\n                this._dragPoint.setTo(this.sprite.x - pointer.x, this.sprite.y - pointer.y);\n            }\n        }\n\n        this.updateDrag(pointer);\n\n        if (this.bringToTop)\n        {\n            this.sprite.bringToTop();\n        }\n\n        this.sprite.events.onDragStart.dispatch(this.sprite, pointer);\n\n    },\n\n    /**\n    * Called by Pointer when drag is stopped on this Sprite. Should not usually be called directly.\n    * @method Phaser.InputHandler#stopDrag\n    * @param {Phaser.Pointer} pointer\n    */\n    stopDrag: function (pointer) {\n\n        this.isDragged = false;\n        this._draggedPointerID = -1;\n        this._pointerData[pointer.id].isDragged = false;\n\n        if (this.snapOnRelease)\n        {\n            if (this.sprite.fixedToCamera)\n            {\n                this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n            }\n            else\n            {\n                this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX);\n                this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY);\n            }\n        }\n\n        this.sprite.events.onDragStop.dispatch(this.sprite, pointer);\n\n        if (this.checkPointerOver(pointer) === false)\n        {\n            this._pointerOutHandler(pointer);\n        }\n\n    },\n\n    /**\n    * Restricts this sprite to drag movement only on the given axis. Note: If both are set to false the sprite will never move!\n    * @method Phaser.InputHandler#setDragLock\n    * @param {boolean} [allowHorizontal=true] - To enable the sprite to be dragged horizontally set to true, otherwise false.\n    * @param {boolean} [allowVertical=true] - To enable the sprite to be dragged vertically set to true, otherwise false.\n    */\n    setDragLock: function (allowHorizontal, allowVertical) {\n\n        if (typeof allowHorizontal == 'undefined') { allowHorizontal = true; }\n        if (typeof allowVertical == 'undefined') { allowVertical = true; }\n\n        this.allowHorizontalDrag = allowHorizontal;\n        this.allowVerticalDrag = allowVertical;\n\n    },\n\n    /**\n    * Make this Sprite snap to the given grid either during drag or when it's released.\n    * For example 16x16 as the snapX and snapY would make the sprite snap to every 16 pixels.\n    * @method Phaser.InputHandler#enableSnap\n    * @param {number} snapX - The width of the grid cell to snap to.\n    * @param {number} snapY - The height of the grid cell to snap to.\n    * @param {boolean} [onDrag=true] - If true the sprite will snap to the grid while being dragged.\n    * @param {boolean} [onRelease=false] - If true the sprite will snap to the grid when released.\n    * @param {number} [snapOffsetX=0] - Used to offset the top-left starting point of the snap grid.\n    * @param {number} [snapOffsetX=0] - Used to offset the top-left starting point of the snap grid.\n    */\n    enableSnap: function (snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) {\n\n        if (typeof onDrag == 'undefined') { onDrag = true; }\n        if (typeof onRelease == 'undefined') { onRelease = false; }\n        if (typeof snapOffsetX == 'undefined') { snapOffsetX = 0; }\n        if (typeof snapOffsetY == 'undefined') { snapOffsetY = 0; }\n\n        this.snapX = snapX;\n        this.snapY = snapY;\n        this.snapOffsetX = snapOffsetX;\n        this.snapOffsetY = snapOffsetY;\n        this.snapOnDrag = onDrag;\n        this.snapOnRelease = onRelease;\n\n    },\n\n    /**\n    * Stops the sprite from snapping to a grid during drag or release.\n    * @method Phaser.InputHandler#disableSnap\n    */\n    disableSnap: function () {\n\n        this.snapOnDrag = false;\n        this.snapOnRelease = false;\n\n    },\n\n    /**\n    * Bounds Rect check for the sprite drag\n    * @method Phaser.InputHandler#checkBoundsRect\n    */\n    checkBoundsRect: function () {\n\n        if (this.sprite.fixedToCamera)\n        {\n            if (this.sprite.cameraOffset.x < this.boundsRect.left)\n            {\n                this.sprite.cameraOffset.x = this.boundsRect.cameraOffset.x;\n            }\n            else if ((this.sprite.cameraOffset.x + this.sprite.width) > this.boundsRect.right)\n            {\n                this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width;\n            }\n\n            if (this.sprite.cameraOffset.y < this.boundsRect.top)\n            {\n                this.sprite.cameraOffset.y = this.boundsRect.top;\n            }\n            else if ((this.sprite.cameraOffset.y + this.sprite.height) > this.boundsRect.bottom)\n            {\n                this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height;\n            }\n        }\n        else\n        {\n            if (this.sprite.x < this.boundsRect.left)\n            {\n                this.sprite.x = this.boundsRect.x;\n            }\n            else if ((this.sprite.x + this.sprite.width) > this.boundsRect.right)\n            {\n                this.sprite.x = this.boundsRect.right - this.sprite.width;\n            }\n\n            if (this.sprite.y < this.boundsRect.top)\n            {\n                this.sprite.y = this.boundsRect.top;\n            }\n            else if ((this.sprite.y + this.sprite.height) > this.boundsRect.bottom)\n            {\n                this.sprite.y = this.boundsRect.bottom - this.sprite.height;\n            }\n        }\n\n    },\n\n    /**\n    * Parent Sprite Bounds check for the sprite drag.\n    * @method Phaser.InputHandler#checkBoundsSprite\n    */\n    checkBoundsSprite: function () {\n\n        if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera)\n        {\n            if (this.sprite.cameraOffset.x < this.boundsSprite.camerOffset.x)\n            {\n                this.sprite.cameraOffset.x = this.boundsSprite.camerOffset.x;\n            }\n            else if ((this.sprite.cameraOffset.x + this.sprite.width) > (this.boundsSprite.camerOffset.x + this.boundsSprite.width))\n            {\n                this.sprite.cameraOffset.x = (this.boundsSprite.camerOffset.x + this.boundsSprite.width) - this.sprite.width;\n            }\n\n            if (this.sprite.cameraOffset.y < this.boundsSprite.camerOffset.y)\n            {\n                this.sprite.cameraOffset.y = this.boundsSprite.camerOffset.y;\n            }\n            else if ((this.sprite.cameraOffset.y + this.sprite.height) > (this.boundsSprite.camerOffset.y + this.boundsSprite.height))\n            {\n                this.sprite.cameraOffset.y = (this.boundsSprite.camerOffset.y + this.boundsSprite.height) - this.sprite.height;\n            }\n        }\n        else\n        {\n            if (this.sprite.x < this.boundsSprite.x)\n            {\n                this.sprite.x = this.boundsSprite.x;\n            }\n            else if ((this.sprite.x + this.sprite.width) > (this.boundsSprite.x + this.boundsSprite.width))\n            {\n                this.sprite.x = (this.boundsSprite.x + this.boundsSprite.width) - this.sprite.width;\n            }\n\n            if (this.sprite.y < this.boundsSprite.y)\n            {\n                this.sprite.y = this.boundsSprite.y;\n            }\n            else if ((this.sprite.y + this.sprite.height) > (this.boundsSprite.y + this.boundsSprite.height))\n            {\n                this.sprite.y = (this.boundsSprite.y + this.boundsSprite.height) - this.sprite.height;\n            }\n        }\n\n    }\n\n};\n\nPhaser.InputHandler.prototype.constructor = Phaser.InputHandler;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Events\n*\n* @classdesc The Events component is a collection of events fired by the parent game object.\n*\n* For example to tell when a Sprite has been added to a new group:\n*\n* `sprite.events.onAddedToGroup.add(yourFunction, this);`\n*\n* Where `yourFunction` is the function you want called when this event occurs.\n*\n* Note that the Input related events only exist if the Sprite has had `inputEnabled` set to `true`.\n*\n* @constructor\n*\n* @param {Phaser.Sprite} sprite - A reference to Description.\n*/\nPhaser.Events = function (sprite) {\n\n    this.parent = sprite;\n\n    this.onAddedToGroup = new Phaser.Signal();\n    this.onRemovedFromGroup = new Phaser.Signal();\n    this.onKilled = new Phaser.Signal();\n    this.onRevived = new Phaser.Signal();\n    this.onOutOfBounds = new Phaser.Signal();\n    this.onEnterBounds = new Phaser.Signal();\n\n    this.onInputOver = null;\n    this.onInputOut = null;\n    this.onInputDown = null;\n    this.onInputUp = null;\n    this.onDragStart = null;\n    this.onDragStop = null;\n\n    this.onAnimationStart = null;\n    this.onAnimationComplete = null;\n    this.onAnimationLoop = null;\n\n};\n\nPhaser.Events.prototype = {\n\n    destroy: function () {\n\n        this.parent = null;\n        this.onAddedToGroup.dispose();\n        this.onRemovedFromGroup.dispose();\n        this.onKilled.dispose();\n        this.onRevived.dispose();\n        this.onOutOfBounds.dispose();\n\n        if (this.onInputOver)\n        {\n            this.onInputOver.dispose();\n            this.onInputOut.dispose();\n            this.onInputDown.dispose();\n            this.onInputUp.dispose();\n            this.onDragStart.dispose();\n            this.onDragStop.dispose();\n        }\n\n        if (this.onAnimationStart)\n        {\n            this.onAnimationStart.dispose();\n            this.onAnimationComplete.dispose();\n            this.onAnimationLoop.dispose();\n        }\n\n    }\n\n};\n\nPhaser.Events.prototype.constructor = Phaser.Events;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Game Object Factory is a quick way to create all of the different sorts of core objects that Phaser uses.\n*\n* @class Phaser.GameObjectFactory\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.GameObjectFactory = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world.\n    */\n    this.world = this.game.world;\n\n};\n\nPhaser.GameObjectFactory.prototype = {\n\n    /**\n    * Adds an existing object to the game world.\n    * @method Phaser.GameObjectFactory#existing\n    * @param {*} object - An instance of Phaser.Sprite, Phaser.Button or any other display object..\n    * @return {*} The child that was added to the Group.\n    */\n    existing: function (object) {\n\n        return this.world.add(object);\n\n    },\n\n    /**\n    * Create a new `Image` object. An Image is a light-weight object you can use to display anything that doesn't need physics or animation.\n    * It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.\n    *\n    * @method Phaser.GameObjectFactory#image\n    * @param {number} x - X position of the image.\n    * @param {number} y - Y position of the image.\n    * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @returns {Phaser.Sprite} the newly created sprite object.\n    */\n    image: function (x, y, key, frame, group) {\n\n        if (typeof group === 'undefined') { group = this.world; }\n\n        return group.add(new Phaser.Image(this.game, x, y, key, frame));\n\n    },\n\n    /**\n    * Create a new Sprite with specific position and sprite sheet key.\n    *\n    * @method Phaser.GameObjectFactory#sprite\n    * @param {number} x - X position of the new sprite.\n    * @param {number} y - Y position of the new sprite.\n    * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @returns {Phaser.Sprite} the newly created sprite object.\n    */\n    sprite: function (x, y, key, frame, group) {\n\n        if (typeof group === 'undefined') { group = this.world; }\n\n        return group.create(x, y, key, frame);\n\n    },\n\n    /**\n    * Create a tween object for a specific object. The object can be any JavaScript object or Phaser object such as Sprite.\n    *\n    * @method Phaser.GameObjectFactory#tween\n    * @param {object} obj - Object the tween will be run on.\n    * @return {Phaser.Tween} The newly created Phaser.Tween object.\n    */\n    tween: function (obj) {\n\n        return this.game.tweens.create(obj);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    *\n    * @method Phaser.GameObjectFactory#group\n    * @param {any} [parent] - The parent Group or DisplayObjectContainer that will hold this group, if any. If set to null the Group won't be added to the display list. If undefined it will be added to World by default.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @param {boolean} [enableBody=false] - If true all Sprites created with `Group.create` or `Group.createMulitple` will have a physics body created on them. Change the body type with physicsBodyType.\n    * @param {number} [physicsBodyType=0] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.\n    * @return {Phaser.Group} The newly created group.\n    */\n    group: function (parent, name, addToStage, enableBody, physicsBodyType) {\n\n        return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    * A Physics Group is the same as an ordinary Group except that is has enableBody turned on by default, so any Sprites it creates\n    * are automatically given a physics body.\n    *\n    * @method Phaser.GameObjectFactory#group\n    * @param {number} [physicsBodyType=Phaser.Physics.ARCADE] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.\n    * @param {any} [parent] - The parent Group or DisplayObjectContainer that will hold this group, if any. If set to null the Group won't be added to the display list. If undefined it will be added to World by default.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @return {Phaser.Group} The newly created group.\n    */\n    physicsGroup: function (physicsBodyType, parent, name, addToStage) {\n\n        return new Phaser.Group(this.game, parent, name, addToStage, true, physicsBodyType);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    *\n    * @method Phaser.GameObjectFactory#spriteBatch\n    * @param {any} parent - The parent Group or DisplayObjectContainer that will hold this group, if any.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @return {Phaser.Group} The newly created group.\n    */\n    spriteBatch: function (parent, name, addToStage) {\n\n        if (typeof name === 'undefined') { name = 'group'; }\n        if (typeof addToStage === 'undefined') { addToStage = false; }\n\n        return new Phaser.SpriteBatch(this.game, parent, name, addToStage);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectFactory#audio\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created text object.\n    */\n    audio: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectFactory#sound\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created text object.\n    */\n    sound: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n    * Creates a new TileSprite object.\n    *\n    * @method Phaser.GameObjectFactory#tileSprite\n    * @param {number} x - The x coordinate (in world space) to position the TileSprite at.\n    * @param {number} y - The y coordinate (in world space) to position the TileSprite at.\n    * @param {number} width - The width of the TileSprite.\n    * @param {number} height - The height of the TileSprite.\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.TileSprite} The newly created tileSprite object.\n    */\n    tileSprite: function (x, y, width, height, key, frame, group) {\n\n        if (typeof group === 'undefined') { group = this.world; }\n\n        return group.add(new Phaser.TileSprite(this.game, x, y, width, height, key, frame));\n\n    },\n\n    /**\n    * Creates a new Text object.\n    *\n    * @method Phaser.GameObjectFactory#text\n    * @param {number} x - X position of the new text object.\n    * @param {number} y - Y position of the new text object.\n    * @param {string} text - The actual text that will be written.\n    * @param {object} style - The style object containing style attributes like font, font size , etc.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.Text} The newly created text object.\n    */\n    text: function (x, y, text, style, group) {\n\n        if (typeof group === 'undefined') { group = this.world; }\n\n        return group.add(new Phaser.Text(this.game, x, y, text, style));\n\n    },\n\n    /**\n    * Creates a new Button object.\n    *\n    * @method Phaser.GameObjectFactory#button\n    * @param {number} [x] X position of the new button object.\n    * @param {number} [y] Y position of the new button object.\n    * @param {string} [key] The image key as defined in the Game.Cache to use as the texture for this button.\n    * @param {function} [callback] The function to call when this button is pressed\n    * @param {object} [callbackContext] The context in which the callback will be called (usually 'this')\n    * @param {string|number} [overFrame] This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [outFrame] This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [downFrame] This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [upFrame] This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.Button} The newly created button object.\n    */\n    button: function (x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group) {\n\n        if (typeof group === 'undefined') { group = this.world; }\n\n        return group.add(new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame));\n\n    },\n\n    /**\n    * Creates a new Graphics object.\n    *\n    * @method Phaser.GameObjectFactory#graphics\n    * @param {number} x - X position of the new graphics object.\n    * @param {number} y - Y position of the new graphics object.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.Graphics} The newly created graphics object.\n    */\n    graphics: function (x, y, group) {\n\n        if (typeof group === 'undefined') { group = this.world; }\n\n        return group.add(new Phaser.Graphics(this.game, x, y));\n\n    },\n\n    /**\n    * Emitter is a lightweight particle emitter. It can be used for one-time explosions or for\n    * continuous effects like rain and fire. All it really does is launch Particle objects out\n    * at set intervals, and fixes their positions and velocities accorindgly.\n    *\n    * @method Phaser.GameObjectFactory#emitter\n    * @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [maxParticles=50] - The total number of particles in this emitter.\n    * @return {Phaser.Emitter} The newly created emitter object.\n    */\n    emitter: function (x, y, maxParticles) {\n\n        return this.game.particles.add(new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles));\n\n    },\n\n    /**\n    * Create a new RetroFont object to be used as a texture for an Image or Sprite and optionally add it to the Cache.\n    * A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.\n    * If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText\n    * is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.\n    * The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,\n    * i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.\n    *\n    * @method Phaser.GameObjectFactory#retroFont\n    * @param {string} font - The key of the image in the Game.Cache that the RetroFont will use.\n    * @param {number} characterWidth - The width of each character in the font set.\n    * @param {number} characterHeight - The height of each character in the font set.\n    * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.\n    * @param {number} charsPerRow - The number of characters per row in the font set.\n    * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.\n    * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.\n    * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.\n    * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.\n    * @return {Phaser.RetroFont} The newly created RetroFont texture which can be applied to an Image or Sprite.\n    */\n    retroFont: function (font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {\n\n        return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);\n\n    },\n\n    /**\n    * Create a new BitmapText object.\n    *\n    * @method Phaser.GameObjectFactory#bitmapText\n    * @param {number} x - X position of the new bitmapText object.\n    * @param {number} y - Y position of the new bitmapText object.\n    * @param {string} font - The key of the BitmapText font as stored in Game.Cache.\n    * @param {string} [text] - The actual text that will be rendered. Can be set later via BitmapText.text.\n    * @param {number} [size] - The size the font will be rendered in, in pixels.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.BitmapText} The newly created bitmapText object.\n    */\n    bitmapText: function (x, y, font, text, size, group) {\n\n        if (typeof group === 'undefined') { group = this.world; }\n\n        return group.add(new Phaser.BitmapText(this.game, x, y, font, text, size));\n\n    },\n\n    /**\n    * Creates a new Phaser.Tilemap object. The map can either be populated with data from a Tiled JSON file or from a CSV file.\n    * To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\n    * When using CSV data you must provide the key and the tileWidth and tileHeight parameters.\n    * If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\n    * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.\n    *\n    * @method Phaser.GameObjectFactory#tilemap\n    * @param {string} [key] - The key of the tilemap data as stored in the Cache. If you're creating a blank map either leave this parameter out or pass `null`.\n    * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @return {Phaser.Tilemap} The newly created tilemap object.\n    */\n    tilemap: function (key, tileWidth, tileHeight, width, height) {\n\n        return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);\n\n    },\n\n    /**\n    * A dynamic initially blank canvas to which images can be drawn.\n    *\n    * @method Phaser.GameObjectFactory#renderTexture\n    * @param {number} [width=100] - the width of the RenderTexture.\n    * @param {number} [height=100] - the height of the RenderTexture.\n    * @param {string} [key=''] - Asset key for the RenderTexture when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this RenderTexture be added to the Game.Cache? If so you can retrieve it with Cache.getTexture(key)\n    * @return {Phaser.RenderTexture} The newly created RenderTexture object.\n    */\n    renderTexture: function (width, height, key, addToCache) {\n\n        if (typeof key === 'undefined' || key === '') { key = this.game.rnd.uuid(); }\n        if (typeof addToCache === 'undefined') { addToCache = false; }\n\n        var texture = new Phaser.RenderTexture(this.game, width, height, key);\n\n        if (addToCache)\n        {\n            this.game.cache.addRenderTexture(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * A BitmapData object which can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.\n    *\n    * @method Phaser.GameObjectFactory#bitmapData\n    * @param {number} [width=100] - The width of the BitmapData in pixels.\n    * @param {number} [height=100] - The height of the BitmapData in pixels.\n    * @param {string} [key=''] - Asset key for the BitmapData when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this BitmapData be added to the Game.Cache? If so you can retrieve it with Cache.getBitmapData(key)\n    * @return {Phaser.BitmapData} The newly created BitmapData object.\n    */\n    bitmapData: function (width, height, key, addToCache) {\n\n        if (typeof addToCache === 'undefined') { addToCache = false; }\n        if (typeof key === 'undefined' || key === '') { key = this.game.rnd.uuid(); }\n\n        var texture = new Phaser.BitmapData(this.game, key, width, height);\n\n        if (addToCache)\n        {\n            this.game.cache.addBitmapData(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * A WebGL shader/filter that can be applied to Sprites.\n    *\n    * @method Phaser.GameObjectFactory#filter\n    * @param {string} filter - The name of the filter you wish to create, for example HueRotate or SineWave.\n    * @param {any} - Whatever parameters are needed to be passed to the filter init function.\n    * @return {Phaser.Filter} The newly created Phaser.Filter object.\n    */\n    filter: function (filter) {\n\n        var args = Array.prototype.splice.call(arguments, 1);\n\n        var filter = new Phaser.Filter[filter](this.game);\n\n        filter.init.apply(filter, args);\n\n        return filter;\n\n    }\n\n};\n\nPhaser.GameObjectFactory.prototype.constructor = Phaser.GameObjectFactory;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Game Object Creator is a quick way to create all of the different sorts of core objects that Phaser uses, but not add them to the game world.\n* Use the GameObjectFactory to create and add the objects into the world.\n*\n* @class Phaser.GameObjectCreator\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.GameObjectCreator = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.World} world - A reference to the game world.\n    */\n    this.world = this.game.world;\n\n};\n\nPhaser.GameObjectCreator.prototype = {\n\n    /**\n    * Create a new `Image` object. An Image is a light-weight object you can use to display anything that doesn't need physics or animation.\n    * It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.\n    *\n    * @method Phaser.GameObjectCreator#image\n    * @param {number} x - X position of the image.\n    * @param {number} y - Y position of the image.\n    * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n    * @returns {Phaser.Sprite} the newly created sprite object.\n    */\n    image: function (x, y, key, frame) {\n\n        return new Phaser.Image(this.game, x, y, key, frame);\n\n    },\n\n    /**\n    * Create a new Sprite with specific position and sprite sheet key.\n    *\n    * @method Phaser.GameObjectCreator#sprite\n    * @param {number} x - X position of the new sprite.\n    * @param {number} y - Y position of the new sprite.\n    * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n    * @returns {Phaser.Sprite} the newly created sprite object.\n    */\n    sprite: function (x, y, key, frame) {\n\n        return new Phaser.Sprite(this.game, x, y, key, frame);\n\n    },\n\n    /**\n    * Create a tween object for a specific object. The object can be any JavaScript object or Phaser object such as Sprite.\n    *\n    * @method Phaser.GameObjectCreator#tween\n    * @param {object} obj - Object the tween will be run on.\n    * @return {Phaser.Tween} The Tween object.\n    */\n    tween: function (obj) {\n\n        return new Phaser.Tween(obj, this.game);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    *\n    * @method Phaser.GameObjectCreator#group\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @param {boolean} [enableBody=false] - If true all Sprites created with `Group.create` or `Group.createMulitple` will have a physics body created on them. Change the body type with physicsBodyType.\n    * @param {number} [physicsBodyType=0] - If enableBody is true this is the type of physics body that is created on new Sprites. Phaser.Physics.ARCADE, Phaser.Physics.P2, Phaser.Physics.NINJA, etc.\n    * @return {Phaser.Group} The newly created group.\n    */\n    group: function (parent, name, addToStage, enableBody, physicsBodyType) {\n\n        return new Phaser.Group(this.game, null, name, addToStage, enableBody, physicsBodyType);\n\n    },\n\n    /**\n    * A Group is a container for display objects that allows for fast pooling, recycling and collision checks.\n    *\n    * @method Phaser.GameObjectCreator#spriteBatch\n    * @param {any} parent - The parent Group or DisplayObjectContainer that will hold this group, if any.\n    * @param {string} [name='group'] - A name for this Group. Not used internally but useful for debugging.\n    * @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n    * @return {Phaser.Group} The newly created group.\n    */\n    spriteBatch: function (parent, name, addToStage) {\n\n        if (typeof name === 'undefined') { name = 'group'; }\n        if (typeof addToStage === 'undefined') { addToStage = false; }\n\n        return new Phaser.SpriteBatch(this.game, parent, name, addToStage);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectCreator#audio\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created text object.\n    */\n    audio: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n    * Creates a new Sound object.\n    *\n    * @method Phaser.GameObjectCreator#sound\n    * @param {string} key - The Game.cache key of the sound that this object will use.\n    * @param {number} [volume=1] - The volume at which the sound will be played.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The newly created text object.\n    */\n    sound: function (key, volume, loop, connect) {\n\n        return this.game.sound.add(key, volume, loop, connect);\n\n    },\n\n    /**\n    * Creates a new TileSprite object.\n    *\n    * @method Phaser.GameObjectCreator#tileSprite\n    * @param {number} x - The x coordinate (in world space) to position the TileSprite at.\n    * @param {number} y - The y coordinate (in world space) to position the TileSprite at.\n    * @param {number} width - The width of the TileSprite.\n    * @param {number} height - The height of the TileSprite.\n    * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n    * @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n    * @return {Phaser.TileSprite} The newly created tileSprite object.\n    */\n    tileSprite: function (x, y, width, height, key, frame) {\n\n        return new Phaser.TileSprite(this.game, x, y, width, height, key, frame);\n\n    },\n\n    /**\n    * Creates a new Text object.\n    *\n    * @method Phaser.GameObjectCreator#text\n    * @param {number} x - X position of the new text object.\n    * @param {number} y - Y position of the new text object.\n    * @param {string} text - The actual text that will be written.\n    * @param {object} style - The style object containing style attributes like font, font size , etc.\n    * @return {Phaser.Text} The newly created text object.\n    */\n    text: function (x, y, text, style) {\n\n        return new Phaser.Text(this.game, x, y, text, style);\n\n    },\n\n    /**\n    * Creates a new Button object.\n    *\n    * @method Phaser.GameObjectCreator#button\n    * @param {number} [x] X position of the new button object.\n    * @param {number} [y] Y position of the new button object.\n    * @param {string} [key] The image key as defined in the Game.Cache to use as the texture for this button.\n    * @param {function} [callback] The function to call when this button is pressed\n    * @param {object} [callbackContext] The context in which the callback will be called (usually 'this')\n    * @param {string|number} [overFrame] This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [outFrame] This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [downFrame] This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.\n    * @param {string|number} [upFrame] This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.\n    * @return {Phaser.Button} The newly created button object.\n    */\n    button: function (x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {\n\n        return new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame);\n\n    },\n\n    /**\n    * Creates a new Graphics object.\n    *\n    * @method Phaser.GameObjectCreator#graphics\n    * @param {number} x - X position of the new graphics object.\n    * @param {number} y - Y position of the new graphics object.\n    * @return {Phaser.Graphics} The newly created graphics object.\n    */\n    graphics: function (x, y) {\n\n        return new Phaser.Graphics(this.game, x, y);\n\n    },\n\n    /**\n    * Emitter is a lightweight particle emitter. It can be used for one-time explosions or for\n    * continuous effects like rain and fire. All it really does is launch Particle objects out\n    * at set intervals, and fixes their positions and velocities accorindgly.\n    *\n    * @method Phaser.GameObjectCreator#emitter\n    * @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.\n    * @param {number} [maxParticles=50] - The total number of particles in this emitter.\n    * @return {Phaser.Emitter} The newly created emitter object.\n    */\n    emitter: function (x, y, maxParticles) {\n\n        return new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles);\n\n    },\n\n    /**\n    * Create a new RetroFont object to be used as a texture for an Image or Sprite and optionally add it to the Cache.\n    * A RetroFont uses a bitmap which contains fixed with characters for the font set. You use character spacing to define the set.\n    * If you need variable width character support then use a BitmapText object instead. The main difference between a RetroFont and a BitmapText\n    * is that a RetroFont creates a single texture that you can apply to a game object, where-as a BitmapText creates one Sprite object per letter of text.\n    * The texture can be asssigned or one or multiple images/sprites, but note that the text the RetroFont uses will be shared across them all,\n    * i.e. if you need each Image to have different text in it, then you need to create multiple RetroFont objects.\n    *\n    * @method Phaser.GameObjectCreator#retroFont\n    * @param {string} font - The key of the image in the Game.Cache that the RetroFont will use.\n    * @param {number} characterWidth - The width of each character in the font set.\n    * @param {number} characterHeight - The height of each character in the font set.\n    * @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.\n    * @param {number} charsPerRow - The number of characters per row in the font set.\n    * @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.\n    * @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.\n    * @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.\n    * @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.\n    * @return {Phaser.RetroFont} The newly created RetroFont texture which can be applied to an Image or Sprite.\n    */\n    retroFont: function (font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {\n\n        return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset);\n\n    },\n\n    /**\n    * Create a new BitmapText object.\n    *\n    * @method Phaser.GameObjectCreator#bitmapText\n    * @param {number} x - X position of the new bitmapText object.\n    * @param {number} y - Y position of the new bitmapText object.\n    * @param {string} font - The key of the BitmapText font as stored in Game.Cache.\n    * @param {string} [text] - The actual text that will be rendered. Can be set later via BitmapText.text.\n    * @param {number} [size] - The size the font will be rendered in, in pixels.\n    * @return {Phaser.BitmapText} The newly created bitmapText object.\n    */\n    bitmapText: function (x, y, font, text, size) {\n\n        return new Phaser.BitmapText(this.game, x, y, font, text, size);\n\n    },\n\n    /**\n    * Creates a new Phaser.Tilemap object. The map can either be populated with data from a Tiled JSON file or from a CSV file.\n    * To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\n    * When using CSV data you must provide the key and the tileWidth and tileHeight parameters.\n    * If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\n    * Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.\n    *\n    * @method Phaser.GameObjectCreator#tilemap\n    * @param {string} [key] - The key of the tilemap data as stored in the Cache. If you're creating a blank map either leave this parameter out or pass `null`.\n    * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    */\n    tilemap: function (key, tileWidth, tileHeight, width, height) {\n\n        return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height);\n\n    },\n\n    /**\n    * A dynamic initially blank canvas to which images can be drawn.\n    *\n    * @method Phaser.GameObjectCreator#renderTexture\n    * @param {number} [width=100] - the width of the RenderTexture.\n    * @param {number} [height=100] - the height of the RenderTexture.\n    * @param {string} [key=''] - Asset key for the RenderTexture when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this RenderTexture be added to the Game.Cache? If so you can retrieve it with Cache.getTexture(key)\n    * @return {Phaser.RenderTexture} The newly created RenderTexture object.\n    */\n    renderTexture: function (width, height, key, addToCache) {\n\n        if (typeof key === 'undefined' || key === '') { key = this.game.rnd.uuid(); }\n        if (typeof addToCache === 'undefined') { addToCache = false; }\n\n        var texture = new Phaser.RenderTexture(this.game, width, height, key);\n\n        if (addToCache)\n        {\n            this.game.cache.addRenderTexture(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * A BitmapData object which can be manipulated and drawn to like a traditional Canvas object and used to texture Sprites.\n    *\n    * @method Phaser.GameObjectCreator#bitmapData\n    * @param {number} [width=100] - The width of the BitmapData in pixels.\n    * @param {number} [height=100] - The height of the BitmapData in pixels.\n    * @param {string} [key=''] - Asset key for the BitmapData when stored in the Cache (see addToCache parameter).\n    * @param {boolean} [addToCache=false] - Should this BitmapData be added to the Game.Cache? If so you can retrieve it with Cache.getBitmapData(key)\n    * @return {Phaser.BitmapData} The newly created BitmapData object.\n    */\n    bitmapData: function (width, height, key, addToCache) {\n\n        if (typeof addToCache === 'undefined') { addToCache = false; }\n        if (typeof key === 'undefined' || key === '') { key = this.game.rnd.uuid(); }\n\n        var texture = new Phaser.BitmapData(this.game, key, width, height);\n\n        if (addToCache)\n        {\n            this.game.cache.addBitmapData(key, texture);\n        }\n\n        return texture;\n\n    },\n\n    /**\n    * A WebGL shader/filter that can be applied to Sprites.\n    *\n    * @method Phaser.GameObjectCreator#filter\n    * @param {string} filter - The name of the filter you wish to create, for example HueRotate or SineWave.\n    * @param {any} - Whatever parameters are needed to be passed to the filter init function.\n    * @return {Phaser.Filter} The newly created Phaser.Filter object.\n    */\n    filter: function (filter) {\n\n        var args = Array.prototype.splice.call(arguments, 1);\n\n        var filter = new Phaser.Filter[filter](this.game);\n\n        filter.init.apply(filter, args);\n\n        return filter;\n\n    }\n\n};\n\nPhaser.GameObjectCreator.prototype.constructor = Phaser.GameObjectCreator;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new BitmapData object.\n*\n* @class Phaser.BitmapData\n*\n* @classdesc A BitmapData object contains a Canvas element to which you can draw anything you like via normal Canvas context operations.\n* A single BitmapData can be used as the texture one or many Images/Sprites. So if you need to dynamically create a Sprite texture then they are a good choice.\n*\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {string} key - Internal Phaser reference key for the render texture.\n* @param {number} [width=100] - The width of the BitmapData in pixels.\n* @param {number} [height=100] - The height of the BitmapData in pixels.\n*/\nPhaser.BitmapData = function (game, key, width, height) {\n\n    if (typeof width === 'undefined') { width = 100; }\n    if (typeof height === 'undefined') { height = 100; }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} key - The key of the BitmapData in the Cache, if stored there.\n    */\n    this.key = key;\n\n    /**\n    * @property {number} width - The width of the BitmapData in pixels.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height of the BitmapData in pixels.\n    */\n    this.height = height;\n\n    /**\n    * @property {HTMLCanvasElement} canvas - The canvas to which this BitmapData draws.\n    * @default\n    */\n    this.canvas = Phaser.Canvas.create(width, height, '', true);\n\n    /**\n    * @property {CanvasRenderingContext2D} context - The 2d context of the canvas.\n    * @default\n    */\n    this.context = this.canvas.getContext('2d');\n\n    /**\n    * @property {CanvasRenderingContext2D} ctx - A reference to BitmapData.context.\n    */\n    this.ctx = this.context;\n\n    /**\n    * @property {ImageData} imageData - The context image data.\n    */\n    this.imageData = this.context.getImageData(0, 0, width, height);\n\n    /**\n    * @property {Uint8ClampedArray} data - A Uint8ClampedArray view into BitmapData.buffer.\n    */\n    this.data = this.imageData.data;\n\n    /**\n    * @property {Uint32Array} pixels - An Uint32Array view into BitmapData.buffer.\n    */\n    this.pixels = null;\n\n    /**\n    * @property {ArrayBuffer} buffer - An ArrayBuffer the same size as the context ImageData.\n    */\n    if (this.imageData.data.buffer)\n    {\n        this.buffer = this.imageData.data.buffer;\n        this.pixels = new Uint32Array(this.buffer);\n    }\n    else\n    {\n        if (window['ArrayBuffer'])\n        {\n            this.buffer = new ArrayBuffer(this.imageData.data.length);\n            this.pixels = new Uint32Array(this.buffer);\n        }\n        else\n        {\n            this.pixels = this.imageData.data;\n        }\n    }\n\n    /**\n    * @property {PIXI.BaseTexture} baseTexture - The PIXI.BaseTexture.\n    * @default\n    */\n    this.baseTexture = new PIXI.BaseTexture(this.canvas);\n\n    /**\n    * @property {PIXI.Texture} texture - The PIXI.Texture.\n    * @default\n    */\n    this.texture = new PIXI.Texture(this.baseTexture);\n\n    /**\n    * @property {Phaser.Frame} textureFrame - The Frame this BitmapData uses for rendering.\n    * @default\n    */\n    this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, 'bitmapData', game.rnd.uuid());\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.BITMAPDATA;\n\n    /**\n    * @property {boolean} disableTextureUpload - If disableTextureUpload is true this BitmapData will never send its image data to the GPU when its dirty flag is true.\n    */\n    this.disableTextureUpload = false;\n\n    /**\n    * @property {boolean} dirty - If dirty this BitmapData will be re-rendered.\n    */\n    this.dirty = false;\n\n    //  Aliases\n    this.cls = this.clear;\n    this.update = this.refreshBuffer;\n\n    /**\n    * @property {number} _tempR - Internal cache var.\n    * @private\n    */\n    this._tempR = 0;\n\n    /**\n    * @property {number} _tempG - Internal cache var.\n    * @private\n    */\n    this._tempG = 0;\n\n    /**\n    * @property {number} _tempB - Internal cache var.\n    * @private\n    */\n    this._tempB = 0;\n\n};\n\nPhaser.BitmapData.prototype = {\n\n    /**\n    * Updates the given objects so that they use this BitmapData as their texture. This will replace any texture they will currently have set.\n    *\n    * @method Phaser.BitmapData#add\n    * @param {Phaser.Sprite|Phaser.Sprite[]|Phaser.Image|Phaser.Image[]} object - Either a single Sprite/Image or an Array of Sprites/Images.\n    */\n    add: function (object) {\n\n        if (Array.isArray(object))\n        {\n            for (var i = 0; i < object.length; i++)\n            {\n                if (object[i]['loadTexture'])\n                {\n                    object[i].loadTexture(this);\n                }\n            }\n        }\n        else\n        {\n            object.loadTexture(this);\n        }\n\n    },\n\n    /**\n    * Clears the BitmapData context using a clearRect.\n    *\n    * @method Phaser.BitmapData#cls\n    */\n\n    /**\n    * Clears the BitmapData context using a clearRect.\n    *\n    * @method Phaser.BitmapData#clear\n    */\n    clear: function () {\n\n        this.context.clearRect(0, 0, this.width, this.height);\n\n        this.dirty = true;\n\n    },\n\n    /**\n    * Fills the BitmapData with the given color.\n    *\n    * @method Phaser.BitmapData#fill\n    * @param {number} r - The red color value, between 0 and 0xFF (255).\n    * @param {number} g - The green color value, between 0 and 0xFF (255).\n    * @param {number} b - The blue color value, between 0 and 0xFF (255).\n    * @param {number} [a=1] - The alpha color value, between 0 and 1.\n    */\n    fill: function (r, g, b, a) {\n\n        if (typeof a === 'undefined') { a = 1; }\n\n        this.context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n        this.context.fillRect(0, 0, this.width, this.height);\n        this.dirty = true;\n\n    },\n\n    /**\n    * Resizes the BitmapData. This changes the size of the underlying canvas and refreshes the buffer.\n    *\n    * @method Phaser.BitmapData#resize\n    */\n    resize: function (width, height) {\n\n        if (width !== this.width || height !== this.height)\n        {\n            this.width = width;\n            this.height = height;\n            this.canvas.width = width;\n            this.canvas.height = height;\n            this.textureFrame.width = width;\n            this.textureFrame.height = height;\n            this.refreshBuffer();\n        }\n\n        this.dirty = true;\n\n    },\n\n    /**\n    * This re-creates the BitmapData.imageData from the current context.\n    * It then re-builds the ArrayBuffer, the data Uint8ClampedArray reference and the pixels Int32Array.\n    * If not given the dimensions defaults to the full size of the context.\n    *\n    * @method Phaser.BitmapData#update\n    * @param {number} [x=0] - The x coordinate of the top-left of the image data area to grab from.\n    * @param {number} [y=0] - The y coordinate of the top-left of the image data area to grab from.\n    * @param {number} [width] - The width of the image data area.\n    * @param {number} [height] - The height of the image data area.\n    */\n\n    /**\n    * DEPRECATED: This method will be removed in Phaser 2.1. Please use BitmapData.update instead.\n    *\n    * This re-creates the BitmapData.imageData from the current context.\n    * It then re-builds the ArrayBuffer, the data Uint8ClampedArray reference and the pixels Int32Array.\n    * If not given the dimensions defaults to the full size of the context.\n    *\n    * @method Phaser.BitmapData#refreshBuffer\n    * @param {number} [x=0] - The x coordinate of the top-left of the image data area to grab from.\n    * @param {number} [y=0] - The y coordinate of the top-left of the image data area to grab from.\n    * @param {number} [width] - The width of the image data area.\n    * @param {number} [height] - The height of the image data area.\n    */\n    refreshBuffer: function (x, y, width, height) {\n\n        if (typeof x === 'undefined') { x = 0; }\n        if (typeof y === 'undefined') { y = 0; }\n        if (typeof width === 'undefined') { width = this.width; }\n        if (typeof height === 'undefined') { height = this.height; }\n\n        this.imageData = this.context.getImageData(x, y, width, height);\n        this.data = this.imageData.data;\n\n        if (this.imageData.data.buffer)\n        {\n            this.buffer = this.imageData.data.buffer;\n            this.pixels = new Uint32Array(this.buffer);\n        }\n        else\n        {\n            if (window['ArrayBuffer'])\n            {\n                this.buffer = new ArrayBuffer(this.imageData.data.length);\n                this.pixels = new Uint32Array(this.buffer);\n            }\n            else\n            {\n                this.pixels = this.imageData.data;\n            }\n        }\n\n    },\n\n    /**\n    * Scans through the area specified in this BitmapData and sends a color object for every pixel to the given callback.\n    * The callback will be sent a color object with 6 properties: `{ r: number, g: number, b: number, a: number, color: number, rgba: string }`.\n    * Where r, g, b and a are integers between 0 and 255 representing the color component values for red, green, blue and alpha.\n    * The `color` property is an Int32 of the full color. Note the endianess of this will change per system.\n    * The `rgba` property is a CSS style rgba() string which can be used with context.fillStyle calls, among others.\n    * The callback will also be sent the pixels x and y coordinates respectively.\n    * The callback must return either `false`, in which case no change will be made to the pixel, or a new color object.\n    * If a new color object is returned the pixel will be set to the r, g, b and a color values given within it.\n    *\n    * @method Phaser.BitmapData#processPixelRGB\n    * @param {function} callback - The callback that will be sent each pixel color object to be processed.\n    * @param {object} callbackContext - The context under which the callback will be called.\n    * @param {number} [x=0] - The x coordinate of the top-left of the region to process from.\n    * @param {number} [y=0] - The y coordinate of the top-left of the region to process from.\n    * @param {number} [width] - The width of the region to process.\n    * @param {number} [height] - The height of the region to process.\n    */\n    processPixelRGB: function (callback, callbackContext, x, y, width, height) {\n\n        if (typeof x === 'undefined') { x = 0; }\n        if (typeof y === 'undefined') { y = 0; }\n        if (typeof width === 'undefined') { width = this.width; }\n        if (typeof height === 'undefined') { height = this.height; }\n\n        var w = x + width;\n        var h = y + height;\n        var pixel = Phaser.Color.createColor();\n        var result = { r: 0, g: 0, b: 0, a: 0 };\n        var dirty = false;\n\n        for (var ty = y; ty < h; ty++)\n        {\n            for (var tx = x; tx < w; tx++)\n            {\n                Phaser.Color.unpackPixel(this.getPixel32(tx, ty), pixel);\n\n                result = callback.call(callbackContext, pixel, tx, ty);\n\n                if (result !== false && result !== null)\n                {\n                    this.setPixel32(tx, ty, result.r, result.g, result.b, result.a, false);\n                    dirty = true;\n                }\n            }\n        }\n\n        if (dirty)\n        {\n            this.context.putImageData(this.imageData, 0, 0);\n            this.dirty = true;\n        }\n\n    },\n\n    /**\n    * Scans through the area specified in this BitmapData and sends the color for every pixel to the given callback along with its x and y coordinates.\n    * Whatever value the callback returns is set as the new color for that pixel, unless it returns the same color, in which case it's skipped.\n    * Note that the format of the color received will be different depending on if the system is big or little endian.\n    * It is expected that your callback will deal with endianess. If you'd rather Phaser did it then use processPixelRGB instead.\n    * The callback will also be sent the pixels x and y coordinates respectively.\n    *\n    * @method Phaser.BitmapData#processPixel\n    * @param {function} callback - The callback that will be sent each pixel color to be processed.\n    * @param {object} callbackContext - The context under which the callback will be called.\n    * @param {number} [x=0] - The x coordinate of the top-left of the region to process from.\n    * @param {number} [y=0] - The y coordinate of the top-left of the region to process from.\n    * @param {number} [width] - The width of the region to process.\n    * @param {number} [height] - The height of the region to process.\n    */\n    processPixel: function (callback, callbackContext, x, y, width, height) {\n\n        if (typeof x === 'undefined') { x = 0; }\n        if (typeof y === 'undefined') { y = 0; }\n        if (typeof width === 'undefined') { width = this.width; }\n        if (typeof height === 'undefined') { height = this.height; }\n\n        var w = x + width;\n        var h = y + height;\n        var pixel = 0;\n        var result = 0;\n        var dirty = false;\n\n        for (var ty = y; ty < h; ty++)\n        {\n            for (var tx = x; tx < w; tx++)\n            {\n                pixel = this.getPixel32(tx, ty);\n                result = callback.call(callbackContext, pixel, tx, ty);\n\n                if (result !== pixel)\n                {\n                    this.pixels[ty * this.width + tx] = result;\n                    dirty = true;\n                }\n            }\n        }\n\n        if (dirty)\n        {\n            this.context.putImageData(this.imageData, 0, 0);\n            this.dirty = true;\n        }\n\n    },\n\n    /**\n    * Replaces all pixels matching one color with another. The color values are given as two sets of RGBA values.\n    * An optional region parameter controls if the replacement happens in just a specific area of the BitmapData or the entire thing. \n    *\n    * @method Phaser.BitmapData#replaceRGB\n    * @param {number} r1 - The red color value to be replaced. Between 0 and 255.\n    * @param {number} g1 - The green color value to be replaced. Between 0 and 255.\n    * @param {number} b1 - The blue color value to be replaced. Between 0 and 255.\n    * @param {number} a1 - The alpha color value to be replaced. Between 0 and 255.\n    * @param {number} r2 - The red color value that is the replacement color. Between 0 and 255.\n    * @param {number} g2 - The green color value that is the replacement color. Between 0 and 255.\n    * @param {number} b2 - The blue color value that is the replacement color. Between 0 and 255.\n    * @param {number} a2 - The alpha color value that is the replacement color. Between 0 and 255.\n    * @param {Phaser.Rectangle} [region] - The area to perform the search over. If not given it will replace over the whole BitmapData.\n    */\n    replaceRGB: function (r1, g1, b1, a1, r2, g2, b2, a2, region) {\n\n        var sx = 0;\n        var sy = 0;\n        var w = this.width;\n        var h = this.height;\n        var source = Phaser.Color.packPixel(r1, g1, b1, a1);\n\n        if (region !== undefined && region instanceof Phaser.Rectangle)\n        {\n            sx = region.x;\n            sy = region.y;\n            w = region.width;\n            h = region.height;\n        }\n\n        for (var y = 0; y < h; y++)\n        {\n            for (var x = 0; x < w; x++)\n            {\n                if (this.getPixel32(sx + x, sy + y) === source)\n                {\n                    this.setPixel32(sx + x, sy + y, r2, g2, b2, a2, false);\n                }\n            }\n        }\n\n        this.context.putImageData(this.imageData, 0, 0);\n        this.dirty = true;\n\n    },\n\n    /**\n    * Sets the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.\n    *\n    * @method Phaser.BitmapData#setHSL\n    * @param {number} [h=null] - The hue, in the range 0 - 1.\n    * @param {number} [s=null] - The saturation, in the range 0 - 1.\n    * @param {number} [l=null] - The lightness, in the range 0 - 1.\n    * @param {Phaser.Rectangle} [region] - The area to perform the operation on. If not given it will run over the whole BitmapData.\n    */\n    setHSL: function (h, s, l, region) {\n\n        if (typeof h === 'undefined' || h === null) { h = false; }\n        if (typeof s === 'undefined' || s === null) { s = false; }\n        if (typeof l === 'undefined' || l === null) { l = false; }\n\n        if (!h && !s && !l)\n        {\n            return;\n        }\n\n        if (typeof region === 'undefined')\n        {\n            region = new Phaser.Rectangle(0, 0, this.width, this.height);\n        }\n\n        var pixel = Phaser.Color.createColor();\n\n        for (var y = region.y; y < region.bottom; y++)\n        {\n            for (var x = region.x; x < region.right; x++)\n            {\n                Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);\n\n                if (h)\n                {\n                    pixel.h = h;\n                }\n\n                if (s)\n                {\n                    pixel.s = s;\n                }\n\n                if (l)\n                {\n                    pixel.l = l;\n                }\n\n                Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);\n                this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);\n            }\n        }\n\n        this.context.putImageData(this.imageData, 0, 0);\n        this.dirty = true;\n\n    },\n\n    /**\n    * Shifts any or all of the hue, saturation and lightness values on every pixel in the given region, or the whole BitmapData if no region was specified.\n    * Shifting will add the given value onto the current h, s and l values, not replace them.\n    * The hue is wrapped to keep it within the range 0 to 1. Saturation and lightness are clamped to not exceed 1.\n    *\n    * @method Phaser.BitmapData#shiftHSL\n    * @param {number} [h=null] - The amount to shift the hue by.\n    * @param {number} [s=null] - The amount to shift the saturation by.\n    * @param {number} [l=null] - The amount to shift the lightness by.\n    * @param {Phaser.Rectangle} [region] - The area to perform the operation on. If not given it will run over the whole BitmapData.\n    */\n    shiftHSL: function (h, s, l, region) {\n\n        if (typeof h === 'undefined' || h === null) { h = false; }\n        if (typeof s === 'undefined' || s === null) { s = false; }\n        if (typeof l === 'undefined' || l === null) { l = false; }\n\n        if (!h && !s && !l)\n        {\n            return;\n        }\n\n        if (typeof region === 'undefined')\n        {\n            region = new Phaser.Rectangle(0, 0, this.width, this.height);\n        }\n\n        var pixel = Phaser.Color.createColor();\n\n        for (var y = region.y; y < region.bottom; y++)\n        {\n            for (var x = region.x; x < region.right; x++)\n            {\n                Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true);\n\n                if (h)\n                {\n                    pixel.h = this.game.math.wrap(pixel.h + h, 0, 1);\n                }\n\n                if (s)\n                {\n                    pixel.s = this.game.math.limitValue(pixel.s + s, 0, 1);\n                }\n\n                if (l)\n                {\n                    pixel.l = this.game.math.limitValue(pixel.l + l, 0, 1);\n                }\n\n                Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel);\n                this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false);\n            }\n        }\n\n        this.context.putImageData(this.imageData, 0, 0);\n        this.dirty = true;\n\n    },\n\n    /**\n    * Sets the color of the given pixel to the specified red, green, blue and alpha values.\n    *\n    * @method Phaser.BitmapData#setPixel32\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} red - The red color value, between 0 and 0xFF (255).\n    * @param {number} green - The green color value, between 0 and 0xFF (255).\n    * @param {number} blue - The blue color value, between 0 and 0xFF (255).\n    * @param {number} alpha - The alpha color value, between 0 and 0xFF (255).\n    * @param {boolean} [immediate=true] - If `true` the context.putImageData will be called and the dirty flag set.\n    */\n    setPixel32: function (x, y, red, green, blue, alpha, immediate) {\n\n        if (typeof immediate === 'undefined') { immediate = true; }\n\n        if (x >= 0 && x <= this.width && y >= 0 && y <= this.height)\n        {\n            if (Phaser.Device.LITTLE_ENDIAN)\n            {\n                this.pixels[y * this.width + x] = (alpha << 24) | (blue << 16) | (green << 8) | red;\n            }\n            else\n            {\n                this.pixels[y * this.width + x] = (red << 24) | (green << 16) | (blue << 8) | alpha;\n            }\n\n            if (immediate)\n            {\n                this.context.putImageData(this.imageData, 0, 0);\n                this.dirty = true;\n            }\n        }\n\n    },\n\n    /**\n    * Sets the color of the given pixel to the specified red, green and blue values.\n    *\n    * @method Phaser.BitmapData#setPixel\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} red - The red color value, between 0 and 0xFF (255).\n    * @param {number} green - The green color value, between 0 and 0xFF (255).\n    * @param {number} blue - The blue color value, between 0 and 0xFF (255).\n    * @param {number} alpha - The alpha color value, between 0 and 0xFF (255).\n    * @param {boolean} [immediate=true] - If `true` the context.putImageData will be called and the dirty flag set.\n    */\n    setPixel: function (x, y, red, green, blue, immediate) {\n\n        this.setPixel32(x, y, red, green, blue, 255, immediate);\n\n    },\n\n    /**\n    * Get the color of a specific pixel in the context into a color object.\n    *\n    * @method Phaser.BitmapData#getPixel\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {object} [out] - An object into which 4 properties will be created: r, g, b and a. If not provided a new object will be created.\n    * @return {object} An object with the red, green, blue and alpha values set in the r, g, b and a properties.\n    */\n    getPixel: function (x, y, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor();\n        }\n\n        var index = ~~(x + (y * this.width));\n\n        index *= 4;\n\n        if (this.data[index])\n        {\n            out.r = this.data[index];\n            out.g = this.data[++index];\n            out.b = this.data[++index];\n            out.a = this.data[++index];\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Get the color of a specific pixel including its alpha value.\n    * Note that on little-endian systems the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA.\n    *\n    * @method Phaser.BitmapData#getPixel32\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @return {number} A native color value integer (format: 0xAARRGGBB)\n    */\n    getPixel32: function (x, y) {\n\n        if (x >= 0 && x <= this.width && y >= 0 && y <= this.height)\n        {\n            return this.pixels[y * this.width + x];\n        }\n\n    },\n\n    /**\n    * Get the color of a specific pixel including its alpha value as a color object containing r,g,b,a and rgba properties.\n    *\n    * @method Phaser.BitmapData#getPixelRGB\n    * @param {number} x - The x coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {number} y - The y coordinate of the pixel to be set. Must lay within the dimensions of this BitmapData.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @param {boolean} [hsl=false] - Also convert the rgb values into hsl?\n    * @param {boolean} [hsv=false] - Also convert the rgb values into hsv?\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    getPixelRGB: function (x, y, out, hsl, hsv) {\n\n        return Phaser.Color.unpackPixel(this.getPixel32(x, y), out, hsl, hsv);\n\n    },\n\n    /**\n    * Gets all the pixels from the region specified by the given Rectangle object.\n    *\n    * @method Phaser.BitmapData#getPixels\n    * @param {Phaser.Rectangle} rect - The Rectangle region to get.\n    * @return {ImageData} Returns a ImageData object containing a Uint8ClampedArray data property.\n    */\n    getPixels: function (rect) {\n\n        return this.context.getImageData(rect.x, rect.y, rect.width, rect.height);\n\n    },\n\n    /**\n    * Copies the pixels from the source image to this BitmapData based on the given area and destination.\n    *\n    * @method Phaser.BitmapData#copyPixels\n    * @param {HTMLImage|string} source - The Image to draw. If you give a key it will try and find the Image in the Game.Cache.\n    * @param {Phaser.Rectangle} area - The Rectangle region to copy from the source image.\n    * @param {number} destX - The destination x coordinate to copy the image to.\n    * @param {number} destY - The destination y coordinate to copy the image to.\n    */\n    copyPixels: function (source, area, destX, destY) {\n\n        if (typeof source === 'string')\n        {\n            source = this.game.cache.getImage(source);\n        }\n\n        if (source)\n        {\n            this.context.drawImage(source, area.x, area.y, area.width, area.height, destX, destY, area.width, area.height);\n        }\n\n        this.dirty = true;\n\n    },\n\n    /**\n    * Draws the given image to this BitmapData at the coordinates specified. If you need to only draw a part of the image use BitmapData.copyPixels instead.\n    *\n    * @method Phaser.BitmapData#draw\n    * @param {HTMLImage|string} source - The Image to draw. If you give a string it will try and find the Image in the Game.Cache.\n    * @param {number} [x=0] - The x coordinate to draw the image to.\n    * @param {number} [y=0] - The y coordinate to draw the image to.\n    */\n    draw: function (source, x, y) {\n\n        if (typeof x === 'undefined') { x = 0; }\n        if (typeof y === 'undefined') { y = 0; }\n\n        if (typeof source === 'string')\n        {\n            source = this.game.cache.getImage(source);\n        }\n\n        if (source)\n        {\n            this.context.drawImage(source, 0, 0, source.width, source.height, x, y, source.width, source.height);\n        }\n\n        this.dirty = true;\n\n    },\n\n    /**\n    * Draws the given image to this BitmapData at the coordinates specified. If you need to only draw a part of the image use BitmapData.copyPixels instead.\n    *\n    * @method Phaser.BitmapData#drawSprite\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The Sprite to draw. Must have a loaded texture and frame.\n    * @param {number} [x=0] - The x coordinate to draw the Sprite to.\n    * @param {number} [y=0] - The y coordinate to draw the Sprite to.\n    */\n    drawSprite: function (sprite, x, y) {\n\n        if (typeof x === 'undefined') { x = 0; }\n        if (typeof y === 'undefined') { y = 0; }\n\n        var frame = sprite.texture.frame;\n\n        this.context.drawImage(sprite.texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, x, y, frame.width, frame.height);\n\n        this.dirty = true;\n\n    },\n\n    /**\n    * Draws the given image onto this BitmapData using an image as an alpha mask.\n    *\n    * @method Phaser.BitmapData#alphaMask\n    * @param {HTMLImage|string} source - The Image to draw. If you give a key it will try and find the Image in the Game.Cache.\n    * @param {HTMLImage|string} mask - The Image to use as the alpha mask. If you give a key it will try and find the Image in the Game.Cache.\n    */\n    alphaMask: function (source, mask) {\n\n        var temp = this.context.globalCompositeOperation;\n\n        if (typeof mask === 'string')\n        {\n            mask = this.game.cache.getImage(mask);\n        }\n\n        if (mask)\n        {\n            this.context.drawImage(mask, 0, 0);\n        }\n\n        this.context.globalCompositeOperation = 'source-atop';\n\n        if (typeof source === 'string')\n        {\n            source = this.game.cache.getImage(source);\n        }\n\n        if (source)\n        {\n            this.context.drawImage(source, 0, 0);\n        }\n\n        this.context.globalCompositeOperation = temp;\n\n        this.dirty = true;\n\n    },\n\n    /**\n    * Scans this BitmapData for all pixels matching the given r,g,b values and then draws them into the given destination BitmapData.\n    * The destination BitmapData must be large enough to receive all of the pixels that are scanned.\n    * Although the destination BitmapData is returned from this method, it's actually modified directly in place, meaning this call is perfectly valid:\n    * `picture.extract(mask, r, g, b)`\n    *\n    * @method Phaser.BitmapData#extract\n    * @param {Phaser.BitmapData} destination - The BitmapData that the extracts pixels will be drawn to.\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} [a=255] - The alpha color component, in the range 0 - 255.\n    * @returns {Phaser.BitmapData} The BitmapData that the extract pixels were drawn on.\n    */\n    extract: function (destination, r, g, b, a) {\n\n        if (typeof a === 'undefined') { a = 255; }\n\n        this.processPixelRGB(\n            function(pixel, x, y){\n                if (pixel.r === r && pixel.g === g && pixel.b === b)\n                {\n                    destination.setPixel32(x, y, r, g, b, a, false);\n                }\n                return false;\n            },\n            this);\n\n        destination.context.putImageData(destination.imageData, 0, 0);\n        destination.dirty = true;\n\n        return destination;\n\n    },\n\n    /**\n    * Draws a filled Circle to the BitmapData at the given x, y coordinates and radius in size.\n    *\n    * @method Phaser.BitmapData#circle\n    * @param {number} x - The x coordinate to draw the Circle at.\n    * @param {number} y - The y coordinate to draw the Circle at.\n    * @param {number} radius - The radius of the Circle.\n    * @param {string} [fillStyle] - If set the context fillStyle will be set to this value before the circle is drawn.\n    */\n    circle: function (x, y, radius, fillStyle) {\n\n        if (typeof fillStyle !== 'undefined')\n        {\n            this.context.fillStyle = fillStyle;\n        }\n\n        this.context.beginPath();\n        this.context.arc(x, y, radius, 0, Math.PI * 2, false);\n        this.context.closePath();\n\n        this.context.fill();\n\n    },\n\n    /**\n    * If the game is running in WebGL this will push the texture up to the GPU if it's dirty.\n    * This is called automatically if the BitmapData is being used by a Sprite, otherwise you need to remember to call it in your render function.\n    * If you wish to suppress this functionality set BitmapData.disableTextureUpload to `true`.\n    *\n    * @method Phaser.BitmapData#render\n    */\n    render: function () {\n\n        if (!this.disableTextureUpload && this.game.renderType === Phaser.WEBGL && this.dirty)\n        {\n            //  Only needed if running in WebGL, otherwise this array will never get cleared down\n            //  should use the rendersession\n            PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);\n\n            this.dirty = false;\n        }\n\n    }\n\n};\n\nPhaser.BitmapData.prototype.constructor = Phaser.BitmapData;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Sprite\n*\n* @classdesc Create a new `Sprite` object. Sprites are the lifeblood of your game, used for nearly everything visual.\n*\n* At its most basic a Sprite consists of a set of coordinates and a texture that is rendered to the canvas.\n* They also contain additional properties allowing for physics motion (via Sprite.body), input handling (via Sprite.input),\n* events (via Sprite.events), animation (via Sprite.animations), camera culling and more. Please see the Examples for use cases.\n*\n* @constructor\n* @extends PIXI.Sprite\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} x - The x coordinate (in world space) to position the Sprite at.\n* @param {number} y - The y coordinate (in world space) to position the Sprite at.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n* @param {string|number} frame - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.Sprite = function (game, x, y, key, frame) {\n\n    x = x || 0;\n    y = y || 0;\n    key = key || null;\n    frame = frame || null;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} name - The user defined name given to this Sprite.\n    * @default\n    */\n    this.name = '';\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.SPRITE;\n\n    /**\n    * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.\n    */\n    this.z = 0;\n\n    /**\n    * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.\n    */\n    this.events = new Phaser.Events(this);\n\n    /**\n    * @property {Phaser.AnimationManager} animations - This manages animations of the sprite. You can modify animations through it (see Phaser.AnimationManager)\n    */\n    this.animations = new Phaser.AnimationManager(this);\n\n    /**\n    *  @property {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n    */\n    this.key = key;\n\n    /**\n    * @property {number} _frame - Internal cache var.\n    * @private\n    */\n    this._frame = 0;\n\n    /**\n    * @property {string} _frameName - Internal cache var.\n    * @private\n    */\n    this._frameName = '';\n\n    PIXI.Sprite.call(this, PIXI.TextureCache['__default']);\n\n    this.loadTexture(key, frame);\n\n    this.position.set(x, y);\n\n    /**\n    * @property {Phaser.Point} world - The world coordinates of this Sprite. This differs from the x/y coordinates which are relative to the Sprites container.\n    */\n    this.world = new Phaser.Point(x, y);\n\n    /**\n    * Should this Sprite be automatically culled if out of range of the camera?\n    * A culled sprite has its renderable property set to 'false'.\n    * Be advised this is quite an expensive operation, as it has to calculate the bounds of the object every frame, so only enable it if you really need it.\n    *\n    * @property {boolean} autoCull - A flag indicating if the Sprite should be automatically camera culled or not.\n    * @default\n    */\n    this.autoCull = false;\n\n    /**\n    * @property {Phaser.InputHandler|null} input - The Input Handler for this object. Needs to be enabled with image.inputEnabled = true before you can use it.\n    */\n    this.input = null;\n\n    /**\n    * By default Sprites won't add themselves to any physics system and their physics body will be `null`.\n    * To enable them for physics you need to call `game.physics.enable(sprite, system)` where `sprite` is this object\n    * and `system` is the Physics system you want to use to manage this body. Once enabled you can access all physics related properties via `Sprite.body`.\n    *\n    * Important: Enabling a Sprite for P2 or Ninja physics will automatically set `Sprite.anchor` to 0.5 so the physics body is centered on the Sprite.\n    * If you need a different result then adjust or re-create the Body shape offsets manually, and/or reset the anchor after enabling physics.\n    *\n    * @property {Phaser.Physics.Arcade.Body|Phaser.Physics.P2.Body|Phaser.Physics.Ninja.Body|null} body\n    * @default\n    */\n    this.body = null;\n\n    /**\n    * @property {number} health - Health value. Used in combination with damage() to allow for quick killing of Sprites.\n    */\n    this.health = 1;\n\n    /**\n    * If you would like the Sprite to have a lifespan once 'born' you can set this to a positive value. Handy for particles, bullets, etc.\n    * The lifespan is decremented by game.time.elapsed each update, once it reaches zero the kill() function is called.\n    * @property {number} lifespan - The lifespan of the Sprite (in ms) before it will be killed.\n    * @default\n    */\n    this.lifespan = 0;\n\n    /**\n    * If true the Sprite checks if it is still within the world each frame, when it leaves the world it dispatches Sprite.events.onOutOfBounds\n    * and optionally kills the sprite (if Sprite.outOfBoundsKill is true). By default this is disabled because the Sprite has to calculate its\n    * bounds every frame to support it, and not all games need it. Enable it by setting the value to true.\n    * @property {boolean} checkWorldBounds\n    * @default\n    */\n    this.checkWorldBounds = false;\n\n    /**\n    * @property {boolean} outOfBoundsKill - If true Sprite.kill is called as soon as Sprite.inWorld returns false, as long as Sprite.checkWorldBounds is true.\n    * @default\n    */\n    this.outOfBoundsKill = false;\n\n    /**\n    * @property {boolean} debug - Handy flag to use with Game.enableStep\n    * @default\n    */\n    this.debug = false;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    /**\n    * A small internal cache:\n    * 0 = previous position.x\n    * 1 = previous position.y\n    * 2 = previous rotation\n    * 3 = renderID\n    * 4 = fresh? (0 = no, 1 = yes)\n    * 5 = outOfBoundsFired (0 = no, 1 = yes)\n    * 6 = exists (0 = no, 1 = yes)\n    * 7 = fixed to camera (0 = no, 1 = yes)\n    * 8 = destroy phase? (0 = no, 1 = yes)\n    * @property {Array} _cache\n    * @private\n    */\n    this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];\n\n    /**\n    * @property {Phaser.Rectangle} _bounds - Internal cache var.\n    * @private\n    */\n    this._bounds = new Phaser.Rectangle();\n\n};\n\nPhaser.Sprite.prototype = Object.create(PIXI.Sprite.prototype);\nPhaser.Sprite.prototype.constructor = Phaser.Sprite;\n\n/**\n* Automatically called by World.preUpdate.\n*\n* @method Phaser.Sprite#preUpdate\n* @memberof Phaser.Sprite\n* @return {boolean} True if the Sprite was rendered, otherwise false.\n*/\nPhaser.Sprite.prototype.preUpdate = function() {\n\n    if (this._cache[4] === 1 && this.exists)\n    {\n        this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);\n        this.worldTransform.tx = this.world.x;\n        this.worldTransform.ty = this.world.y;\n        this._cache[0] = this.world.x;\n        this._cache[1] = this.world.y;\n        this._cache[2] = this.rotation;\n\n        if (this.body)\n        {\n            this.body.preUpdate();\n        }\n\n        this._cache[4] = 0;\n\n        return false;\n    }\n\n    this._cache[0] = this.world.x;\n    this._cache[1] = this.world.y;\n    this._cache[2] = this.rotation;\n\n    if (!this.exists || !this.parent.exists)\n    {\n        //  Reset the renderOrderID\n        this._cache[3] = -1;\n        return false;\n    }\n\n    if (this.lifespan > 0)\n    {\n        this.lifespan -= this.game.time.elapsed;\n\n        if (this.lifespan <= 0)\n        {\n            this.kill();\n            return false;\n        }\n    }\n\n    //  Cache the bounds if we need it\n    if (this.autoCull || this.checkWorldBounds)\n    {\n        this._bounds.copyFrom(this.getBounds());\n    }\n\n    if (this.autoCull)\n    {\n        //  Won't get rendered but will still get its transform updated\n        this.renderable = this.game.world.camera.screenView.intersects(this._bounds);\n    }\n\n    if (this.checkWorldBounds)\n    {\n        //  The Sprite is already out of the world bounds, so let's check to see if it has come back again\n        if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds))\n        {\n            this._cache[5] = 0;\n            this.events.onEnterBounds.dispatch(this);\n        }\n        else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds))\n        {\n            //  The Sprite WAS in the screen, but has now left.\n            this._cache[5] = 1;\n            this.events.onOutOfBounds.dispatch(this);\n\n            if (this.outOfBoundsKill)\n            {\n                this.kill();\n                return false;\n            }\n        }\n    }\n\n    this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);\n\n    if (this.visible)\n    {\n        this._cache[3] = this.game.stage.currentRenderOrderID++;\n    }\n\n    this.animations.update();\n\n    if (this.body)\n    {\n        this.body.preUpdate();\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n    return true;\n\n};\n\n/**\n* Override and use this function in your own custom objects to handle any update requirements you may have.\n* Remember if this Sprite has any children you should call update on them too.\n*\n* @method Phaser.Sprite#update\n* @memberof Phaser.Sprite\n*/\nPhaser.Sprite.prototype.update = function() {\n\n};\n\n/**\n* Internal function called by the World postUpdate cycle.\n*\n* @method Phaser.Sprite#postUpdate\n* @memberof Phaser.Sprite\n*/\nPhaser.Sprite.prototype.postUpdate = function() {\n\n    if (this.key instanceof Phaser.BitmapData)\n    {\n        this.key.render();\n    }\n\n    if (this.exists && this.body)\n    {\n        this.body.postUpdate();\n    }\n\n    //  Fixed to Camera?\n    if (this._cache[7] === 1)\n    {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].postUpdate();\n    }\n\n};\n\n/**\n* Changes the Texture the Sprite is using entirely. The old texture is removed and the new one is referenced or fetched from the Cache.\n* This causes a WebGL texture update, so use sparingly or in low-intensity portions of your game.\n*\n* @method Phaser.Sprite#loadTexture\n* @memberof Phaser.Sprite\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n* @param {string|number} frame - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.Sprite.prototype.loadTexture = function (key, frame) {\n\n    frame = frame || 0;\n\n    if (key instanceof Phaser.RenderTexture)\n    {\n        this.key = key.key;\n        this.setTexture(key);\n        return;\n    }\n    else if (key instanceof Phaser.BitmapData)\n    {\n        this.key = key;\n        this.setTexture(key.texture);\n        return;\n    }\n    else if (key instanceof PIXI.Texture)\n    {\n        this.key = key;\n        this.setTexture(key);\n        return;\n    }\n    else\n    {\n        if (key === null || typeof key === 'undefined')\n        {\n            this.key = '__default';\n            this.setTexture(PIXI.TextureCache[this.key]);\n            return;\n        }\n        else if (typeof key === 'string' && !this.game.cache.checkImageKey(key))\n        {\n            this.key = '__missing';\n            this.setTexture(PIXI.TextureCache[this.key]);\n            return;\n        }\n\n        if (this.game.cache.isSpriteSheet(key))\n        {\n            this.key = key;\n\n            // var frameData = this.game.cache.getFrameData(key);\n            this.animations.loadFrameData(this.game.cache.getFrameData(key));\n\n            if (typeof frame === 'string')\n            {\n                this.frameName = frame;\n            }\n            else\n            {\n                this.frame = frame;\n            }\n        }\n        else\n        {\n            this.key = key;\n            this.setTexture(PIXI.TextureCache[key]);\n            return;\n        }\n    }\n\n};\n\n/**\n* Crop allows you to crop the texture used to display this Sprite.\n* Cropping takes place from the top-left of the Sprite and can be modified in real-time by providing an updated rectangle object.\n* Note that cropping a Sprite will reset its animation to the first frame. You cannot currently crop an animated Sprite.\n*\n* @method Phaser.Sprite#crop\n* @memberof Phaser.Sprite\n* @param {Phaser.Rectangle} rect - The Rectangle to crop the Sprite to. Pass null or no parameters to clear a previously set crop rectangle.\n*/\nPhaser.Sprite.prototype.crop = function(rect) {\n\n    if (typeof rect === 'undefined' || rect === null)\n    {\n        //  Clear any crop that may be set\n        if (this.texture.hasOwnProperty('sourceWidth'))\n        {\n            this.texture.setFrame(new Phaser.Rectangle(0, 0, this.texture.sourceWidth, this.texture.sourceHeight));\n        }\n    }\n    else\n    {\n        //  Do we need to clone the PIXI.Texture object?\n        if (this.texture instanceof PIXI.Texture)\n        {\n            //  Yup, let's rock it ...\n            var local = {};\n\n            Phaser.Utils.extend(true, local, this.texture);\n\n            local.sourceWidth = local.width;\n            local.sourceHeight = local.height;\n            local.frame = rect;\n            local.width = rect.width;\n            local.height = rect.height;\n\n            this.texture = local;\n\n            this.texture.updateFrame = true;\n            PIXI.Texture.frameUpdates.push(this.texture);\n        }\n        else\n        {\n            this.texture.setFrame(rect);\n        }\n    }\n\n};\n\n/**\n* Brings a 'dead' Sprite back to life, optionally giving it the health value specified.\n* A resurrected Sprite has its alive, exists and visible properties all set to true.\n* It will dispatch the onRevived event, you can listen to Sprite.events.onRevived for the signal.\n*\n* @method Phaser.Sprite#revive\n* @memberof Phaser.Sprite\n* @param {number} [health=1] - The health to give the Sprite.\n* @return (Phaser.Sprite) This instance.\n*/\nPhaser.Sprite.prototype.revive = function(health) {\n\n    if (typeof health === 'undefined') { health = 1; }\n\n    this.alive = true;\n    this.exists = true;\n    this.visible = true;\n    this.health = health;\n\n    if (this.events)\n    {\n        this.events.onRevived.dispatch(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Kills a Sprite. A killed Sprite has its alive, exists and visible properties all set to false.\n* It will dispatch the onKilled event, you can listen to Sprite.events.onKilled for the signal.\n* Note that killing a Sprite is a way for you to quickly recycle it in a Sprite pool, it doesn't free it up from memory.\n* If you don't need this Sprite any more you should call Sprite.destroy instead.\n*\n* @method Phaser.Sprite#kill\n* @memberof Phaser.Sprite\n* @return (Phaser.Sprite) This instance.\n*/\nPhaser.Sprite.prototype.kill = function() {\n\n    this.alive = false;\n    this.exists = false;\n    this.visible = false;\n\n    if (this.events)\n    {\n        this.events.onKilled.dispatch(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Destroys the Sprite. This removes it from its parent group, destroys the input, event and animation handlers if present\n* and nulls its reference to game, freeing it up for garbage collection.\n*\n* @method Phaser.Sprite#destroy\n* @memberof Phaser.Sprite\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.Sprite.prototype.destroy = function(destroyChildren) {\n\n    if (this.game === null || this._cache[8] === 1) { return; }\n\n    if (typeof destroyChildren === 'undefined') { destroyChildren = true; }\n\n    this._cache[8] = 1;\n\n    if (this.parent)\n    {\n        if (this.parent instanceof Phaser.Group)\n        {\n            this.parent.remove(this);\n        }\n        else\n        {\n            this.parent.removeChild(this);\n        }\n    }\n\n    if (this.input)\n    {\n        this.input.destroy();\n    }\n\n    if (this.animations)\n    {\n        this.animations.destroy();\n    }\n\n    if (this.body)\n    {\n        this.body.destroy();\n    }\n\n    if (this.events)\n    {\n        this.events.destroy();\n    }\n\n    var i = this.children.length;\n\n    if (destroyChildren)\n    {\n        while (i--)\n        {\n            this.children[i].destroy(destroyChildren);\n        }\n    }\n    else\n    {\n        while (i--)\n        {\n            this.removeChild(this.children[i]);\n        }\n    }\n\n    this.alive = false;\n    this.exists = false;\n    this.visible = false;\n\n    this.filters = null;\n    this.mask = null;\n    this.game = null;\n\n    this._cache[8] = 0;\n\n};\n\n/**\n* Damages the Sprite, this removes the given amount from the Sprites health property.\n* If health is then taken below or is equal to zero `Sprite.kill` is called.\n*\n* @method Phaser.Sprite#damage\n* @memberof Phaser.Sprite\n* @param {number} amount - The amount to subtract from the Sprite.health value.\n* @return (Phaser.Sprite) This instance.\n*/\nPhaser.Sprite.prototype.damage = function(amount) {\n\n    if (this.alive)\n    {\n        this.health -= amount;\n\n        if (this.health <= 0)\n        {\n            this.kill();\n        }\n    }\n\n    return this;\n\n};\n\n/**\n* Resets the Sprite. This places the Sprite at the given x/y world coordinates and then\n* sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state and health values.\n* If the Sprite has a physics body that too is reset.\n*\n* @method Phaser.Sprite#reset\n* @memberof Phaser.Sprite\n* @param {number} x - The x coordinate (in world space) to position the Sprite at.\n* @param {number} y - The y coordinate (in world space) to position the Sprite at.\n* @param {number} [health=1] - The health to give the Sprite.\n* @return (Phaser.Sprite) This instance.\n*/\nPhaser.Sprite.prototype.reset = function(x, y, health) {\n\n    if (typeof health === 'undefined') { health = 1; }\n\n    this.world.setTo(x, y);\n    this.position.x = x;\n    this.position.y = y;\n    this.alive = true;\n    this.exists = true;\n    this.visible = true;\n    this.renderable = true;\n    this._outOfBoundsFired = false;\n\n    this.health = health;\n\n    if (this.body)\n    {\n        this.body.reset(x, y, false, false);\n    }\n\n    this._cache[4] = 1;\n\n    return this;\n\n};\n\n/**\n* Brings the Sprite to the top of the display list it is a child of. Sprites that are members of a Phaser.Group are only\n* bought to the top of that Group, not the entire display list.\n*\n* @method Phaser.Sprite#bringToTop\n* @memberof Phaser.Sprite\n* @return (Phaser.Sprite) This instance.\n*/\nPhaser.Sprite.prototype.bringToTop = function() {\n\n    if (this.parent)\n    {\n        this.parent.bringToTop(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Play an animation based on the given key. The animation should previously have been added via sprite.animations.add()\n* If the requested animation is already playing this request will be ignored. If you need to reset an already running animation do so directly on the Animation object itself.\n*\n* @method Phaser.Sprite#play\n* @memberof Phaser.Sprite\n* @param {string} name - The name of the animation to be played, e.g. \"fire\", \"walk\", \"jump\".\n* @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.\n* @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.\n* @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.\n* @return {Phaser.Animation} A reference to playing Animation instance.\n*/\nPhaser.Sprite.prototype.play = function (name, frameRate, loop, killOnComplete) {\n\n    if (this.animations)\n    {\n        return this.animations.play(name, frameRate, loop, killOnComplete);\n    }\n\n};\n\n/**\n* Checks to see if the bounds of this Sprite overlaps with the bounds of the given Display Object, which can be a Sprite, Image, TileSprite or anything that extends those such as a Button.\n* This check ignores the Sprites hitArea property and runs a Sprite.getBounds comparison on both objects to determine the result.\n* Therefore it's relatively expensive to use in large quantities (i.e. with lots of Sprites at a high frequency), but should be fine for low-volume testing where physics isn't required.\n* \n* @method Phaser.Sprite#overlap\n* @memberof Phaser.Sprite\n* @param {Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Button|PIXI.DisplayObject} displayObject - The display object to check against.\n* @return {boolean} True if the bounds of this Sprite intersects at any point with the bounds of the given display object.\n*/\nPhaser.Sprite.prototype.overlap = function (displayObject) {\n\n    return Phaser.Rectangle.intersects(this.getBounds(), displayObject.getBounds());\n\n};\n\n/**\n* Indicates the rotation of the Sprite, in degrees, from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement player.angle = 450 is the same as player.angle = 90.\n* If you wish to work in radians instead of degrees use the property Sprite.rotation instead. Working in radians is also a little faster as it doesn't have to convert the angle.\n*\n* @name Phaser.Sprite#angle\n* @property {number} angle - The angle of this Sprite in degrees.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"angle\", {\n\n    get: function() {\n\n        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));\n\n    },\n\n    set: function(value) {\n\n        this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));\n\n    }\n\n});\n\n/**\n* Returns the delta x value. The difference between world.x now and in the previous step.\n*\n* @name Phaser.Sprite#deltaX\n* @property {number} deltaX - The delta value. Positive if the motion was to the right, negative if to the left.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"deltaX\", {\n\n    get: function() {\n\n        return this.world.x - this._cache[0];\n\n    }\n\n});\n\n/**\n* Returns the delta y value. The difference between world.y now and in the previous step.\n*\n* @name Phaser.Sprite#deltaY\n* @property {number} deltaY - The delta value. Positive if the motion was downwards, negative if upwards.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"deltaY\", {\n\n    get: function() {\n\n        return this.world.y - this._cache[1];\n\n    }\n\n});\n\n/**\n* Returns the delta z value. The difference between rotation now and in the previous step.\n*\n* @name Phaser.Sprite#deltaZ\n* @property {number} deltaZ - The delta value.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"deltaZ\", {\n\n    get: function() {\n\n        return this.rotation - this._cache[2];\n\n    }\n\n});\n\n/**\n* Checks if the Sprite bounds are within the game world, otherwise false if fully outside of it.\n*\n* @name Phaser.Sprite#inWorld\n* @property {boolean} inWorld - True if the Sprite bounds is within the game world, even if only partially. Otherwise false if fully outside of it.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"inWorld\", {\n\n    get: function() {\n\n        return this.game.world.bounds.intersects(this.getBounds());\n\n    }\n\n});\n\n/**\n* Checks if the Sprite bounds are within the game camera, otherwise false if fully outside of it.\n*\n* @name Phaser.Sprite#inCamera\n* @property {boolean} inCamera - True if the Sprite bounds is within the game camera, even if only partially. Otherwise false if fully outside of it.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"inCamera\", {\n\n    get: function() {\n\n        return this.game.world.camera.screenView.intersects(this.getBounds());\n\n    }\n\n});\n\n/**\n* @name Phaser.Sprite#frame\n* @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"frame\", {\n\n    get: function () {\n        return this.animations.frame;\n    },\n\n    set: function (value) {\n        this.animations.frame = value;\n    }\n\n});\n\n/**\n* @name Phaser.Sprite#frameName\n* @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"frameName\", {\n\n    get: function () {\n        return this.animations.frameName;\n    },\n\n    set: function (value) {\n        this.animations.frameName = value;\n    }\n\n});\n\n/**\n* @name Phaser.Sprite#renderOrderID\n* @property {number} renderOrderID - The render order ID, reset every frame.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"renderOrderID\", {\n\n    get: function() {\n\n        return this._cache[3];\n\n    }\n\n});\n\n/**\n* By default a Sprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is\n* activated for this object and it will then start to process click/touch events and more.\n*\n* @name Phaser.Sprite#inputEnabled\n* @property {boolean} inputEnabled - Set to true to allow this object to receive input events.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"inputEnabled\", {\n\n    get: function () {\n\n        return (this.input && this.input.enabled);\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            if (this.input === null)\n            {\n                this.input = new Phaser.InputHandler(this);\n                this.input.start();\n            }\n            else if (this.input && !this.input.enabled)\n            {\n                this.input.start();\n            }\n        }\n        else\n        {\n            if (this.input && this.input.enabled)\n            {\n                this.input.stop();\n            }\n        }\n\n    }\n\n});\n\n/**\n* Sprite.exists controls if the core game loop and physics update this Sprite or not.\n* When you set Sprite.exists to false it will remove its Body from the physics world (if it has one) and also set Sprite.visible to false.\n* Setting Sprite.exists to true will re-add the Body to the physics world (if it has a body) and set Sprite.visible to true.\n*\n* @name Phaser.Sprite#exists\n* @property {boolean} exists - If the Sprite is processed by the core game update and physics.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"exists\", {\n\n    get: function () {\n\n        return !!this._cache[6];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            //  exists = true\n            this._cache[6] = 1;\n\n            if (this.body && this.body.type === Phaser.Physics.P2JS)\n            {\n                this.body.addToWorld();\n            }\n\n            this.visible = true;\n        }\n        else\n        {\n            //  exists = false\n            this._cache[6] = 0;\n\n            if (this.body && this.body.type === Phaser.Physics.P2JS)\n            {\n                this.body.removeFromWorld();\n            }\n\n            this.visible = false;\n\n        }\n    }\n\n});\n\n/**\n* An Sprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Sprite.cameraOffset.\n* Note that the cameraOffset values are in addition to any parent in the display list.\n* So if this Sprite was in a Group that has x: 200, then this will be added to the cameraOffset.x\n*\n* @name Phaser.Sprite#fixedToCamera\n* @property {boolean} fixedToCamera - Set to true to fix this Sprite to the Camera at its current world coordinates.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"fixedToCamera\", {\n\n    get: function () {\n\n        return !!this._cache[7];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            this._cache[7] = 1;\n            this.cameraOffset.set(this.x, this.y);\n        }\n        else\n        {\n            this._cache[7] = 0;\n        }\n    }\n\n});\n\n/**\n* Enable or disable texture smoothing for this Sprite. Only works for bitmap/image textures. Smoothing is enabled by default.\n*\n* @name Phaser.Sprite#smoothed\n* @property {boolean} smoothed - Set to true to smooth the texture of this Sprite, or false to disable smoothing (great for pixel art)\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"smoothed\", {\n\n    get: function () {\n\n        return !this.texture.baseTexture.scaleMode;\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            if (this.texture)\n            {\n                this.texture.baseTexture.scaleMode = 0;\n            }\n        }\n        else\n        {\n            if (this.texture)\n            {\n                this.texture.baseTexture.scaleMode = 1;\n            }\n        }\n    }\n\n});\n\n/**\n* The position of the Sprite on the x axis relative to the local coordinates of the parent.\n*\n* @name Phaser.Sprite#x\n* @property {number} x - The position of the Sprite on the x axis relative to the local coordinates of the parent.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"x\", {\n\n    get: function () {\n\n        return this.position.x;\n\n    },\n\n    set: function (value) {\n\n        this.position.x = value;\n\n        if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2)\n        {\n            this.body._reset = 1;\n        }\n\n    }\n\n});\n\n/**\n* The position of the Sprite on the y axis relative to the local coordinates of the parent.\n*\n* @name Phaser.Sprite#y\n* @property {number} y - The position of the Sprite on the y axis relative to the local coordinates of the parent.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"y\", {\n\n    get: function () {\n\n        return this.position.y;\n\n    },\n\n    set: function (value) {\n\n        this.position.y = value;\n\n        if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2)\n        {\n            this.body._reset = 1;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Sprite#destroyPhase\n* @property {boolean} destroyPhase - True if this object is currently being destroyed.\n*/\nObject.defineProperty(Phaser.Sprite.prototype, \"destroyPhase\", {\n\n    get: function () {\n\n        return !!this._cache[8];\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Image\n*\n* @classdesc Create a new `Image` object. An Image is a light-weight object you can use to display anything that doesn't need physics or animation.\n* It can still rotate, scale, crop and receive input events. This makes it perfect for logos, backgrounds, simple buttons and other non-Sprite graphics.\n*\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} x - The x coordinate of the Imaget. The coordinate is relative to any parent container this Image may be in.\n* @param {number} y - The y coordinate of the Image. The coordinate is relative to any parent container this Image may be in.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - The texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n* @param {string|number} frame - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.Image = function (game, x, y, key, frame) {\n\n    x = x || 0;\n    y = y || 0;\n    key = key || null;\n    frame = frame || null;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} exists - If exists = false then the Image isn't updated by the core game loop.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * @property {string} name - The user defined name given to this Image.\n    * @default\n    */\n    this.name = '';\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.IMAGE;\n\n    /**\n    * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.\n    */\n    this.z = 0;\n\n    /**\n    * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Image or its components.\n    */\n    this.events = new Phaser.Events(this);\n\n    /**\n    *  @property {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n    */\n    this.key = key;\n\n    /**\n    * @property {number} _frame - Internal cache var.\n    * @private\n    */\n    this._frame = 0;\n\n    /**\n    * @property {string} _frameName - Internal cache var.\n    * @private\n    */\n    this._frameName = '';\n\n    PIXI.Sprite.call(this, PIXI.TextureCache['__default']);\n\n    this.loadTexture(key, frame);\n\n    this.position.set(x, y);\n\n    /**\n    * @property {Phaser.Point} world - The world coordinates of this Image. This differs from the x/y coordinates which are relative to the Images container.\n    */\n    this.world = new Phaser.Point(x, y);\n\n    /**\n    * Should this Image be automatically culled if out of range of the camera?\n    * A culled sprite has its renderable property set to 'false'.\n    * Be advised this is quite an expensive operation, as it has to calculate the bounds of the object every frame, so only enable it if you really need it.\n    *\n    * @property {boolean} autoCull - A flag indicating if the Image should be automatically camera culled or not.\n    * @default\n    */\n    this.autoCull = false;\n\n    /**\n    * @property {Phaser.InputHandler|null} input - The Input Handler for this object. Needs to be enabled with image.inputEnabled = true before you can use it.\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    /**\n    * A small internal cache:\n    * 0 = previous position.x\n    * 1 = previous position.y\n    * 2 = previous rotation\n    * 3 = renderID\n    * 4 = fresh? (0 = no, 1 = yes)\n    * 5 = outOfBoundsFired (0 = no, 1 = yes)\n    * 6 = exists (0 = no, 1 = yes)\n    * 7 = fixed to camera (0 = no, 1 = yes)\n    * 8 = destroy phase? (0 = no, 1 = yes)\n    * @property {Array} _cache\n    * @private\n    */\n    this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];\n\n};\n\nPhaser.Image.prototype = Object.create(PIXI.Sprite.prototype);\nPhaser.Image.prototype.constructor = Phaser.Image;\n\n/**\n* Automatically called by World.preUpdate.\n*\n* @method Phaser.Image#preUpdate\n* @memberof Phaser.Image\n*/\nPhaser.Image.prototype.preUpdate = function() {\n\n    this._cache[0] = this.world.x;\n    this._cache[1] = this.world.y;\n    this._cache[2] = this.rotation;\n\n    if (!this.exists || !this.parent.exists)\n    {\n        this._cache[3] = -1;\n        return false;\n    }\n\n    if (this.autoCull)\n    {\n        //  Won't get rendered but will still get its transform updated\n        this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());\n    }\n\n    this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);\n\n    if (this.visible)\n    {\n        this._cache[3] = this.game.stage.currentRenderOrderID++;\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n    return true;\n\n};\n\n/**\n* Override and use this function in your own custom objects to handle any update requirements you may have.\n*\n* @method Phaser.Image#update\n* @memberof Phaser.Image\n*/\nPhaser.Image.prototype.update = function() {\n\n};\n\n/**\n* Internal function called by the World postUpdate cycle.\n*\n* @method Phaser.Image#postUpdate\n* @memberof Phaser.Image\n*/\nPhaser.Image.prototype.postUpdate = function() {\n\n    if (this.key instanceof Phaser.BitmapData)\n    {\n        this.key.render();\n    }\n\n    //  Fixed to Camera?\n    if (this._cache[7] === 1)\n    {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].postUpdate();\n    }\n\n};\n\n/**\n* Changes the Texture the Image is using entirely. The old texture is removed and the new one is referenced or fetched from the Cache.\n* This causes a WebGL texture update, so use sparingly or in low-intensity portions of your game.\n*\n* @method Phaser.Image#loadTexture\n* @memberof Phaser.Image\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Image during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n* @param {string|number} frame - If this Image is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.Image.prototype.loadTexture = function (key, frame) {\n\n    frame = frame || 0;\n\n    if (key instanceof Phaser.RenderTexture)\n    {\n        this.key = key.key;\n        this.setTexture(key);\n        return;\n    }\n    else if (key instanceof Phaser.BitmapData)\n    {\n        this.key = key;\n        this.setTexture(key.texture);\n        return;\n    }\n    else if (key instanceof PIXI.Texture)\n    {\n        this.key = key;\n        this.setTexture(key);\n        return;\n    }\n    else\n    {\n        if (key === null || typeof key === 'undefined')\n        {\n            this.key = '__default';\n            this.setTexture(PIXI.TextureCache[this.key]);\n            return;\n        }\n        else if (typeof key === 'string' && !this.game.cache.checkImageKey(key))\n        {\n            this.key = '__missing';\n            this.setTexture(PIXI.TextureCache[this.key]);\n            return;\n        }\n\n        if (this.game.cache.isSpriteSheet(key))\n        {\n            this.key = key;\n\n            var frameData = this.game.cache.getFrameData(key);\n\n            if (typeof frame === 'string')\n            {\n                this._frame = 0;\n                this._frameName = frame;\n                this.setTexture(PIXI.TextureCache[frameData.getFrameByName(frame).uuid]);\n                return;\n            }\n            else\n            {\n                this._frame = frame;\n                this._frameName = '';\n                this.setTexture(PIXI.TextureCache[frameData.getFrame(frame).uuid]);\n                return;\n            }\n        }\n        else\n        {\n            this.key = key;\n            this.setTexture(PIXI.TextureCache[key]);\n            return;\n        }\n    }\n\n};\n\n/**\n* Crop allows you to crop the texture used to display this Image.\n* Cropping takes place from the top-left of the Image and can be modified in real-time by providing an updated rectangle object.\n*\n* @method Phaser.Image#crop\n* @memberof Phaser.Image\n* @param {Phaser.Rectangle} rect - The Rectangle to crop the Image to. Pass null or no parameters to clear a previously set crop rectangle.\n*/\nPhaser.Image.prototype.crop = function(rect) {\n\n    if (typeof rect === 'undefined' || rect === null)\n    {\n        //  Clear any crop that may be set\n        if (this.texture.hasOwnProperty('sourceWidth'))\n        {\n            this.texture.setFrame(new Phaser.Rectangle(0, 0, this.texture.sourceWidth, this.texture.sourceHeight));\n        }\n    }\n    else\n    {\n        //  Do we need to clone the PIXI.Texture object?\n        if (this.texture instanceof PIXI.Texture)\n        {\n            //  Yup, let's rock it ...\n            var local = {};\n\n            Phaser.Utils.extend(true, local, this.texture);\n\n            local.sourceWidth = local.width;\n            local.sourceHeight = local.height;\n            local.frame = rect;\n            local.width = rect.width;\n            local.height = rect.height;\n\n            this.texture = local;\n\n            this.texture.updateFrame = true;\n            PIXI.Texture.frameUpdates.push(this.texture);\n        }\n        else\n        {\n            this.texture.setFrame(rect);\n        }\n    }\n\n};\n\n/**\n* Brings a 'dead' Image back to life, optionally giving it the health value specified.\n* A resurrected Image has its alive, exists and visible properties all set to true.\n* It will dispatch the onRevived event, you can listen to Image.events.onRevived for the signal.\n*\n* @method Phaser.Image#revive\n* @memberof Phaser.Image\n* @return {Phaser.Image} This instance.\n*/\nPhaser.Image.prototype.revive = function() {\n\n    this.alive = true;\n    this.exists = true;\n    this.visible = true;\n\n    if (this.events)\n    {\n        this.events.onRevived.dispatch(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Kills a Image. A killed Image has its alive, exists and visible properties all set to false.\n* It will dispatch the onKilled event, you can listen to Image.events.onKilled for the signal.\n* Note that killing a Image is a way for you to quickly recycle it in a Image pool, it doesn't free it up from memory.\n* If you don't need this Image any more you should call Image.destroy instead.\n*\n* @method Phaser.Image#kill\n* @memberof Phaser.Image\n* @return {Phaser.Image} This instance.\n*/\nPhaser.Image.prototype.kill = function() {\n\n    this.alive = false;\n    this.exists = false;\n    this.visible = false;\n\n    if (this.events)\n    {\n        this.events.onKilled.dispatch(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Destroys the Image. This removes it from its parent group, destroys the input, event and animation handlers if present\n* and nulls its reference to game, freeing it up for garbage collection.\n*\n* @method Phaser.Image#destroy\n* @memberof Phaser.Image\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.Image.prototype.destroy = function(destroyChildren) {\n\n    if (this.game === null || this.destroyPhase) { return; }\n\n    if (typeof destroyChildren === 'undefined') { destroyChildren = true; }\n\n    this._cache[8] = 1;\n\n    if (this.parent)\n    {\n        if (this.parent instanceof Phaser.Group)\n        {\n            this.parent.remove(this);\n        }\n        else\n        {\n            this.parent.removeChild(this);\n        }\n    }\n\n    if (this.events)\n    {\n        this.events.destroy();\n    }\n\n    if (this.input)\n    {\n        this.input.destroy();\n    }\n\n    var i = this.children.length;\n\n    if (destroyChildren)\n    {\n        while (i--)\n        {\n            this.children[i].destroy(destroyChildren);\n        }\n    }\n    else\n    {\n        while (i--)\n        {\n            this.removeChild(this.children[i]);\n        }\n    }\n\n    this.alive = false;\n    this.exists = false;\n    this.visible = false;\n\n    this.filters = null;\n    this.mask = null;\n    this.game = null;\n\n    this._cache[8] = 0;\n\n};\n\n/**\n* Resets the Image. This places the Image at the given x/y world coordinates and then sets alive, exists, visible and renderable all to true.\n*\n* @method Phaser.Image#reset\n* @memberof Phaser.Image\n* @param {number} x - The x coordinate (in world space) to position the Image at.\n* @param {number} y - The y coordinate (in world space) to position the Image at.\n* @return {Phaser.Image} This instance.\n*/\nPhaser.Image.prototype.reset = function(x, y) {\n\n    this.world.setTo(x, y);\n    this.position.x = x;\n    this.position.y = y;\n    this.alive = true;\n    this.exists = true;\n    this.visible = true;\n    this.renderable = true;\n\n    return this;\n\n};\n\n/**\n* Brings the Image to the top of the display list it is a child of. Images that are members of a Phaser.Group are only\n* bought to the top of that Group, not the entire display list.\n*\n* @method Phaser.Image#bringToTop\n* @memberof Phaser.Image\n* @return {Phaser.Image} This instance.\n*/\nPhaser.Image.prototype.bringToTop = function() {\n\n    if (this.parent)\n    {\n        this.parent.bringToTop(this);\n    }\n\n    return this;\n\n};\n\n/**\n* Indicates the rotation of the Image, in degrees, from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement player.angle = 450 is the same as player.angle = 90.\n* If you wish to work in radians instead of degrees use the property Image.rotation instead. Working in radians is also a little faster as it doesn't have to convert the angle.\n*\n* @name Phaser.Image#angle\n* @property {number} angle - The angle of this Image in degrees.\n*/\nObject.defineProperty(Phaser.Image.prototype, \"angle\", {\n\n    get: function() {\n\n        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));\n\n    },\n\n    set: function(value) {\n\n        this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));\n\n    }\n\n});\n\n/**\n* Returns the delta x value. The difference between world.x now and in the previous step.\n*\n* @name Phaser.Image#deltaX\n* @property {number} deltaX - The delta value. Positive if the motion was to the right, negative if to the left.\n* @readonly\n*/\nObject.defineProperty(Phaser.Image.prototype, \"deltaX\", {\n\n    get: function() {\n\n        return this.world.x - this._cache[0];\n\n    }\n\n});\n\n/**\n* Returns the delta y value. The difference between world.y now and in the previous step.\n*\n* @name Phaser.Image#deltaY\n* @property {number} deltaY - The delta value. Positive if the motion was downwards, negative if upwards.\n* @readonly\n*/\nObject.defineProperty(Phaser.Image.prototype, \"deltaY\", {\n\n    get: function() {\n\n        return this.world.y - this._cache[1];\n\n    }\n\n});\n\n/**\n* Returns the delta z value. The difference between rotation now and in the previous step.\n*\n* @name Phaser.Image#deltaZ\n* @property {number} deltaZ - The delta value.\n* @readonly\n*/\nObject.defineProperty(Phaser.Image.prototype, \"deltaZ\", {\n\n    get: function() {\n\n        return this.rotation - this._cache[2];\n\n    }\n\n});\n\n/**\n* Checks if the Image bounds are within the game world, otherwise false if fully outside of it.\n*\n* @name Phaser.Image#inWorld\n* @property {boolean} inWorld - True if the Image bounds is within the game world, even if only partially. Otherwise false if fully outside of it.\n* @readonly\n*/\nObject.defineProperty(Phaser.Image.prototype, \"inWorld\", {\n\n    get: function() {\n\n        return this.game.world.bounds.intersects(this.getBounds());\n\n    }\n\n});\n\n/**\n* Checks if the Image bounds are within the game camera, otherwise false if fully outside of it.\n*\n* @name Phaser.Image#inCamera\n* @property {boolean} inCamera - True if the Image bounds is within the game camera, even if only partially. Otherwise false if fully outside of it.\n* @readonly\n*/\nObject.defineProperty(Phaser.Image.prototype, \"inCamera\", {\n\n    get: function() {\n\n        return this.game.world.camera.screenView.intersects(this.getBounds());\n\n    }\n\n});\n\n/**\n* @name Phaser.Image#frame\n* @property {number} frame - Gets or sets the current frame index and updates the Texture for display.\n*/\nObject.defineProperty(Phaser.Image.prototype, \"frame\", {\n\n    get: function() {\n\n        return this._frame;\n\n    },\n\n    set: function(value) {\n\n        if (value !== this.frame && this.game.cache.isSpriteSheet(this.key))\n        {\n            var frameData = this.game.cache.getFrameData(this.key);\n\n            if (frameData && value < frameData.total && frameData.getFrame(value))\n            {\n                this.setTexture(PIXI.TextureCache[frameData.getFrame(value).uuid]);\n                this._frame = value;\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Image#frameName\n* @property {string} frameName - Gets or sets the current frame by name and updates the Texture for display.\n*/\nObject.defineProperty(Phaser.Image.prototype, \"frameName\", {\n\n    get: function() {\n\n        return this._frameName;\n\n    },\n\n    set: function(value) {\n\n        if (value !== this.frameName && this.game.cache.isSpriteSheet(this.key))\n        {\n            var frameData = this.game.cache.getFrameData(this.key);\n\n            if (frameData && frameData.getFrameByName(value))\n            {\n                this.setTexture(PIXI.TextureCache[frameData.getFrameByName(value).uuid]);\n                this._frameName = value;\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Image#renderOrderID\n* @property {number} renderOrderID - The render order ID, reset every frame.\n* @readonly\n*/\nObject.defineProperty(Phaser.Image.prototype, \"renderOrderID\", {\n\n    get: function() {\n\n        return this._cache[3];\n\n    }\n\n});\n\n/**\n* By default an Image won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is\n* activated for this object and it will then start to process click/touch events and more.\n*\n* @name Phaser.Image#inputEnabled\n* @property {boolean} inputEnabled - Set to true to allow this object to receive input events.\n*/\nObject.defineProperty(Phaser.Image.prototype, \"inputEnabled\", {\n\n    get: function () {\n\n        return (this.input && this.input.enabled);\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            if (this.input === null)\n            {\n                this.input = new Phaser.InputHandler(this);\n                this.input.start();\n            }\n            else if (this.input && !this.input.enabled)\n            {\n                this.input.start();\n            }\n        }\n        else\n        {\n            if (this.input && this.input.enabled)\n            {\n                this.input.stop();\n            }\n        }\n    }\n\n});\n\n/**\n* An Image that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Image.cameraOffset.\n* Note that the cameraOffset values are in addition to any parent in the display list.\n* So if this Image was in a Group that has x: 200, then this will be added to the cameraOffset.x\n*\n* @name Phaser.Image#fixedToCamera\n* @property {boolean} fixedToCamera - Set to true to fix this Image to the Camera at its current world coordinates.\n*/\nObject.defineProperty(Phaser.Image.prototype, \"fixedToCamera\", {\n\n    get: function () {\n\n        return !!this._cache[7];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            this._cache[7] = 1;\n            this.cameraOffset.set(this.x, this.y);\n        }\n        else\n        {\n            this._cache[7] = 0;\n        }\n    }\n\n});\n\n/**\n* Enable or disable texture smoothing for this Image. Only works for bitmap/image textures. Smoothing is enabled by default.\n*\n* @name Phaser.Image#smoothed\n* @property {boolean} smoothed - Set to true to smooth the texture of this Image, or false to disable smoothing (great for pixel art)\n*/\nObject.defineProperty(Phaser.Image.prototype, \"smoothed\", {\n\n    get: function () {\n\n        return !this.texture.baseTexture.scaleMode;\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            if (this.texture)\n            {\n                this.texture.baseTexture.scaleMode = 0;\n            }\n        }\n        else\n        {\n            if (this.texture)\n            {\n                this.texture.baseTexture.scaleMode = 1;\n            }\n        }\n    }\n\n});\n\n/**\n* @name Phaser.Image#destroyPhase\n* @property {boolean} destroyPhase - True if this object is currently being destroyed.\n*/\nObject.defineProperty(Phaser.Image.prototype, \"destroyPhase\", {\n\n    get: function () {\n\n        return !!this._cache[8];\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A TileSprite is a Sprite that has a repeating texture. The texture can be scrolled and scaled and will automatically wrap on the edges as it does so.\n* Please note that TileSprites, as with normal Sprites, have no input handler or physics bodies by default. Both need enabling.\n*\n* @class Phaser.TileSprite\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} x - The x coordinate (in world space) to position the TileSprite at.\n* @param {number} y - The y coordinate (in world space) to position the TileSprite at.\n* @param {number} width - The width of the TileSprite.\n* @param {number} height - The height of the TileSprite.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the TileSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n* @param {string|number} frame - If this TileSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.TileSprite = function (game, x, y, width, height, key, frame) {\n\n    x = x || 0;\n    y = y || 0;\n    width = width || 256;\n    height = height || 256;\n    key = key || null;\n    frame = frame || null;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} name - The user defined name given to this Sprite.\n    * @default\n    */\n    this.name = '';\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.TILESPRITE;\n\n    /**\n    * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.\n    */\n    this.z = 0;\n\n    /**\n    * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.\n    */\n    this.events = new Phaser.Events(this);\n\n    /**\n    * @property {Phaser.AnimationManager} animations - This manages animations of the sprite. You can modify animations through it (see Phaser.AnimationManager)\n    */\n    this.animations = new Phaser.AnimationManager(this);\n\n    /**\n    *  @property {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n    */\n    this.key = key;\n\n    /**\n    * @property {number} _frame - Internal cache var.\n    * @private\n    */\n    this._frame = 0;\n\n    /**\n    * @property {string} _frameName - Internal cache var.\n    * @private\n    */\n    this._frameName = '';\n\n    /**\n    * @property {Phaser.Point} _scroll - Internal cache var.\n    * @private\n    */\n    this._scroll = new Phaser.Point();\n\n    PIXI.TilingSprite.call(this, PIXI.TextureCache['__default'], width, height);\n\n    this.loadTexture(key, frame);\n\n    this.position.set(x, y);\n\n    /**\n    * @property {Phaser.InputHandler|null} input - The Input Handler for this object. Needs to be enabled with image.inputEnabled = true before you can use it.\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Point} world - The world coordinates of this Sprite. This differs from the x/y coordinates which are relative to the Sprites container.\n    */\n    this.world = new Phaser.Point(x, y);\n\n    /**\n    * Should this Sprite be automatically culled if out of range of the camera?\n    * A culled sprite has its renderable property set to 'false'.\n    * Be advised this is quite an expensive operation, as it has to calculate the bounds of the object every frame, so only enable it if you really need it.\n    *\n    * @property {boolean} autoCull - A flag indicating if the Sprite should be automatically camera culled or not.\n    * @default\n    */\n    this.autoCull = false;\n\n    /**\n    * If true the Sprite checks if it is still within the world each frame, when it leaves the world it dispatches Sprite.events.onOutOfBounds\n    * and optionally kills the sprite (if Sprite.outOfBoundsKill is true). By default this is disabled because the Sprite has to calculate its\n    * bounds every frame to support it, and not all games need it. Enable it by setting the value to true.\n    * @property {boolean} checkWorldBounds\n    * @default\n    */\n    this.checkWorldBounds = false;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    /**\n    * By default Sprites won't add themselves to any physics system and their physics body will be `null`.\n    * To enable them for physics you need to call `game.physics.enable(sprite, system)` where `sprite` is this object\n    * and `system` is the Physics system you want to use to manage this body. Once enabled you can access all physics related properties via `Sprite.body`.\n    *\n    * Important: Enabling a Sprite for P2 or Ninja physics will automatically set `Sprite.anchor` to 0.5 so the physics body is centered on the Sprite.\n    * If you need a different result then adjust or re-create the Body shape offsets manually, and/or reset the anchor after enabling physics.\n    *\n    * @property {Phaser.Physics.Arcade.Body|Phaser.Physics.P2.Body|Phaser.Physics.Ninja.Body|null} body\n    * @default\n    */\n    this.body = null;\n\n    /**\n    * A small internal cache:\n    * 0 = previous position.x\n    * 1 = previous position.y\n    * 2 = previous rotation\n    * 3 = renderID\n    * 4 = fresh? (0 = no, 1 = yes)\n    * 5 = outOfBoundsFired (0 = no, 1 = yes)\n    * 6 = exists (0 = no, 1 = yes)\n    * 7 = fixed to camera (0 = no, 1 = yes)\n    * 8 = destroy phase? (0 = no, 1 = yes)\n    * @property {Array} _cache\n    * @private\n    */\n    this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];\n\n};\n\nPhaser.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype);\nPhaser.TileSprite.prototype.constructor = Phaser.TileSprite;\n\n/**\n* Automatically called by World.preUpdate.\n*\n* @method Phaser.TileSprite#preUpdate\n* @memberof Phaser.TileSprite\n*/\nPhaser.TileSprite.prototype.preUpdate = function() {\n\n    if (this._cache[4] === 1 && this.exists)\n    {\n        this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y);\n        this.worldTransform.tx = this.world.x;\n        this.worldTransform.ty = this.world.y;\n        this._cache[0] = this.world.x;\n        this._cache[1] = this.world.y;\n        this._cache[2] = this.rotation;\n\n        if (this.body)\n        {\n            this.body.preUpdate();\n        }\n\n        this._cache[4] = 0;\n\n        return false;\n    }\n\n    this._cache[0] = this.world.x;\n    this._cache[1] = this.world.y;\n    this._cache[2] = this.rotation;\n\n    if (!this.exists || !this.parent.exists)\n    {\n        //  Reset the renderOrderID\n        this._cache[3] = -1;\n        return false;\n    }\n\n    //  Cache the bounds if we need it\n    if (this.autoCull || this.checkWorldBounds)\n    {\n        this._bounds.copyFrom(this.getBounds());\n    }\n\n    if (this.autoCull)\n    {\n        //  Won't get rendered but will still get its transform updated\n        this.renderable = this.game.world.camera.screenView.intersects(this._bounds);\n    }\n\n    if (this.checkWorldBounds)\n    {\n        //  The Sprite is already out of the world bounds, so let's check to see if it has come back again\n        if (this._cache[5] === 1 && this.game.world.bounds.intersects(this._bounds))\n        {\n            this._cache[5] = 0;\n            this.events.onEnterBounds.dispatch(this);\n        }\n        else if (this._cache[5] === 0 && !this.game.world.bounds.intersects(this._bounds))\n        {\n            //  The Sprite WAS in the screen, but has now left.\n            this._cache[5] = 1;\n            this.events.onOutOfBounds.dispatch(this);\n        }\n    }\n\n    this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty);\n\n    if (this.visible)\n    {\n        this._cache[3] = this.game.stage.currentRenderOrderID++;\n    }\n\n    this.animations.update();\n\n    if (this._scroll.x !== 0)\n    {\n        this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed;\n    }\n\n    if (this._scroll.y !== 0)\n    {\n        this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed;\n    }\n\n    if (this.body)\n    {\n        this.body.preUpdate();\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n    return true;\n\n};\n\n/**\n* Override and use this function in your own custom objects to handle any update requirements you may have.\n*\n* @method Phaser.TileSprite#update\n* @memberof Phaser.TileSprite\n*/\nPhaser.TileSprite.prototype.update = function() {\n\n};\n\n/**\n* Internal function called by the World postUpdate cycle.\n*\n* @method Phaser.TileSprite#postUpdate\n* @memberof Phaser.TileSprite\n*/\nPhaser.TileSprite.prototype.postUpdate = function() {\n\n    if (this.exists && this.body)\n    {\n        this.body.postUpdate();\n    }\n\n    //  Fixed to Camera?\n    if (this._cache[7] === 1)\n    {\n        this.position.x = this.game.camera.view.x + this.cameraOffset.x;\n        this.position.y = this.game.camera.view.y + this.cameraOffset.y;\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].postUpdate();\n    }\n\n};\n\n/**\n* Sets this TileSprite to automatically scroll in the given direction until stopped via TileSprite.stopScroll().\n* The scroll speed is specified in pixels per second.\n* A negative x value will scroll to the left. A positive x value will scroll to the right.\n* A negative y value will scroll up. A positive y value will scroll down.\n*\n* @method Phaser.TileSprite#autoScroll\n* @memberof Phaser.TileSprite\n*/\nPhaser.TileSprite.prototype.autoScroll = function(x, y) {\n\n    this._scroll.set(x, y);\n\n};\n\n/**\n* Stops an automatically scrolling TileSprite.\n*\n* @method Phaser.TileSprite#stopScroll\n* @memberof Phaser.TileSprite\n*/\nPhaser.TileSprite.prototype.stopScroll = function() {\n\n    this._scroll.set(0, 0);\n\n};\n\n/**\n* Changes the Texture the TileSprite is using entirely. The old texture is removed and the new one is referenced or fetched from the Cache.\n* This causes a WebGL texture update, so use sparingly or in low-intensity portions of your game.\n*\n* @method Phaser.TileSprite#loadTexture\n* @memberof Phaser.TileSprite\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture, BitmapData or PIXI.Texture.\n* @param {string|number} frame - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.TileSprite.prototype.loadTexture = function (key, frame) {\n\n    frame = frame || 0;\n\n    if (key instanceof Phaser.RenderTexture)\n    {\n        this.key = key.key;\n        this.setTexture(key);\n        return;\n    }\n    else if (key instanceof Phaser.BitmapData)\n    {\n        this.key = key;\n        this.setTexture(key.texture);\n        return;\n    }\n    else if (key instanceof PIXI.Texture)\n    {\n        this.key = key;\n        this.setTexture(key);\n        return;\n    }\n    else\n    {\n        if (key === null || typeof key === 'undefined')\n        {\n            this.key = '__default';\n            this.setTexture(PIXI.TextureCache[this.key]);\n            return;\n        }\n        else if (typeof key === 'string' && !this.game.cache.checkImageKey(key))\n        {\n            this.key = '__missing';\n            this.setTexture(PIXI.TextureCache[this.key]);\n            return;\n        }\n\n        if (this.game.cache.isSpriteSheet(key))\n        {\n            this.key = key;\n\n            // var frameData = this.game.cache.getFrameData(key);\n            this.animations.loadFrameData(this.game.cache.getFrameData(key));\n\n            if (typeof frame === 'string')\n            {\n                this.frameName = frame;\n            }\n            else\n            {\n                this.frame = frame;\n            }\n        }\n        else\n        {\n            this.key = key;\n            this.setTexture(PIXI.TextureCache[key]);\n            return;\n        }\n    }\n\n};\n\n/**\n* Destroys the TileSprite. This removes it from its parent group, destroys the event and animation handlers if present\n* and nulls its reference to game, freeing it up for garbage collection.\n*\n* @method Phaser.TileSprite#destroy\n* @memberof Phaser.TileSprite\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.TileSprite.prototype.destroy = function(destroyChildren) {\n\n    if (this.game === null || this.destroyPhase) { return; }\n\n    if (typeof destroyChildren === 'undefined') { destroyChildren = true; }\n\n    this._cache[8] = 1;\n\n    if (this.filters)\n    {\n        this.filters = null;\n    }\n\n    if (this.parent)\n    {\n        if (this.parent instanceof Phaser.Group)\n        {\n            this.parent.remove(this);\n        }\n        else\n        {\n            this.parent.removeChild(this);\n        }\n    }\n\n    this.animations.destroy();\n\n    this.events.destroy();\n\n    var i = this.children.length;\n\n    if (destroyChildren)\n    {\n        while (i--)\n        {\n            this.children[i].destroy(destroyChildren);\n        }\n    }\n    else\n    {\n        while (i--)\n        {\n            this.removeChild(this.children[i]);\n        }\n    }\n\n    this.exists = false;\n    this.visible = false;\n\n    this.filters = null;\n    this.mask = null;\n    this.game = null;\n\n    this._cache[8] = 0;\n\n};\n\n/**\n* Play an animation based on the given key. The animation should previously have been added via sprite.animations.add()\n* If the requested animation is already playing this request will be ignored. If you need to reset an already running animation do so directly on the Animation object itself.\n*\n* @method Phaser.TileSprite#play\n* @memberof Phaser.TileSprite\n* @param {string} name - The name of the animation to be played, e.g. \"fire\", \"walk\", \"jump\".\n* @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.\n* @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.\n* @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.\n* @return {Phaser.Animation} A reference to playing Animation instance.\n*/\nPhaser.TileSprite.prototype.play = function (name, frameRate, loop, killOnComplete) {\n\n    return this.animations.play(name, frameRate, loop, killOnComplete);\n\n};\n\n/**\n* Resets the TileSprite. This places the TileSprite at the given x/y world coordinates, resets the tilePosition and then\n* sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state.\n* If the TileSprite has a physics body that too is reset.\n* \n* @method Phaser.TileSprite#reset\n* @memberof Phaser.TileSprite\n* @param {number} x - The x coordinate (in world space) to position the Sprite at.\n* @param {number} y - The y coordinate (in world space) to position the Sprite at.\n* @return (Phaser.TileSprite) This instance.\n*/\nPhaser.TileSprite.prototype.reset = function(x, y) {\n\n    this.world.setTo(x, y);\n    this.position.x = x;\n    this.position.y = y;\n    this.alive = true;\n    this.exists = true;\n    this.visible = true;\n    this.renderable = true;\n    this._outOfBoundsFired = false;\n\n    this.tilePosition.x = 0;\n    this.tilePosition.y = 0;\n\n    if (this.body)\n    {\n        this.body.reset(x, y, false, false);\n    }\n\n    this._cache[4] = 1;\n\n    return this;\n    \n};\n\n/**\n* Indicates the rotation of the Sprite, in degrees, from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement player.angle = 450 is the same as player.angle = 90.\n* If you wish to work in radians instead of degrees use the property Sprite.rotation instead. Working in radians is also a little faster as it doesn't have to convert the angle.\n*\n* @name Phaser.TileSprite#angle\n* @property {number} angle - The angle of this Sprite in degrees.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"angle\", {\n\n    get: function() {\n\n        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation));\n\n    },\n\n    set: function(value) {\n\n        this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));\n\n    }\n\n});\n\n/**\n* @name Phaser.TileSprite#frame\n* @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"frame\", {\n\n    get: function () {\n        return this.animations.frame;\n    },\n\n    set: function (value) {\n\n        if (value !== this.animations.frame)\n        {\n            this.animations.frame = value;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.TileSprite#frameName\n* @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"frameName\", {\n\n    get: function () {\n        return this.animations.frameName;\n    },\n\n    set: function (value) {\n\n        if (value !== this.animations.frameName)\n        {\n            this.animations.frameName = value;\n        }\n\n    }\n\n});\n\n/**\n* An TileSprite that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in TileSprite.cameraOffset.\n* Note that the cameraOffset values are in addition to any parent in the display list.\n* So if this TileSprite was in a Group that has x: 200, then this will be added to the cameraOffset.x\n*\n* @name Phaser.TileSprite#fixedToCamera\n* @property {boolean} fixedToCamera - Set to true to fix this TileSprite to the Camera at its current world coordinates.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"fixedToCamera\", {\n\n    get: function () {\n\n        return !!this._cache[7];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            this._cache[7] = 1;\n            this.cameraOffset.set(this.x, this.y);\n        }\n        else\n        {\n            this._cache[7] = 0;\n        }\n    }\n\n});\n\n/**\n* TileSprite.exists controls if the core game loop and physics update this TileSprite or not.\n* When you set TileSprite.exists to false it will remove its Body from the physics world (if it has one) and also set TileSprite.visible to false.\n* Setting TileSprite.exists to true will re-add the Body to the physics world (if it has a body) and set TileSprite.visible to true.\n*\n* @name Phaser.TileSprite#exists\n* @property {boolean} exists - If the TileSprite is processed by the core game update and physics.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"exists\", {\n\n    get: function () {\n\n        return !!this._cache[6];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            //  exists = true\n            this._cache[6] = 1;\n\n            if (this.body && this.body.type === Phaser.Physics.P2JS)\n            {\n                this.body.addToWorld();\n            }\n\n            this.visible = true;\n        }\n        else\n        {\n            //  exists = false\n            this._cache[6] = 0;\n\n            if (this.body && this.body.type === Phaser.Physics.P2JS)\n            {\n                this.body.safeRemove = true;\n            }\n\n            this.visible = false;\n\n        }\n    }\n\n});\n\n/**\n* By default a TileSprite won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is\n* activated for this object and it will then start to process click/touch events and more.\n*\n* @name Phaser.TileSprite#inputEnabled\n* @property {boolean} inputEnabled - Set to true to allow this object to receive input events.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"inputEnabled\", {\n\n    get: function () {\n\n        return (this.input && this.input.enabled);\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            if (this.input === null)\n            {\n                this.input = new Phaser.InputHandler(this);\n                this.input.start();\n            }\n            else if (this.input && !this.input.enabled)\n            {\n                this.input.start();\n            }\n        }\n        else\n        {\n            if (this.input && this.input.enabled)\n            {\n                this.input.stop();\n            }\n        }\n\n    }\n\n});\n\n/**\n* The position of the TileSprite on the x axis relative to the local coordinates of the parent.\n*\n* @name Phaser.TileSprite#x\n* @property {number} x - The position of the TileSprite on the x axis relative to the local coordinates of the parent.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"x\", {\n\n    get: function () {\n\n        return this.position.x;\n\n    },\n\n    set: function (value) {\n\n        this.position.x = value;\n\n        if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2)\n        {\n            this.body._reset = 1;\n        }\n\n    }\n\n});\n\n/**\n* The position of the TileSprite on the y axis relative to the local coordinates of the parent.\n*\n* @name Phaser.TileSprite#y\n* @property {number} y - The position of the TileSprite on the y axis relative to the local coordinates of the parent.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"y\", {\n\n    get: function () {\n\n        return this.position.y;\n\n    },\n\n    set: function (value) {\n\n        this.position.y = value;\n\n        if (this.body && this.body.type === Phaser.Physics.ARCADE && this.body.phase === 2)\n        {\n            this.body._reset = 1;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.TileSprite#destroyPhase\n* @property {boolean} destroyPhase - True if this object is currently being destroyed.\n*/\nObject.defineProperty(Phaser.TileSprite.prototype, \"destroyPhase\", {\n\n    get: function () {\n\n        return !!this._cache[8];\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Create a new `Text` object. This uses a local hidden Canvas object and renders the type into it. It then makes a texture from this for renderning to the view.\n* Because of this you can only display fonts that are currently loaded and available to the browser. It won't load the fonts for you.\n* Here is a compatibility table showing the available default fonts across different mobile browsers: http://www.jordanm.co.uk/tinytype\n*\n* @class Phaser.Text\n* @extends PIXI.Text\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n* @param {number} x - X position of the new text object.\n* @param {number} y - Y position of the new text object.\n* @param {string} text - The actual text that will be written.\n* @param {object} style - The style object containing style attributes like font, font size ,\n*/\nPhaser.Text = function (game, x, y, text, style) {\n\n    x = x || 0;\n    y = y || 0;\n    text = text || ' ';\n    style = style || {};\n\n    if (text.length === 0)\n    {\n        text = ' ';\n    }\n    else\n    {\n        text = text.toString();\n    }\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} exists - If exists = false then the Text isn't updated by the core game loop.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * @property {string} name - The user defined name given to this object.\n    * @default\n    */\n    this.name = '';\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.TEXT;\n\n    /**\n    * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.\n    */\n    this.z = 0;\n\n    /**\n    * @property {Phaser.Point} world - The world coordinates of this Sprite. This differs from the x/y coordinates which are relative to the Sprites container.\n    */\n    this.world = new Phaser.Point(x, y);\n\n    /**\n    * @property {string} _text - Internal cache var.\n    * @private\n    */\n    this._text = text;\n\n    /**\n    * @property {string} _font - Internal cache var.\n    * @private\n    */\n    this._font = '';\n\n    /**\n    * @property {number} _fontSize - Internal cache var.\n    * @private\n    */\n    this._fontSize = 32;\n\n    /**\n    * @property {string} _fontWeight - Internal cache var.\n    * @private\n    */\n    this._fontWeight = 'normal';\n\n    /**\n    * @property {number} lineSpacing - Additional spacing (in pixels) between each line of text if multi-line.\n    * @private\n    */\n    this._lineSpacing = 0;\n\n    /**\n    * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.\n    */\n    this.events = new Phaser.Events(this);\n\n    /**\n    * @property {Phaser.InputHandler|null} input - The Input Handler for this object. Needs to be enabled with image.inputEnabled = true before you can use it.\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    this.setStyle(style);\n\n    PIXI.Text.call(this, text, this.style);\n\n    this.position.set(x, y);\n\n    /**\n    * A small internal cache:\n    * 0 = previous position.x\n    * 1 = previous position.y\n    * 2 = previous rotation\n    * 3 = renderID\n    * 4 = fresh? (0 = no, 1 = yes)\n    * 5 = outOfBoundsFired (0 = no, 1 = yes)\n    * 6 = exists (0 = no, 1 = yes)\n    * 7 = fixed to camera (0 = no, 1 = yes)\n    * 8 = destroy phase? (0 = no, 1 = yes)\n    * @property {Array} _cache\n    * @private\n    */\n    this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];\n\n};\n\nPhaser.Text.prototype = Object.create(PIXI.Text.prototype);\nPhaser.Text.prototype.constructor = Phaser.Text;\n\n/**\n* Automatically called by World.preUpdate.\n* @method Phaser.Text.prototype.preUpdate\n*/\nPhaser.Text.prototype.preUpdate = function () {\n\n    this._cache[0] = this.world.x;\n    this._cache[1] = this.world.y;\n    this._cache[2] = this.rotation;\n\n    if (!this.exists || !this.parent.exists)\n    {\n        this.renderOrderID = -1;\n        return false;\n    }\n\n    if (this.autoCull)\n    {\n        //  Won't get rendered but will still get its transform updated\n        this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());\n    }\n\n    this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);\n\n    if (this.visible)\n    {\n        this._cache[3] = this.game.stage.currentRenderOrderID++;\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].preUpdate();\n    }\n\n    return true;\n\n};\n\n/**\n* Override and use this function in your own custom objects to handle any update requirements you may have.\n*\n* @method Phaser.Text#update\n* @memberof Phaser.Text\n*/\nPhaser.Text.prototype.update = function() {\n\n};\n\n/**\n* Automatically called by World.postUpdate.\n* @method Phaser.Text.prototype.postUpdate\n*/\nPhaser.Text.prototype.postUpdate = function () {\n\n    if (this._cache[7] === 1)\n    {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n    //  Update any Children\n    for (var i = 0, len = this.children.length; i < len; i++)\n    {\n        this.children[i].postUpdate();\n    }\n\n};\n\n/**\n* @method Phaser.Text.prototype.destroy\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.Text.prototype.destroy = function (destroyChildren) {\n\n    if (this.game === null || this.destroyPhase) { return; }\n\n    if (typeof destroyChildren === 'undefined') { destroyChildren = true; }\n\n    this._cache[8] = 1;\n\n    if (this.parent)\n    {\n        if (this.parent instanceof Phaser.Group)\n        {\n            this.parent.remove(this);\n        }\n        else\n        {\n            this.parent.removeChild(this);\n        }\n    }\n\n    this.texture.destroy();\n\n    if (this.canvas.parentNode)\n    {\n        this.canvas.parentNode.removeChild(this.canvas);\n    }\n    else\n    {\n        this.canvas = null;\n        this.context = null;\n    }\n\n    var i = this.children.length;\n\n    if (destroyChildren)\n    {\n        while (i--)\n        {\n            this.children[i].destroy(destroyChildren);\n        }\n    }\n    else\n    {\n        while (i--)\n        {\n            this.removeChild(this.children[i]);\n        }\n    }\n\n    this.exists = false;\n    this.visible = false;\n\n    this.filters = null;\n    this.mask = null;\n    this.game = null;\n\n    this._cache[8] = 0;\n\n};\n\n/**\n* @method Phaser.Text.prototype.setShadow\n* @param {number} [x=0] - The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.\n* @param {number} [y=0] - The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.\n* @param {string} [color='rgba(0,0,0,0)'] - The color of the shadow, as given in CSS rgba format. Set the alpha component to 0 to disable the shadow.\n* @param {number} [blur=0] - The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).\n*/\nPhaser.Text.prototype.setShadow = function (x, y, color, blur) {\n\n    this.style.shadowOffsetX = x || 0;\n    this.style.shadowOffsetY = y || 0;\n    this.style.shadowColor = color || 'rgba(0,0,0,0)';\n    this.style.shadowBlur = blur || 0;\n    this.dirty = true;\n\n};\n\n/**\n* Set the style of the text by passing a single style object to it.\n*\n* @method Phaser.Text.prototype.setStyle\n* @param [style] {Object} The style parameters\n* @param [style.font='bold 20pt Arial'] {String} The style and size of the font\n* @param [style.fill='black'] {Object} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n* @param [style.align='left'] {String} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n* @param [style.stroke='black'] {String} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n* @param [style.strokeThickness=0] {Number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n* @param [style.wordWrap=false] {Boolean} Indicates if word wrap should be used\n* @param [style.wordWrapWidth=100] {Number} The width at which text will wrap\n*/\nPhaser.Text.prototype.setStyle = function (style) {\n\n    style = style || {};\n    style.font = style.font || 'bold 20pt Arial';\n    style.fill = style.fill || 'black';\n    style.align = style.align || 'left';\n    style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n    style.strokeThickness = style.strokeThickness || 0;\n    style.wordWrap = style.wordWrap || false;\n    style.wordWrapWidth = style.wordWrapWidth || 100;\n    style.shadowOffsetX = style.shadowOffsetX || 0;\n    style.shadowOffsetY = style.shadowOffsetY || 0;\n    style.shadowColor = style.shadowColor || 'rgba(0,0,0,0)';\n    style.shadowBlur = style.shadowBlur || 0;\n\n    this.style = style;\n    this.dirty = true;\n\n};\n\n/**\n* Renders text. This replaces the Pixi.Text.updateText function as we need a few extra bits in here.\n*\n* @method Phaser.Text.prototype.updateText\n* @private\n*/\nPhaser.Text.prototype.updateText = function () {\n\n    this.context.font = this.style.font;\n\n    var outputText = this.text;\n\n    // word wrap\n    // preserve original text\n    if (this.style.wordWrap)\n    {\n        outputText = this.runWordWrap(this.text);\n    }\n\n    //split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    //calculate text width\n    var lineWidths = [];\n    var maxLineWidth = 0;\n\n    for (var i = 0; i < lines.length; i++)\n    {\n        var lineWidth = this.context.measureText(lines[i]).width;\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    this.canvas.width = maxLineWidth + this.style.strokeThickness;\n\n    //calculate text height\n    var lineHeight = this.determineFontHeight('font: ' + this.style.font + ';') + this.style.strokeThickness + this._lineSpacing + this.style.shadowOffsetY;\n\n    this.canvas.height = lineHeight * lines.length;\n\n    if (navigator.isCocoonJS)\n    {\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n\n    //set canvas text styles\n    this.context.fillStyle = this.style.fill;\n    this.context.font = this.style.font;\n\n    this.context.strokeStyle = this.style.stroke;\n    this.context.lineWidth = this.style.strokeThickness;\n\n    this.context.shadowOffsetX = this.style.shadowOffsetX;\n    this.context.shadowOffsetY = this.style.shadowOffsetY;\n    this.context.shadowColor = this.style.shadowColor;\n    this.context.shadowBlur = this.style.shadowBlur;\n\n    this.context.textBaseline = 'top';\n    this.context.lineCap = 'round';\n    this.context.lineJoin = 'round';\n\n    //draw lines line by line\n    for (i = 0; i < lines.length; i++)\n    {\n        var linePosition = new PIXI.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + i * lineHeight);\n\n        if (this.style.align === 'right')\n        {\n            linePosition.x += maxLineWidth - lineWidths[i];\n        }\n        else if (this.style.align === 'center')\n        {\n            linePosition.x += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        linePosition.y += this._lineSpacing;\n\n        if (this.style.stroke && this.style.strokeThickness)\n        {\n            this.context.strokeText(lines[i], linePosition.x, linePosition.y);\n        }\n\n        if (this.style.fill)\n        {\n            this.context.fillText(lines[i], linePosition.x, linePosition.y);\n        }\n    }\n\n    this.updateTexture();\n};\n\n/**\n* Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n*\n* @method Phaser.Text.prototype.runWordWrap\n* @private\n*/\nPhaser.Text.prototype.runWordWrap = function (text) {\n\n    var result = '';\n    var lines = text.split('\\n');\n\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = this.style.wordWrapWidth;\n        var words = lines[i].split(' ');\n\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n\n            if (wordWidthWithSpace > spaceLeft)\n            {\n                // Skip printing the newline if it's the first word of the line that is greater than the word wrap width.\n                if (j > 0)\n                {\n                    result += '\\n';\n                }\n                result += words[j] + ' ';\n                spaceLeft = this.style.wordWrapWidth - wordWidth;\n            }\n            else\n            {\n                spaceLeft -= wordWidthWithSpace;\n                result += words[j] + ' ';\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n\n    return result;\n\n};\n\n/**\n* Indicates the rotation of the Text, in degrees, from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement player.angle = 450 is the same as player.angle = 90.\n* If you wish to work in radians instead of degrees use the property Sprite.rotation instead.\n* @name Phaser.Text#angle\n* @property {number} angle - Gets or sets the angle of rotation in degrees.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'angle', {\n\n    get: function() {\n        return Phaser.Math.radToDeg(this.rotation);\n    },\n\n    set: function(value) {\n        this.rotation = Phaser.Math.degToRad(value);\n    }\n\n});\n\n/**\n* The text string to be displayed by this Text object, taking into account the style settings.\n* @name Phaser.Text#text\n* @property {string} text - The text string to be displayed by this Text object, taking into account the style settings.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'text', {\n\n    get: function() {\n        return this._text;\n    },\n\n    set: function(value) {\n\n        if (value !== this._text)\n        {\n            this._text = value.toString() || ' ';\n            this.dirty = true;\n            this.updateTransform();\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#font\n* @property {string} font - The font the text will be rendered in, i.e. 'Arial'. Must be loaded in the browser before use.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'font', {\n\n    get: function() {\n        return this._font;\n    },\n\n    set: function(value) {\n\n        if (value !== this._font)\n        {\n            this._font = value.trim();\n            this.style.font = this._fontWeight + ' ' + this._fontSize + \"px '\" + this._font + \"'\";\n            this.dirty = true;\n            this.updateTransform();\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#fontSize\n* @property {number} fontSize - The size of the font in pixels.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fontSize', {\n\n    get: function() {\n        return this._fontSize;\n    },\n\n    set: function(value) {\n\n        value = parseInt(value, 10);\n\n        if (value !== this._fontSize)\n        {\n            this._fontSize = value;\n            this.style.font = this._fontWeight + ' ' + this._fontSize + \"px '\" + this._font + \"'\";\n            this.dirty = true;\n            this.updateTransform();\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#fontWeight\n* @property {number} fontWeight - The weight of the font: 'normal', 'bold', 'italic'. You can combine settings too, such as 'bold italic'.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fontWeight', {\n\n    get: function() {\n        return this._fontWeight;\n    },\n\n    set: function(value) {\n\n        if (value !== this._fontWeight)\n        {\n            this._fontWeight = value;\n            this.style.font = this._fontWeight + ' ' + this._fontSize + \"px '\" + this._font + \"'\";\n            this.dirty = true;\n            this.updateTransform();\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#fill\n* @property {object} fill - A canvas fillstyle that will be used on the text eg 'red', '#00FF00'.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'fill', {\n\n    get: function() {\n        return this.style.fill;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.fill)\n        {\n            this.style.fill = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#align\n* @property {string} align - Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'align', {\n\n    get: function() {\n        return this.style.align;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.align)\n        {\n            this.style.align = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#stroke\n* @property {string} stroke - A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'stroke', {\n\n    get: function() {\n        return this.style.stroke;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.stroke)\n        {\n            this.style.stroke = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#strokeThickness\n* @property {number} strokeThickness - A number that represents the thickness of the stroke. Default is 0 (no stroke)\n*/\nObject.defineProperty(Phaser.Text.prototype, 'strokeThickness', {\n\n    get: function() {\n        return this.style.strokeThickness;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.strokeThickness)\n        {\n            this.style.strokeThickness = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#wordWrap\n* @property {boolean} wordWrap - Indicates if word wrap should be used.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'wordWrap', {\n\n    get: function() {\n        return this.style.wordWrap;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.wordWrap)\n        {\n            this.style.wordWrap = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#wordWrapWidth\n* @property {number} wordWrapWidth - The width at which text will wrap.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'wordWrapWidth', {\n\n    get: function() {\n        return this.style.wordWrapWidth;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.wordWrapWidth)\n        {\n            this.style.wordWrapWidth = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#lineSpacing\n* @property {number} lineSpacing - Additional spacing (in pixels) between each line of text if multi-line.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'lineSpacing', {\n\n    get: function() {\n        return this._lineSpacing;\n    },\n\n    set: function(value) {\n\n        if (value !== this._lineSpacing)\n        {\n            this._lineSpacing = parseFloat(value);\n            this.dirty = true;\n            this.updateTransform();\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowOffsetX\n* @property {number} shadowOffsetX - The shadowOffsetX value in pixels. This is how far offset horizontally the shadow effect will be.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowOffsetX', {\n\n    get: function() {\n        return this.style.shadowOffsetX;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowOffsetX)\n        {\n            this.style.shadowOffsetX = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowOffsetY\n* @property {number} shadowOffsetY - The shadowOffsetY value in pixels. This is how far offset vertically the shadow effect will be.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowOffsetY', {\n\n    get: function() {\n        return this.style.shadowOffsetY;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowOffsetY)\n        {\n            this.style.shadowOffsetY = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowColor\n* @property {string} shadowColor - The color of the shadow, as given in CSS rgba format. Set the alpha component to 0 to disable the shadow.\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowColor', {\n\n    get: function() {\n        return this.style.shadowColor;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowColor)\n        {\n            this.style.shadowColor = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Text#shadowBlur\n* @property {number} shadowBlur - The shadowBlur value. Make the shadow softer by applying a Gaussian blur to it. A number from 0 (no blur) up to approx. 10 (depending on scene).\n*/\nObject.defineProperty(Phaser.Text.prototype, 'shadowBlur', {\n\n    get: function() {\n        return this.style.shadowBlur;\n    },\n\n    set: function(value) {\n\n        if (value !== this.style.shadowBlur)\n        {\n            this.style.shadowBlur = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* By default a Text object won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is\n* activated for this object and it will then start to process click/touch events and more.\n*\n* @name Phaser.Text#inputEnabled\n* @property {boolean} inputEnabled - Set to true to allow this object to receive input events.\n*/\nObject.defineProperty(Phaser.Text.prototype, \"inputEnabled\", {\n\n    get: function () {\n\n        return (this.input && this.input.enabled);\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            if (this.input === null)\n            {\n                this.input = new Phaser.InputHandler(this);\n                this.input.start();\n            }\n            else if (this.input && !this.input.enabled)\n            {\n                this.input.start();\n            }\n        }\n        else\n        {\n            if (this.input && this.input.enabled)\n            {\n                this.input.stop();\n            }\n        }\n\n    }\n\n});\n\n/**\n* An Text that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Text.cameraOffset.\n* Note that the cameraOffset values are in addition to any parent in the display list.\n* So if this Text was in a Group that has x: 200, then this will be added to the cameraOffset.x\n*\n* @name Phaser.Text#fixedToCamera\n* @property {boolean} fixedToCamera - Set to true to fix this Text to the Camera at its current world coordinates.\n*/\nObject.defineProperty(Phaser.Text.prototype, \"fixedToCamera\", {\n\n    get: function () {\n\n        return !!this._cache[7];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            this._cache[7] = 1;\n            this.cameraOffset.set(this.x, this.y);\n        }\n        else\n        {\n            this._cache[7] = 0;\n        }\n    }\n\n});\n\n/**\n* @name Phaser.Text#destroyPhase\n* @property {boolean} destroyPhase - True if this object is currently being destroyed.\n*/\nObject.defineProperty(Phaser.Text.prototype, \"destroyPhase\", {\n\n    get: function () {\n\n        return !!this._cache[8];\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new BitmapText object.\n*\n* @class Phaser.BitmapText\n*\n* @classdesc BitmapText objects work by taking a texture file and an XML file that describes the font layout.\n*\n* On Windows you can use the free app BMFont: http://www.angelcode.com/products/bmfont/\n* On OS X we recommend Glyph Designer: http://www.71squared.com/en/glyphdesigner\n* For Web there is the great Littera: http://kvazars.com/littera/\n*\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} x - X position of the new bitmapText object.\n* @param {number} y - Y position of the new bitmapText object.\n* @param {string} font - The key of the BitmapFont as stored in Game.Cache.\n* @param {string} [text=''] - The actual text that will be rendered. Can be set later via BitmapText.text.\n* @param {number} [size=32] - The size the font will be rendered in, in pixels.\n*/\nPhaser.BitmapText = function (game, x, y, font, text, size) {\n\n    x = x || 0;\n    y = y || 0;\n    font = font || '';\n    text = text || '';\n    size = size || 32;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} exists - If exists = false then the Sprite isn't updated by the core game loop or physics subsystem at all.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * @property {string} name - The user defined name given to this BitmapText.\n    * @default\n    */\n    this.name = '';\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @readonly\n    */\n    this.type = Phaser.BITMAPTEXT;\n\n    /**\n    * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.\n    */\n    this.z = 0;\n\n    /**\n    * @property {Phaser.Point} world - The world coordinates of this Sprite. This differs from the x/y coordinates which are relative to the Sprites container.\n    */\n    this.world = new Phaser.Point(x, y);\n\n    /**\n    * @property {string} _text - Internal cache var.\n    * @private\n    */\n    this._text = text;\n\n    /**\n    * @property {string} _font - Internal cache var.\n    * @private\n    */\n    this._font = font;\n\n    /**\n    * @property {number} _fontSize - Internal cache var.\n    * @private\n    */\n    this._fontSize = size;\n\n    /**\n    * @property {string} _align - Internal cache var.\n    * @private\n    */\n    this._align = 'left';\n\n    /**\n    * @property {number} _tint - Internal cache var.\n    * @private\n    */\n    this._tint = 0xFFFFFF;\n\n    /**\n    * @property {Phaser.Events} events - The Events you can subscribe to that are dispatched when certain things happen on this Sprite or its components.\n    */\n    this.events = new Phaser.Events(this);\n\n    /**\n    * @property {Phaser.InputHandler|null} input - The Input Handler for this object. Needs to be enabled with image.inputEnabled = true before you can use it.\n    */\n    this.input = null;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    PIXI.BitmapText.call(this, text);\n\n    this.position.set(x, y);\n\n    /**\n    * A small internal cache:\n    * 0 = previous position.x\n    * 1 = previous position.y\n    * 2 = previous rotation\n    * 3 = renderID\n    * 4 = fresh? (0 = no, 1 = yes)\n    * 5 = outOfBoundsFired (0 = no, 1 = yes)\n    * 6 = exists (0 = no, 1 = yes)\n    * 7 = fixed to camera (0 = no, 1 = yes)\n    * 8 = destroy phase? (0 = no, 1 = yes)\n    * @property {Array} _cache\n    * @private\n    */\n    this._cache = [0, 0, 0, 0, 1, 0, 1, 0, 0];\n\n};\n\nPhaser.BitmapText.prototype = Object.create(PIXI.BitmapText.prototype);\nPhaser.BitmapText.prototype.constructor = Phaser.BitmapText;\n\n/**\n* @method Phaser.BitmapText.prototype.setStyle\n* @private\n*/\nPhaser.BitmapText.prototype.setStyle = function() {\n\n    this.style = { align: this._align };\n    this.fontName = this._font;\n    this.fontSize = this._fontSize;\n    this.dirty = true;\n\n};\n\n/**\n* Automatically called by World.preUpdate.\n* @method Phaser.BitmapText.prototype.preUpdate\n*/\nPhaser.BitmapText.prototype.preUpdate = function () {\n\n    this._cache[0] = this.world.x;\n    this._cache[1] = this.world.y;\n    this._cache[2] = this.rotation;\n\n    if (!this.exists || !this.parent.exists)\n    {\n        this.renderOrderID = -1;\n        return false;\n    }\n\n    if (this.autoCull)\n    {\n        //  Won't get rendered but will still get its transform updated\n        this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());\n    }\n\n    this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);\n\n    if (this.visible)\n    {\n        this._cache[3] = this.game.stage.currentRenderOrderID++;\n    }\n\n    return true;\n\n};\n\n/**\n* Override and use this function in your own custom objects to handle any update requirements you may have.\n*\n* @method Phaser.BitmapText.prototype.update\n*/\nPhaser.BitmapText.prototype.update = function() {\n\n};\n\n/**\n* Automatically called by World.postUpdate.\n* @method Phaser.BitmapText.prototype.postUpdate\n*/\nPhaser.BitmapText.prototype.postUpdate = function () {\n\n    //  Fixed to Camera?\n    if (this._cache[7] === 1)\n    {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n};\n\n/**\n* Destroy this BitmapText instance. This will remove any filters and un-parent any children.\n* @method Phaser.BitmapText.prototype.destroy\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.BitmapText.prototype.destroy = function(destroyChildren) {\n\n    if (this.game === null || this.destroyPhase) { return; }\n\n    if (typeof destroyChildren === 'undefined') { destroyChildren = true; }\n\n    this._cache[8] = 1;\n\n    if (this.parent)\n    {\n        if (this.parent instanceof Phaser.Group)\n        {\n            this.parent.remove(this);\n        }\n        else\n        {\n            this.parent.removeChild(this);\n        }\n    }\n\n    var i = this.children.length;\n\n    if (destroyChildren)\n    {\n        while (i--)\n        {\n            if (this.children[i].destroy)\n            {\n                this.children[i].destroy(destroyChildren);\n            }\n            else\n            {\n                this.removeChild(this.children[i]);\n            }\n        }\n    }\n    else\n    {\n        while (i--)\n        {\n            this.removeChild(this.children[i]);\n        }\n    }\n\n    this.exists = false;\n    this.visible = false;\n\n    this.filters = null;\n    this.mask = null;\n    this.game = null;\n\n    this._cache[8] = 0;\n\n};\n\n/**\n* @name Phaser.BitmapText#align\n* @property {string} align - Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, 'align', {\n\n    get: function() {\n        return this._align;\n    },\n\n    set: function(value) {\n\n        if (value !== this._align)\n        {\n            this._align = value;\n            this.setStyle();\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.BitmapText#tint\n* @property {number} tint - The tint applied to the BitmapText. This is a hex value. Set to white to disable (0xFFFFFF)\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, 'tint', {\n\n    get: function() {\n        return this._tint;\n    },\n\n    set: function(value) {\n\n        if (value !== this._tint)\n        {\n            this._tint = value;\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* Indicates the rotation of the Text, in degrees, from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement player.angle = 450 is the same as player.angle = 90.\n* If you wish to work in radians instead of degrees use the property Sprite.rotation instead.\n* @name Phaser.BitmapText#angle\n* @property {number} angle - Gets or sets the angle of rotation in degrees.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, 'angle', {\n\n    get: function() {\n        return Phaser.Math.radToDeg(this.rotation);\n    },\n\n    set: function(value) {\n        this.rotation = Phaser.Math.degToRad(value);\n    }\n\n});\n\n/**\n* @name Phaser.BitmapText#font\n* @property {string} font - The font the text will be rendered in, i.e. 'Arial'. Must be loaded in the browser before use.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, 'font', {\n\n    get: function() {\n        return this._font;\n    },\n\n    set: function(value) {\n\n        if (value !== this._font)\n        {\n            this._font = value.trim();\n            this.style.font = this._fontSize + \"px '\" + this._font + \"'\";\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.BitmapText#fontSize\n* @property {number} fontSize - The size of the font in pixels.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, 'fontSize', {\n\n    get: function() {\n        return this._fontSize;\n    },\n\n    set: function(value) {\n\n        value = parseInt(value, 10);\n\n        if (value !== this._fontSize)\n        {\n            this._fontSize = value;\n            this.style.font = this._fontSize + \"px '\" + this._font + \"'\";\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* The text string to be displayed by this Text object, taking into account the style settings.\n* @name Phaser.BitmapText#text\n* @property {string} text - The text string to be displayed by this Text object, taking into account the style settings.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, 'text', {\n\n    get: function() {\n        return this._text;\n    },\n\n    set: function(value) {\n\n        if (value !== this._text)\n        {\n            this._text = value.toString() || ' ';\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* By default a Text object won't process any input events at all. By setting inputEnabled to true the Phaser.InputHandler is\n* activated for this object and it will then start to process click/touch events and more.\n*\n* @name Phaser.BitmapText#inputEnabled\n* @property {boolean} inputEnabled - Set to true to allow this object to receive input events.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, \"inputEnabled\", {\n\n    get: function () {\n\n        return (this.input && this.input.enabled);\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            if (this.input === null)\n            {\n                this.input = new Phaser.InputHandler(this);\n                this.input.start();\n            }\n            else if (this.input && !this.input.enabled)\n            {\n                this.input.start();\n            }\n        }\n        else\n        {\n            if (this.input && this.input.enabled)\n            {\n                this.input.stop();\n            }\n        }\n\n    }\n\n});\n\n/**\n* An BitmapText that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in BitmapText.cameraOffset.\n* Note that the cameraOffset values are in addition to any parent in the display list.\n* So if this BitmapText was in a Group that has x: 200, then this will be added to the cameraOffset.x\n*\n* @name Phaser.BitmapText#fixedToCamera\n* @property {boolean} fixedToCamera - Set to true to fix this BitmapText to the Camera at its current world coordinates.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, \"fixedToCamera\", {\n\n    get: function () {\n\n        return !!this._cache[7];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            this._cache[7] = 1;\n            this.cameraOffset.set(this.x, this.y);\n        }\n        else\n        {\n            this._cache[7] = 0;\n        }\n    }\n\n});\n\n/**\n* @name Phaser.BitmapText#destroyPhase\n* @property {boolean} destroyPhase - True if this object is currently being destroyed.\n*/\nObject.defineProperty(Phaser.BitmapText.prototype, \"destroyPhase\", {\n\n    get: function () {\n\n        return !!this._cache[8];\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Button\n*\n* @classdesc Create a new `Button` object. A Button is a special type of Sprite that is set-up to handle Pointer events automatically. The four states a Button responds to are:\n*\n* * 'Over' - when the Pointer moves over the Button. This is also commonly known as 'hover'.\n* * 'Out' - when the Pointer that was previously over the Button moves out of it.\n* * 'Down' - when the Pointer is pressed down on the Button. I.e. touched on a touch enabled device or clicked with the mouse.\n* * 'Up' - when the Pointer that was pressed down on the Button is released again.\n*\n* You can set a unique texture frame and Sound for any of these states.\n*\n* @constructor\n* @extends Phaser.Image\n*\n* @param {Phaser.Game} game Current game instance.\n* @param {number} [x=0] - X position of the Button.\n* @param {number} [y=0] - Y position of the Button.\n* @param {string} [key] - The image key as defined in the Game.Cache to use as the texture for this Button.\n* @param {function} [callback] - The function to call when this Button is pressed.\n* @param {object} [callbackContext] - The context in which the callback will be called (usually 'this').\n* @param {string|number} [overFrame] - This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.\n* @param {string|number} [outFrame] - This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.\n* @param {string|number} [downFrame] - This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.\n* @param {string|number} [upFrame] - This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.\n*/\nPhaser.Button = function (game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) {\n\n    x = x || 0;\n    y = y || 0;\n    key = key || null;\n    callback = callback || null;\n    callbackContext = callbackContext || this;\n\n    Phaser.Image.call(this, game, x, y, key, outFrame);\n\n    /**\n    * @property {number} type - The Phaser Object Type.\n    */\n    this.type = Phaser.BUTTON;\n\n    /**\n    * @property {string} _onOverFrameName - Internal variable.\n    * @private\n    * @default\n    */\n    this._onOverFrameName = null;\n\n    /**\n    * @property {string} _onOutFrameName - Internal variable.\n    * @private\n    * @default\n    */\n    this._onOutFrameName = null;\n\n    /**\n    * @property {string} _onDownFrameName - Internal variable.\n    * @private\n    * @default\n    */\n    this._onDownFrameName = null;\n\n    /**\n    * @property {string} _onUpFrameName - Internal variable.\n    * @private\n    * @default\n    */\n    this._onUpFrameName = null;\n\n    /**\n    * @property {number} _onOverFrameID - Internal variable.\n    * @private\n    * @default\n    */\n    this._onOverFrameID = null;\n\n    /**\n    * @property {number} _onOutFrameID - Internal variable.\n    * @private\n    * @default\n    */\n    this._onOutFrameID = null;\n\n    /**\n    * @property {number} _onDownFrameID - Internal variable.\n    * @private\n    * @default\n    */\n    this._onDownFrameID = null;\n\n    /**\n    * @property {number} _onUpFrameID - Internal variable.\n    * @private\n    * @default\n    */\n    this._onUpFrameID = null;\n\n    /**\n    * @property {Phaser.Sound} onOverSound - The Sound to be played when this Buttons Over state is activated.\n    * @default\n    */\n    this.onOverSound = null;\n\n    /**\n    * @property {Phaser.Sound} onOutSound - The Sound to be played when this Buttons Out state is activated.\n    * @default\n    */\n    this.onOutSound = null;\n\n    /**\n    * @property {Phaser.Sound} onDownSound - The Sound to be played when this Buttons Down state is activated.\n    * @default\n    */\n    this.onDownSound = null;\n\n    /**\n    * @property {Phaser.Sound} onUpSound - The Sound to be played when this Buttons Up state is activated.\n    * @default\n    */\n    this.onUpSound = null;\n\n    /**\n    * @property {string} onOverSoundMarker - The Sound Marker used in conjunction with the onOverSound.\n    * @default\n    */\n    this.onOverSoundMarker = '';\n\n    /**\n    * @property {string} onOutSoundMarker - The Sound Marker used in conjunction with the onOutSound.\n    * @default\n    */\n    this.onOutSoundMarker = '';\n\n    /**\n    * @property {string} onDownSoundMarker - The Sound Marker used in conjunction with the onDownSound.\n    * @default\n    */\n    this.onDownSoundMarker = '';\n\n    /**\n    * @property {string} onUpSoundMarker - The Sound Marker used in conjunction with the onUpSound.\n    * @default\n    */\n    this.onUpSoundMarker = '';\n\n    /**\n    * @property {Phaser.Signal} onInputOver - The Signal (or event) dispatched when this Button is in an Over state.\n    */\n    this.onInputOver = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onInputOut - The Signal (or event) dispatched when this Button is in an Out state.\n    */\n    this.onInputOut = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onInputDown - The Signal (or event) dispatched when this Button is in an Down state.\n    */\n    this.onInputDown = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onInputUp - The Signal (or event) dispatched when this Button is in an Up state.\n    */\n    this.onInputUp = new Phaser.Signal();\n\n    /**\n    * @property {boolean} freezeFrames - When true the Button will cease to change texture frame on all events (over, out, up, down).\n    */\n    this.freezeFrames = false;\n\n    /**\n    * When the Button is touched / clicked and then released you can force it to enter a state of \"out\" instead of \"up\".\n    * @property {boolean} forceOut\n    * @default\n    */\n    this.forceOut = false;\n\n    this.inputEnabled = true;\n\n    this.input.start(0, true);\n\n    this.setFrames(overFrame, outFrame, downFrame, upFrame);\n\n    if (callback !== null)\n    {\n        this.onInputUp.add(callback, callbackContext);\n    }\n\n    //  Redirect the input events to here so we can handle animation updates, etc\n    this.events.onInputOver.add(this.onInputOverHandler, this);\n    this.events.onInputOut.add(this.onInputOutHandler, this);\n    this.events.onInputDown.add(this.onInputDownHandler, this);\n    this.events.onInputUp.add(this.onInputUpHandler, this);\n\n};\n\nPhaser.Button.prototype = Object.create(Phaser.Image.prototype);\nPhaser.Button.prototype.constructor = Phaser.Button;\n\n/**\n* Clears all of the frames set on this Button.\n*\n* @method Phaser.Button.prototype.clearFrames\n*/\nPhaser.Button.prototype.clearFrames = function () {\n\n    this._onOverFrameName = null;\n    this._onOverFrameID = null;\n\n    this._onOutFrameName = null;\n    this._onOutFrameID = null;\n\n    this._onDownFrameName = null;\n    this._onDownFrameID = null;\n\n    this._onUpFrameName = null;\n    this._onUpFrameID = null;\n\n};\n\n/**\n* Used to manually set the frames that will be used for the different states of the Button.\n*\n* @method Phaser.Button.prototype.setFrames\n* @param {string|number} [overFrame] - This is the frame or frameName that will be set when this button is in an over state. Give either a number to use a frame ID or a string for a frame name.\n* @param {string|number} [outFrame] - This is the frame or frameName that will be set when this button is in an out state. Give either a number to use a frame ID or a string for a frame name.\n* @param {string|number} [downFrame] - This is the frame or frameName that will be set when this button is in a down state. Give either a number to use a frame ID or a string for a frame name.\n* @param {string|number} [upFrame] - This is the frame or frameName that will be set when this button is in an up state. Give either a number to use a frame ID or a string for a frame name.\n*/\nPhaser.Button.prototype.setFrames = function (overFrame, outFrame, downFrame, upFrame) {\n\n    this.clearFrames();\n\n    if (overFrame !== null)\n    {\n        if (typeof overFrame === 'string')\n        {\n            this._onOverFrameName = overFrame;\n\n            if (this.input.pointerOver())\n            {\n                this.frameName = overFrame;\n            }\n        }\n        else\n        {\n            this._onOverFrameID = overFrame;\n\n            if (this.input.pointerOver())\n            {\n                this.frame = overFrame;\n            }\n        }\n    }\n\n    if (outFrame !== null)\n    {\n        if (typeof outFrame === 'string')\n        {\n            this._onOutFrameName = outFrame;\n\n            if (this.input.pointerOver() === false)\n            {\n                this.frameName = outFrame;\n            }\n        }\n        else\n        {\n            this._onOutFrameID = outFrame;\n\n            if (this.input.pointerOver() === false)\n            {\n                this.frame = outFrame;\n            }\n        }\n    }\n\n    if (downFrame !== null)\n    {\n        if (typeof downFrame === 'string')\n        {\n            this._onDownFrameName = downFrame;\n\n            if (this.input.pointerDown())\n            {\n                this.frameName = downFrame;\n            }\n        }\n        else\n        {\n            this._onDownFrameID = downFrame;\n\n            if (this.input.pointerDown())\n            {\n                this.frame = downFrame;\n            }\n        }\n    }\n\n    if (upFrame !== null)\n    {\n        if (typeof upFrame === 'string')\n        {\n            this._onUpFrameName = upFrame;\n\n            if (this.input.pointerUp())\n            {\n                this.frameName = upFrame;\n            }\n        }\n        else\n        {\n            this._onUpFrameID = upFrame;\n\n            if (this.input.pointerUp())\n            {\n                this.frame = upFrame;\n            }\n        }\n    }\n\n};\n\n/**\n* Sets the sounds to be played whenever this Button is interacted with. Sounds can be either full Sound objects, or markers pointing to a section of a Sound object.\n* The most common forms of sounds are 'hover' effects and 'click' effects, which is why the order of the parameters is overSound then downSound.\n* Call this function with no parameters at all to reset all sounds on this Button.\n*\n* @method Phaser.Button.prototype.setSounds\n* @param {Phaser.Sound} [overSound] - Over Button Sound.\n* @param {string} [overMarker] - Over Button Sound Marker.\n* @param {Phaser.Sound} [downSound] - Down Button Sound.\n* @param {string} [downMarker] - Down Button Sound Marker.\n* @param {Phaser.Sound} [outSound] - Out Button Sound.\n* @param {string} [outMarker] - Out Button Sound Marker.\n* @param {Phaser.Sound} [upSound] - Up Button Sound.\n* @param {string} [upMarker] - Up Button Sound Marker.\n*/\nPhaser.Button.prototype.setSounds = function (overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) {\n\n    this.setOverSound(overSound, overMarker);\n    this.setOutSound(outSound, outMarker);\n    this.setDownSound(downSound, downMarker);\n    this.setUpSound(upSound, upMarker);\n\n};\n\n/**\n* The Sound to be played when a Pointer moves over this Button.\n*\n* @method Phaser.Button.prototype.setOverSound\n* @param {Phaser.Sound} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setOverSound = function (sound, marker) {\n\n    this.onOverSound = null;\n    this.onOverSoundMarker = '';\n\n    if (sound instanceof Phaser.Sound)\n    {\n        this.onOverSound = sound;\n    }\n\n    if (typeof marker === 'string')\n    {\n        this.onOverSoundMarker = marker;\n    }\n\n};\n\n/**\n* The Sound to be played when a Pointer moves out of this Button.\n*\n* @method Phaser.Button.prototype.setOutSound\n* @param {Phaser.Sound} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setOutSound = function (sound, marker) {\n\n    this.onOutSound = null;\n    this.onOutSoundMarker = '';\n\n    if (sound instanceof Phaser.Sound)\n    {\n        this.onOutSound = sound;\n    }\n\n    if (typeof marker === 'string')\n    {\n        this.onOutSoundMarker = marker;\n    }\n\n};\n\n/**\n* The Sound to be played when a Pointer presses down on this Button.\n*\n* @method Phaser.Button.prototype.setDownSound\n* @param {Phaser.Sound} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setDownSound = function (sound, marker) {\n\n    this.onDownSound = null;\n    this.onDownSoundMarker = '';\n\n    if (sound instanceof Phaser.Sound)\n    {\n        this.onDownSound = sound;\n    }\n\n    if (typeof marker === 'string')\n    {\n        this.onDownSoundMarker = marker;\n    }\n\n};\n\n/**\n* The Sound to be played when a Pointer has pressed down and is released from this Button.\n*\n* @method Phaser.Button.prototype.setUpSound\n* @param {Phaser.Sound} sound - The Sound that will be played.\n* @param {string} [marker] - A Sound Marker that will be used in the playback.\n*/\nPhaser.Button.prototype.setUpSound = function (sound, marker) {\n\n    this.onUpSound = null;\n    this.onUpSoundMarker = '';\n\n    if (sound instanceof Phaser.Sound)\n    {\n        this.onUpSound = sound;\n    }\n\n    if (typeof marker === 'string')\n    {\n        this.onUpSoundMarker = marker;\n    }\n\n};\n\n/**\n* Internal function that handles input events.\n*\n* @protected\n* @method Phaser.Button.prototype.onInputOverHandler\n* @param {Phaser.Button} sprite - The Button that the event occured on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputOverHandler = function (sprite, pointer) {\n\n    if (this.freezeFrames === false)\n    {\n        this.setState(1);\n    }\n\n    if (this.onOverSound)\n    {\n        this.onOverSound.play(this.onOverSoundMarker);\n    }\n\n    if (this.onInputOver)\n    {\n        this.onInputOver.dispatch(this, pointer);\n    }\n};\n\n/**\n* Internal function that handles input events.\n*\n* @protected\n* @method Phaser.Button.prototype.onInputOutHandler\n* @param {Phaser.Button} sprite - The Button that the event occured on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputOutHandler = function (sprite, pointer) {\n\n    if (this.freezeFrames === false)\n    {\n        this.setState(2);\n    }\n\n    if (this.onOutSound)\n    {\n        this.onOutSound.play(this.onOutSoundMarker);\n    }\n\n    if (this.onInputOut)\n    {\n        this.onInputOut.dispatch(this, pointer);\n    }\n};\n\n/**\n* Internal function that handles input events.\n*\n* @protected\n* @method Phaser.Button.prototype.onInputDownHandler\n* @param {Phaser.Button} sprite - The Button that the event occured on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputDownHandler = function (sprite, pointer) {\n\n    if (this.freezeFrames === false)\n    {\n        this.setState(3);\n    }\n\n    if (this.onDownSound)\n    {\n        this.onDownSound.play(this.onDownSoundMarker);\n    }\n\n    if (this.onInputDown)\n    {\n        this.onInputDown.dispatch(this, pointer);\n    }\n};\n\n/**\n* Internal function that handles input events.\n*\n* @protected\n* @method Phaser.Button.prototype.onInputUpHandler\n* @param {Phaser.Button} sprite - The Button that the event occured on.\n* @param {Phaser.Pointer} pointer - The Pointer that activated the Button.\n*/\nPhaser.Button.prototype.onInputUpHandler = function (sprite, pointer, isOver) {\n\n    if (this.onUpSound)\n    {\n        this.onUpSound.play(this.onUpSoundMarker);\n    }\n\n    if (this.onInputUp)\n    {\n        this.onInputUp.dispatch(this, pointer, isOver);\n    }\n\n    if (this.freezeFrames)\n    {\n        return;\n    }\n\n    if (this.forceOut)\n    {\n        //  Button should be forced to the Out frame when released.\n        this.setState(2);\n    }\n    else\n    {\n        if (this._onUpFrameName !== null || this._onUpFrameID !== null)\n        {\n            this.setState(4);\n        }\n        else\n        {\n            if (isOver)\n            {\n                this.setState(1);\n            }\n            else\n            {\n                this.setState(2);\n            }\n        }\n    }\n\n};\n\n/**\n* Internal function that handles Button state changes.\n*\n* @protected\n* @method Phaser.Button.prototype.setState\n* @param {number} newState - The new State of the Button.\n*/\nPhaser.Button.prototype.setState = function (newState) {\n\n    if (newState === 1)\n    {\n        //  Over\n        if (this._onOverFrameName != null)\n        {\n            this.frameName = this._onOverFrameName;\n        }\n        else if (this._onOverFrameID != null)\n        {\n            this.frame = this._onOverFrameID;\n        }\n    }\n    else if (newState === 2)\n    {\n        //  Out\n        if (this._onOutFrameName != null)\n        {\n            this.frameName = this._onOutFrameName;\n        }\n        else if (this._onOutFrameID != null)\n        {\n            this.frame = this._onOutFrameID;\n        }\n    }\n    else if (newState === 3)\n    {\n        //  Down\n        if (this._onDownFrameName != null)\n        {\n            this.frameName = this._onDownFrameName;\n        }\n        else if (this._onDownFrameID != null)\n        {\n            this.frame = this._onDownFrameID;\n        }\n    }\n    else if (newState === 4)\n    {\n        //  Up\n        if (this._onUpFrameName != null)\n        {\n            this.frameName = this._onUpFrameName;\n        }\n        else if (this._onUpFrameID != null)\n        {\n            this.frame = this._onUpFrameID;\n        }\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new `Graphics` object.\n*\n* @class Phaser.Graphics\n* @constructor\n*\n* @param {Phaser.Game} game Current game instance.\n* @param {number} x - X position of the new graphics object.\n* @param {number} y - Y position of the new graphics object.\n*/\nPhaser.Graphics = function (game, x, y) {\n\n    x = x || 0;\n    y = y || 0;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} exists - If exists = false then the Text isn't updated by the core game loop.\n    * @default\n    */\n    this.exists = true;\n\n    /**\n    * @property {string} name - The user defined name given to this object.\n    * @default\n    */\n    this.name = '';\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.GRAPHICS;\n\n    /**\n    * @property {number} z - The z-depth value of this object within its Group (remember the World is a Group as well). No two objects in a Group can have the same z value.\n    */\n    this.z = 0;\n\n    /**\n    * @property {Phaser.Point} world - The world coordinates of this Sprite. This differs from the x/y coordinates which are relative to the Sprites container.\n    */\n    this.world = new Phaser.Point(x, y);\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixedToCamera then this stores the x/y offset that its drawn at, from the top-left of the camera view.\n    */\n    this.cameraOffset = new Phaser.Point();\n\n    PIXI.Graphics.call(this);\n\n    this.position.set(x, y);\n\n    /**\n    * A small internal cache:\n    * 0 = previous position.x\n    * 1 = previous position.y\n    * 2 = previous rotation\n    * 3 = renderID\n    * 4 = fresh? (0 = no, 1 = yes)\n    * 5 = outOfBoundsFired (0 = no, 1 = yes)\n    * 6 = exists (0 = no, 1 = yes)\n    * 7 = fixed to camera (0 = no, 1 = yes)\n    * 8 = destroy phase? (0 = no, 1 = yes)\n    * @property {Array} _cache\n    * @private\n    */\n    this._cache = [ 0, 0, 0, 0, 1, 0, 1, 0, 0 ];\n\n};\n\nPhaser.Graphics.prototype = Object.create(PIXI.Graphics.prototype);\nPhaser.Graphics.prototype.constructor = Phaser.Graphics;\n\n/**\n* Automatically called by World.preUpdate.\n* @method Phaser.Graphics.prototype.preUpdate\n*/\nPhaser.Graphics.prototype.preUpdate = function () {\n\n    this._cache[0] = this.world.x;\n    this._cache[1] = this.world.y;\n    this._cache[2] = this.rotation;\n\n    if (!this.exists || !this.parent.exists)\n    {\n        this.renderOrderID = -1;\n        return false;\n    }\n\n    if (this.autoCull)\n    {\n        //  Won't get rendered but will still get its transform updated\n        this.renderable = this.game.world.camera.screenView.intersects(this.getBounds());\n    }\n\n    this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);\n\n    if (this.visible)\n    {\n        this._cache[3] = this.game.stage.currentRenderOrderID++;\n    }\n\n    return true;\n\n};\n\n/**\n* Override and use this function in your own custom objects to handle any update requirements you may have.\n*\n* @method Phaser.Graphics#update\n* @memberof Phaser.Graphics\n*/\nPhaser.Graphics.prototype.update = function() {\n\n};\n\n/**\n* Automatically called by World.postUpdate.\n* @method Phaser.Graphics.prototype.postUpdate\n*/\nPhaser.Graphics.prototype.postUpdate = function () {\n\n    //  Fixed to Camera?\n    if (this._cache[7] === 1)\n    {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n};\n\n/**\n* Destroy this Graphics instance.\n*\n* @method Phaser.Graphics.prototype.destroy\n* @param {boolean} [destroyChildren=true] - Should every child of this object have its destroy method called?\n*/\nPhaser.Graphics.prototype.destroy = function(destroyChildren) {\n\n    if (this.game === null || this.destroyPhase) { return; }\n\n    if (typeof destroyChildren === 'undefined') { destroyChildren = true; }\n\n    this._cache[8] = 1;\n\n    this.clear();\n\n    if (this.parent)\n    {\n        if (this.parent instanceof Phaser.Group)\n        {\n            this.parent.remove(this);\n        }\n        else\n        {\n            this.parent.removeChild(this);\n        }\n    }\n\n    var i = this.children.length;\n\n    if (destroyChildren)\n    {\n        while (i--)\n        {\n            this.children[i].destroy(destroyChildren);\n        }\n    }\n    else\n    {\n        while (i--)\n        {\n            this.removeChild(this.children[i]);\n        }\n    }\n\n    this.exists = false;\n    this.visible = false;\n\n    this.game = null;\n\n    this._cache[8] = 0;\n\n};\n\n/*\n* Draws a {Phaser.Polygon} or a {PIXI.Polygon} filled\n*\n* @method Phaser.Graphics.prototype.drawPolygon\n*/\nPhaser.Graphics.prototype.drawPolygon = function (poly) {\n\n    this.moveTo(poly.points[0].x, poly.points[0].y);\n\n    for (var i = 1; i < poly.points.length; i += 1)\n    {\n        this.lineTo(poly.points[i].x, poly.points[i].y);\n    }\n\n    this.lineTo(poly.points[0].x, poly.points[0].y);\n\n};\n\n/**\n* Indicates the rotation of the Graphics, in degrees, from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement player.angle = 450 is the same as player.angle = 90.\n* If you wish to work in radians instead of degrees use the property Sprite.rotation instead.\n* @name Phaser.Graphics#angle\n* @property {number} angle - Gets or sets the angle of rotation in degrees.\n*/\nObject.defineProperty(Phaser.Graphics.prototype, 'angle', {\n\n    get: function() {\n        return Phaser.Math.radToDeg(this.rotation);\n    },\n\n    set: function(value) {\n        this.rotation = Phaser.Math.degToRad(value);\n    }\n\n});\n\n/**\n* An Graphics that is fixed to the camera uses its x/y coordinates as offsets from the top left of the camera. These are stored in Graphics.cameraOffset.\n* Note that the cameraOffset values are in addition to any parent in the display list.\n* So if this Graphics was in a Group that has x: 200, then this will be added to the cameraOffset.x\n*\n* @name Phaser.Graphics#fixedToCamera\n* @property {boolean} fixedToCamera - Set to true to fix this Graphics to the Camera at its current world coordinates.\n*/\nObject.defineProperty(Phaser.Graphics.prototype, \"fixedToCamera\", {\n\n    get: function () {\n\n        return !!this._cache[7];\n\n    },\n\n    set: function (value) {\n\n        if (value)\n        {\n            this._cache[7] = 1;\n            this.cameraOffset.set(this.x, this.y);\n        }\n        else\n        {\n            this._cache[7] = 0;\n        }\n    }\n\n});\n\n/**\n* @name Phaser.Graphics#destroyPhase\n* @property {boolean} destroyPhase - True if this object is currently being destroyed.\n*/\nObject.defineProperty(Phaser.Graphics.prototype, \"destroyPhase\", {\n\n    get: function () {\n\n        return !!this._cache[8];\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A RenderTexture is a special texture that allows any displayObject to be rendered to it.\n* @class Phaser.RenderTexture\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n* @param {string} key - Internal Phaser reference key for the render texture.\n* @param {number} [width=100] - The width of the render texture.\n* @param {number} [height=100] - The height of the render texture.\n*/\nPhaser.RenderTexture = function (game, width, height, key) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} key - The key of the RenderTexture in the Cache, if stored there.\n    */\n    this.key = key;\n\n    /**\n    * @property {number} type - Base Phaser object type.\n    */\n    this.type = Phaser.RENDERTEXTURE;\n\n    /**\n    * @property {Phaser.Point} _temp - Internal var.\n    * @private\n    */\n    this._temp = new Phaser.Point();\n\n    PIXI.RenderTexture.call(this, width, height);\n\n};\n\nPhaser.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype);\nPhaser.RenderTexture.prototype.constructor = Phaser.RenderTexture;\n\n/**\n* This function will draw the display object to the texture.\n*\n* @method Phaser.RenderTexture.prototype.renderXY\n* @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Group} displayObject  The display object to render to this texture.\n* @param {number} x - The x position to render the object at.\n* @param {number} y - The y position to render the object at.\n* @param {boolean} clear - If true the texture will be cleared before the display object is drawn.\n*/\nPhaser.RenderTexture.prototype.renderXY = function (displayObject, x, y, clear) {\n\n    this._temp.set(x, y);\n\n    this.render(displayObject, this._temp, clear);\n\n};\n\n//  Documentation stubs\n\n/**\n* This function will draw the display object to the texture.\n*\n* @method Phaser.RenderTexture.prototype.render\n* @param {Phaser.Sprite|Phaser.Image|Phaser.Text|Phaser.BitmapText|Phaser.Group} displayObject  The display object to render to this texture.\n* @param {Phaser.Point} position - A Point object containing the position to render the display object at.\n* @param {boolean} clear - If true the texture will be cleared before the display object is drawn.\n*/\n\n/**\n* Resize this RenderTexture to the given width and height.\n*\n* @method Phaser.RenderTexture.prototype.resize\n* @param {number} width - The new width of the RenderTexture.\n* @param {number} height - The new height of the RenderTexture.\n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser SpriteBatch constructor.\n*\n* @classdesc The SpriteBatch class is a really fast version of the DisplayObjectContainer built solely for speed, so use when you need a lot of sprites or particles.\n* @class Phaser.SpriteBatch\n* @extends Phaser.Group\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Phaser.Group|Phaser.Sprite} parent - The parent Group, DisplayObject or DisplayObjectContainer that this Group will be added to. If undefined or null it will use game.world.\n* @param {string} [name=group] - A name for this Group. Not used internally but useful for debugging.\n* @param {boolean} [addToStage=false] - If set to true this Group will be added directly to the Game.Stage instead of Game.World.\n*/\nPhaser.SpriteBatch = function (game, parent, name, addToStage) {\n\n    PIXI.SpriteBatch.call(this);\n\n    Phaser.Group.call(this, game, parent, name, addToStage);\n\n    /**\n    * @property {number} type - Internal Phaser Type value.\n    * @protected\n    */\n    this.type = Phaser.SPRITEBATCH;\n\n};\n\nPhaser.SpriteBatch.prototype = Phaser.Utils.extend(true, Phaser.SpriteBatch.prototype, Phaser.Group.prototype, PIXI.SpriteBatch.prototype);\n\nPhaser.SpriteBatch.prototype.constructor = Phaser.SpriteBatch;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.RetroFont\n* @extends Phaser.RenderTexture\n* @constructor\n* @param {Phaser.Game} game - Current game instance.\n* @param {string} key - The font set graphic set as stored in the Game.Cache.\n* @param {number} characterWidth - The width of each character in the font set.\n* @param {number} characterHeight - The height of each character in the font set.\n* @param {string} chars - The characters used in the font set, in display order. You can use the TEXT_SET consts for common font set arrangements.\n* @param {number} charsPerRow - The number of characters per row in the font set.\n* @param {number} [xSpacing=0] - If the characters in the font set have horizontal spacing between them set the required amount here.\n* @param {number} [ySpacing=0] - If the characters in the font set have vertical spacing between them set the required amount here.\n* @param {number} [xOffset=0] - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.\n* @param {number} [yOffset=0] - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.\n*/\nPhaser.RetroFont = function (game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) {\n\n    /**\n    * @property {number} characterWidth - The width of each character in the font set.\n    */\n    this.characterWidth = characterWidth;\n\n    /**\n    * @property {number} characterHeight - The height of each character in the font set.\n    */\n    this.characterHeight = characterHeight;\n\n    /**\n    * @property {number} characterSpacingX - If the characters in the font set have horizontal spacing between them set the required amount here.\n    */\n    this.characterSpacingX = xSpacing || 0;\n\n    /**\n    * @property {number} characterSpacingY - If the characters in the font set have vertical spacing between them set the required amount here.\n    */\n    this.characterSpacingY = ySpacing || 0;\n\n    /**\n    * @property {number} characterPerRow - The number of characters per row in the font set.\n    */\n    this.characterPerRow = charsPerRow;\n\n    /**\n    * @property {number} offsetX - If the font set doesn't start at the top left of the given image, specify the X coordinate offset here.\n    */\n    this.offsetX = xOffset || 0;\n\n    /**\n    * @property {number} offsetY - If the font set doesn't start at the top left of the given image, specify the Y coordinate offset here.\n    */\n    this.offsetY = yOffset || 0;\n\n    /**\n    * @property {string} align - Alignment of the text when multiLine = true or a fixedWidth is set. Set to RetroFont.ALIGN_LEFT (default), RetroFont.ALIGN_RIGHT or RetroFont.ALIGN_CENTER.\n    */\n    this.align = \"left\";\n\n    /**\n    * @property {boolean} multiLine - If set to true all carriage-returns in text will form new lines (see align). If false the font will only contain one single line of text (the default)\n    * @default\n    */\n    this.multiLine = false;\n\n    /**\n    * @property {boolean} autoUpperCase - Automatically convert any text to upper case. Lots of old bitmap fonts only contain upper-case characters, so the default is true.\n    * @default\n    */\n    this.autoUpperCase = true;\n\n    /**\n    * @property {number} customSpacingX - Adds horizontal spacing between each character of the font, in pixels.\n    * @default\n    */\n    this.customSpacingX = 0;\n\n    /**\n    * @property {number} customSpacingY - Adds vertical spacing between each line of multi-line text, set in pixels.\n    * @default\n    */\n    this.customSpacingY = 0;\n\n    /**\n    * If you need this RetroFont image to have a fixed width you can set the width in this value.\n    * If text is wider than the width specified it will be cropped off.\n    * @property {number} fixedWidth\n    */\n    this.fixedWidth = 0;\n\n    /**\n    * @property {HTMLImage} fontSet - A reference to the image stored in the Game.Cache that contains the font.\n    */\n    this.fontSet = game.cache.getImage(key);\n\n    /**\n    * @property {string} _text - The text of the font image.\n    * @private\n    */\n    this._text = '';\n\n    /**\n    * @property {array} grabData - An array of rects for faster character pasting.\n    * @private\n    */\n    this.grabData = [];\n\n    //  Now generate our rects for faster copying later on\n    var currentX = this.offsetX;\n    var currentY = this.offsetY;\n    var r = 0;\n    var data = new Phaser.FrameData();\n\n    for (var c = 0; c < chars.length; c++)\n    {\n        var uuid = game.rnd.uuid();\n\n        var frame = data.addFrame(new Phaser.Frame(c, currentX, currentY, this.characterWidth, this.characterHeight, '', uuid));\n\n        this.grabData[chars.charCodeAt(c)] = frame.index;\n\n        PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {\n            x: currentX,\n            y: currentY,\n            width: this.characterWidth,\n            height: this.characterHeight\n        });\n\n        r++;\n\n        if (r == this.characterPerRow)\n        {\n            r = 0;\n            currentX = this.offsetX;\n            currentY += this.characterHeight + this.characterSpacingY;\n        }\n        else\n        {\n            currentX += this.characterWidth + this.characterSpacingX;\n        }\n    }\n\n    game.cache.updateFrameData(key, data);\n\n    this.stamp = new Phaser.Image(game, 0, 0, key, 0);\n\n    Phaser.RenderTexture.call(this, game);\n\n    /**\n    * @property {number} type - Base Phaser object type.\n    */\n    this.type = Phaser.RETROFONT;\n\n};\n\nPhaser.RetroFont.prototype = Object.create(Phaser.RenderTexture.prototype);\nPhaser.RetroFont.prototype.constructor = Phaser.RetroFont;\n\n/**\n* Align each line of multi-line text to the left.\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.ALIGN_LEFT = \"left\";\n\n/**\n* Align each line of multi-line text to the right.\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.ALIGN_RIGHT = \"right\";\n\n/**\n* Align each line of multi-line text in the center.\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.ALIGN_CENTER = \"center\";\n\n/**\n* Text Set 1 = !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET1 = \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\";\n\n/**\n* Text Set 2 =  !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET2 = \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n/**\n* Text Set 3 = ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \";\n\n/**\n* Text Set 4 = ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET4 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789\";\n\n/**\n* Text Set 5 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET5 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789\";\n\n/**\n* Text Set 6 = ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\\\"(),-.'\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET6 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\\\"(),-.' \";\n\n/**\n* Text Set 7 = AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\\\")28FLRX-'39\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET7 = \"AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\\\")28FLRX-'39\";\n\n/**\n* Text Set 8 = 0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET8 = \"0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n/**\n* Text Set 9 = ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\\\"?!\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET9 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\\\"?!\";\n\n/**\n* Text Set 10 = ABCDEFGHIJKLMNOPQRSTUVWXYZ\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET10 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n/**\n* Text Set 11 = ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\\\"-+!?()':;0123456789\n* @constant\n* @type {string}\n*/\nPhaser.RetroFont.TEXT_SET11 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\\\"-+!?()':;0123456789\";\n\n/**\n* If you need this FlxSprite to have a fixed width and custom alignment you can set the width here.<br>\n* If text is wider than the width specified it will be cropped off.\n*\n* @method Phaser.RetroFont#setFixedWidth\n* @memberof Phaser.RetroFont\n* @param {number} width - Width in pixels of this RetroFont. Set to zero to disable and re-enable automatic resizing.\n* @param {string} [lineAlignment='left'] - Align the text within this width. Set to RetroFont.ALIGN_LEFT (default), RetroFont.ALIGN_RIGHT or RetroFont.ALIGN_CENTER.\n*/\nPhaser.RetroFont.prototype.setFixedWidth = function (width, lineAlignment) {\n\n    if (typeof lineAlignment === 'undefined') { lineAlignment = 'left'; }\n\n    this.fixedWidth = width;\n    this.align = lineAlignment;\n\n};\n\n/**\n* A helper function that quickly sets lots of variables at once, and then updates the text.\n*\n* @method Phaser.RetroFont#setText\n* @memberof Phaser.RetroFont\n* @param {string} content - The text of this sprite.\n* @param {boolean} [multiLine=false] - Set to true if you want to support carriage-returns in the text and create a multi-line sprite instead of a single line.\n* @param {number} [characterSpacing=0] - To add horizontal spacing between each character specify the amount in pixels.\n* @param {number} [lineSpacing=0] - To add vertical spacing between each line of text, set the amount in pixels.\n* @param {string} [lineAlignment='left'] - Align each line of multi-line text. Set to RetroFont.ALIGN_LEFT, RetroFont.ALIGN_RIGHT or RetroFont.ALIGN_CENTER.\n* @param {boolean} [allowLowerCase=false] - Lots of bitmap font sets only include upper-case characters, if yours needs to support lower case then set this to true.\n*/\nPhaser.RetroFont.prototype.setText = function (content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) {\n\n    this.multiLine = multiLine || false;\n    this.customSpacingX = characterSpacing || 0;\n    this.customSpacingY = lineSpacing || 0;\n    this.align = lineAlignment || 'left';\n\n    if (allowLowerCase)\n    {\n        this.autoUpperCase = false;\n    }\n    else\n    {\n        this.autoUpperCase = true;\n    }\n\n    if (content.length > 0)\n    {\n        this.text = content;\n    }\n\n};\n\n/**\n* Over rides the default PIXI.RenderTexture resize event as we need our baseTexture resized as well.\n*\n* @method Phaser.RetroFont#resize\n* @memberof Phaser.RetroFont\n*/\nPhaser.RetroFont.prototype.resize = function (width, height) {\n\n    this.width = width;\n    this.height = height;\n\n    this.frame.width = this.width;\n    this.frame.height = this.height;\n\n    this.baseTexture.width = this.width;\n    this.baseTexture.height = this.height;\n\n    if (this.renderer.type === PIXI.WEBGL_RENDERER)\n    {\n        this.projection.x = this.width / 2;\n        this.projection.y = -this.height / 2;\n\n        var gl = this.renderer.gl;\n        gl.bindTexture(gl.TEXTURE_2D, this.baseTexture._glTextures[gl.id]);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    }\n    else\n    {\n        this.textureBuffer.resize(this.width, this.height);\n    }\n\n    PIXI.Texture.frameUpdates.push(this);\n\n};\n\n/**\n* Updates the BitmapData of the Sprite with the text\n*\n* @method Phaser.RetroFont#buildRetroFontText\n* @memberof Phaser.RetroFont\n*/\nPhaser.RetroFont.prototype.buildRetroFontText = function () {\n\n    var cx = 0;\n    var cy = 0;\n\n    if (this.multiLine)\n    {\n        var lines = this._text.split(\"\\n\");\n\n        if (this.fixedWidth > 0)\n        {\n            this.resize(this.fixedWidth, (lines.length * (this.characterHeight + this.customSpacingY)) - this.customSpacingY);\n        }\n        else\n        {\n            this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), (lines.length * (this.characterHeight + this.customSpacingY)) - this.customSpacingY);\n        }\n\n        this.textureBuffer.clear();\n\n        //  Loop through each line of text\n        for (var i = 0; i < lines.length; i++)\n        {\n            //  This line of text is held in lines[i] - need to work out the alignment\n            switch (this.align)\n            {\n                case Phaser.RetroFont.ALIGN_LEFT:\n                    cx = 0;\n                    break;\n\n                case Phaser.RetroFont.ALIGN_RIGHT:\n                    cx = this.width - (lines[i].length * (this.characterWidth + this.customSpacingX));\n                    break;\n\n                case Phaser.RetroFont.ALIGN_CENTER:\n                    cx = (this.width / 2) - ((lines[i].length * (this.characterWidth + this.customSpacingX)) / 2);\n                    cx += this.customSpacingX / 2;\n                    break;\n            }\n\n            //  Sanity checks\n            if (cx < 0)\n            {\n                cx = 0;\n            }\n\n            this.pasteLine(lines[i], cx, cy, this.customSpacingX);\n\n            cy += this.characterHeight + this.customSpacingY;\n        }\n    }\n    else\n    {\n        if (this.fixedWidth > 0)\n        {\n            this.resize(this.fixedWidth, this.characterHeight);\n        }\n        else\n        {\n            this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight);\n        }\n\n        this.textureBuffer.clear();\n\n        switch (this.align)\n        {\n            case Phaser.RetroFont.ALIGN_LEFT:\n                cx = 0;\n                break;\n\n            case Phaser.RetroFont.ALIGN_RIGHT:\n                cx = this.width - (this._text.length * (this.characterWidth + this.customSpacingX));\n                break;\n\n            case Phaser.RetroFont.ALIGN_CENTER:\n                cx = (this.width / 2) - ((this._text.length * (this.characterWidth + this.customSpacingX)) / 2);\n                cx += this.customSpacingX / 2;\n                break;\n        }\n\n        this.pasteLine(this._text, cx, 0, this.customSpacingX);\n    }\n\n};\n\n/**\n* Internal function that takes a single line of text (2nd parameter) and pastes it into the BitmapData at the given coordinates.\n* Used by getLine and getMultiLine\n*\n* @method Phaser.RetroFont#buildRetroFontText\n* @memberof Phaser.RetroFont\n* @param {string} line - The single line of text to paste.\n* @param {number} x - The x coordinate.\n* @param {number} y - The y coordinate.\n* @param {number} customSpacingX - Custom X spacing.\n*/\nPhaser.RetroFont.prototype.pasteLine = function (line, x, y, customSpacingX) {\n\n    var p = new Phaser.Point();\n\n    for (var c = 0; c < line.length; c++)\n    {\n        //  If it's a space then there is no point copying, so leave a blank space\n        if (line.charAt(c) == \" \")\n        {\n            x += this.characterWidth + customSpacingX;\n        }\n        else\n        {\n            //  If the character doesn't exist in the font then we don't want a blank space, we just want to skip it\n            if (this.grabData[line.charCodeAt(c)] >= 0)\n            {\n                this.stamp.frame = this.grabData[line.charCodeAt(c)];\n                p.set(x, y);\n                this.render(this.stamp, p, false);\n\n                x += this.characterWidth + customSpacingX;\n\n                if (x > this.width)\n                {\n                    break;\n                }\n            }\n        }\n    }\n};\n\n/**\n* Works out the longest line of text in _text and returns its length\n*\n* @method Phaser.RetroFont#getLongestLine\n* @memberof Phaser.RetroFont\n* @return {number} The length of the longest line of text.\n*/\nPhaser.RetroFont.prototype.getLongestLine = function () {\n\n    var longestLine = 0;\n\n    if (this._text.length > 0)\n    {\n        var lines = this._text.split(\"\\n\");\n\n        for (var i = 0; i < lines.length; i++)\n        {\n            if (lines[i].length > longestLine)\n            {\n                longestLine = lines[i].length;\n            }\n        }\n    }\n\n    return longestLine;\n};\n\n/**\n* Internal helper function that removes all unsupported characters from the _text String, leaving only characters contained in the font set.\n*\n* @method Phaser.RetroFont#removeUnsupportedCharacters\n* @memberof Phaser.RetroFont\n* @protected\n* @param {boolean} [stripCR=true] - Should it strip carriage returns as well?\n* @return {string}  A clean version of the string.\n*/\nPhaser.RetroFont.prototype.removeUnsupportedCharacters = function (stripCR) {\n\n    var newString = \"\";\n\n    for (var c = 0; c < this._text.length; c++)\n    {\n        var aChar = this._text[c];\n        var code = aChar.charCodeAt(0);\n\n        if (this.grabData[code] >= 0 || (!stripCR && aChar === \"\\n\"))\n        {\n            newString = newString.concat(aChar);\n        }\n    }\n\n    return newString;\n};\n\n/**\n* @name Phaser.BitmapText#text\n* @property {string} text - Set this value to update the text in this sprite. Carriage returns are automatically stripped out if multiLine is false. Text is converted to upper case if autoUpperCase is true.\n*/\nObject.defineProperty(Phaser.RetroFont.prototype, \"text\", {\n\n    get: function () {\n\n        return this._text;\n\n    },\n\n    set: function (value) {\n\n        var newText;\n\n        if (this.autoUpperCase)\n        {\n            newText = value.toUpperCase();\n        }\n        else\n        {\n            newText = value;\n        }\n\n        if (newText !== this._text)\n        {\n            this._text = newText;\n\n            this.removeUnsupportedCharacters(this.multiLine);\n\n            this.buildRetroFontText();\n        }\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* @class Phaser.Particle\n*\n* @classdesc Create a new `Particle` object. Particles are extended Sprites that are emitted by a particle emitter such as Phaser.Particles.Arcade.Emitter.\n*\n* @constructor\n* @extends Phaser.Sprite\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {number} x - The x coordinate (in world space) to position the Particle at.\n* @param {number} y - The y coordinate (in world space) to position the Particle at.\n* @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the Particle during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n* @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n*/\nPhaser.Particle = function (game, x, y, key, frame) {\n\n    Phaser.Sprite.call(this, game, x, y, key, frame);\n\n    /**\n    * @property {boolean} autoScale - If this Particle automatically scales this is set to true by Particle.setScaleData.\n    * @protected\n    */\n    this.autoScale = false;\n\n    /**\n    * @property {array} scaleData - A reference to the scaleData array owned by the Emitter that emitted this Particle.\n    * @protected\n    */\n    this.scaleData = null;\n\n    /**\n    * @property {number} _s - Internal cache var for tracking auto scale.\n    * @private\n    */\n    this._s = 0;\n\n    /**\n    * @property {boolean} autoAlpha - If this Particle automatically changes alpha this is set to true by Particle.setAlphaData.\n    * @protected\n    */\n    this.autoAlpha = false;\n\n    /**\n    * @property {array} alphaData - A reference to the alphaData array owned by the Emitter that emitted this Particle.\n    * @protected\n    */\n    this.alphaData = null;\n\n    /**\n    * @property {number} _a - Internal cache var for tracking auto alpha.\n    * @private\n    */\n    this._a = 0;\n\n};\n\nPhaser.Particle.prototype = Object.create(Phaser.Sprite.prototype);\nPhaser.Particle.prototype.constructor = Phaser.Particle;\n\n/**\n* Updates the Particle scale or alpha if autoScale and autoAlpha are set.\n*\n* @method Phaser.Particle#update\n* @memberof Phaser.Particle\n*/\nPhaser.Particle.prototype.update = function() {\n\n    if (this.autoScale)\n    {\n        this._s--;\n\n        if (this._s)\n        {\n            this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);\n        }\n        else\n        {\n            this.autoScale = false;\n        }\n    }\n\n    if (this.autoAlpha)\n    {\n        this._a--;\n\n        if (this._a)\n        {\n            this.alpha = this.alphaData[this._a].v;\n        }\n        else\n        {\n            this.autoAlpha = false;\n        }\n    }\n\n};\n\n/**\n* Called by the Emitter when this particle is emitted. Left empty for you to over-ride as required.\n*\n* @method Phaser.Particle#onEmit\n* @memberof Phaser.Particle\n*/\nPhaser.Particle.prototype.onEmit = function() {\n};\n\n/**\n* Called by the Emitter if autoAlpha has been enabled. Passes over the alpha ease data and resets the alpha counter.\n*\n* @method Phaser.Particle#setAlphaData\n* @memberof Phaser.Particle\n*/\nPhaser.Particle.prototype.setAlphaData = function(data) {\n\n    this.alphaData = data;\n    this._a = data.length - 1;\n    this.alpha = this.alphaData[this._a].v;\n    this.autoAlpha = true;\n\n};\n\n/**\n* Called by the Emitter if autoScale has been enabled. Passes over the scale ease data and resets the scale counter.\n*\n* @method Phaser.Particle#setScaleData\n* @memberof Phaser.Particle\n*/\nPhaser.Particle.prototype.setScaleData = function(data) {\n\n    this.scaleData = data;\n    this._s = data.length - 1;\n    this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y);\n    this.autoScale = true;\n\n};\n\n/**\n* Resets the Particle. This places the Particle at the given x/y world coordinates and then\n* sets alive, exists, visible and renderable all to true. Also resets the outOfBounds state and health values.\n* If the Particle has a physics body that too is reset.\n*\n* @method Phaser.Particle#reset\n* @memberof Phaser.Particle\n* @param {number} x - The x coordinate (in world space) to position the Particle at.\n* @param {number} y - The y coordinate (in world space) to position the Particle at.\n* @param {number} [health=1] - The health to give the Particle.\n* @return (Phaser.Particle) This instance.\n*/\nPhaser.Particle.prototype.reset = function(x, y, health) {\n\n    if (typeof health === 'undefined') { health = 1; }\n\n    this.world.setTo(x, y);\n    this.position.x = x;\n    this.position.y = y;\n    this.alive = true;\n    this.exists = true;\n    this.visible = true;\n    this.renderable = true;\n    this._outOfBoundsFired = false;\n\n    this.health = health;\n\n    if (this.body)\n    {\n        this.body.reset(x, y, false, false);\n    }\n\n    this._cache[4] = 1;\n\n    this.alpha = 1;\n    this.scale.set(1);\n\n    this.autoScale = false;\n    this.autoAlpha = false;\n\n    return this;\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Canvas class handles everything related to creating the `canvas` DOM tag that Phaser will use, including styles, offset and aspect ratio.\n*\n* @class Phaser.Canvas\n* @static\n*/\nPhaser.Canvas = {\n\n    /**\n    * Creates a `canvas` DOM element. The element is not automatically added to the document.\n    *\n    * @method Phaser.Canvas.create\n    * @param {number} [width=256] - The width of the canvas element.\n    * @param {number} [height=256] - The height of the canvas element..\n    * @param {string} [id=''] - If given this will be set as the ID of the canvas element, otherwise no ID will be set.\n    * @param {boolean} [noCocoon=false] - CocoonJS only allows 1 screencanvas object, which should be your game. If you need to create another canvas (i.e. for a texture) set this to 'true'.\n    * @return {HTMLCanvasElement} The newly created canvas element.\n    */\n    create: function (width, height, id, noCocoon) {\n\n        if (typeof noCocoon === 'undefined') { noCocoon = false; }\n\n        width = width || 256;\n        height = height || 256;\n\n        if (noCocoon)\n        {\n            var canvas = document.createElement('canvas');\n        }\n        else\n        {\n            var canvas = document.createElement(navigator.isCocoonJS ? 'screencanvas' : 'canvas');\n        }\n\n        if (typeof id === 'string' && id !== '')\n        {\n            canvas.id = id;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        canvas.style.display = 'block';\n\n        return canvas;\n\n    },\n\n    /**\n    * Get the DOM offset values of any given element\n    * @method Phaser.Canvas.getOffset\n    * @param {HTMLElement} element - The targeted element that we want to retrieve the offset.\n    * @param {Phaser.Point} [point] - The point we want to take the x/y values of the offset.\n    * @return {Phaser.Point} - A point objet with the offsetX and Y as its properties.\n    */\n    getOffset: function (element, point) {\n\n        point = point || new Phaser.Point();\n\n        var box = element.getBoundingClientRect();\n        var clientTop = element.clientTop || document.body.clientTop || 0;\n        var clientLeft = element.clientLeft || document.body.clientLeft || 0;\n\n        //  Without this check Chrome is now throwing console warnings about strict vs. quirks :(\n\n        var scrollTop = 0;\n        var scrollLeft = 0;\n\n        if (document.compatMode === 'CSS1Compat')\n        {\n            scrollTop = window.pageYOffset || document.documentElement.scrollTop || element.scrollTop || 0;\n            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || element.scrollLeft || 0;\n        }\n        else\n        {\n            scrollTop = window.pageYOffset || document.body.scrollTop || element.scrollTop || 0;\n            scrollLeft = window.pageXOffset || document.body.scrollLeft || element.scrollLeft || 0;\n        }\n\n        point.x = box.left + scrollLeft - clientLeft;\n        point.y = box.top + scrollTop - clientTop;\n\n        return point;\n\n    },\n\n    /**\n    * Returns the aspect ratio of the given canvas.\n    *\n    * @method Phaser.Canvas.getAspectRatio\n    * @param {HTMLCanvasElement} canvas - The canvas to get the aspect ratio from.\n    * @return {number} The ratio between canvas' width and height.\n    */\n    getAspectRatio: function (canvas) {\n        return canvas.width / canvas.height;\n    },\n\n    /**\n    * Sets the background color behind the canvas. This changes the canvas style property.\n    *\n    * @method Phaser.Canvas.setBackgroundColor\n    * @param {HTMLCanvasElement} canvas - The canvas to set the background color on.\n    * @param {string} [color] - The color to set. Can be in the format 'rgb(r,g,b)', or '#RRGGBB' or any valid CSS color.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    setBackgroundColor: function (canvas, color) {\n\n        color = color || 'rgb(0,0,0)';\n\n        canvas.style.backgroundColor = color;\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the touch-action property on the canvas style. Can be used to disable default browser touch actions.\n    *\n    * @method Phaser.Canvas.setTouchAction\n    * @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.\n    * @param {String} [value] - The touch action to set. Defaults to 'none'.\n    * @return {HTMLCanvasElement} The source canvas.\n    */\n    setTouchAction: function (canvas, value) {\n\n        value = value || 'none';\n\n        canvas.style.msTouchAction = value;\n        canvas.style['ms-touch-action'] = value;\n        canvas.style['touch-action'] = value;\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the user-select property on the canvas style. Can be used to disable default browser selection actions.\n    *\n    * @method Phaser.Canvas.setUserSelect\n    * @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.\n    * @param {String} [value] - The touch action to set. Defaults to 'none'.\n    * @return {HTMLCanvasElement} The source canvas.\n    */\n    setUserSelect: function (canvas, value) {\n\n        value = value || 'none';\n\n        canvas.style['-webkit-touch-callout'] = value;\n        canvas.style['-webkit-user-select'] = value;\n        canvas.style['-khtml-user-select'] = value;\n        canvas.style['-moz-user-select'] = value;\n        canvas.style['-ms-user-select'] = value;\n        canvas.style['user-select'] = value;\n        canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)';\n\n        return canvas;\n\n    },\n\n    /**\n    * Adds the given canvas element to the DOM. The canvas will be added as a child of the given parent.\n    * If no parent is given it will be added as a child of the document.body.\n    *\n    * @method Phaser.Canvas.addToDOM\n    * @param {HTMLCanvasElement} canvas - The canvas to set the touch action on.\n    * @param {string|HTMLElement} parent - The DOM element to add the canvas to.\n    * @param {boolean} [overflowHidden=true] - If set to true it will add the overflow='hidden' style to the parent DOM element.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    addToDOM: function (canvas, parent, overflowHidden) {\n\n        var target;\n\n        if (typeof overflowHidden === 'undefined') { overflowHidden = true; }\n\n        if (parent)\n        {\n            if (typeof parent === 'string')\n            {\n                // hopefully an element ID\n                target = document.getElementById(parent);\n            }\n            else if (typeof parent === 'object' && parent.nodeType === 1)\n            {\n                // quick test for a HTMLelement\n                target = parent;\n            }\n        }\n\n        // Fallback, covers an invalid ID and a non HTMLelement object\n        if (!target)\n        {\n            target = document.body;\n        }\n\n        if (overflowHidden && target.style)\n        {\n            target.style.overflow = 'hidden';\n        }\n\n        target.appendChild(canvas);\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the transform of the given canvas to the matrix values provided.\n    *\n    * @method Phaser.Canvas.setTransform\n    * @param {CanvasRenderingContext2D} context - The context to set the transform on.\n    * @param {number} translateX - The value to translate horizontally by.\n    * @param {number} translateY - The value to translate vertically by.\n    * @param {number} scaleX - The value to scale horizontally by.\n    * @param {number} scaleY - The value to scale vertically by.\n    * @param {number} skewX - The value to skew horizontaly by.\n    * @param {number} skewY - The value to skew vertically by.\n    * @return {CanvasRenderingContext2D} Returns the source context.\n    */\n    setTransform: function (context, translateX, translateY, scaleX, scaleY, skewX, skewY) {\n\n        context.setTransform(scaleX, skewX, skewY, scaleY, translateX, translateY);\n\n        return context;\n\n    },\n\n    /**\n    * Sets the Image Smoothing property on the given context. Set to false to disable image smoothing.\n    * By default browsers have image smoothing enabled, which isn't always what you visually want, especially\n    * when using pixel art in a game. Note that this sets the property on the context itself, so that any image\n    * drawn to the context will be affected. This sets the property across all current browsers but support is\n    * patchy on earlier browsers, especially on mobile.\n    *\n    * @method Phaser.Canvas.setSmoothingEnabled\n    * @param {CanvasRenderingContext2D} context - The context to enable or disable the image smoothing on.\n    * @param {boolean} value - If set to true it will enable image smoothing, false will disable it.\n    * @return {CanvasRenderingContext2D} Returns the source context.\n    */\n    setSmoothingEnabled: function (context, value) {\n\n        context['imageSmoothingEnabled'] = value;\n        context['mozImageSmoothingEnabled'] = value;\n        context['oImageSmoothingEnabled'] = value;\n        context['webkitImageSmoothingEnabled'] = value;\n        context['msImageSmoothingEnabled'] = value;\n\n        return context;\n\n    },\n\n    /**\n    * Sets the CSS image-rendering property on the given canvas to be 'crisp' (aka 'optimize contrast on webkit').\n    * Note that if this doesn't given the desired result then see the setSmoothingEnabled.\n    *\n    * @method Phaser.Canvas.setImageRenderingCrisp\n    * @param {HTMLCanvasElement} canvas - The canvas to set image-rendering crisp on.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    setImageRenderingCrisp: function (canvas) {\n\n        canvas.style['image-rendering'] = 'optimizeSpeed';\n        canvas.style['image-rendering'] = 'crisp-edges';\n        canvas.style['image-rendering'] = '-moz-crisp-edges';\n        canvas.style['image-rendering'] = '-webkit-optimize-contrast';\n        canvas.style['image-rendering'] = 'optimize-contrast';\n        canvas.style.msInterpolationMode = 'nearest-neighbor';\n\n        return canvas;\n\n    },\n\n    /**\n    * Sets the CSS image-rendering property on the given canvas to be 'bicubic' (aka 'auto').\n    * Note that if this doesn't given the desired result then see the CanvasUtils.setSmoothingEnabled method.\n    *\n    * @method Phaser.Canvas.setImageRenderingBicubic\n    * @param {HTMLCanvasElement} canvas The canvas to set image-rendering bicubic on.\n    * @return {HTMLCanvasElement} Returns the source canvas.\n    */\n    setImageRenderingBicubic: function (canvas) {\n\n        canvas.style['image-rendering'] = 'auto';\n        canvas.style.msInterpolationMode = 'bicubic';\n\n        return canvas;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Detects device support capabilities. Using some elements from System.js by MrDoob and Modernizr\n*\n* @class Phaser.Device\n* @constructor\n*/\n\nPhaser.Device = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    //  Operating System\n\n    /**\n    * @property {boolean} desktop - Is running desktop?\n    * @default\n    */\n    this.desktop = false;\n\n    /**\n    * @property {boolean} iOS - Is running on iOS?\n    * @default\n    */\n    this.iOS = false;\n\n    /**\n    * @property {boolean} cocoonJS - Is the game running under CocoonJS?\n    * @default\n    */\n    this.cocoonJS = false;\n\n    /**\n    * @property {boolean} ejecta - Is the game running under Ejecta?\n    * @default\n    */\n    this.ejecta = false;\n\n    /**\n    * @property {boolean} crosswalk - Is the game running under the Intel Crosswalk XDK?\n    * @default\n    */\n    this.crosswalk = false;\n\n    /**\n    * @property {boolean} android - Is running on android?\n    * @default\n    */\n    this.android = false;\n\n    /**\n    * @property {boolean} chromeOS - Is running on chromeOS?\n    * @default\n    */\n    this.chromeOS = false;\n\n    /**\n    * @property {boolean} linux - Is running on linux?\n    * @default\n    */\n    this.linux = false;\n\n    /**\n    * @property {boolean} macOS - Is running on macOS?\n    * @default\n    */\n    this.macOS = false;\n\n    /**\n    * @property {boolean} windows - Is running on windows?\n    * @default\n    */\n    this.windows = false;\n\n    /**\n    * @property {boolean} windowsPhone - Is running on a Windows Phone?\n    * @default\n    */\n    this.windowsPhone = false;\n\n    //  Features\n\n    /**\n    * @property {boolean} canvas - Is canvas available?\n    * @default\n    */\n    this.canvas = false;\n\n    /**\n    * @property {boolean} file - Is file available?\n    * @default\n    */\n    this.file = false;\n\n    /**\n    * @property {boolean} fileSystem - Is fileSystem available?\n    * @default\n    */\n    this.fileSystem = false;\n\n    /**\n    * @property {boolean} localStorage - Is localStorage available?\n    * @default\n    */\n    this.localStorage = false;\n\n    /**\n    * @property {boolean} webGL - Is webGL available?\n    * @default\n    */\n    this.webGL = false;\n\n    /**\n    * @property {boolean} worker - Is worker available?\n    * @default\n    */\n    this.worker = false;\n\n    /**\n    * @property {boolean} touch - Is touch available?\n    * @default\n    */\n    this.touch = false;\n\n    /**\n    * @property {boolean} mspointer - Is mspointer available?\n    * @default\n    */\n    this.mspointer = false;\n\n    /**\n    * @property {boolean} css3D - Is css3D available?\n    * @default\n    */\n    this.css3D = false;\n\n    /**\n    * @property {boolean} pointerLock - Is Pointer Lock available?\n    * @default\n    */\n    this.pointerLock = false;\n\n    /**\n    * @property {boolean} typedArray - Does the browser support TypedArrays?\n    * @default\n    */\n    this.typedArray = false;\n\n    /**\n    * @property {boolean} vibration - Does the device support the Vibration API?\n    * @default\n    */\n    this.vibration = false;\n\n    /**\n    * @property {boolean} getUserMedia - Does the device support the getUserMedia API?\n    * @default\n    */\n    this.getUserMedia = false;\n\n    /**\n    * @property {boolean} quirksMode - Is the browser running in strict mode (false) or quirks mode? (true)\n    * @default\n    */\n    this.quirksMode = false;\n\n    //  Browser\n\n    /**\n    * @property {boolean} arora - Set to true if running in Arora.\n    * @default\n    */\n    this.arora = false;\n\n    /**\n    * @property {boolean} chrome - Set to true if running in Chrome.\n    * @default\n    */\n    this.chrome = false;\n\n    /**\n    * @property {boolean} epiphany - Set to true if running in Epiphany.\n    * @default\n    */\n    this.epiphany = false;\n\n    /**\n    * @property {boolean} firefox - Set to true if running in Firefox.\n    * @default\n    */\n    this.firefox = false;\n\n    /**\n    * @property {boolean} ie - Set to true if running in Internet Explorer.\n    * @default\n    */\n    this.ie = false;\n\n    /**\n    * @property {number} ieVersion - If running in Internet Explorer this will contain the major version number. Beyond IE10 you should use Device.trident and Device.tridentVersion.\n    * @default\n    */\n    this.ieVersion = 0;\n\n    /**\n    * @property {boolean} trident - Set to true if running a Trident version of Internet Explorer (IE11+)\n    * @default\n    */\n    this.trident = false;\n\n    /**\n    * @property {number} tridentVersion - If running in Internet Explorer 11 this will contain the major version number. See http://msdn.microsoft.com/en-us/library/ie/ms537503(v=vs.85).aspx\n    * @default\n    */\n    this.tridentVersion = 0;\n\n    /**\n    * @property {boolean} mobileSafari - Set to true if running in Mobile Safari.\n    * @default\n    */\n    this.mobileSafari = false;\n\n    /**\n    * @property {boolean} midori - Set to true if running in Midori.\n    * @default\n    */\n    this.midori = false;\n\n    /**\n    * @property {boolean} opera - Set to true if running in Opera.\n    * @default\n    */\n    this.opera = false;\n\n    /**\n    * @property {boolean} safari - Set to true if running in Safari.\n    * @default\n    */\n    this.safari = false;\n\n    /**\n    * @property {boolean} webApp - Set to true if running as a WebApp, i.e. within a WebView\n    * @default\n    */\n    this.webApp = false;\n\n    /**\n    * @property {boolean} silk - Set to true if running in the Silk browser (as used on the Amazon Kindle)\n    * @default\n    */\n    this.silk = false;\n\n    //  Audio\n\n    /**\n    * @property {boolean} audioData - Are Audio tags available?\n    * @default\n    */\n    this.audioData = false;\n\n    /**\n    * @property {boolean} webAudio - Is the WebAudio API available?\n    * @default\n    */\n    this.webAudio = false;\n\n    /**\n    * @property {boolean} ogg - Can this device play ogg files?\n    * @default\n    */\n    this.ogg = false;\n\n    /**\n    * @property {boolean} opus - Can this device play opus files?\n    * @default\n    */\n    this.opus = false;\n\n    /**\n    * @property {boolean} mp3 - Can this device play mp3 files?\n    * @default\n    */\n    this.mp3 = false;\n\n    /**\n    * @property {boolean} wav - Can this device play wav files?\n    * @default\n    */\n    this.wav = false;\n\n    /**\n    * Can this device play m4a files?\n    * @property {boolean} m4a - True if this device can play m4a files.\n    * @default\n    */\n    this.m4a = false;\n\n    /**\n    * @property {boolean} webm - Can this device play webm files?\n    * @default\n    */\n    this.webm = false;\n\n    //  Device\n\n    /**\n    * @property {boolean} iPhone - Is running on iPhone?\n    * @default\n    */\n    this.iPhone = false;\n\n    /**\n    * @property {boolean} iPhone4 - Is running on iPhone4?\n    * @default\n    */\n    this.iPhone4 = false;\n\n    /**\n    * @property {boolean} iPad - Is running on iPad?\n    * @default\n    */\n    this.iPad = false;\n\n    /**\n    * @property {number} pixelRatio - PixelRatio of the host device?\n    * @default\n    */\n    this.pixelRatio = 0;\n\n    /**\n    * @property {boolean} littleEndian - Is the device big or little endian? (only detected if the browser supports TypedArrays)\n    * @default\n    */\n    this.littleEndian = false;\n\n    /**\n    * @property {boolean} support32bit - Does the device context support 32bit pixel manipulation using array buffer views?\n    * @default\n    */\n    this.support32bit = false;\n\n    /**\n    * @property {boolean} fullscreen - Does the browser support the Full Screen API?\n    * @default\n    */\n    this.fullscreen = false;\n\n    /**\n    * @property {string} requestFullscreen - If the browser supports the Full Screen API this holds the call you need to use to activate it.\n    * @default\n    */\n    this.requestFullscreen = '';\n\n    /**\n    * @property {string} cancelFullscreen - If the browser supports the Full Screen API this holds the call you need to use to cancel it.\n    * @default\n    */\n    this.cancelFullscreen = '';\n\n    /**\n    * @property {boolean} fullscreenKeyboard - Does the browser support access to the Keyboard during Full Screen mode?\n    * @default\n    */\n    this.fullscreenKeyboard = false;\n\n    //  Run the checks\n    this._checkAudio();\n    this._checkBrowser();\n    this._checkCSS3D();\n    this._checkDevice();\n    this._checkFeatures();\n    this._checkOS();\n\n};\n\nPhaser.Device.LITTLE_ENDIAN = false;\n\nPhaser.Device.prototype = {\n\n    /**\n    * Check which OS is game running on.\n    * @method Phaser.Device#_checkOS\n    * @private\n    */\n    _checkOS: function () {\n\n        var ua = navigator.userAgent;\n\n        if (/Android/.test(ua))\n        {\n            this.android = true;\n        }\n        else if (/CrOS/.test(ua))\n        {\n            this.chromeOS = true;\n        }\n        else if (/iP[ao]d|iPhone/i.test(ua))\n        {\n            this.iOS = true;\n        }\n        else if (/Linux/.test(ua))\n        {\n            this.linux = true;\n        }\n        else if (/Mac OS/.test(ua))\n        {\n            this.macOS = true;\n        }\n        else if (/Windows/.test(ua))\n        {\n            this.windows = true;\n\n            if (/Windows Phone/i.test(ua))\n            {\n                this.windowsPhone = true;\n            }\n        }\n\n        if (this.windows || this.macOS || (this.linux && this.silk === false))\n        {\n            this.desktop = true;\n        }\n\n        //  Windows Phone / Table reset\n        if (this.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))\n        {\n            this.desktop = false;\n        }\n\n    },\n\n    /**\n    * Check HTML5 features of the host environment.\n    * @method Phaser.Device#_checkFeatures\n    * @private\n    */\n    _checkFeatures: function () {\n\n        this.canvas = !!window['CanvasRenderingContext2D'] || this.cocoonJS;\n\n        try {\n            this.localStorage = !!localStorage.getItem;\n        } catch (error) {\n            this.localStorage = false;\n        }\n\n        this.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob'];\n        this.fileSystem = !!window['requestFileSystem'];\n        this.webGL = ( function () { try { var canvas = document.createElement( 'canvas' ); return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ); } catch( e ) { return false; } } )();\n\n        if (this.webGL === null || this.webGL === false)\n        {\n            this.webGL = false;\n        }\n        else\n        {\n            this.webGL = true;\n        }\n\n        this.worker = !!window['Worker'];\n\n        if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints > 1))\n        {\n            this.touch = true;\n        }\n\n        if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled)\n        {\n            this.mspointer = true;\n        }\n\n        this.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;\n\n        this.quirksMode = (document.compatMode === 'CSS1Compat') ? false : true;\n\n        this.getUserMedia = !!(navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);\n\n    },\n\n    /**\n    * Checks for support of the Full Screen API.\n    *\n    * @method Phaser.Device#checkFullScreenSupport\n    */\n    checkFullScreenSupport: function () {\n\n        var fs = [\n            'requestFullscreen',\n            'requestFullScreen',\n            'webkitRequestFullscreen',\n            'webkitRequestFullScreen',\n            'msRequestFullscreen',\n            'msRequestFullScreen',\n            'mozRequestFullScreen',\n            'mozRequestFullscreen'\n        ];\n\n        for (var i = 0; i < fs.length; i++)\n        {\n            if (this.game.canvas[fs[i]])\n            {\n                this.fullscreen = true;\n                this.requestFullscreen = fs[i];\n            }\n        }\n\n        var cfs = [\n            'cancelFullScreen',\n            'exitFullscreen',\n            'webkitCancelFullScreen',\n            'webkitExitFullscreen',\n            'msCancelFullScreen',\n            'msExitFullscreen',\n            'mozCancelFullScreen',\n            'mozExitFullscreen'\n        ];\n\n        if (this.fullscreen)\n        {\n            for (var i = 0; i < cfs.length; i++)\n            {\n                if (this.game.canvas[cfs[i]])\n                {\n                    this.cancelFullscreen = cfs[i];\n                }\n            }\n        }\n\n        //  Keyboard Input?\n        if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT'])\n        {\n            this.fullscreenKeyboard = true;\n        }\n\n    },\n\n    /**\n    * Check what browser is game running in.\n    * @method Phaser.Device#_checkBrowser\n    * @private\n    */\n    _checkBrowser: function () {\n\n        var ua = navigator.userAgent;\n\n        if (/Arora/.test(ua))\n        {\n            this.arora = true;\n        }\n        else if (/Chrome/.test(ua))\n        {\n            this.chrome = true;\n        }\n        else if (/Epiphany/.test(ua))\n        {\n            this.epiphany = true;\n        }\n        else if (/Firefox/.test(ua))\n        {\n            this.firefox = true;\n        }\n        else if (/Mobile Safari/.test(ua))\n        {\n            this.mobileSafari = true;\n        }\n        else if (/MSIE (\\d+\\.\\d+);/.test(ua))\n        {\n            this.ie = true;\n            this.ieVersion = parseInt(RegExp.$1, 10);\n        }\n        else if (/Midori/.test(ua))\n        {\n            this.midori = true;\n        }\n        else if (/Opera/.test(ua))\n        {\n            this.opera = true;\n        }\n        else if (/Safari/.test(ua))\n        {\n            this.safari = true;\n        }\n        else if (/Silk/.test(ua))\n        {\n            this.silk = true;\n        }\n        else if (/Trident\\/(\\d+\\.\\d+)(.*)rv:(\\d+\\.\\d+)/.test(ua))\n        {\n            this.ie = true;\n            this.trident = true;\n            this.tridentVersion = parseInt(RegExp.$1, 10);\n            this.ieVersion = parseInt(RegExp.$3, 10);\n        }\n\n        // WebApp mode in iOS\n        if (navigator['standalone'])\n        {\n            this.webApp = true;\n        }\n\n        if (navigator['isCocoonJS'])\n        {\n            this.cocoonJS = true;\n        }\n\n        if (typeof window.ejecta !== \"undefined\")\n        {\n            this.ejecta = true;\n        }\n\n        if (/Crosswalk/.test(ua))\n        {\n            this.crosswalk = true;\n        }\n\n    },\n\n    /**\n    * Check audio support.\n    * @method Phaser.Device#_checkAudio\n    * @private\n    */\n    _checkAudio: function () {\n\n        this.audioData = !!(window['Audio']);\n        this.webAudio = !!(window['webkitAudioContext'] || window['AudioContext']);\n        var audioElement = document.createElement('audio');\n        var result = false;\n\n        try {\n            if (result = !!audioElement.canPlayType) {\n\n                if (audioElement.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')) {\n                    this.ogg = true;\n                }\n\n                if (audioElement.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '')) {\n                    this.opus = true;\n                }\n\n                if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, '')) {\n                    this.mp3 = true;\n                }\n\n                // Mimetypes accepted:\n                //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements\n                //   bit.ly/iphoneoscodecs\n                if (audioElement.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')) {\n                    this.wav = true;\n                }\n\n                if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, '')) {\n                    this.m4a = true;\n                }\n\n                if (audioElement.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')) {\n                    this.webm = true;\n                }\n            }\n        } catch (e) {\n        }\n\n    },\n\n    /**\n    * Check PixelRatio, iOS device, Vibration API, ArrayBuffers and endianess.\n    * @method Phaser.Device#_checkDevice\n    * @private\n    */\n    _checkDevice: function () {\n\n        this.pixelRatio = window['devicePixelRatio'] || 1;\n        this.iPhone = navigator.userAgent.toLowerCase().indexOf('iphone') != -1;\n        this.iPhone4 = (this.pixelRatio == 2 && this.iPhone);\n        this.iPad = navigator.userAgent.toLowerCase().indexOf('ipad') != -1;\n\n        if (typeof Int8Array !== 'undefined')\n        {\n            this.typedArray = true;\n        }\n        else\n        {\n            this.typedArray = false;\n        }\n\n        if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined')\n        {\n            this.littleEndian = this._checkIsLittleEndian();\n            Phaser.Device.LITTLE_ENDIAN = this.littleEndian;\n        }\n\n        this.support32bit = (typeof ArrayBuffer !== \"undefined\" && typeof Uint8ClampedArray !== \"undefined\" && typeof Int32Array !== \"undefined\" && this.littleEndian !== null && this._checkIsUint8ClampedImageData());\n\n        navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;\n\n        if (navigator.vibrate)\n        {\n            this.vibration = true;\n        }\n\n    },\n\n    /**\n    * Check Little or Big Endian system.\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Device#_checkIsLittleEndian\n    * @private\n    */\n    _checkIsLittleEndian: function () {\n\n        var a = new ArrayBuffer(4);\n        var b = new Uint8Array(a);\n        var c = new Uint32Array(a);\n\n        b[0] = 0xa1;\n        b[1] = 0xb2;\n        b[2] = 0xc3;\n        b[3] = 0xd4;\n\n        if (c[0] == 0xd4c3b2a1)\n        {\n            return true;\n        }\n\n        if (c[0] == 0xa1b2c3d4)\n        {\n            return false;\n        }\n        else\n        {\n            //  Could not determine endianness\n            return null;\n        }\n\n    },\n\n    /**\n    * Test to see if ImageData uses CanvasPixelArray or Uint8ClampedArray.\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Device#_checkIsUint8ClampedImageData\n    * @private\n    */\n    _checkIsUint8ClampedImageData: function () {\n\n        if (typeof Uint8ClampedArray === \"undefined\")\n        {\n            return false;\n        }\n\n        var elem = document.createElement('canvas');\n        var ctx = elem.getContext('2d');\n\n        if (!ctx)\n        {\n            return false;\n        }\n\n        var image = ctx.createImageData(1, 1);\n        \n        return image.data instanceof Uint8ClampedArray;\n\n    },\n\n    /**\n    * Check whether the host environment support 3D CSS.\n    * @method Phaser.Device#_checkCSS3D\n    * @private\n    */\n    _checkCSS3D: function () {\n\n        var el = document.createElement('p');\n        var has3d;\n        var transforms = {\n            'webkitTransform': '-webkit-transform',\n            'OTransform': '-o-transform',\n            'msTransform': '-ms-transform',\n            'MozTransform': '-moz-transform',\n            'transform': 'transform'\n        };\n\n        // Add it to the body to get the computed style.\n        document.body.insertBefore(el, null);\n\n        for (var t in transforms)\n        {\n            if (el.style[t] !== undefined)\n            {\n                el.style[t] = \"translate3d(1px,1px,1px)\";\n                has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]);\n            }\n        }\n\n        document.body.removeChild(el);\n        this.css3D = (has3d !== undefined && has3d.length > 0 && has3d !== \"none\");\n\n    },\n\n    /**\n    * Check whether the host environment can play audio.\n    * @method Phaser.Device#canPlayAudio\n    * @param {string} type - One of 'mp3, 'ogg', 'm4a', 'wav', 'webm'.\n    * @return {boolean} True if the given file type is supported by the browser, otherwise false.\n    */\n    canPlayAudio: function (type) {\n\n        if (type == 'mp3' && this.mp3)\n        {\n            return true;\n        }\n        else if (type == 'ogg' && (this.ogg || this.opus))\n        {\n            return true;\n        }\n        else if (type == 'm4a' && this.m4a)\n        {\n            return true;\n        }\n        else if (type == 'wav' && this.wav)\n        {\n            return true;\n        }\n        else if (type == 'webm' && this.webm)\n        {\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Check whether the console is open.\n    * Note that this only works in Firefox with Firebug and earlier versions of Chrome.\n    * It used to work in Chrome, but then they removed the ability: http://src.chromium.org/viewvc/blink?view=revision&revision=151136\n    * \n    * @method Phaser.Device#isConsoleOpen\n    * @return {boolean} True if the browser dev console is open.\n    */\n    isConsoleOpen: function () {\n\n        if (window.console && window.console['firebug'])\n        {\n            return true;\n        }\n\n        if (window.console)\n        {\n            console.profile();\n            console.profileEnd();\n\n            if (console.clear)\n            {\n                console.clear();\n            }\n\n            if (console['profiles'])\n            {\n                return console['profiles'].length > 0;\n            }\n        }\n\n        return false;\n\n    }\n\n};\n\nPhaser.Device.prototype.constructor = Phaser.Device;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Abstracts away the use of RAF or setTimeOut for the core game update loop.\n*\n* @class Phaser.RequestAnimationFrame\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {boolean} [forceSetTimeOut=false] - Tell Phaser to use setTimeOut even if raf is available.\n*/\nPhaser.RequestAnimationFrame = function(game, forceSetTimeOut) {\n\n    if (typeof forceSetTimeOut === 'undefined') { forceSetTimeOut = false; }\n\n    /**\n    * @property {Phaser.Game} game - The currently running game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} isRunning - true if RequestAnimationFrame is running, otherwise false.\n    * @default\n    */\n    this.isRunning = false;\n\n    /**\n    * @property {boolean} forceSetTimeOut - Tell Phaser to use setTimeOut even if raf is available.\n    */\n    this.forceSetTimeOut = forceSetTimeOut;\n\n    var vendors = [\n        'ms',\n        'moz',\n        'webkit',\n        'o'\n    ];\n\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++)\n    {\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'];\n    }\n\n    /**\n    * @property {boolean} _isSetTimeOut  - true if the browser is using setTimeout instead of raf.\n    * @private\n    */\n    this._isSetTimeOut = false;\n\n    /**\n    * @property {function} _onLoop - The function called by the update.\n    * @private\n    */\n    this._onLoop = null;\n\n    /**\n    * @property {number} _timeOutID - The callback ID used when calling cancel.\n    * @private\n    */\n    this._timeOutID = null;\n\n};\n\nPhaser.RequestAnimationFrame.prototype = {\n\n    /**\n    * Starts the requestAnimationFrame running or setTimeout if unavailable in browser\n    * @method Phaser.RequestAnimationFrame#start\n    */\n    start: function () {\n\n        this.isRunning = true;\n\n        var _this = this;\n\n        if (!window.requestAnimationFrame || this.forceSetTimeOut)\n        {\n            this._isSetTimeOut = true;\n\n            this._onLoop = function () {\n                return _this.updateSetTimeout();\n            };\n\n            this._timeOutID = window.setTimeout(this._onLoop, 0);\n        }\n        else\n        {\n            this._isSetTimeOut = false;\n\n            this._onLoop = function (time) {\n                return _this.updateRAF(time);\n            };\n\n            this._timeOutID = window.requestAnimationFrame(this._onLoop);\n        }\n\n    },\n\n    /**\n    * The update method for the requestAnimationFrame\n    * @method Phaser.RequestAnimationFrame#updateRAF\n    */\n    updateRAF: function () {\n\n        this.game.update(Date.now());\n\n        this._timeOutID = window.requestAnimationFrame(this._onLoop);\n\n    },\n\n    /**\n    * The update method for the setTimeout.\n    * @method Phaser.RequestAnimationFrame#updateSetTimeout\n    */\n    updateSetTimeout: function () {\n\n        this.game.update(Date.now());\n\n        this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall);\n\n    },\n\n    /**\n    * Stops the requestAnimationFrame from running.\n    * @method Phaser.RequestAnimationFrame#stop\n    */\n    stop: function () {\n\n        if (this._isSetTimeOut)\n        {\n            clearTimeout(this._timeOutID);\n        }\n        else\n        {\n            window.cancelAnimationFrame(this._timeOutID);\n        }\n\n        this.isRunning = false;\n\n    },\n\n    /**\n    * Is the browser using setTimeout?\n    * @method Phaser.RequestAnimationFrame#isSetTimeOut\n    * @return {boolean}\n    */\n    isSetTimeOut: function () {\n        return this._isSetTimeOut;\n    },\n\n    /**\n    * Is the browser using requestAnimationFrame?\n    * @method Phaser.RequestAnimationFrame#isRAF\n    * @return {boolean}\n    */\n    isRAF: function () {\n        return (this._isSetTimeOut === false);\n    }\n\n};\n\nPhaser.RequestAnimationFrame.prototype.constructor = Phaser.RequestAnimationFrame;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A collection of mathematical methods.\n*\n* @class Phaser.Math\n*/\nPhaser.Math = {\n\n    /**\n    * = 2 &pi;\n    * @method Phaser.Math#PI2\n    */\n    PI2: Math.PI * 2,\n\n    /**\n    * Two number are fuzzyEqual if their difference is less than &epsilon;.\n    * @method Phaser.Math#fuzzyEqual\n    * @param {number} a\n    * @param {number} b\n    * @param {number} epsilon\n    * @return {boolean} True if |a-b|<&epsilon;\n    */\n    fuzzyEqual: function (a, b, epsilon) {\n        if (typeof epsilon === \"undefined\") { epsilon = 0.0001; }\n        return Math.abs(a - b) < epsilon;\n    },\n\n    /**\n    * a is fuzzyLessThan b if it is less than b + &epsilon;.\n    * @method Phaser.Math#fuzzyLessThan\n    * @param {number} a\n    * @param {number} b\n    * @param {number} epsilon\n    * @return {boolean} True if a<b+&epsilon;\n    */\n    fuzzyLessThan: function (a, b, epsilon) {\n        if (typeof epsilon === \"undefined\") { epsilon = 0.0001; }\n        return a < b + epsilon;\n    },\n\n    /**\n    * a is fuzzyGreaterThan b if it is more than b - &epsilon;.\n    * @method Phaser.Math#fuzzyGreaterThan\n    * @param {number} a\n    * @param {number} b\n    * @param {number} epsilon\n    * @return {boolean} True if a>b+&epsilon;\n    */\n    fuzzyGreaterThan: function (a, b, epsilon) {\n        if (typeof epsilon === \"undefined\") { epsilon = 0.0001; }\n        return a > b - epsilon;\n    },\n\n    /**\n    * @method Phaser.Math#fuzzyCeil\n    * @param {number} val\n    * @param {number} epsilon\n    * @return {boolean} ceiling(val-&epsilon;)\n    */\n    fuzzyCeil: function (val, epsilon) {\n        if (typeof epsilon === \"undefined\") { epsilon = 0.0001; }\n        return Math.ceil(val - epsilon);\n    },\n\n    /**\n    * @method Phaser.Math#fuzzyFloor\n    * @param {number} val\n    * @param {number} epsilon\n    * @return {boolean} floor(val-&epsilon;)\n    */\n    fuzzyFloor: function (val, epsilon) {\n        if (typeof epsilon === \"undefined\") { epsilon = 0.0001; }\n        return Math.floor(val + epsilon);\n    },\n\n    /**\n    * Averages all values passed to the function and returns the result. You can pass as many parameters as you like.\n    * @method Phaser.Math#average\n    * @return {number} The average of all given values.\n    */\n    average: function () {\n\n        var args = [];\n\n        for (var _i = 0; _i < (arguments.length - 0); _i++) {\n            args[_i] = arguments[_i + 0];\n        }\n\n        var avg = 0;\n\n        for (var i = 0; i < args.length; i++) {\n            avg += args[i];\n        }\n\n        return avg / args.length;\n\n    },\n\n    /**\n    * @method Phaser.Math#truncate\n    * @param {number} n\n    * @return {number}\n    */\n    truncate: function (n) {\n        return (n > 0) ? Math.floor(n) : Math.ceil(n);\n    },\n\n    /**\n    * @method Phaser.Math#shear\n    * @param {number} n\n    * @return {number} n mod 1\n    */\n    shear: function (n) {\n        return n % 1;\n    },\n\n    /**\n    * Snap a value to nearest grid slice, using rounding.\n    *\n    * Example: if you have an interval gap of 5 and a position of 12... you will snap to 10 whereas 14 will snap to 15.\n    *\n    * @method Phaser.Math#snapTo\n    * @param {number} input - The value to snap.\n    * @param {number} gap - The interval gap of the grid.\n    * @param {number} [start] - Optional starting offset for gap.\n    * @return {number}\n    */\n    snapTo: function (input, gap, start) {\n\n        if (typeof start === \"undefined\") { start = 0; }\n\n        if (gap === 0) {\n            return input;\n        }\n\n        input -= start;\n        input = gap * Math.round(input / gap);\n\n        return start + input;\n\n    },\n\n    /**\n    * Snap a value to nearest grid slice, using floor.\n    *\n    * Example: if you have an interval gap of 5 and a position of 12... you will snap to 10. As will 14 snap to 10... but 16 will snap to 15\n    *\n    * @method Phaser.Math#snapToFloor\n    * @param {number} input - The value to snap.\n    * @param {number} gap - The interval gap of the grid.\n    * @param {number} [start] - Optional starting offset for gap.\n    * @return {number}\n    */\n    snapToFloor: function (input, gap, start) {\n\n        if (typeof start === \"undefined\") { start = 0; }\n\n        if (gap === 0) {\n            return input;\n        }\n\n        input -= start;\n        input = gap * Math.floor(input / gap);\n\n        return start + input;\n\n    },\n\n    /**\n    * Snap a value to nearest grid slice, using ceil.\n    *\n    * Example: if you have an interval gap of 5 and a position of 12... you will snap to 15. As will 14 will snap to 15... but 16 will snap to 20.\n    *\n    * @method Phaser.Math#snapToCeil\n    * @param {number} input - The value to snap.\n    * @param {number} gap - The interval gap of the grid.\n    * @param {number} [start] - Optional starting offset for gap.\n    * @return {number}\n    */\n    snapToCeil: function (input, gap, start) {\n\n        if (typeof start === \"undefined\") { start = 0; }\n\n        if (gap === 0) {\n            return input;\n        }\n\n        input -= start;\n        input = gap * Math.ceil(input / gap);\n\n        return start + input;\n\n    },\n\n\n    /**\n    * Snaps a value to the nearest value in an array.\n    * @method Phaser.Math#snapToInArray\n    * @param {number} input\n    * @param {array} arr\n    * @param {boolean} sort - True if the array needs to be sorted.\n    * @return {number}\n    */\n    snapToInArray: function (input, arr, sort) {\n\n        if (typeof sort === \"undefined\") { sort = true; }\n\n        if (sort) {\n            arr.sort();\n        }\n\n        if (input < arr[0]) {\n            return arr[0];\n        }\n\n        var i = 1;\n\n        while (arr[i] < input) {\n            i++;\n        }\n\n        var low = arr[i - 1];\n        var high = (i < arr.length) ? arr[i] : Number.POSITIVE_INFINITY;\n\n        return ((high - input) <= (input - low)) ? high : low;\n\n    },\n\n    /**\n    * Round to some place comparative to a 'base', default is 10 for decimal place.\n    *\n    * 'place' is represented by the power applied to 'base' to get that place\n    * e.g.\n    * 2000/7 ~= 285.714285714285714285714 ~= (bin)100011101.1011011011011011\n    *\n    * roundTo(2000/7,3) === 0\n    * roundTo(2000/7,2) == 300\n    * roundTo(2000/7,1) == 290\n    * roundTo(2000/7,0) == 286\n    * roundTo(2000/7,-1) == 285.7\n    * roundTo(2000/7,-2) == 285.71\n    * roundTo(2000/7,-3) == 285.714\n    * roundTo(2000/7,-4) == 285.7143\n    * roundTo(2000/7,-5) == 285.71429\n    *\n    * roundTo(2000/7,3,2)  == 288       -- 100100000\n    * roundTo(2000/7,2,2)  == 284       -- 100011100\n    * roundTo(2000/7,1,2)  == 286       -- 100011110\n    * roundTo(2000/7,0,2)  == 286       -- 100011110\n    * roundTo(2000/7,-1,2) == 285.5     -- 100011101.1\n    * roundTo(2000/7,-2,2) == 285.75    -- 100011101.11\n    * roundTo(2000/7,-3,2) == 285.75    -- 100011101.11\n    * roundTo(2000/7,-4,2) == 285.6875  -- 100011101.1011\n    * roundTo(2000/7,-5,2) == 285.71875 -- 100011101.10111\n    *\n    * Note what occurs when we round to the 3rd space (8ths place), 100100000, this is to be assumed\n    * because we are rounding 100011.1011011011011011 which rounds up.\n    *\n    * @method Phaser.Math#roundTo\n    * @param {number} value - The value to round.\n    * @param {number} place - The place to round to.\n    * @param {number} base - The base to round in... default is 10 for decimal.\n    * @return {number}\n    */\n    roundTo: function (value, place, base) {\n\n        if (typeof place === \"undefined\") { place = 0; }\n        if (typeof base === \"undefined\") { base = 10; }\n\n        var p = Math.pow(base, -place);\n\n        return Math.round(value * p) / p;\n\n    },\n\n    /**\n    * @method Phaser.Math#floorTo\n    * @param {number} value - The value to round.\n    * @param {number} place - The place to round to.\n    * @param {number} base - The base to round in... default is 10 for decimal.\n    * @return {number}\n    */\n    floorTo: function (value, place, base) {\n\n        if (typeof place === \"undefined\") { place = 0; }\n        if (typeof base === \"undefined\") { base = 10; }\n\n        var p = Math.pow(base, -place);\n\n        return Math.floor(value * p) / p;\n\n    },\n\n    /**\n    * @method Phaser.Math#ceilTo\n    * @param {number} value - The value to round.\n    * @param {number} place - The place to round to.\n    * @param {number} base - The base to round in... default is 10 for decimal.\n    * @return {number}\n    */\n    ceilTo: function (value, place, base) {\n\n        if (typeof place === \"undefined\") { place = 0; }\n        if (typeof base === \"undefined\") { base = 10; }\n\n        var p = Math.pow(base, -place);\n\n        return Math.ceil(value * p) / p;\n\n    },\n\n    /**\n    * A one dimensional linear interpolation of a value.\n    * @method Phaser.Math#interpolateFloat\n    * @param {number} a\n    * @param {number} b\n    * @param {number} weight\n    * @return {number}\n    */\n    interpolateFloat: function (a, b, weight) {\n        return (b - a) * weight + a;\n    },\n\n    /**\n    * Find the angle of a segment from (x1, y1) -> (x2, y2).\n    * @method Phaser.Math#angleBetween\n    * @param {number} x1\n    * @param {number} y1\n    * @param {number} x2\n    * @param {number} y2\n    * @return {number}\n    */\n    angleBetween: function (x1, y1, x2, y2) {\n        return Math.atan2(y2 - y1, x2 - x1);\n    },\n\n    /**\n    * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\n    * @method Phaser.Math#angleBetweenPoints\n    * @param {Phaser.Point} point1\n    * @param {Phaser.Point} point2\n    * @return {number}\n    */\n    angleBetweenPoints: function (point1, point2) {\n        return Math.atan2(point2.y - point1.y, point2.x - point1.x);\n    },\n\n    /**\n    * Reverses an angle.\n    * @method Phaser.Math#reverseAngle\n    * @param {number} angleRad - The angle to reverse, in radians.\n    * @return {number} Returns the reverse angle, in radians.\n    */\n    reverseAngle: function (angleRad) {\n        return this.normalizeAngle(angleRad + Math.PI, true);\n    },\n\n    /**\n    * Normalizes an angle to the [0,2pi) range.\n    * @method Phaser.Math#normalizeAngle\n    * @param {number} angleRad - The angle to normalize, in radians.\n    * @return {number} Returns the angle, fit within the [0,2pi] range, in radians.\n    */\n    normalizeAngle: function (angleRad) {\n\n        angleRad = angleRad % (2 * Math.PI);\n        return angleRad >= 0 ? angleRad : angleRad + 2 * Math.PI;\n\n    },\n\n    /**\n    * Normalizes a latitude to the [-90,90] range. Latitudes above 90 or below -90 are capped, not wrapped.\n    * @method Phaser.Math#normalizeLatitude\n    * @param {number} lat - The latitude to normalize, in degrees.\n    * @return {number} Returns the latitude, fit within the [-90,90] range.\n    */\n    normalizeLatitude: function (lat) {\n        return Math.max(-90, Math.min(90, lat));\n    },\n\n    /**\n    * Normalizes a longitude to the [-180,180] range. Longitudes above 180 or below -180 are wrapped.\n    * @method Phaser.Math#normalizeLongitude\n    * @param {number} lng - The longitude to normalize, in degrees.\n    * @return {number} Returns the longitude, fit within the [-180,180] range.\n    */\n    normalizeLongitude: function (lng) {\n\n        if (lng % 360 == 180)\n        {\n            return 180;\n        }\n\n        lng = lng % 360;\n        return lng < -180 ? lng + 360 : lng > 180 ? lng - 360 : lng;\n\n    },\n\n    /**\n    * Closest angle between two angles from a1 to a2 absolute value the return for exact angle\n    * @method Phaser.Math#nearestAngleBetween\n    * @param {number} a1\n    * @param {number} a2\n    * @param {boolean} radians - True if angle sizes are expressed in radians.\n    * @return {number}\n    */\n    nearestAngleBetween: function (a1, a2, radians) {\n\n        if (typeof radians === \"undefined\") { radians = true; }\n\n        var rd = (radians) ? Math.PI : 180;\n        a1 = this.normalizeAngle(a1, radians);\n        a2 = this.normalizeAngle(a2, radians);\n\n        if (a1 < -rd / 2 && a2 > rd / 2)\n        {\n            a1 += rd * 2;\n        }\n\n        if (a2 < -rd / 2 && a1 > rd / 2)\n        {\n            a2 += rd * 2;\n        }\n\n        return a2 - a1;\n\n    },\n\n    /**\n    * Interpolate across the shortest arc between two angles.\n    * @method Phaser.Math#interpolateAngles\n    * @param {number} a1 - Description.\n    * @param {number} a2 - Description.\n    * @param {number} weight - Description.\n    * @param {boolean} radians - True if angle sizes are expressed in radians.\n    * @param {Description} ease - Description.\n    * @return {number}\n    */\n    interpolateAngles: function (a1, a2, weight, radians, ease) {\n\n        if (typeof radians === \"undefined\") { radians = true; }\n        if (typeof ease === \"undefined\") { ease = null; }\n\n        a1 = this.normalizeAngle(a1, radians);\n        a2 = this.normalizeAngleToAnother(a2, a1, radians);\n\n        return (typeof ease === 'function') ? ease(weight, a1, a2 - a1, 1) : this.interpolateFloat(a1, a2, weight);\n\n    },\n\n    /**\n    * Generate a random bool result based on the chance value.\n    * <p>\n    * Returns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance\n    * of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.\n    * </p>\n    * @method Phaser.Math#chanceRoll\n    * @param {number} chance - The chance of receiving the value. A number between 0 and 100 (effectively 0% to 100%).\n    * @return {boolean} True if the roll passed, or false otherwise.\n    */\n    chanceRoll: function (chance) {\n\n        if (typeof chance === \"undefined\") { chance = 50; }\n\n        if (chance <= 0)\n        {\n            return false;\n        }\n        else if (chance >= 100)\n        {\n            return true;\n        }\n        else\n        {\n            if (Math.random() * 100 >= chance)\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n        }\n\n    },\n\n    /**\n    * Returns an Array containing the numbers from min to max (inclusive).\n    *\n    * @method Phaser.Math#numberArray\n    * @param {number} min - The minimum value the array starts with.\n    * @param {number} max - The maximum value the array contains.\n    * @return {array} The array of number values.\n    */\n    numberArray: function (min, max) {\n\n        var result = [];\n\n        for (var i = min; i <= max; i++)\n        {\n            result.push(i);\n        }\n\n        return result;\n\n    },\n\n    /**\n    * Adds the given amount to the value, but never lets the value go over the specified maximum.\n    *\n    * @method Phaser.Math#maxAdd\n    * @param {number} value - The value to add the amount to.\n    * @param {number} amount - The amount to add to the value.\n    * @param {number} max- The maximum the value is allowed to be.\n    * @return {number}\n    */\n    maxAdd: function (value, amount, max) {\n\n        value += amount;\n\n        if (value > max)\n        {\n            value = max;\n        }\n\n        return value;\n\n    },\n\n    /**\n    * Subtracts the given amount from the value, but never lets the value go below the specified minimum.\n    *\n    * @method Phaser.Math#minSub\n    * @param {number} value - The base value.\n    * @param {number} amount - The amount to subtract from the base value.\n    * @param {number} min - The minimum the value is allowed to be.\n    * @return {number} The new value.\n    */\n    minSub: function (value, amount, min) {\n\n        value -= amount;\n\n        if (value < min)\n        {\n            value = min;\n        }\n\n        return value;\n\n    },\n\n    /**\n    * Ensures that the value always stays between min and max, by wrapping the value around.\n    * max should be larger than min, or the function will return 0.\n    *\n    * @method Phaser.Math#wrap\n    * @param {number} value - The value to wrap.\n    * @param {number} min - The minimum the value is allowed to be.\n    * @param {number} max - The maximum the value is allowed to be.\n    * @return {number} The wrapped value.\n    */\n    wrap: function (value, min, max) {\n\n        var range = max - min;\n\n        if (range <= 0)\n        {\n            return 0;\n        }\n\n        var result = (value - min) % range;\n\n        if (result < 0)\n        {\n            result += range;\n        }\n\n        return result + min;\n\n    },\n\n    /**\n    * Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.\n    * Values must be positive integers, and are passed through Math.abs.\n    *\n    * @method Phaser.Math#wrapValue\n    * @param {number} value - The value to add the amount to.\n    * @param {number} amount - The amount to add to the value.\n    * @param {number} max - The maximum the value is allowed to be.\n    * @return {number} The wrapped value.\n    */\n    wrapValue: function (value, amount, max) {\n\n        var diff;\n        value = Math.abs(value);\n        amount = Math.abs(amount);\n        max = Math.abs(max);\n        diff = (value + amount) % max;\n\n        return diff;\n\n    },\n\n    /**\n    * Ensures the given value is between min and max inclusive.\n    *\n    * @method Phaser.Math#limitValue\n    * @param {number} value - The value to limit.\n    * @param {number} min - The minimum the value can be.\n    * @param {number} max - The maximum the value can be.\n    * @return {number} The limited value.\n    */\n    limitValue: function(value, min, max) {\n\n        return value < min ? min : value > max ? max : value;\n\n    },\n\n    /**\n    * Randomly returns either a 1 or -1.\n    *\n    * @method Phaser.Math#randomSign\n    * @return {number}  1 or -1\n    */\n    randomSign: function () {\n\n        return (Math.random() > 0.5) ? 1 : -1;\n\n    },\n\n    /**\n    * Returns true if the number given is odd.\n    *\n    * @method Phaser.Math#isOdd\n    * @param {number} n - The number to check.\n    * @return {boolean} True if the given number is odd. False if the given number is even.\n    */\n    isOdd: function (n) {\n\n        return (n & 1);\n\n    },\n\n    /**\n    * Returns true if the number given is even.\n    *\n    * @method Phaser.Math#isEven\n    * @param {number} n - The number to check.\n    * @return {boolean} True if the given number is even. False if the given number is odd.\n    */\n    isEven: function (n) {\n\n        if (n & 1)\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n\n    },\n\n    /**\n    * Updated version of Math.min that can be passed either an array of numbers or the numbers as parameters.\n    * See http://jsperf.com/math-s-min-max-vs-homemade/5\n    *\n    * @method Phaser.Math#min\n    * @return {number} The lowest value from those given.\n    */\n    min: function () {\n\n        if (arguments.length === 1 && typeof arguments[0] === 'object')\n        {\n            var data = arguments[0];\n        }\n        else\n        {\n            var data = arguments;\n        }\n\n        for (var i = 1, min = 0, len = data.length; i < len; i++)\n        {\n            if (data[i] < data[min])\n            {\n                min = i;\n            }\n        }\n\n        return data[min];\n\n    },\n\n    /**\n    * Updated version of Math.max that can be passed either an array of numbers or the numbers as parameters.\n    *\n    * @method Phaser.Math#max\n    * @return {number} The largest value from those given.\n    */\n    max: function () {\n\n        if (arguments.length === 1 && typeof arguments[0] === 'object')\n        {\n            var data = arguments[0];\n        }\n        else\n        {\n            var data = arguments;\n        }\n\n        for (var i = 1, max = 0, len = data.length; i < len; i++)\n        {\n            if (data[i] > data[max])\n            {\n                max = i;\n            }\n        }\n\n        return data[max];\n\n    },\n\n    /**\n    * Updated version of Math.min that can be passed a property and either an array of objects or the objects as parameters.\n    * It will find the lowest matching property value from the given objects.\n    *\n    * @method Phaser.Math#minProperty\n    * @return {number} The lowest value from those given.\n    */\n    minProperty: function (property) {\n\n        if (arguments.length === 2 && typeof arguments[1] === 'object')\n        {\n            var data = arguments[1];\n        }\n        else\n        {\n            var data = arguments.slice(1);\n        }\n\n        for (var i = 1, min = 0, len = data.length; i < len; i++)\n        {\n            if (data[i][property] < data[min][property])\n            {\n                min = i;\n            }\n        }\n\n        return data[min][property];\n\n    },\n\n    /**\n    * Updated version of Math.max that can be passed a property and either an array of objects or the objects as parameters.\n    * It will find the largest matching property value from the given objects.\n    *\n    * @method Phaser.Math#maxProperty\n    * @return {number} The largest value from those given.\n    */\n    maxProperty: function (property) {\n\n        if (arguments.length === 2 && typeof arguments[1] === 'object')\n        {\n            var data = arguments[1];\n        }\n        else\n        {\n            var data = arguments.slice(1);\n        }\n\n        for (var i = 1, max = 0, len = data.length; i < len; i++)\n        {\n            if (data[i][property] > data[max][property])\n            {\n                max = i;\n            }\n        }\n\n        return data[max][property];\n\n    },\n\n    /**\n    * Keeps an angle value between -180 and +180.\n    *\n    * @method Phaser.Math#wrapAngle\n    * @param {number} angle - The angle value to check\n    * @param {boolean} radians - True if angle is given in radians.\n    * @return {number} The new angle value, returns the same as the input angle if it was within bounds.\n    */\n    wrapAngle: function (angle, radians) {\n\n        var radianFactor = (radians) ? Math.PI / 180 : 1;\n        return this.wrap(angle, -180 * radianFactor, 180 * radianFactor);\n\n    },\n\n    /**\n    * Keeps an angle value between the given min and max values.\n    *\n    * @method Phaser.Math#angleLimit\n    * @param {number} angle - The angle value to check. Must be between -180 and +180.\n    * @param {number} min - The minimum angle that is allowed (must be -180 or greater).\n    * @param {number} max - The maximum angle that is allowed (must be 180 or less).\n    * @return {number} The new angle value, returns the same as the input angle if it was within bounds\n    */\n    angleLimit: function (angle, min, max) {\n\n        var result = angle;\n\n        if (angle > max)\n        {\n            result = max;\n        }\n        else if (angle < min)\n        {\n            result = min;\n        }\n\n        return result;\n\n    },\n\n    /**\n    * A Linear Interpolation Method, mostly used by Phaser.Tween.\n    * @method Phaser.Math#linearInterpolation\n    * @param {number} v\n    * @param {number} k\n    * @return {number}\n    */\n    linearInterpolation: function (v, k) {\n\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n\n        if (k < 0)\n        {\n            return this.linear(v[0], v[1], f);\n        }\n\n        if (k > 1)\n        {\n            return this.linear(v[m], v[m - 1], m - f);\n        }\n\n        return this.linear(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n    },\n\n    /**\n    * A Bezier Interpolation Method, mostly used by Phaser.Tween.\n    * @method Phaser.Math#bezierInterpolation\n    * @param {number} v\n    * @param {number} k\n    * @return {number}\n    */\n    bezierInterpolation: function (v, k) {\n\n        var b = 0;\n        var n = v.length - 1;\n\n        for (var i = 0; i <= n; i++)\n        {\n            b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * this.bernstein(n, i);\n        }\n\n        return b;\n\n    },\n\n    /**\n    * A Catmull Rom Interpolation Method, mostly used by Phaser.Tween.\n    * @method Phaser.Math#catmullRomInterpolation\n    * @param {number} v\n    * @param {number} k\n    * @return {number}\n    */\n    catmullRomInterpolation: function (v, k) {\n\n        var m = v.length - 1;\n        var f = m * k;\n        var i = Math.floor(f);\n\n        if (v[0] === v[m])\n        {\n            if (k < 0)\n            {\n                i = Math.floor(f = m * (1 + k));\n            }\n\n            return this.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\n        }\n        else\n        {\n            if (k < 0)\n            {\n                return v[0] - (this.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]);\n            }\n\n            if (k > 1)\n            {\n                return v[m] - (this.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n            }\n\n            return this.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n        }\n\n    },\n\n    /**\n    * Description.\n    * @method Phaser.Math#Linear\n    * @param {number} p0\n    * @param {number} p1\n    * @param {number} t\n    * @return {number}\n    */\n    linear: function (p0, p1, t) {\n        return (p1 - p0) * t + p0;\n    },\n\n    /**\n    * @method Phaser.Math#bernstein\n    * @param {number} n\n    * @param {number} i\n    * @return {number}\n    */\n    bernstein: function (n, i) {\n        return this.factorial(n) / this.factorial(i) / this.factorial(n - i);\n    },\n\n    /**\n    * Description.\n    * @method Phaser.Math#catmullRom\n    * @param {number} p0\n    * @param {number} p1\n    * @param {number} p2\n    * @param {number} p3\n    * @param {number} t\n    * @return {number}\n    */\n    catmullRom: function (p0, p1, p2, p3, t) {\n\n        var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2;\n\n        return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n    },\n\n    /**\n    * @method Phaser.Math#difference\n    * @param {number} a\n    * @param {number} b\n    * @return {number}\n    */\n    difference: function (a, b) {\n        return Math.abs(a - b);\n    },\n\n    /**\n    * Fetch a random entry from the given array.\n    * Will return null if random selection is missing, or array has no entries.\n    *\n    * @method Phaser.Math#getRandom\n    * @param {array} objects - An array of objects.\n    * @param {number} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.\n    * @param {number} length - Optional restriction on the number of values you want to randomly select from.\n    * @return {object} The random object that was selected.\n    */\n    getRandom: function (objects, startIndex, length) {\n\n        if (typeof startIndex === \"undefined\") { startIndex = 0; }\n        if (typeof length === \"undefined\") { length = 0; }\n\n        if (objects != null) {\n\n            var l = length;\n\n            if ((l === 0) || (l > objects.length - startIndex))\n            {\n                l = objects.length - startIndex;\n            }\n\n            if (l > 0)\n            {\n                return objects[startIndex + Math.floor(Math.random() * l)];\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Removes a random object from the given array and returns it.\n    * Will return null if random selection is missing, or array has no entries.\n    *\n    * @method Phaser.Math#removeRandom\n    * @param {array} objects - An array of objects.\n    * @param {number} startIndex - Optional offset off the front of the array. Default value is 0, or the beginning of the array.\n    * @param {number} length - Optional restriction on the number of values you want to randomly select from.\n    * @return {object} The random object that was removed.\n    */\n    removeRandom: function (objects, startIndex, length) {\n\n        if (typeof startIndex === \"undefined\") { startIndex = 0; }\n        if (typeof length === \"undefined\") { length = 0; }\n\n        if (objects != null) {\n\n            var l = length;\n\n            if ((l === 0) || (l > objects.length - startIndex))\n            {\n                l = objects.length - startIndex;\n            }\n\n            if (l > 0)\n            {\n                var idx = startIndex + Math.floor(Math.random() * l);\n                var removed = objects.splice(idx, 1);\n                return removed[0];\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Round down to the next whole number. E.g. floor(1.7) == 1, and floor(-2.7) == -2.\n    *\n    * @method Phaser.Math#floor\n    * @param {number} Value Any number.\n    * @return {number} The rounded value of that number.\n    */\n    floor: function (value) {\n\n        var n = value | 0;\n\n        return (value > 0) ? (n) : ((n != value) ? (n - 1) : (n));\n\n    },\n\n    /**\n    * Round up to the next whole number.  E.g. ceil(1.3) == 2, and ceil(-2.3) == -3.\n    *\n    * @method Phaser.Math#ceil\n    * @param {number} value - Any number.\n    * @return {number} The rounded value of that number.\n    */\n    ceil: function (value) {\n        var n = value | 0;\n        return (value > 0) ? ((n != value) ? (n + 1) : (n)) : (n);\n    },\n\n    /**\n    * Generate a sine and cosine table simultaneously and extremely quickly. Based on research by Franky of scene.at\n    * <p>\n    * The parameters allow you to specify the length, amplitude and frequency of the wave. Once you have called this function\n    * you should get the results via getSinTable() and getCosTable(). This generator is fast enough to be used in real-time.\n    * </p>\n    * @method Phaser.Math#sinCosGenerator\n    * @param {number} length - The length of the wave\n    * @param {number} sinAmplitude - The amplitude to apply to the sine table (default 1.0) if you need values between say -+ 125 then give 125 as the value\n    * @param {number} cosAmplitude - The amplitude to apply to the cosine table (default 1.0) if you need values between say -+ 125 then give 125 as the value\n    * @param {number} frequency  - The frequency of the sine and cosine table data\n    * @return {Array} Returns the sine table\n    */\n    sinCosGenerator: function (length, sinAmplitude, cosAmplitude, frequency) {\n\n        if (typeof sinAmplitude === \"undefined\") { sinAmplitude = 1.0; }\n        if (typeof cosAmplitude === \"undefined\") { cosAmplitude = 1.0; }\n        if (typeof frequency === \"undefined\") { frequency = 1.0; }\n\n        var sin = sinAmplitude;\n        var cos = cosAmplitude;\n        var frq = frequency * Math.PI / length;\n\n        var cosTable = [];\n        var sinTable = [];\n\n        for (var c = 0; c < length; c++) {\n\n            cos -= sin * frq;\n            sin += cos * frq;\n\n            cosTable[c] = cos;\n            sinTable[c] = sin;\n\n        }\n\n        return { sin: sinTable, cos: cosTable, length: length };\n\n    },\n\n    /**\n    * Removes the top element from the stack and re-inserts it onto the bottom, then returns it.\n    * The original stack is modified in the process. This effectively moves the position of the data from the start to the end of the table.\n    *\n    * @method Phaser.Math#shift\n    * @param {array} stack - The array to shift.\n    * @return {any} The shifted value.\n    */\n    shift: function (stack) {\n\n        var s = stack.shift();\n        stack.push(s);\n\n        return s;\n\n    },\n\n    /**\n    * Shuffles the data in the given array into a new order\n    * @method Phaser.Math#shuffleArray\n    * @param {array} array - The array to shuffle\n    * @return {array} The array\n    */\n    shuffleArray: function (array) {\n\n        for (var i = array.length - 1; i > 0; i--) {\n\n            var j = Math.floor(Math.random() * (i + 1));\n            var temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n\n        return array;\n\n    },\n\n    /**\n    * Returns the distance between the two given set of coordinates.\n    *\n    * @method Phaser.Math#distance\n    * @param {number} x1\n    * @param {number} y1\n    * @param {number} x2\n    * @param {number} y2\n    * @return {number} The distance between the two sets of coordinates.\n    */\n    distance: function (x1, y1, x2, y2) {\n\n        var dx = x1 - x2;\n        var dy = y1 - y2;\n\n        return Math.sqrt(dx * dx + dy * dy);\n\n    },\n\n    /**\n    * Returns the distance between the two given set of coordinates at the power given.\n    *\n    * @method Phaser.Math#distancePow\n    * @param {number} x1\n    * @param {number} y1\n    * @param {number} x2\n    * @param {number} y2\n    * @param {number} [pow=2]\n    * @return {number} The distance between the two sets of coordinates.\n    */\n    distancePow: function (x1, y1, x2, y2, pow) {\n\n        if (typeof pow === 'undefined') { pow = 2; }\n\n        return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow));\n\n    },\n\n    /**\n    * Returns the rounded distance between the two given set of coordinates.\n    *\n    * @method Phaser.Math#distanceRounded\n    * @param {number} x1\n    * @param {number} y1\n    * @param {number} x2\n    * @param {number} y2\n    * @return {number} The distance between this Point object and the destination Point object.\n    */\n    distanceRounded: function (x1, y1, x2, y2) {\n\n        return Math.round(Phaser.Math.distance(x1, y1, x2, y2));\n\n    },\n\n    /**\n    * Force a value within the boundaries of two values.\n    * Clamp value to range <a, b>\n    *\n    * @method Phaser.Math#clamp\n    * @param {number} x\n    * @param {number} a\n    * @param {number} b\n    * @return {number}\n    */\n    clamp: function ( x, a, b ) {\n\n        return ( x < a ) ? a : ( ( x > b ) ? b : x );\n\n    },\n\n    /**\n    * Clamp value to range <a, inf).\n    *\n    * @method Phaser.Math#clampBottom\n    * @param {number} x\n    * @param {number} a\n    * @return {number}\n    */\n    clampBottom: function ( x, a ) {\n\n        return x < a ? a : x;\n\n    },\n\n    /**\n    * Checks if two values are within the given tolerance of each other.\n    *\n    * @method Phaser.Math#within\n    * @param {number} a - The first number to check\n    * @param {number} b - The second number to check\n    * @param {number} tolerance - The tolerance. Anything equal to or less than this is considered within the range.\n    * @return {boolean} True if a is <= tolerance of b.\n    */\n    within: function ( a, b, tolerance ) {\n\n        return (Math.abs(a - b) <= tolerance);\n\n    },\n\n    /**\n    * Linear mapping from range <a1, a2> to range <b1, b2>\n    *\n    * @method Phaser.Math#mapLinear\n    * @param {number} x the value to map\n    * @param {number} a1 first endpoint of the range <a1, a2>\n    * @param {number} a2 final endpoint of the range <a1, a2>\n    * @param {number} b1 first endpoint of the range <b1, b2>\n    * @param {number} b2 final endpoint of the range  <b1, b2>\n    * @return {number}\n    */\n    mapLinear: function ( x, a1, a2, b1, b2 ) {\n\n        return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n    },\n\n    /**\n    * Smoothstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep\n    *\n    * @method Phaser.Math#smoothstep\n    * @param {number} x\n    * @param {number} min\n    * @param {number} max\n    * @return {number}\n    */\n    smoothstep: function ( x, min, max ) {\n\n        x = Math.max(0, Math.min(1, (x - min) / (max - min)));\n        return x * x * (3 - 2 * x);\n\n    },\n\n    /**\n    * Smootherstep function as detailed at http://en.wikipedia.org/wiki/Smoothstep\n    *\n    * @method Phaser.Math#smootherstep\n    * @param {number} x\n    * @param {number} min\n    * @param {number} max\n    * @return {number}\n    */\n    smootherstep: function ( x, min, max ) {\n\n        x = Math.max(0, Math.min(1, (x - min) / (max - min)));\n        return x * x * x * (x * (x * 6 - 15) + 10);\n\n    },\n\n    /**\n    * A value representing the sign of the value.\n    * -1 for negative, +1 for positive, 0 if value is 0\n    *\n    * @method Phaser.Math#sign\n    * @param {number} x\n    * @return {number}\n    */\n    sign: function ( x ) {\n\n        return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\n\n    },\n\n    /**\n    * Convert degrees to radians.\n    *\n    * @method Phaser.Math#degToRad\n    * @return {function}\n    */\n    degToRad: (function() {\n\n        var degreeToRadiansFactor = Math.PI / 180;\n\n        return function ( degrees ) {\n\n            return degrees * degreeToRadiansFactor;\n\n        };\n\n    }()),\n\n    /**\n    * Convert degrees to radians.\n    *\n    * @method Phaser.Math#radToDeg\n    * @return {function}\n    */\n    radToDeg: (function() {\n\n        var radianToDegreesFactor = 180 / Math.PI;\n\n        return function ( radians ) {\n\n            return radians * radianToDegreesFactor;\n\n        };\n\n    }())\n\n};\n\n/* jshint noempty: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.RandomDataGenerator constructor.\n*\n* @class Phaser.RandomDataGenerator\n* @classdesc An extremely useful repeatable random data generator. Access it via Phaser.Game.rnd\n* Based on Nonsense by Josh Faul https://github.com/jocafa/Nonsense.\n* Random number generator from http://baagoe.org/en/wiki/Better_random_numbers_for_javascript\n*\n* @constructor\n* @param {array} seeds\n*/\nPhaser.RandomDataGenerator = function (seeds) {\n\n    if (typeof seeds === \"undefined\") { seeds = []; }\n\n    /**\n    * @property {number} c - Internal var.\n    * @private\n    */\n    this.c = 1;\n\n    /**\n    * @property {number} s0 - Internal var.\n    * @private\n    */\n    this.s0 = 0;\n\n    /**\n    * @property {number} s1 - Internal var.\n    * @private\n    */\n    this.s1 = 0;\n\n    /**\n    * @property {number} s2 - Internal var.\n    * @private\n    */\n    this.s2 = 0;\n\n    this.sow(seeds);\n\n};\n\nPhaser.RandomDataGenerator.prototype = {\n\n    /**\n    * Private random helper.\n    *\n    * @method Phaser.RandomDataGenerator#rnd\n    * @private\n    * @return {number}\n    */\n    rnd: function () {\n\n        var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32\n\n        this.c = t | 0;\n        this.s0 = this.s1;\n        this.s1 = this.s2;\n        this.s2 = t - this.c;\n\n        return this.s2;\n    },\n\n    /**\n    * Reset the seed of the random data generator.\n    *\n    * @method Phaser.RandomDataGenerator#sow\n    * @param {array} seeds\n    */\n    sow: function (seeds) {\n\n        if (typeof seeds === \"undefined\") { seeds = []; }\n\n        this.s0 = this.hash(' ');\n        this.s1 = this.hash(this.s0);\n        this.s2 = this.hash(this.s1);\n        this.c = 1;\n\n        var seed;\n\n        for (var i = 0; seed = seeds[i++]; )\n        {\n            this.s0 -= this.hash(seed);\n            this.s0 += ~~(this.s0 < 0);\n            this.s1 -= this.hash(seed);\n            this.s1 += ~~(this.s1 < 0);\n            this.s2 -= this.hash(seed);\n            this.s2 += ~~(this.s2 < 0);\n        }\n\n    },\n\n    /**\n    * Internal method that creates a seed hash.\n    *\n    * @method Phaser.RandomDataGenerator#hash\n    * @private\n    * @param {Any} data\n    * @return {number} hashed value.\n    */\n    hash: function (data) {\n\n        var h, i, n;\n        n = 0xefc8249d;\n        data = data.toString();\n\n        for (i = 0; i < data.length; i++) {\n            n += data.charCodeAt(i);\n            h = 0.02519603282416938 * n;\n            n = h >>> 0;\n            h -= n;\n            h *= n;\n            n = h >>> 0;\n            h -= n;\n            n += h * 0x100000000;// 2^32\n        }\n\n        return (n >>> 0) * 2.3283064365386963e-10;// 2^-32\n\n    },\n\n    /**\n    * Returns a random integer between 0 and 2^32.\n    *\n    * @method Phaser.RandomDataGenerator#integer\n    * @return {number} A random integer between 0 and 2^32.\n    */\n    integer: function() {\n\n        return this.rnd.apply(this) * 0x100000000;// 2^32\n\n    },\n\n    /**\n    * Returns a random real number between 0 and 1.\n    *\n    * @method Phaser.RandomDataGenerator#frac\n    * @return {number} A random real number between 0 and 1.\n    */\n    frac: function() {\n\n        return this.rnd.apply(this) + (this.rnd.apply(this) * 0x200000 | 0) * 1.1102230246251565e-16;   // 2^-53\n\n    },\n\n    /**\n    * Returns a random real number between 0 and 2^32.\n    *\n    * @method Phaser.RandomDataGenerator#real\n    * @return {number} A random real number between 0 and 2^32.\n    */\n    real: function() {\n\n        return this.integer() + this.frac();\n\n    },\n\n    /**\n    * Returns a random integer between and including min and max.\n    *\n    * @method Phaser.RandomDataGenerator#integerInRange\n    * @param {number} min - The minimum value in the range.\n    * @param {number} max - The maximum value in the range.\n    * @return {number} A random number between min and max.\n    */\n    integerInRange: function (min, max) {\n\n        return Math.floor(this.realInRange(0, max - min + 1)) + min;\n\n    },\n\n    /**\n    * Returns a random real number between min and max.\n    *\n    * @method Phaser.RandomDataGenerator#realInRange\n    * @param {number} min - The minimum value in the range.\n    * @param {number} max - The maximum value in the range.\n    * @return {number} A random number between min and max.\n    */\n    realInRange: function (min, max) {\n\n        return this.frac() * (max - min) + min;\n\n    },\n\n    /**\n    * Returns a random real number between -1 and 1.\n    *\n    * @method Phaser.RandomDataGenerator#normal\n    * @return {number} A random real number between -1 and 1.\n    */\n    normal: function () {\n\n        return 1 - 2 * this.frac();\n\n    },\n\n    /**\n    * Returns a valid RFC4122 version4 ID hex string from https://gist.github.com/1308368\n    *\n    * @method Phaser.RandomDataGenerator#uuid\n    * @return {string} A valid RFC4122 version4 ID hex string\n    */\n    uuid: function () {\n\n        var a = '';\n        var b = '';\n\n        for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-')\n        {\n        }\n\n        return b;\n\n    },\n\n    /**\n    * Returns a random member of `array`.\n    *\n    * @method Phaser.RandomDataGenerator#pick\n    * @param {Array} ary - An Array to pick a random member of.\n    * @return {any} A random member of the array.\n    */\n    pick: function (ary) {\n\n        return ary[this.integerInRange(0, ary.length - 1)];\n\n    },\n\n    /**\n    * Returns a random member of `array`, favoring the earlier entries.\n    *\n    * @method Phaser.RandomDataGenerator#weightedPick\n    * @param {Array} ary - An Array to pick a random member of.\n    * @return {any} A random member of the array.\n    */\n    weightedPick: function (ary) {\n\n        return ary[~~(Math.pow(this.frac(), 2) * (ary.length - 1))];\n\n    },\n\n    /**\n    * Returns a random timestamp between min and max, or between the beginning of 2000 and the end of 2020 if min and max aren't specified.\n    *\n    * @method Phaser.RandomDataGenerator#timestamp\n    * @param {number} min - The minimum value in the range.\n    * @param {number} max - The maximum value in the range.\n    * @return {number} A random timestamp between min and max.\n    */\n    timestamp: function (min, max) {\n\n        return this.realInRange(min || 946684800000, max || 1577862000000);\n\n    },\n\n    /**\n    * Returns a random angle between -180 and 180.\n    *\n    * @method Phaser.RandomDataGenerator#angle\n    * @return {number} A random number between -180 and 180.\n    */\n    angle: function() {\n\n        return this.integerInRange(-180, 180);\n\n    }\n\n};\n\nPhaser.RandomDataGenerator.prototype.constructor = Phaser.RandomDataGenerator;\n\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2014 Photon Storm Ltd.\n * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n */\n\n/**\n* Javascript QuadTree\n* @version 1.0\n* @author Timo Hausmann\n*\n* @version 1.3, March 11th 2014\n* @author Richard Davey\n* The original code was a conversion of the Java code posted to GameDevTuts. However I've tweaked\n* it massively to add node indexing, removed lots of temp. var creation and significantly\n* increased performance as a result.\n*\n* Original version at https://github.com/timohausmann/quadtree-js/\n*/\n\n/**\n* @copyright  2012 Timo Hausmann\n*\n* Permission is hereby granted, free of charge, to any person obtaining\n* a copy of this software and associated documentation files (the\n* \"Software\"), to deal in the Software without restriction, including\n* without limitation the rights to use, copy, modify, merge, publish,\n* distribute, sublicense, and/or sell copies of the Software, and to\n* permit persons to whom the Software is furnished to do so, subject to\n* the following conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/**\n* QuadTree Constructor\n*\n* @class Phaser.QuadTree\n* @classdesc A QuadTree implementation. The original code was a conversion of the Java code posted to GameDevTuts.\n* However I've tweaked it massively to add node indexing, removed lots of temp. var creation and significantly increased performance as a result.\n* Original version at https://github.com/timohausmann/quadtree-js/\n* @constructor\n* @param {number} x - The top left coordinate of the quadtree.\n* @param {number} y - The top left coordinate of the quadtree.\n* @param {number} width - The width of the quadtree in pixels.\n* @param {number} height - The height of the quadtree in pixels.\n* @param {number} [maxObjects=10] - The maximum number of objects per node.\n* @param {number} [maxLevels=4] - The maximum number of levels to iterate to.\n* @param {number} [level=0] - Which level is this?\n*/\nPhaser.QuadTree = function(x, y, width, height, maxObjects, maxLevels, level) {\n\n    /**\n    * @property {number} maxObjects - The maximum number of objects per node.\n    * @default\n    */\n    this.maxObjects = 10;\n\n    /**\n    * @property {number} maxLevels - The maximum number of levels to break down to.\n    * @default\n    */\n    this.maxLevels = 4;\n\n    /**\n    * @property {number} level - The current level.\n    */\n    this.level = 0;\n\n    /**\n    * @property {object} bounds - Object that contains the quadtree bounds.\n    */\n    this.bounds = {};\n\n    /**\n    * @property {array} objects - Array of quadtree children.\n    */\n    this.objects = [];\n\n    /**\n    * @property {array} nodes - Array of associated child nodes.\n    */\n    this.nodes = [];\n\n    /**\n    * @property {array} _empty - Internal empty array.\n    * @private\n    */\n    this._empty = [];\n\n    this.reset(x, y, width, height, maxObjects, maxLevels, level);\n\n};\n\nPhaser.QuadTree.prototype = {\n\n    /**\n    * Resets the QuadTree.\n    *\n    * @method Phaser.QuadTree#reset\n    * @param {number} x - The top left coordinate of the quadtree.\n    * @param {number} y - The top left coordinate of the quadtree.\n    * @param {number} width - The width of the quadtree in pixels.\n    * @param {number} height - The height of the quadtree in pixels.\n    * @param {number} [maxObjects=10] - The maximum number of objects per node.\n    * @param {number} [maxLevels=4] - The maximum number of levels to iterate to.\n    * @param {number} [level=0] - Which level is this?\n    */\n    reset: function (x, y, width, height, maxObjects, maxLevels, level) {\n\n        this.maxObjects = maxObjects || 10;\n        this.maxLevels = maxLevels || 4;\n        this.level = level || 0;\n\n        this.bounds = {\n            x: Math.round(x),\n            y: Math.round(y),\n            width: width,\n            height: height,\n            subWidth: Math.floor(width / 2),\n            subHeight: Math.floor(height / 2),\n            right: Math.round(x) + Math.floor(width / 2),\n            bottom: Math.round(y) + Math.floor(height / 2)\n        };\n\n        this.objects.length = 0;\n        this.nodes.length = 0;\n\n    },\n\n    /**\n    * Populates this quadtree with the children of the given Group. In order to be added the child must exist and have a body property.\n    *\n    * @method Phaser.QuadTree#populate\n    * @param {Phaser.Group} group - The Group to add to the quadtree.\n    */\n    populate: function (group) {\n\n        group.forEach(this.populateHandler, this, true);\n\n    },\n\n    /**\n    * Handler for the populate method.\n    *\n    * @method Phaser.QuadTree#populateHandler\n    * @param {Phaser.Sprite|object} sprite - The Sprite to check.\n    */\n    populateHandler: function (sprite) {\n\n        if (sprite.body && sprite.exists)\n        {\n            this.insert(sprite.body);\n        }\n\n    },\n\n    /**\n    * Split the node into 4 subnodes\n    *\n    * @method Phaser.QuadTree#split\n    */\n    split: function () {\n\n        this.level++;\n\n        //  top right node\n        this.nodes[0] = new Phaser.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);\n\n        //  top left node\n        this.nodes[1] = new Phaser.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);\n\n        //  bottom left node\n        this.nodes[2] = new Phaser.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);\n\n        //  bottom right node\n        this.nodes[3] = new Phaser.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);\n\n    },\n\n    /**\n    * Insert the object into the node. If the node exceeds the capacity, it will split and add all objects to their corresponding subnodes.\n    *\n    * @method Phaser.QuadTree#insert\n    * @param {Phaser.Physics.Arcade.Body|object} body - The Body object to insert into the quadtree. Can be any object so long as it exposes x, y, right and bottom properties.\n    */\n    insert: function (body) {\n\n        var i = 0;\n        var index;\n\n        //  if we have subnodes ...\n        if (this.nodes[0] != null)\n        {\n            index = this.getIndex(body);\n\n            if (index !== -1)\n            {\n                this.nodes[index].insert(body);\n                return;\n            }\n        }\n\n        this.objects.push(body);\n\n        if (this.objects.length > this.maxObjects && this.level < this.maxLevels)\n        {\n            //  Split if we don't already have subnodes\n            if (this.nodes[0] == null)\n            {\n                this.split();\n            }\n\n            //  Add objects to subnodes\n            while (i < this.objects.length)\n            {\n                index = this.getIndex(this.objects[i]);\n\n                if (index !== -1)\n                {\n                    //  this is expensive - see what we can do about it\n                    this.nodes[index].insert(this.objects.splice(i, 1)[0]);\n                }\n                else\n                {\n                    i++;\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Determine which node the object belongs to.\n    *\n    * @method Phaser.QuadTree#getIndex\n    * @param {Phaser.Rectangle|object} rect - The bounds in which to check.\n    * @return {number} index - Index of the subnode (0-3), or -1 if rect cannot completely fit within a subnode and is part of the parent node.\n    */\n    getIndex: function (rect) {\n\n        //  default is that rect doesn't fit, i.e. it straddles the internal quadrants\n        var index = -1;\n\n        if (rect.x < this.bounds.right && rect.right < this.bounds.right)\n        {\n            if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom)\n            {\n                //  rect fits within the top-left quadrant of this quadtree\n                index = 1;\n            }\n            else if (rect.y > this.bounds.bottom)\n            {\n                //  rect fits within the bottom-left quadrant of this quadtree\n                index = 2;\n            }\n        }\n        else if (rect.x > this.bounds.right)\n        {\n            //  rect can completely fit within the right quadrants\n            if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom)\n            {\n                //  rect fits within the top-right quadrant of this quadtree\n                index = 0;\n            }\n            else if (rect.y > this.bounds.bottom)\n            {\n                //  rect fits within the bottom-right quadrant of this quadtree\n                index = 3;\n            }\n        }\n\n        return index;\n\n    },\n\n    /**\n    * Return all objects that could collide with the given Sprite.\n    *\n    * @method Phaser.QuadTree#retrieve\n    * @param {Phaser.Sprite} sprite - The sprite to check against.\n    * @return {array} - Array with all detected objects.\n    */\n    retrieve: function (sprite) {\n\n        if (!sprite.body)\n        {\n            return this._empty;\n        }\n\n        var returnObjects = this.objects;\n\n        var index = this.getIndex(sprite.body);\n\n        if (this.nodes[0])\n        {\n            //  If rect fits into a subnode ..\n            if (index !== -1)\n            {\n                returnObjects = returnObjects.concat(this.nodes[index].retrieve(sprite));\n            }\n            else\n            {\n                //  If rect does not fit into a subnode, check it against all subnodes (unrolled for speed)\n                returnObjects = returnObjects.concat(this.nodes[0].retrieve(sprite));\n                returnObjects = returnObjects.concat(this.nodes[1].retrieve(sprite));\n                returnObjects = returnObjects.concat(this.nodes[2].retrieve(sprite));\n                returnObjects = returnObjects.concat(this.nodes[3].retrieve(sprite));\n            }\n        }\n\n        return returnObjects;\n\n    },\n\n    /**\n    * Clear the quadtree.\n    * @method Phaser.QuadTree#clear\n    */\n    clear: function () {\n\n        this.objects.length = 0;\n\n        var i = this.nodes.length;\n\n        while (i--)\n        {\n            this.nodes[i].clear();\n            this.nodes.splice(i, 1);\n        }\n\n        this.nodes.length = 0;\n    }\n\n};\n\nPhaser.QuadTree.prototype.constructor = Phaser.QuadTree;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Net handles browser URL related tasks such as checking host names, domain names and query string manipulation.\n*\n* @class Phaser.Net\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Net = function (game) {\n\n    this.game = game;\n\n};\n\nPhaser.Net.prototype = {\n\n    /**\n    * Returns the hostname given by the browser.\n    *\n    * @method Phaser.Net#getHostName\n    * @return {string}\n    */\n    getHostName: function () {\n\n        if (window.location && window.location.hostname) {\n            return window.location.hostname;\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Compares the given domain name against the hostname of the browser containing the game.\n    * If the domain name is found it returns true.\n    * You can specify a part of a domain, for example 'google' would match 'google.com', 'google.co.uk', etc.\n    * Do not include 'http://' at the start.\n    *\n    * @method Phaser.Net#checkDomainName\n    * @param {string} domain\n    * @return {boolean} true if the given domain fragment can be found in the window.location.hostname\n    */\n    checkDomainName: function (domain) {\n        return window.location.hostname.indexOf(domain) !== -1;\n    },\n\n    /**\n    * Updates a value on the Query String and returns it in full.\n    * If the value doesn't already exist it is set.\n    * If the value exists it is replaced with the new value given. If you don't provide a new value it is removed from the query string.\n    * Optionally you can redirect to the new url, or just return it as a string.\n    *\n    * @method Phaser.Net#updateQueryString\n    * @param {string} key - The querystring key to update.\n    * @param {string} value - The new value to be set. If it already exists it will be replaced.\n    * @param {boolean} redirect - If true the browser will issue a redirect to the url with the new querystring.\n    * @param {string} url - The URL to modify. If none is given it uses window.location.href.\n    * @return {string} If redirect is false then the modified url and query string is returned.\n    */\n    updateQueryString: function (key, value, redirect, url) {\n\n        if (typeof redirect === \"undefined\") { redirect = false; }\n        if (typeof url === \"undefined\" || url === '') { url = window.location.href; }\n\n        var output = '';\n        var re = new RegExp(\"([?|&])\" + key + \"=.*?(&|#|$)(.*)\", \"gi\");\n\n        if (re.test(url))\n        {\n            if (typeof value !== 'undefined' && value !== null)\n            {\n                output = url.replace(re, '$1' + key + \"=\" + value + '$2$3');\n            }\n            else\n            {\n                output = url.replace(re, '$1$3').replace(/(&|\\?)$/, '');\n            }\n        }\n        else\n        {\n            if (typeof value !== 'undefined' && value !== null)\n            {\n                var separator = url.indexOf('?') !== -1 ? '&' : '?';\n                var hash = url.split('#');\n                url = hash[0] + separator + key + '=' + value;\n\n                if (hash[1]) {\n                    url += '#' + hash[1];\n                }\n\n                output = url;\n\n            }\n            else\n            {\n                output = url;\n            }\n        }\n\n        if (redirect)\n        {\n            window.location.href = output;\n        }\n        else\n        {\n            return output;\n        }\n\n    },\n\n    /**\n    * Returns the Query String as an object.\n    * If you specify a parameter it will return just the value of that parameter, should it exist.\n    *\n    * @method Phaser.Net#getQueryString\n    * @param {string} [parameter=''] - If specified this will return just the value for that key.\n    * @return {string|object} An object containing the key value pairs found in the query string or just the value if a parameter was given.\n    */\n    getQueryString: function (parameter) {\n\n        if (typeof parameter === \"undefined\") { parameter = ''; }\n\n        var output = {};\n        var keyValues = location.search.substring(1).split('&');\n\n        for (var i in keyValues)\n        {\n            var key = keyValues[i].split('=');\n\n            if (key.length > 1)\n            {\n                if (parameter && parameter == this.decodeURI(key[0]))\n                {\n                    return this.decodeURI(key[1]);\n                }\n                else\n                {\n                    output[this.decodeURI(key[0])] = this.decodeURI(key[1]);\n                }\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Returns the Query String as an object.\n    * If you specify a parameter it will return just the value of that parameter, should it exist.\n    *\n    * @method Phaser.Net#decodeURI\n    * @param {string} value - The URI component to be decoded.\n    * @return {string} The decoded value.\n    */\n    decodeURI: function (value) {\n        return decodeURIComponent(value.replace(/\\+/g, \" \"));\n    }\n\n};\n\nPhaser.Net.prototype.constructor = Phaser.Net;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser - TweenManager\n*\n* @class Phaser.TweenManager\n* @classdesc\n* Phaser.Game has a single instance of the TweenManager through which all Tween objects are created and updated.\n* Tweens are hooked into the game clock and pause system, adjusting based on the game state.\n*\n* TweenManager is based heavily on tween.js by http://soledadpenades.com.\n* The difference being that tweens belong to a games instance of TweenManager, rather than to a global TWEEN object.\n* It also has callbacks swapped for Signals and a few issues patched with regard to properties and completion errors.\n* Please see https://github.com/sole/tween.js for a full list of contributors.\n* @constructor\n*\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.TweenManager = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {array<Phaser.Tween>} _tweens - All of the currently running tweens.\n    * @private\n    */\n    this._tweens = [];\n\n    /**\n    * @property {array<Phaser.Tween>} _add - All of the tweens queued to be added in the next update.\n    * @private\n    */\n    this._add = [];\n\n    this.game.onPause.add(this._pauseAll, this);\n    this.game.onResume.add(this._resumeAll, this);\n\n};\n\nPhaser.TweenManager.prototype = {\n\n    /**\n    * Get all the tween objects in an array.\n    * @method Phaser.TweenManager#getAll\n    * @returns {Phaser.Tween[]} Array with all tween objects.\n    */\n    getAll: function () {\n\n        return this._tweens;\n\n    },\n\n    /**\n    * Remove all tweens running and in the queue. Doesn't call any of the tween onComplete events.\n    * @method Phaser.TweenManager#removeAll\n    */\n    removeAll: function () {\n\n        for (var i = 0; i < this._tweens.length; i++)\n        {\n            this._tweens[i].pendingDelete = true;\n        }\n\n        this._add = [];\n\n    },\n\n    /**\n    * Add a new tween into the TweenManager.\n    *\n    * @method Phaser.TweenManager#add\n    * @param {Phaser.Tween} tween - The tween object you want to add.\n    * @returns {Phaser.Tween} The tween object you added to the manager.\n    */\n    add: function (tween) {\n\n        tween._manager = this;\n        this._add.push(tween);\n\n    },\n\n    /**\n    * Create a tween object for a specific object. The object can be any JavaScript object or Phaser object such as Sprite.\n    *\n    * @method Phaser.TweenManager#create\n    * @param {Object} object - Object the tween will be run on.\n    * @returns {Phaser.Tween} The newly created tween object.\n    */\n    create: function (object) {\n\n        return new Phaser.Tween(object, this.game, this);\n\n    },\n\n    /**\n    * Remove a tween from this manager.\n    *\n    * @method Phaser.TweenManager#remove\n    * @param {Phaser.Tween} tween - The tween object you want to remove.\n    */\n    remove: function (tween) {\n\n        var i = this._tweens.indexOf(tween);\n\n        if (i !== -1)\n        {\n            this._tweens[i].pendingDelete = true;\n        }\n\n    },\n\n    /**\n    * Update all the tween objects you added to this manager.\n    *\n    * @method Phaser.TweenManager#update\n    * @returns {boolean} Return false if there's no tween to update, otherwise return true.\n    */\n    update: function () {\n\n        if (this._tweens.length === 0 && this._add.length === 0)\n        {\n            return false;\n        }\n\n        var i = 0;\n        var numTweens = this._tweens.length;\n\n        while (i < numTweens)\n        {\n            if (this._tweens[i].update(this.game.time.now))\n            {\n                i++;\n            }\n            else\n            {\n                this._tweens.splice(i, 1);\n\n                numTweens--;\n            }\n        }\n\n        //  If there are any new tweens to be added, do so now - otherwise they can be spliced out of the array before ever running\n        if (this._add.length > 0)\n        {\n            this._tweens = this._tweens.concat(this._add);\n            this._add.length = 0;\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Checks to see if a particular Sprite is currently being tweened.\n    *\n    * @method Phaser.TweenManager#isTweening\n    * @param {object} object - The object to check for tweens against.\n    * @returns {boolean} Returns true if the object is currently being tweened, false if not.\n    */\n    isTweening: function(object) {\n\n        return this._tweens.some(function(tween) {\n            return tween._object === object;\n        });\n\n    },\n\n    /**\n    * Private. Called by game focus loss. Pauses all currently running tweens.\n    *\n    * @method Phaser.TweenManager#_pauseAll\n    * @private\n    */\n    _pauseAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i]._pause();\n        }\n\n    },\n\n    /**\n    * Private. Called by game focus loss. Resumes all currently paused tweens.\n    *\n    * @method Phaser.TweenManager#_resumeAll\n    * @private\n    */\n    _resumeAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i]._resume();\n        }\n\n    },\n\n    /**\n    * Pauses all currently running tweens.\n    *\n    * @method Phaser.TweenManager#pauseAll\n    */\n    pauseAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i].pause();\n        }\n\n    },\n\n    /**\n    * Resumes all currently paused tweens.\n    *\n    * @method Phaser.TweenManager#resumeAll\n    */\n    resumeAll: function () {\n\n        for (var i = this._tweens.length - 1; i >= 0; i--)\n        {\n            this._tweens[i].resume(true);\n        }\n\n    }\n\n};\n\nPhaser.TweenManager.prototype.constructor = Phaser.TweenManager;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Tween constructor\n* Create a new <code>Tween</code>.\n*\n* @class Phaser.Tween\n* @constructor\n* @param {object} object - Target object will be affected by this tween.\n* @param {Phaser.Game} game - Current game instance.\n* @param {Phaser.TweenManager} manager - The TweenManager responsible for looking after this Tween.\n*/\nPhaser.Tween = function (object, game, manager) {\n\n    /**\n    * Reference to the target object.\n    * @property {object} _object\n    * @private\n    */\n    this._object = object;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.TweenManager} _manager - Reference to the TweenManager.\n    * @private\n    */\n    this._manager = manager;\n\n    /**\n    * @property {object} _valuesStart - Private value object.\n    * @private\n    */\n    this._valuesStart = {};\n\n    /**\n    * @property {object} _valuesEnd - Private value object.\n    * @private\n    */\n    this._valuesEnd = {};\n\n    /**\n    * @property {object} _valuesStartRepeat - Private value object.\n    * @private\n    */\n    this._valuesStartRepeat = {};\n\n    /**\n    * @property {number} _duration - Private duration counter.\n    * @private\n    * @default\n    */\n    this._duration = 1000;\n\n    /**\n    * @property {number} _repeat - Private repeat counter.\n    * @private\n    * @default\n    */\n    this._repeat = 0;\n\n    /**\n    * @property {boolean} _yoyo - Private yoyo flag.\n    * @private\n    * @default\n    */\n    this._yoyo = false;\n\n    /**\n    * @property {boolean} _reversed - Private reversed flag.\n    * @private\n    * @default\n    */\n    this._reversed = false;\n\n    /**\n    * @property {number} _delayTime - Private delay counter.\n    * @private\n    * @default\n    */\n    this._delayTime = 0;\n\n    /**\n    * @property {number} _startTime - Private start time counter.\n    * @private\n    * @default null\n    */\n    this._startTime = null;\n\n    /**\n    * @property {function} _easingFunction - The easing function used for the tween.\n    * @private\n    */\n    this._easingFunction = Phaser.Easing.Linear.None;\n\n    /**\n    * @property {function} _interpolationFunction - The interpolation function used for the tween.\n    * @private\n    */\n    this._interpolationFunction = Phaser.Math.linearInterpolation;\n\n    /**\n    * @property {array} _chainedTweens - A private array of chained tweens.\n    * @private\n    */\n    this._chainedTweens = [];\n\n    /**\n    * @property {boolean} _onStartCallbackFired - Private flag.\n    * @private\n    * @default\n    */\n    this._onStartCallbackFired = false;\n\n    /**\n    * @property {function} _onUpdateCallback - An onUpdate callback.\n    * @private\n    * @default null\n    */\n    this._onUpdateCallback = null;\n\n    /**\n    * @property {object} _onUpdateCallbackContext - The context in which to call the onUpdate callback.\n    * @private\n    * @default null\n    */\n    this._onUpdateCallbackContext = null;\n\n    /**\n    * @property {boolean} _paused - Is this Tween paused or not?\n    * @private\n    * @default\n    */\n    this._paused = false;\n\n    /**\n    * @property {number} _pausedTime - Private pause timer.\n    * @private\n    * @default\n    */\n    this._pausedTime = 0;\n\n    /**\n    * @property {boolean} _codePaused - Was the Tween paused by code or by Game focus loss?\n    * @private\n    */\n    this._codePaused = false;\n\n    /**\n    * @property {boolean} pendingDelete - If this tween is ready to be deleted by the TweenManager.\n    * @default\n    */\n    this.pendingDelete = false;\n\n    // Set all starting values present on the target object - why? this will copy loads of properties we don't need - commenting out for now\n    // for (var field in object)\n    // {\n    //     this._valuesStart[field] = parseFloat(object[field], 10);\n    // }\n\n    /**\n    * @property {Phaser.Signal} onStart - The onStart event is fired when the Tween begins.\n    */\n    this.onStart = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onLoop - The onLoop event is fired if the Tween loops.\n    */\n    this.onLoop = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onComplete - The onComplete event is fired when the Tween completes. Does not fire if the Tween is set to loop.\n    */\n    this.onComplete = new Phaser.Signal();\n\n    /**\n    * @property {boolean} isRunning - If the tween is running this is set to true, otherwise false. Tweens that are in a delayed state, waiting to start, are considered as being running.\n    * @default\n    */\n    this.isRunning = false;\n\n};\n\nPhaser.Tween.prototype = {\n\n    /**\n    * Configure the Tween\n    *\n    * @method Phaser.Tween#to\n    * @param {object} properties - Properties you want to tween.\n    * @param {number} [duration=1000] - Duration of this tween in ms.\n    * @param {function} [ease=null] - Easing function. If not set it will default to Phaser.Easing.Linear.None.\n    * @param {boolean} [autoStart=false] - Whether this tween will start automatically or not.\n    * @param {number} [delay=0] - Delay before this tween will start, defaults to 0 (no delay). Value given is in ms.\n    * @param {number} [repeat=0] - Should the tween automatically restart once complete? If you want it to run forever set as Number.MAX_VALUE. This ignores any chained tweens.\n    * @param {boolean} [yoyo=false] - A tween that yoyos will reverse itself and play backwards automatically. A yoyo'd tween doesn't fire the Tween.onComplete event, so listen for Tween.onLoop instead.\n    * @return {Phaser.Tween} This Tween object.\n    */\n    to: function (properties, duration, ease, autoStart, delay, repeat, yoyo) {\n\n        duration = duration || 1000;\n        ease = ease || null;\n        autoStart = autoStart || false;\n        delay = delay || 0;\n        repeat = repeat || 0;\n        yoyo = yoyo || false;\n\n        if (yoyo && repeat === 0)\n        {\n            repeat = 1;\n        }\n\n        var self;\n\n        if (this._parent)\n        {\n            self = this._manager.create(this._object);\n            this._lastChild.chain(self);\n            this._lastChild = self;\n        }\n        else\n        {\n            self = this;\n            this._parent = this;\n            this._lastChild = this;\n        }\n\n        self._repeat = repeat;\n        self._duration = duration;\n        self._valuesEnd = properties;\n\n        if (ease !== null)\n        {\n            self._easingFunction = ease;\n        }\n\n        if (delay > 0)\n        {\n            self._delayTime = delay;\n        }\n\n        self._yoyo = yoyo;\n\n        if (autoStart)\n        {\n            return this.start();\n        }\n        else\n        {\n            return this;\n        }\n\n    },\n\n    /**\n    * Starts the tween running. Can also be called by the autoStart parameter of Tween.to.\n    *\n    * @method Phaser.Tween#start\n    * @return {Phaser.Tween} Itself.\n    */\n    start: function () {\n\n        if (this.game === null || this._object === null)\n        {\n            return;\n        }\n\n        this._manager.add(this);\n\n        this.isRunning = true;\n\n        this._onStartCallbackFired = false;\n\n        this._startTime = this.game.time.now + this._delayTime;\n\n        for (var property in this._valuesEnd)\n        {\n            // check if an Array was provided as property value\n            if (Array.isArray(this._valuesEnd[property]))\n            {\n                if (this._valuesEnd[property].length === 0)\n                {\n                    continue;\n                }\n\n                // create a local copy of the Array with the start value at the front\n                this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n            }\n\n            this._valuesStart[property] = this._object[property];\n\n            if (!Array.isArray(this._valuesStart[property]))\n            {\n                this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n            }\n\n            this._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n\n        }\n\n        return this;\n\n    },\n\n    /**\n    * This will generate an array populated with the tweened object values from start to end.\n    * It works by running the tween simulation at the given frame rate based on the values set-up in Tween.to and similar functions.\n    * It ignores delay and repeat counts and any chained tweens. Just one play through of tween data is returned, including yoyo if set.\n    *\n    * @method Phaser.Tween#generateData\n    * @param {number} [frameRate=60] - The speed in frames per second that the data should be generated at. The higher the value, the larger the array it creates.\n    * @param {array} [data] - If given the generated data will be appended to this array, otherwise a new array will be returned.\n    * @return {array} An array of tweened values.\n    */\n    generateData: function (frameRate, data) {\n\n        if (this.game === null || this._object === null)\n        {\n            return null;\n        }\n\n        this._startTime = 0;\n\n        for (var property in this._valuesEnd)\n        {\n            // Check if an Array was provided as property value\n            if (Array.isArray(this._valuesEnd[property]))\n            {\n                if (this._valuesEnd[property].length === 0)\n                {\n                    continue;\n                }\n\n                // create a local copy of the Array with the start value at the front\n                this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n            }\n\n            this._valuesStart[property] = this._object[property];\n\n            if (!Array.isArray(this._valuesStart[property]))\n            {\n                this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n            }\n\n            this._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n        }\n\n        //  Simulate the tween. We will run for frameRate * (this._duration / 1000) (ms)\n        var time = 0;\n        var total = Math.floor(frameRate * (this._duration / 1000));\n        var tick = this._duration / total;\n\n        var output = [];\n\n        while (total--)\n        {\n            var property;\n\n            var elapsed = (time - this._startTime) / this._duration;\n            elapsed = elapsed > 1 ? 1 : elapsed;\n\n            var value = this._easingFunction(elapsed);\n            var blob = {};\n\n            for (property in this._valuesEnd)\n            {\n                var start = this._valuesStart[property] || 0;\n                var end = this._valuesEnd[property];\n\n                if (end instanceof Array)\n                {\n                    blob[property] = this._interpolationFunction(end, value);\n                }\n                else\n                {\n                    // Parses relative end values with start as base (e.g.: +10, -3)\n                    if (typeof(end) === 'string')\n                    {\n                        end = start + parseFloat(end, 10);\n                    }\n\n                    // protect against non numeric properties.\n                    if (typeof(end) === 'number')\n                    {\n                        blob[property] = start + ( end - start ) * value;\n                    }\n                }\n            }\n\n            output.push(blob);\n\n            time += tick;\n        }\n\n        if (this._yoyo)\n        {\n            var reversed = output.slice();\n            reversed.reverse();\n            output = output.concat(reversed);\n        }\n\n        if (typeof data !== 'undefined')\n        {\n            data = data.concat(output);\n\n            return data;\n        }\n        else\n        {\n            return output;\n        }\n\n    },\n\n    /**\n    * Stops the tween if running and removes it from the TweenManager. If there are any onComplete callbacks or events they are not dispatched.\n    *\n    * @method Phaser.Tween#stop\n    * @return {Phaser.Tween} Itself.\n    */\n    stop: function () {\n\n        this.isRunning = false;\n\n        this._onUpdateCallback = null;\n\n        this._manager.remove(this);\n\n        return this;\n\n    },\n\n    /**\n    * Sets a delay time before this tween will start.\n    *\n    * @method Phaser.Tween#delay\n    * @param {number} amount - The amount of the delay in ms.\n    * @return {Phaser.Tween} Itself.\n    */\n    delay: function (amount) {\n\n        this._delayTime = amount;\n        return this;\n\n    },\n\n    /**\n    * Sets the number of times this tween will repeat.\n    *\n    * @method Phaser.Tween#repeat\n    * @param {number} times - How many times to repeat.\n    * @return {Phaser.Tween} Itself.\n    */\n    repeat: function (times) {\n\n        this._repeat = times;\n\n        return this;\n\n    },\n\n    /**\n    * A tween that has yoyo set to true will run through from start to finish, then reverse from finish to start.\n    * Used in combination with repeat you can create endless loops.\n    *\n    * @method Phaser.Tween#yoyo\n    * @param {boolean} yoyo - Set to true to yoyo this tween.\n    * @return {Phaser.Tween} Itself.\n    */\n    yoyo: function(yoyo) {\n\n        this._yoyo = yoyo;\n\n        if (yoyo && this._repeat === 0)\n        {\n            this._repeat = 1;\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Set easing function this tween will use, i.e. Phaser.Easing.Linear.None.\n    *\n    * @method Phaser.Tween#easing\n    * @param {function} easing - The easing function this tween will use, i.e. Phaser.Easing.Linear.None.\n    * @return {Phaser.Tween} Itself.\n    */\n    easing: function (easing) {\n\n        this._easingFunction = easing;\n        return this;\n\n    },\n\n    /**\n    * Set interpolation function the tween will use, by default it uses Phaser.Math.linearInterpolation.\n    * Also available: Phaser.Math.bezierInterpolation and Phaser.Math.catmullRomInterpolation.\n    *\n    * @method Phaser.Tween#interpolation\n    * @param {function} interpolation - The interpolation function to use (Phaser.Math.linearInterpolation by default)\n    * @return {Phaser.Tween} Itself.\n    */\n    interpolation: function (interpolation) {\n\n        this._interpolationFunction = interpolation;\n        return this;\n\n    },\n\n    /**\n    * You can chain tweens together by passing a reference to the chain function. This enables one tween to call another on completion.\n    * You can pass as many tweens as you like to this function, they will each be chained in sequence.\n    *\n    * @method Phaser.Tween#chain\n    * @return {Phaser.Tween} Itself.\n    */\n    chain: function () {\n\n        this._chainedTweens = arguments;\n        return this;\n\n    },\n\n    /**\n    * Loop a chain of tweens\n    *\n    * Usage:\n    * game.add.tween(p).to({ x: 700 }, 1000, Phaser.Easing.Linear.None, true)\n    * .to({ y: 300 }, 1000, Phaser.Easing.Linear.None)\n    * .to({ x: 0 }, 1000, Phaser.Easing.Linear.None)\n    * .to({ y: 0 }, 1000, Phaser.Easing.Linear.None)\n    * .loop();\n    * @method Phaser.Tween#loop\n    * @return {Phaser.Tween} Itself.\n    */\n    loop: function() {\n\n        this._lastChild.chain(this);\n        return this;\n\n    },\n\n    /**\n    * Sets a callback to be fired each time this tween updates. Note: callback will be called in the context of the global scope.\n    *\n    * @method Phaser.Tween#onUpdateCallback\n    * @param {function} callback - The callback to invoke each time this tween is updated.\n    * @return {Phaser.Tween} Itself.\n    */\n    onUpdateCallback: function (callback, callbackContext) {\n\n        this._onUpdateCallback = callback;\n        this._onUpdateCallbackContext = callbackContext;\n\n        return this;\n\n    },\n\n    /**\n    * Pauses the tween.\n    *\n    * @method Phaser.Tween#pause\n    */\n    pause: function () {\n\n        this._codePaused = true;\n        this._paused = true;\n        this._pausedTime = this.game.time.now;\n\n    },\n\n    /**\n    * This is called by the core Game loop. Do not call it directly, instead use Tween.pause.\n    * @method Phaser.Tween#_pause\n    * @private\n    */\n    _pause: function () {\n\n        if (!this._codePaused)\n        {\n            this._paused = true;\n            this._pausedTime = this.game.time.now;\n        }\n\n    },\n\n    /**\n    * Resumes a paused tween.\n    *\n    * @method Phaser.Tween#resume\n    */\n    resume: function () {\n\n        if (this._paused)\n        {\n            this._paused = false;\n            this._codePaused = false;\n\n            this._startTime += (this.game.time.now - this._pausedTime);\n        }\n\n    },\n\n    /**\n    * This is called by the core Game loop. Do not call it directly, instead use Tween.pause.\n    * @method Phaser.Tween#_resume\n    * @private\n    */\n    _resume: function () {\n\n        if (this._codePaused)\n        {\n            return;\n        }\n        else\n        {\n            this._startTime += this.game.time.pauseDuration;\n            this._paused = false;\n        }\n\n    },\n\n    /**\n    * Core tween update function called by the TweenManager. Does not need to be invoked directly.\n    *\n    * @method Phaser.Tween#update\n    * @param {number} time - A timestamp passed in by the TweenManager.\n    * @return {boolean} false if the tween has completed and should be deleted from the manager, otherwise true (still active).\n    */\n    update: function (time) {\n\n        if (this.pendingDelete)\n        {\n            return false;\n        }\n\n        if (this._paused || time < this._startTime)\n        {\n            return true;\n        }\n\n        var property;\n\n        if (time < this._startTime)\n        {\n            return true;\n        }\n\n        if (this._onStartCallbackFired === false)\n        {\n            this.onStart.dispatch(this._object);\n            this._onStartCallbackFired = true;\n        }\n\n        var elapsed = (time - this._startTime) / this._duration;\n        elapsed = elapsed > 1 ? 1 : elapsed;\n\n        var value = this._easingFunction(elapsed);\n\n        for (property in this._valuesEnd)\n        {\n            var start = this._valuesStart[property] || 0;\n            var end = this._valuesEnd[property];\n\n            if (end instanceof Array)\n            {\n                this._object[property] = this._interpolationFunction(end, value);\n            }\n            else\n            {\n                // Parses relative end values with start as base (e.g.: +10, -3)\n                if (typeof(end) === 'string')\n                {\n                    end = start + parseFloat(end, 10);\n                }\n\n                // protect against non numeric properties.\n                if (typeof(end) === 'number')\n                {\n                    this._object[property] = start + ( end - start ) * value;\n                }\n            }\n        }\n\n        if (this._onUpdateCallback !== null)\n        {\n            this._onUpdateCallback.call(this._onUpdateCallbackContext, this, value);\n        }\n\n        if (elapsed == 1)\n        {\n            if (this._repeat > 0)\n            {\n                if (isFinite(this._repeat))\n                {\n                    this._repeat--;\n                }\n\n                // reassign starting values, restart by making startTime = now\n                for (property in this._valuesStartRepeat)\n                {\n                    if (typeof(this._valuesEnd[property]) === 'string')\n                    {\n                        this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property], 10);\n                    }\n\n                    if (this._yoyo)\n                    {\n                        var tmp = this._valuesStartRepeat[property];\n                        this._valuesStartRepeat[property] = this._valuesEnd[property];\n                        this._valuesEnd[property] = tmp;\n                        this._reversed = !this._reversed;\n                    }\n\n                    this._valuesStart[property] = this._valuesStartRepeat[property];\n                }\n\n                this._startTime = time + this._delayTime;\n\n                this.onLoop.dispatch(this._object);\n\n                return true;\n            }\n            else\n            {\n                this.isRunning = false;\n                this.onComplete.dispatch(this._object);\n\n                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i ++)\n                {\n                    this._chainedTweens[i].start(time);\n                }\n\n                return false;\n            }\n\n        }\n\n        return true;\n\n    }\n\n};\n\nPhaser.Tween.prototype.constructor = Phaser.Tween;\n\n/* jshint curly: false */\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A collection of easing methods defining ease-in ease-out curves.\n*\n* @class Phaser.Easing\n*/\nPhaser.Easing = {\n\n    /**\n    * Linear easing.\n    *\n    * @class Phaser.Easing.Linear\n    */\n    Linear: {\n\n        /**\n        * Ease-in.\n        *\n        * @method Phaser.Easing.Linear#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} k^2.\n        */\n        None: function ( k ) {\n\n            return k;\n\n        }\n\n    },\n\n    /**\n    * Quadratic easing.\n    *\n    * @class Phaser.Easing.Quadratic\n    */\n    Quadratic: {\n\n        /**\n        * Ease-in.\n        *\n        * @method Phaser.Easing.Quadratic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} k^2.\n        */\n        In: function ( k ) {\n\n            return k * k;\n\n        },\n\n        /**\n        * Ease-out.\n        *\n        * @method Phaser.Easing.Quadratic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} k* (2-k).\n        */\n        Out: function ( k ) {\n\n            return k * ( 2 - k );\n\n        },\n\n        /**\n        * Ease-in/out.\n        *\n        * @method Phaser.Easing.Quadratic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;\n            return - 0.5 * ( --k * ( k - 2 ) - 1 );\n\n        }\n\n    },\n\n    /**\n    * Cubic easing.\n    *\n    * @class Phaser.Easing.Cubic\n    */\n    Cubic: {\n\n        /**\n        * Cubic ease-in.\n        *\n        * @method Phaser.Easing.Cubic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k * k * k;\n\n        },\n\n        /**\n        * Cubic ease-out.\n        *\n        * @method Phaser.Easing.Cubic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return --k * k * k + 1;\n\n        },\n\n        /**\n        * Cubic ease-in/out.\n        *\n        * @method Phaser.Easing.Cubic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;\n            return 0.5 * ( ( k -= 2 ) * k * k + 2 );\n\n        }\n\n    },\n\n    /**\n    * Quartic easing.\n    *\n    * @class Phaser.Easing.Quartic\n    */\n    Quartic: {\n\n        /**\n        * Quartic ease-in.\n        *\n        * @method Phaser.Easing.Quartic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k * k * k * k;\n\n        },\n\n        /**\n        * Quartic ease-out.\n        *\n        * @method Phaser.Easing.Quartic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return 1 - ( --k * k * k * k );\n\n        },\n\n        /**\n        * Quartic ease-in/out.\n        *\n        * @method Phaser.Easing.Quartic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;\n            return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );\n\n        }\n\n    },\n\n    /**\n    * Quintic easing.\n    *\n    * @class Phaser.Easing.Quintic\n    */\n    Quintic: {\n\n        /**\n        * Quintic ease-in.\n        *\n        * @method Phaser.Easing.Quintic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k * k * k * k * k;\n\n        },\n\n        /**\n        * Quintic ease-out.\n        *\n        * @method Phaser.Easing.Quintic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return --k * k * k * k * k + 1;\n\n        },\n\n        /**\n        * Quintic ease-in/out.\n        *\n        * @method Phaser.Easing.Quintic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;\n            return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );\n\n        }\n\n    },\n\n    /**\n    * Sinusoidal easing.\n    *\n    * @class Phaser.Easing.Sinusoidal\n    */\n    Sinusoidal: {\n\n        /**\n        * Sinusoidal ease-in.\n        *\n        * @method Phaser.Easing.Sinusoidal#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return 1 - Math.cos( k * Math.PI / 2 );\n\n        },\n\n        /**\n        * Sinusoidal ease-out.\n        *\n        * @method Phaser.Easing.Sinusoidal#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return Math.sin( k * Math.PI / 2 );\n\n        },\n\n        /**\n        * Sinusoidal ease-in/out.\n        *\n        * @method Phaser.Easing.Sinusoidal#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            return 0.5 * ( 1 - Math.cos( Math.PI * k ) );\n\n        }\n\n    },\n\n    /**\n    * Exponential easing.\n    *\n    * @class Phaser.Easing.Exponential\n    */\n    Exponential: {\n\n        /**\n        * Exponential ease-in.\n        *\n        * @method Phaser.Easing.Exponential#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return k === 0 ? 0 : Math.pow( 1024, k - 1 );\n\n        },\n\n        /**\n        * Exponential ease-out.\n        *\n        * @method Phaser.Easing.Exponential#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );\n\n        },\n\n        /**\n        * Exponential ease-in/out.\n        *\n        * @method Phaser.Easing.Exponential#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );\n            return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );\n\n        }\n\n    },\n\n    /**\n    * Circular easing.\n    *\n    * @class Phaser.Easing.Circular\n    */\n    Circular: {\n\n        /**\n        * Circular ease-in.\n        *\n        * @method Phaser.Easing.Circular#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return 1 - Math.sqrt( 1 - k * k );\n\n        },\n\n        /**\n        * Circular ease-out.\n        *\n        * @method Phaser.Easing.Circular#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            return Math.sqrt( 1 - ( --k * k ) );\n\n        },\n\n        /**\n        * Circular ease-in/out.\n        *\n        * @method Phaser.Easing.Circular#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);\n            return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);\n\n        }\n\n    },\n\n    /**\n    * Elastic easing.\n    *\n    * @class Phaser.Easing.Elastic\n    */\n    Elastic: {\n\n        /**\n        * Elastic ease-in.\n        *\n        * @method Phaser.Easing.Elastic#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            var s, a = 0.1, p = 0.4;\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( !a || a < 1 ) { a = 1; s = p / 4; }\n            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n            return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );\n\n        },\n\n        /**\n        * Elastic ease-out.\n        *\n        * @method Phaser.Easing.Elastic#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            var s, a = 0.1, p = 0.4;\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( !a || a < 1 ) { a = 1; s = p / 4; }\n            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n            return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );\n\n        },\n\n        /**\n        * Elastic ease-in/out.\n        *\n        * @method Phaser.Easing.Elastic#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            var s, a = 0.1, p = 0.4;\n            if ( k === 0 ) return 0;\n            if ( k === 1 ) return 1;\n            if ( !a || a < 1 ) { a = 1; s = p / 4; }\n            else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );\n            if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );\n            return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;\n\n        }\n\n    },\n\n    /**\n    * Back easing.\n    *\n    * @class Phaser.Easing.Back\n    */\n    Back: {\n\n        /**\n        * Back ease-in.\n        *\n        * @method Phaser.Easing.Back#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            var s = 1.70158;\n            return k * k * ( ( s + 1 ) * k - s );\n\n        },\n\n        /**\n        * Back ease-out.\n        *\n        * @method Phaser.Easing.Back#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            var s = 1.70158;\n            return --k * k * ( ( s + 1 ) * k + s ) + 1;\n\n        },\n\n        /**\n        * Back ease-in/out.\n        *\n        * @method Phaser.Easing.Back#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            var s = 1.70158 * 1.525;\n            if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );\n            return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );\n\n        }\n\n    },\n\n    /**\n    * Bounce easing.\n    *\n    * @class Phaser.Easing.Bounce\n    */\n    Bounce: {\n\n        /**\n        * Bounce ease-in.\n        *\n        * @method Phaser.Easing.Bounce#In\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        In: function ( k ) {\n\n            return 1 - Phaser.Easing.Bounce.Out( 1 - k );\n\n        },\n\n        /**\n        * Bounce ease-out.\n        *\n        * @method Phaser.Easing.Bounce#Out\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        Out: function ( k ) {\n\n            if ( k < ( 1 / 2.75 ) ) {\n\n                return 7.5625 * k * k;\n\n            } else if ( k < ( 2 / 2.75 ) ) {\n\n                return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;\n\n            } else if ( k < ( 2.5 / 2.75 ) ) {\n\n                return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;\n\n            } else {\n\n                return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;\n\n            }\n\n        },\n\n        /**\n        * Bounce ease-in/out.\n        *\n        * @method Phaser.Easing.Bounce#InOut\n        * @param {number} k - The value to be tweened.\n        * @returns {number} The tweened value.\n        */\n        InOut: function ( k ) {\n\n            if ( k < 0.5 ) return Phaser.Easing.Bounce.In( k * 2 ) * 0.5;\n            return Phaser.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;\n\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Time constructor.\n*\n* @class Phaser.Time\n* @classdesc This is the core internal game clock. It manages the elapsed time and calculation of elapsed values, used for game object motion and tweens.\n* @constructor\n* @param {Phaser.Game} game A reference to the currently running game.\n*/\nPhaser.Time = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {number} time - Game time counter. If you need a value for in-game calculation please use Phaser.Time.now instead.\n    * @protected\n    */\n    this.time = 0;\n\n    /**\n    * @property {number} now - The time right now.\n    * @protected\n    */\n    this.now = 0;\n\n    /**\n    * @property {number} elapsed - Elapsed time since the last frame (in ms).\n    * @protected\n    */\n    this.elapsed = 0;\n\n    /**\n    * @property {number} pausedTime - Records how long the game has been paused for. Is reset each time the game pauses.\n    * @protected\n    */\n    this.pausedTime = 0;\n\n    /**\n    * @property {boolean} advancedTiming - If true Phaser.Time will perform advanced profiling including the fps rate, fps min/max and msMin and msMax.\n    * @default\n    */\n    this.advancedTiming = false;\n\n    /**\n    * @property {number} fps - Frames per second. Only calculated if Time.advancedTiming is true.\n    * @protected\n    */\n    this.fps = 0;\n\n    /**\n    * @property {number} fpsMin - The lowest rate the fps has dropped to. Only calculated if Time.advancedTiming is true.\n    */\n    this.fpsMin = 1000;\n\n    /**\n    * @property {number} fpsMax - The highest rate the fps has reached (usually no higher than 60fps). Only calculated if Time.advancedTiming is true.\n    */\n    this.fpsMax = 0;\n\n    /**\n    * @property {number} msMin - The minimum amount of time the game has taken between two frames. Only calculated if Time.advancedTiming is true.\n    * @default\n    */\n    this.msMin = 1000;\n\n    /**\n    * @property {number} msMax - The maximum amount of time the game has taken between two frames. Only calculated if Time.advancedTiming is true.\n    */\n    this.msMax = 0;\n\n    /**\n    * @property {number} physicsElapsed - The elapsed time calculated for the physics motion updates. In a stable 60fps system this will be 0.016 every frame.\n    */\n    this.physicsElapsed = 0;\n\n    /**\n    * @property {number} deltaCap - If you need to cap the delta timer, set the value here. For 60fps the delta should be 0.016, so try variances just above this.\n    */\n    this.deltaCap = 0;\n\n    /**\n    * @property {number} timeCap - If the difference in time between two frame updates exceeds this value, the frame time is reset to avoid huge elapsed counts.\n    */\n    this.timeCap = 1000;\n\n    /**\n    * @property {number} frames - The number of frames record in the last second. Only calculated if Time.advancedTiming is true.\n    */\n    this.frames = 0;\n\n    /**\n    * @property {number} pauseDuration - Records how long the game was paused for in miliseconds.\n    */\n    this.pauseDuration = 0;\n\n    /**\n    * @property {number} timeToCall - The value that setTimeout needs to work out when to next update\n    */\n    this.timeToCall = 0;\n\n    /**\n    * @property {number} lastTime - Internal value used by timeToCall as part of the setTimeout loop\n    */\n    this.lastTime = 0;\n\n    /**\n    * @property {Phaser.Timer} events - This is a Phaser.Timer object bound to the master clock to which you can add timed events.\n    */\n    this.events = new Phaser.Timer(this.game, false);\n\n    /**\n    * @property {number} _started - The time at which the Game instance started.\n    * @private\n    */\n    this._started = 0;\n\n    /**\n    * @property {number} _timeLastSecond - The time (in ms) that the last second counter ticked over.\n    * @private\n    */\n    this._timeLastSecond = 0;\n\n    /**\n    * @property {number} _pauseStarted - The time the game started being paused.\n    * @private\n    */\n    this._pauseStarted = 0;\n\n    /**\n    * @property {boolean} _justResumed - Internal value used to recover from the game pause state.\n    * @private\n    */\n    this._justResumed = false;\n\n    /**\n    * @property {array} _timers - Internal store of Phaser.Timer objects.\n    * @private\n    */\n    this._timers = [];\n\n    /**\n    * @property {number} _len - Temp. array length variable.\n    * @private\n    */\n    this._len = 0;\n\n    /**\n    * @property {number} _i - Temp. array counter variable.\n    * @private\n    */\n    this._i = 0;\n\n};\n\nPhaser.Time.prototype = {\n\n    /**\n    * Called automatically by Phaser.Game after boot. Should not be called directly.\n    *\n    * @method Phaser.Time#boot\n    * @protected\n    */\n    boot: function () {\n\n        this._started = Date.now();\n        this.events.start();\n\n    },\n\n    /**\n    * Creates a new stand-alone Phaser.Timer object.\n    *\n    * @method Phaser.Time#create\n    * @param {boolean} [autoDestroy=true] - A Timer that is set to automatically destroy itself will do so after all of its events have been dispatched (assuming no looping events).\n    * @return {Phaser.Timer} The Timer object that was created.\n    */\n    create: function (autoDestroy) {\n\n        if (typeof autoDestroy === 'undefined') { autoDestroy = true; }\n\n        var timer = new Phaser.Timer(this.game, autoDestroy);\n\n        this._timers.push(timer);\n\n        return timer;\n\n    },\n\n    /**\n    * Remove all Timer objects, regardless of their state. Also clears all Timers from the Time.events timer.\n    *\n    * @method Phaser.Time#removeAll\n    */\n    removeAll: function () {\n\n        for (var i = 0; i < this._timers.length; i++)\n        {\n            this._timers[i].destroy();\n        }\n\n        this._timers = [];\n\n        this.events.removeAll();\n\n    },\n\n    /**\n    * Updates the game clock and if enabled the advanced timing data. This is called automatically by Phaser.Game.\n    *\n    * @method Phaser.Time#update\n    * @protected\n    * @param {number} time - The current timestamp.\n    */\n    update: function (time) {\n\n        this.now = time;\n\n        this.timeToCall = this.game.math.max(0, 16 - (time - this.lastTime));\n\n        this.elapsed = this.now - this.time;\n\n        //  spike-dislike\n        if (this.elapsed > this.timeCap)\n        {\n            //  For some reason the time between now and the last time the game was updated was larger than our timeCap\n            //  This can happen if the Stage.disableVisibilityChange is true and you swap tabs, which makes the raf pause.\n            //  In this case we'll drop to some default values to stop the game timers going nuts.\n            this.elapsed = 1 / 60;\n        }\n\n        //  Calculate physics elapsed, ensure it's > 0, use 1/60 as a fallback\n        this.physicsElapsed = this.elapsed / 1000 || 1 / 60;\n\n        if (this.deltaCap > 0 && this.physicsElapsed > this.deltaCap)\n        {\n            this.physicsElapsed = this.deltaCap;\n        }\n\n        if (this.advancedTiming)\n        {\n            this.msMin = this.game.math.min(this.msMin, this.elapsed);\n            this.msMax = this.game.math.max(this.msMax, this.elapsed);\n\n            this.frames++;\n\n            if (this.now > this._timeLastSecond + 1000)\n            {\n                this.fps = Math.round((this.frames * 1000) / (this.now - this._timeLastSecond));\n                this.fpsMin = this.game.math.min(this.fpsMin, this.fps);\n                this.fpsMax = this.game.math.max(this.fpsMax, this.fps);\n                this._timeLastSecond = this.now;\n                this.frames = 0;\n            }\n        }\n\n        this.time = this.now;\n        this.lastTime = time + this.timeToCall;\n\n        //  Paused but still running?\n        if (!this.game.paused)\n        {\n            //  Our internal Phaser.Timer\n            this.events.update(this.now);\n\n            //  Any game level timers\n            this._i = 0;\n            this._len = this._timers.length;\n\n            while (this._i < this._len)\n            {\n                if (this._timers[this._i].update(this.now))\n                {\n                    this._i++;\n                }\n                else\n                {\n                    this._timers.splice(this._i, 1);\n\n                    this._len--;\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Called when the game enters a paused state.\n    *\n    * @method Phaser.Time#gamePaused\n    * @private\n    */\n    gamePaused: function () {\n\n        this._pauseStarted = this.now;\n\n        this.events.pause();\n\n        var i = this._timers.length;\n\n        while (i--)\n        {\n            this._timers[i]._pause();\n        }\n\n    },\n\n    /**\n    * Called when the game resumes from a paused state.\n    *\n    * @method Phaser.Time#gameResumed\n    * @private\n    */\n    gameResumed: function () {\n\n        //  Level out the elapsed timer to avoid spikes\n        this.time = this.now = Date.now();\n\n        this.pauseDuration = this.time - this._pauseStarted;\n\n        this.events.resume();\n\n        var i = this._timers.length;\n\n        while (i--)\n        {\n            this._timers[i]._resume();\n        }\n\n    },\n\n    /**\n    * The number of seconds that have elapsed since the game was started.\n    *\n    * @method Phaser.Time#totalElapsedSeconds\n    * @return {number} The number of seconds that have elapsed since the game was started.\n    */\n    totalElapsedSeconds: function() {\n        return (this.now - this._started) * 0.001;\n    },\n\n    /**\n    * How long has passed since the given time.\n    *\n    * @method Phaser.Time#elapsedSince\n    * @param {number} since - The time you want to measure against.\n    * @return {number} The difference between the given time and now.\n    */\n    elapsedSince: function (since) {\n        return this.now - since;\n    },\n\n    /**\n    * How long has passed since the given time (in seconds).\n    *\n    * @method Phaser.Time#elapsedSecondsSince\n    * @param {number} since - The time you want to measure (in seconds).\n    * @return {number} Duration between given time and now (in seconds).\n    */\n    elapsedSecondsSince: function (since) {\n        return (this.now - since) * 0.001;\n    },\n\n    /**\n    * Resets the private _started value to now and removes all currently running Timers.\n    *\n    * @method Phaser.Time#reset\n    */\n    reset: function () {\n\n        this._started = this.now;\n        this.removeAll();\n\n    }\n\n};\n\nPhaser.Time.prototype.constructor = Phaser.Time;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Timer is a way to create small re-usable or disposable objects that do nothing but wait for a specific moment in time, and then dispatch an event.\n* You can add as many events to a Timer as you like, each with their own delays. A Timer uses milliseconds as its unit of time. There are 1000 ms in 1 second.\n* So if you want to fire an event every quarter of a second you'd need to set the delay to 250.\n*\n* @class Phaser.Timer\n* @classdesc A Timer is a way to create small re-usable or disposable objects that do nothing but wait for a specific moment in time, and then dispatch an event.\n* @constructor\n* @param {Phaser.Game} game A reference to the currently running game.\n* @param {boolean} [autoDestroy=true] - A Timer that is set to automatically destroy itself will do so after all of its events have been dispatched (assuming no looping events).\n*/\nPhaser.Timer = function (game, autoDestroy) {\n\n    if (typeof autoDestroy === 'undefined') { autoDestroy = true; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {boolean} running - True if the Timer is actively running. Do not switch this boolean, if you wish to pause the timer then use Timer.pause() instead.\n    * @default\n    */\n    this.running = false;\n\n    /**\n    * @property {boolean} autoDestroy - A Timer that is set to automatically destroy itself will do so after all of its events have been dispatched (assuming no looping events).\n    */\n    this.autoDestroy = autoDestroy;\n\n    /**\n    * @property {boolean} expired - An expired Timer is one in which all of its events have been dispatched and none are pending.\n    * @readonly\n    * @default\n    */\n    this.expired = false;\n\n    /**\n    * @property {number} elapsed - Elapsed time since the last frame (in ms).\n    * @protected\n    */\n    this.elapsed = 0;\n\n    /**\n    * @property {array<Phaser.TimerEvent>} events - An array holding all of this timers Phaser.TimerEvent objects. Use the methods add, repeat and loop to populate it.\n    */\n    this.events = [];\n\n    /**\n    * @property {Phaser.Signal} onComplete - This signal will be dispatched when this Timer has completed, meaning there are no more events in the queue.\n    */\n    this.onComplete = new Phaser.Signal();\n\n    /**\n    * @property {number} nextTick - The time the next tick will occur.\n    * @readonly\n    * @protected\n    */\n    this.nextTick = 0;\n\n    /**\n    * @property {number} timeCap - If the difference in time between two frame updates exceeds this value, the event times are reset to avoid catch-up situations.\n    */\n    this.timeCap = 1000;\n\n    /**\n    * @property {boolean} paused - The paused state of the Timer. You can pause the timer by calling Timer.pause() and Timer.resume() or by the game pausing.\n    * @readonly\n    * @default\n    */\n    this.paused = false;\n\n    /**\n    * @property {boolean} _codePaused - Was the Timer paused by code or by Game focus loss?\n    * @private\n    */\n    this._codePaused = false;\n\n    /**\n    * @property {number} _started - The time at which this Timer instance started running.\n    * @private\n    * @default\n    */\n    this._started = 0;\n\n    /**\n    * @property {number} _pauseStarted - The time the game started being paused.\n    * @private\n    */\n    this._pauseStarted = 0;\n\n    /**\n    * @property {number} _pauseTotal - Total paused time.\n    * @private\n    */\n    this._pauseTotal = 0;\n\n    /**\n    * @property {number} _now - The current start-time adjusted time.\n    * @private\n    */\n    this._now = Date.now();\n\n    /**\n    * @property {number} _len - Temp. array length variable.\n    * @private\n    */\n    this._len = 0;\n\n    /**\n    * @property {number} _marked - Temp. counter variable.\n    * @private\n    */\n    this._marked = 0;\n\n    /**\n    * @property {number} _i - Temp. array counter variable.\n    * @private\n    */\n    this._i = 0;\n\n    /**\n    * @property {number} _diff - Internal cache var.\n    * @private\n    */\n    this._diff = 0;\n\n    /**\n    * @property {number} _newTick - Internal cache var.\n    * @private\n    */\n    this._newTick = 0;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Timer.MINUTE = 60000;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Timer.SECOND = 1000;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Timer.HALF = 500;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Timer.QUARTER = 250;\n\nPhaser.Timer.prototype = {\n\n    /**\n    * Creates a new TimerEvent on this Timer. Use the methods add, repeat or loop instead of this.\n    * @method Phaser.Timer#create\n    * @private\n    * @param {number} delay - The number of milliseconds that should elapse before the Timer will call the given callback.\n    * @param {boolean} loop - Should the event loop or not?\n    * @param {number} repeatCount - The number of times the event will repeat.\n    * @param {function} callback - The callback that will be called when the Timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {array} arguments - The values to be sent to your callback function when it is called.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    create: function (delay, loop, repeatCount, callback, callbackContext, args) {\n\n        var tick = delay;\n\n        if (this._now === 0)\n        {\n            tick += this.game.time.now;\n        }\n        else\n        {\n            tick += this._now;\n        }\n\n        var event = new Phaser.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args);\n\n        this.events.push(event);\n\n        this.order();\n\n        this.expired = false;\n\n        return event;\n\n    },\n\n    /**\n    * Adds a new Event to this Timer. The event will fire after the given amount of 'delay' in milliseconds has passed, once the Timer has started running.\n    * Call Timer.start() once you have added all of the Events you require for this Timer. The delay is in relation to when the Timer starts, not the time it was added.\n    * If the Timer is already running the delay will be calculated based on the timers current time.\n    *\n    * @method Phaser.Timer#add\n    * @param {number} delay - The number of milliseconds that should elapse before the Timer will call the given callback.\n    * @param {function} callback - The callback that will be called when the Timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {...*} arguments - The values to be sent to your callback function when it is called.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    add: function (delay, callback, callbackContext) {\n\n        return this.create(delay, false, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));\n\n    },\n\n    /**\n    * Adds a new TimerEvent that will always play through once and then repeat for the given number of iterations.\n    * The event will fire after the given amount of 'delay' milliseconds has passed once the Timer has started running.\n    * Call Timer.start() once you have added all of the Events you require for this Timer. The delay is in relation to when the Timer starts, not the time it was added.\n    * If the Timer is already running the delay will be calculated based on the timers current time.\n    *\n    * @method Phaser.Timer#repeat\n    * @param {number} delay - The number of milliseconds that should elapse before the Timer will call the given callback.\n    * @param {number} repeatCount - The number of times the event will repeat once is has finished playback. A repeatCount of 1 means it will repeat itself once, playing the event twice in total.\n    * @param {function} callback - The callback that will be called when the Timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {...*} arguments - The values to be sent to your callback function when it is called.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    repeat: function (delay, repeatCount, callback, callbackContext) {\n\n        return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.splice.call(arguments, 4));\n\n    },\n\n    /**\n    * Adds a new looped Event to this Timer that will repeat forever or until the Timer is stopped.\n    * The event will fire after the given amount of 'delay' milliseconds has passed once the Timer has started running.\n    * Call Timer.start() once you have added all of the Events you require for this Timer. The delay is in relation to when the Timer starts, not the time it was added.\n    * If the Timer is already running the delay will be calculated based on the timers current time.\n    *\n    * @method Phaser.Timer#loop\n    * @param {number} delay - The number of milliseconds that should elapse before the Timer will call the given callback.\n    * @param {function} callback - The callback that will be called when the Timer event occurs.\n    * @param {object} callbackContext - The context in which the callback will be called.\n    * @param {...*} arguments - The values to be sent to your callback function when it is called.\n    * @return {Phaser.TimerEvent} The Phaser.TimerEvent object that was created.\n    */\n    loop: function (delay, callback, callbackContext) {\n\n        return this.create(delay, true, 0, callback, callbackContext, Array.prototype.splice.call(arguments, 3));\n\n    },\n\n    /**\n    * Starts this Timer running.\n    * @method Phaser.Timer#start\n    * @param {number} [delay=0] - The number of milliseconds that should elapse before the Timer will start.\n    */\n    start: function (delay) {\n\n        if (this.running)\n        {\n            return;\n        }\n\n        this._started = this.game.time.now + (delay || 0);\n\n        this.running = true;\n\n        for (var i = 0; i < this.events.length; i++)\n        {\n            this.events[i].tick = this.events[i].delay + this._started;\n        }\n\n    },\n\n    /**\n    * Stops this Timer from running. Does not cause it to be destroyed if autoDestroy is set to true.\n    * @method Phaser.Timer#stop\n    * @param {boolean} [clearEvents=true] - If true all the events in Timer will be cleared, otherwise they will remain.\n    */\n    stop: function (clearEvents) {\n\n        this.running = false;\n\n        if (typeof clearEvents === 'undefined') { clearEvents = true; }\n\n        if (clearEvents)\n        {\n            this.events.length = 0;\n        }\n\n    },\n\n    /**\n    * Removes a pending TimerEvent from the queue.\n    * @param {Phaser.TimerEvent} event - The event to remove from the queue.\n    * @method Phaser.Timer#remove\n    */\n    remove: function (event) {\n\n        for (var i = 0; i < this.events.length; i++)\n        {\n            if (this.events[i] === event)\n            {\n                this.events[i].pendingDelete = true;\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Orders the events on this Timer so they are in tick order. This is called automatically when new events are created.\n    * @method Phaser.Timer#order\n    */\n    order: function () {\n\n        if (this.events.length > 0)\n        {\n            //  Sort the events so the one with the lowest tick is first\n            this.events.sort(this.sortHandler);\n\n            this.nextTick = this.events[0].tick;\n        }\n\n    },\n\n    /**\n    * Sort handler used by Phaser.Timer.order.\n    * @method Phaser.Timer#sortHandler\n    * @protected\n    */\n    sortHandler: function (a, b) {\n\n        if (a.tick < b.tick)\n        {\n            return -1;\n        }\n        else if (a.tick > b.tick)\n        {\n            return 1;\n        }\n\n        return 0;\n\n    },\n\n    /**\n    * Clears any events from the Timer which have pendingDelete set to true and then resets the private _len and _i values.\n    *\n    * @method Phaser.Timer#clearPendingEvents\n    */\n    clearPendingEvents: function () {\n\n        this._i = this.events.length;\n\n        while (this._i--)\n        {\n            if (this.events[this._i].pendingDelete)\n            {\n                this.events.splice(this._i, 1);\n            }\n        }\n\n        this._len = this.events.length;\n        this._i = 0;\n\n    },\n\n    /**\n    * The main Timer update event, called automatically by Phaser.Time.update.\n    *\n    * @method Phaser.Timer#update\n    * @protected\n    * @param {number} time - The time from the core game clock.\n    * @return {boolean} True if there are still events waiting to be dispatched, otherwise false if this Timer can be destroyed.\n    */\n    update: function (time) {\n\n        if (this.paused)\n        {\n            return true;\n        }\n\n        this.elapsed = time - this._now;\n        this._now = time;\n\n        //  spike-dislike\n        if (this.elapsed > this.timeCap)\n        {\n            //  For some reason the time between now and the last time the game was updated was larger than our timeCap.\n            //  This can happen if the Stage.disableVisibilityChange is true and you swap tabs, which makes the raf pause.\n            //  In this case we need to adjust the TimerEvents and nextTick.\n            this.adjustEvents(time - this.elapsed);\n        }\n\n        this._marked = 0;\n\n        //  Clears events marked for deletion and resets _len and _i to 0.\n        this.clearPendingEvents();\n\n        if (this.running && this._now >= this.nextTick && this._len > 0)\n        {\n            while (this._i < this._len && this.running)\n            {\n                if (this._now >= this.events[this._i].tick)\n                {\n                    //  (now + delay) - (time difference from last tick to now)\n                    this._newTick = (this._now + this.events[this._i].delay) - (this._now - this.events[this._i].tick);\n\n                    if (this._newTick < 0)\n                    {\n                        this._newTick = this._now + this.events[this._i].delay;\n                    }\n\n                    if (this.events[this._i].loop === true)\n                    {\n                        this.events[this._i].tick = this._newTick;\n                        this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);\n                    }\n                    else if (this.events[this._i].repeatCount > 0)\n                    {\n                        this.events[this._i].repeatCount--;\n                        this.events[this._i].tick = this._newTick;\n                        this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);\n                    }\n                    else\n                    {\n                        this._marked++;\n                        this.events[this._i].pendingDelete = true;\n                        this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args);\n                    }\n\n                    this._i++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            //  Are there any events left?\n            if (this.events.length > this._marked)\n            {\n                this.order();\n            }\n            else\n            {\n                this.expired = true;\n                this.onComplete.dispatch(this);\n            }\n        }\n\n        if (this.expired && this.autoDestroy)\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n\n    },\n\n    /**\n    * Pauses the Timer and all events in the queue.\n    * @method Phaser.Timer#pause\n    */\n    pause: function () {\n\n        if (this.paused)\n        {\n            return;\n        }\n\n        this._pauseStarted = this.game.time.now;\n\n        this.paused = true;\n        this._codePaused = true;\n\n    },\n\n    /**\n    * This is called by the core Game loop. Do not call it directly, instead use Timer.pause.\n    * @method Phaser.Timer#_pause\n    * @private\n    */\n    _pause: function () {\n\n        if (this.paused)\n        {\n            return;\n        }\n\n        this._pauseStarted = this.game.time.now;\n\n        this.paused = true;\n\n    },\n\n    /**\n    * Adjusts the time of all pending events and the nextTick by the given baseTime.\n    *\n    * @method Phaser.Timer#adjustEvents\n    */\n    adjustEvents: function (baseTime) {\n\n        for (var i = 0; i < this.events.length; i++)\n        {\n            if (!this.events[i].pendingDelete)\n            {\n                //  Work out how long there would have been from when the game paused until the events next tick\n                var t = this.events[i].tick - baseTime;\n\n                if (t < 0)\n                {\n                    t = 0;\n                }\n\n                //  Add the difference on to the time now\n                this.events[i].tick = this._now + t;\n            }\n        }\n\n        var d = this.nextTick - baseTime;\n\n        if (d < 0)\n        {\n            this.nextTick = this._now;\n        }\n        else\n        {\n            this.nextTick = this._now + d;\n        }\n\n    },\n\n    /**\n    * Resumes the Timer and updates all pending events.\n    *\n    * @method Phaser.Timer#resume\n    */\n    resume: function () {\n\n        if (!this.paused)\n        {\n            return;\n        }\n\n        this._pauseTotal += this.game.time.pauseDuration;\n        this._now = this.game.time.now;\n\n        this.adjustEvents(this._pauseStarted);\n\n        this.paused = false;\n        this._codePaused = false;\n\n    },\n\n    /**\n    * This is called by the core Game loop. Do not call it directly, instead use Timer.pause.\n    * @method Phaser.Timer#_resume\n    * @private\n    */\n    _resume: function () {\n\n        if (this._codePaused)\n        {\n            return;\n        }\n        else\n        {\n            this.resume();\n        }\n\n    },\n\n    /**\n    * Removes all Events from this Timer and all callbacks linked to onComplete, but leaves the Timer running.\n    * The onComplete callbacks won't be called.\n    *\n    * @method Phaser.Timer#removeAll\n    */\n    removeAll: function () {\n\n        this.onComplete.removeAll();\n        this.events.length = 0;\n        this._len = 0;\n        this._i = 0;\n\n    },\n\n    /**\n    * Destroys this Timer. Any pending Events are not dispatched.\n    * The onComplete callbacks won't be called.\n    *\n    * @method Phaser.Timer#destroy\n    */\n    destroy: function () {\n\n        this.onComplete.removeAll();\n        this.running = false;\n        this.events = [];\n        this._len = 0;\n        this._i = 0;\n\n    }\n\n};\n\n/**\n* @name Phaser.Timer#next\n* @property {number} next - The time at which the next event will occur.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"next\", {\n\n    get: function () {\n        return this.nextTick;\n    }\n\n});\n\n/**\n* @name Phaser.Timer#duration\n* @property {number} duration - The duration in ms remaining until the next event will occur.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"duration\", {\n\n    get: function () {\n\n        if (this.running && this.nextTick > this._now)\n        {\n            return this.nextTick - this._now;\n        }\n        else\n        {\n            return 0;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Timer#length\n* @property {number} length - The number of pending events in the queue.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"length\", {\n\n    get: function () {\n        return this.events.length;\n    }\n\n});\n\n/**\n* @name Phaser.Timer#ms\n* @property {number} ms - The duration in milliseconds that this Timer has been running for.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"ms\", {\n\n    get: function () {\n        return this._now - this._started - this._pauseTotal;\n    }\n\n});\n\n/**\n* @name Phaser.Timer#seconds\n* @property {number} seconds - The duration in seconds that this Timer has been running for.\n* @readonly\n*/\nObject.defineProperty(Phaser.Timer.prototype, \"seconds\", {\n\n    get: function () {\n        return this.ms * 0.001;\n    }\n\n});\n\nPhaser.Timer.prototype.constructor = Phaser.Timer;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A TimerEvent is a single event that is processed by a Phaser.Timer. It consists of a delay, which is a value in milliseconds after which the event will fire.\n* It can call a specific callback, passing in optional parameters.\n*\n* @class Phaser.TimerEvent\n* @classdesc A TimerEvent is a single event that is processed by a Phaser.Timer. It consists of a delay, which is a value in milliseconds after which the event will fire.\n* @constructor\n* @param {Phaser.Timer} timer - The Timer object that this TimerEvent belongs to.\n* @param {number} delay - The delay in ms at which this TimerEvent fires.\n* @param {number} tick - The tick is the next game clock time that this event will fire at.\n* @param {number} repeatCount - If this TimerEvent repeats it will do so this many times.\n* @param {boolean} loop - True if this TimerEvent loops, otherwise false.\n* @param {function} callback - The callback that will be called when the TimerEvent occurs.\n* @param {object} callbackContext - The context in which the callback will be called.\n* @param {array} arguments - The values to be passed to the callback.\n*/\nPhaser.TimerEvent = function (timer, delay, tick, repeatCount, loop, callback, callbackContext, args) {\n\n    /**\n    * @property {Phaser.Timer} timer - The Timer object that this TimerEvent belongs to.\n    */\n\tthis.timer = timer;\n\n    /**\n    * @property {number} delay - The delay in ms at which this TimerEvent fires.\n    */\n\tthis.delay = delay;\n\n    /**\n    * @property {number} tick - The tick is the next game clock time that this event will fire at.\n    */\n\tthis.tick = tick;\n\n    /**\n    * @property {number} repeatCount - If this TimerEvent repeats it will do so this many times.\n    */\n\tthis.repeatCount = repeatCount - 1;\n\n    /**\n    * @property {boolean} loop - True if this TimerEvent loops, otherwise false.\n    */\n\tthis.loop = loop;\n\n    /**\n    * @property {function} callback - The callback that will be called when the TimerEvent occurs.\n    */\n\tthis.callback = callback;\n\n    /**\n    * @property {object} callbackContext - The context in which the callback will be called.\n    */\n\tthis.callbackContext = callbackContext;\n\n    /**\n    * @property {array} arguments - The values to be passed to the callback.\n    */\n\tthis.args = args;\n\n    /**\n    * @property {boolean} pendingDelete - A flag that controls if the TimerEvent is pending deletion.\n    * @protected\n    */\n    this.pendingDelete = false;\n\n};\n\nPhaser.TimerEvent.prototype.constructor = Phaser.TimerEvent;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Animation Manager is used to add, play and update Phaser Animations.\n* Any Game Object such as Phaser.Sprite that supports animation contains a single AnimationManager instance.\n*\n* @class Phaser.AnimationManager\n* @constructor\n* @param {Phaser.Sprite} sprite - A reference to the Game Object that owns this AnimationManager.\n*/\nPhaser.AnimationManager = function (sprite) {\n\n    /**\n    * @property {Phaser.Sprite} sprite - A reference to the parent Sprite that owns this AnimationManager.\n    */\n    this.sprite = sprite;\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = sprite.game;\n\n    /**\n    * @property {Phaser.Frame} currentFrame - The currently displayed Frame of animation, if any.\n    * @default\n    */\n    this.currentFrame = null;\n\n    /**\n    * @property {Phaser.Animation} currentAnim - The currently displayed animation, if any.\n    * @default\n    */\n    this.currentAnim = null;\n\n    /**\n    * @property {boolean} updateIfVisible - Should the animation data continue to update even if the Sprite.visible is set to false.\n    * @default\n    */\n    this.updateIfVisible = true;\n\n    /**\n    * @property {boolean} isLoaded - Set to true once animation data has been loaded.\n    * @default\n    */\n    this.isLoaded = false;\n\n    /**\n    * @property {Phaser.FrameData} _frameData - A temp. var for holding the currently playing Animations FrameData.\n    * @private\n    * @default\n    */\n    this._frameData = null;\n\n    /**\n    * @property {object} _anims - An internal object that stores all of the Animation instances.\n    * @private\n    */\n    this._anims = {};\n\n    /**\n    * @property {object} _outputFrames - An internal object to help avoid gc.\n    * @private\n    */\n    this._outputFrames = [];\n\n};\n\nPhaser.AnimationManager.prototype = {\n\n    /**\n    * Loads FrameData into the internal temporary vars and resets the frame index to zero.\n    * This is called automatically when a new Sprite is created.\n    *\n    * @method Phaser.AnimationManager#loadFrameData\n    * @private\n    * @param {Phaser.FrameData} frameData - The FrameData set to load.\n    */\n    loadFrameData: function (frameData) {\n\n        this._frameData = frameData;\n        this.frame = 0;\n        this.isLoaded = true;\n\n    },\n\n    /**\n    * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\n    * Animations added in this way are played back with the play function.\n    *\n    * @method Phaser.AnimationManager#add\n    * @param {string} name - The unique (within this Sprite) name for the animation, i.e. \"run\", \"fire\", \"walk\".\n    * @param {Array} [frames=null] - An array of numbers/strings that correspond to the frames to add to this animation and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\n    * @param {number} [frameRate=60] - The speed at which the animation should play. The speed is given in frames per second.\n    * @param {boolean} [loop=false] - Whether or not the animation is looped or just plays once.\n    * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings?\n    * @return {Phaser.Animation} The Animation object that was created.\n    */\n    add: function (name, frames, frameRate, loop, useNumericIndex) {\n\n        if (this._frameData == null)\n        {\n            console.warn('No FrameData available for Phaser.Animation ' + name);\n            return;\n        }\n\n        frames = frames || [];\n        frameRate = frameRate || 60;\n\n        if (typeof loop === 'undefined') { loop = false; }\n\n        //  If they didn't set the useNumericIndex then let's at least try and guess it\n        if (typeof useNumericIndex === 'undefined')\n        {\n            if (frames && typeof frames[0] === 'number')\n            {\n                useNumericIndex = true;\n            }\n            else\n            {\n                useNumericIndex = false;\n            }\n        }\n\n        //  Create the signals the AnimationManager will emit\n        if (this.sprite.events.onAnimationStart == null)\n        {\n            this.sprite.events.onAnimationStart = new Phaser.Signal();\n            this.sprite.events.onAnimationComplete = new Phaser.Signal();\n            this.sprite.events.onAnimationLoop = new Phaser.Signal();\n        }\n\n        this._outputFrames.length = 0;\n\n        this._frameData.getFrameIndexes(frames, useNumericIndex, this._outputFrames);\n\n        this._anims[name] = new Phaser.Animation(this.game, this.sprite, name, this._frameData, this._outputFrames, frameRate, loop);\n        this.currentAnim = this._anims[name];\n        this.currentFrame = this.currentAnim.currentFrame;\n        this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n        if (this.sprite.__tilePattern)\n        {\n            this.__tilePattern = false;\n            this.tilingTexture = false;\n        }\n\n        return this._anims[name];\n\n    },\n\n    /**\n    * Check whether the frames in the given array are valid and exist.\n    *\n    * @method Phaser.AnimationManager#validateFrames\n    * @param {Array} frames - An array of frames to be validated.\n    * @param {boolean} [useNumericIndex=true] - Validate the frames based on their numeric index (true) or string index (false)\n    * @return {boolean} True if all given Frames are valid, otherwise false.\n    */\n    validateFrames: function (frames, useNumericIndex) {\n\n        if (typeof useNumericIndex == 'undefined') { useNumericIndex = true; }\n\n        for (var i = 0; i < frames.length; i++)\n        {\n            if (useNumericIndex === true)\n            {\n                if (frames[i] > this._frameData.total)\n                {\n                    return false;\n                }\n            }\n            else\n            {\n                if (this._frameData.checkFrameName(frames[i]) === false)\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Play an animation based on the given key. The animation should previously have been added via sprite.animations.add()\n    * If the requested animation is already playing this request will be ignored. If you need to reset an already running animation do so directly on the Animation object itself.\n    *\n    * @method Phaser.AnimationManager#play\n    * @param {string} name - The name of the animation to be played, e.g. \"fire\", \"walk\", \"jump\".\n    * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.\n    * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.\n    * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.\n    * @return {Phaser.Animation} A reference to playing Animation instance.\n    */\n    play: function (name, frameRate, loop, killOnComplete) {\n\n        if (this._anims[name])\n        {\n            if (this.currentAnim === this._anims[name])\n            {\n                if (this.currentAnim.isPlaying === false)\n                {\n                    this.currentAnim.paused = false;\n                    return this.currentAnim.play(frameRate, loop, killOnComplete);\n                }\n            }\n            else\n            {\n                if (this.currentAnim && this.currentAnim.isPlaying)\n                {\n                    this.currentAnim.stop();\n                }\n\n                this.currentAnim = this._anims[name];\n                this.currentAnim.paused = false;\n                return this.currentAnim.play(frameRate, loop, killOnComplete);\n            }\n        }\n\n    },\n\n    /**\n    * Stop playback of an animation. If a name is given that specific animation is stopped, otherwise the current animation is stopped.\n    * The currentAnim property of the AnimationManager is automatically set to the animation given.\n    *\n    * @method Phaser.AnimationManager#stop\n    * @param {string} [name=null] - The name of the animation to be stopped, e.g. \"fire\". If none is given the currently running animation is stopped.\n    * @param {boolean} [resetFrame=false] - When the animation is stopped should the currentFrame be set to the first frame of the animation (true) or paused on the last frame displayed (false)\n    */\n    stop: function (name, resetFrame) {\n\n        if (typeof resetFrame == 'undefined') { resetFrame = false; }\n\n        if (typeof name == 'string')\n        {\n            if (this._anims[name])\n            {\n                this.currentAnim = this._anims[name];\n                this.currentAnim.stop(resetFrame);\n            }\n        }\n        else\n        {\n            if (this.currentAnim)\n            {\n                this.currentAnim.stop(resetFrame);\n            }\n        }\n\n    },\n\n    /**\n    * The main update function is called by the Sprites update loop. It's responsible for updating animation frames and firing related events.\n    *\n    * @method Phaser.AnimationManager#update\n    * @protected\n    * @return {boolean} True if a new animation frame has been set, otherwise false.\n    */\n    update: function () {\n\n        if (this.updateIfVisible && !this.sprite.visible)\n        {\n            return false;\n        }\n\n        if (this.currentAnim && this.currentAnim.update() === true)\n        {\n            this.currentFrame = this.currentAnim.currentFrame;\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Returns an animation that was previously added by name.\n    *\n    * @method Phaser.AnimationManager#getAnimation\n    * @param {string} name - The name of the animation to be returned, e.g. \"fire\".\n    * @return {Phaser.Animation} The Animation instance, if found, otherwise null.\n    */\n    getAnimation: function (name) {\n\n        if (typeof name === 'string')\n        {\n            if (this._anims[name])\n            {\n                return this._anims[name];\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Refreshes the current frame data back to the parent Sprite and also resets the texture data.\n    *\n    * @method Phaser.AnimationManager#refreshFrame\n    */\n    refreshFrame: function () {\n\n        this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n        if (this.sprite.__tilePattern)\n        {\n            this.__tilePattern = false;\n            this.tilingTexture = false;\n        }\n\n    },\n\n    /**\n    * Destroys all references this AnimationManager contains.\n    * Iterates through the list of animations stored in this manager and calls destroy on each of them.\n    *\n    * @method Phaser.AnimationManager#destroy\n    */\n    destroy: function () {\n\n        var anim = null;\n\n        for (var anim in this._anims)\n        {\n            if (this._anims.hasOwnProperty(anim))\n            {\n                this._anims[anim].destroy();\n            }\n        }\n\n        this._anims = {};\n        this._frameData = null;\n        this._frameIndex = 0;\n        this.currentAnim = null;\n        this.currentFrame = null;\n\n    }\n\n};\n\nPhaser.AnimationManager.prototype.constructor = Phaser.AnimationManager;\n\n/**\n* @name Phaser.AnimationManager#frameData\n* @property {Phaser.FrameData} frameData - The current animations FrameData.\n* @readonly\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frameData', {\n\n    get: function () {\n        return this._frameData;\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#frameTotal\n* @property {number} frameTotal - The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.\n* @readonly\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frameTotal', {\n\n    get: function () {\n\n        if (this._frameData)\n        {\n            return this._frameData.total;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#paused\n* @property {boolean} paused - Gets and sets the paused state of the current animation.\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'paused', {\n\n    get: function () {\n\n        return this.currentAnim.isPaused;\n\n    },\n\n    set: function (value) {\n\n        this.currentAnim.paused = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#frame\n* @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frame', {\n\n    get: function () {\n\n        if (this.currentFrame)\n        {\n            return this._frameIndex;\n        }\n\n    },\n\n    set: function (value) {\n\n        if (typeof value === 'number' && this._frameData && this._frameData.getFrame(value) !== null)\n        {\n            this.currentFrame = this._frameData.getFrame(value);\n\n            if (this.currentFrame)\n            {\n                this._frameIndex = value;\n                this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n                if (this.sprite.__tilePattern)\n                {\n                    this.__tilePattern = false;\n                    this.tilingTexture = false;\n                }\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.AnimationManager#frameName\n* @property {string} frameName - Gets or sets the current frame name and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.AnimationManager.prototype, 'frameName', {\n\n    get: function () {\n\n        if (this.currentFrame)\n        {\n            return this.currentFrame.name;\n        }\n\n    },\n\n    set: function (value) {\n\n        if (typeof value === 'string' && this._frameData && this._frameData.getFrameByName(value) !== null)\n        {\n            this.currentFrame = this._frameData.getFrameByName(value);\n\n            if (this.currentFrame)\n            {\n                this._frameIndex = this.currentFrame.index;\n                this.sprite.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n                if (this.sprite.__tilePattern)\n                {\n                    this.__tilePattern = false;\n                    this.tilingTexture = false;\n                }\n            }\n        }\n        else\n        {\n            console.warn('Cannot set frameName: ' + value);\n        }\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* An Animation instance contains a single animation and the controls to play it.\n* It is created by the AnimationManager, consists of Animation.Frame objects and belongs to a single Game Object such as a Sprite.\n*\n* @class Phaser.Animation\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {Phaser.Sprite} parent - A reference to the owner of this Animation.\n* @param {string} name - The unique name for this animation, used in playback commands.\n* @param {Phaser.FrameData} frameData - The FrameData object that contains all frames used by this Animation.\n* @param {(Array.<number>|Array.<string>)} frames - An array of numbers or strings indicating which frames to play in which order.\n* @param {number} delay - The time between each frame of the animation, given in ms.\n* @param {boolean} loop - Should this animation loop when it reaches the end or play through once.\n*/\nPhaser.Animation = function (game, parent, name, frameData, frames, delay, loop) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Sprite} _parent - A reference to the parent Sprite that owns this Animation.\n    * @private\n    */\n    this._parent = parent;\n\n    /**\n    * @property {Phaser.FrameData} _frameData - The FrameData the Animation uses.\n    * @private\n    */\n    this._frameData = frameData;\n\n    /**\n    * @property {string} name - The user defined name given to this Animation.\n    */\n    this.name = name;\n\n    /**\n    * @property {array} _frames\n    * @private\n    */\n    this._frames = [];\n    this._frames = this._frames.concat(frames);\n\n    /**\n    * @property {number} delay - The delay in ms between each frame of the Animation.\n    */\n    this.delay = 1000 / delay;\n\n    /**\n    * @property {boolean} loop - The loop state of the Animation.\n    */\n    this.loop = loop;\n\n    /**\n    * @property {number} loopCount - The number of times the animation has looped since it was last started.\n    */\n    this.loopCount = 0;\n\n    /**\n    * @property {boolean} killOnComplete - Should the parent of this Animation be killed when the animation completes?\n    * @default\n    */\n    this.killOnComplete = false;\n\n    /**\n    * @property {boolean} isFinished - The finished state of the Animation. Set to true once playback completes, false during playback.\n    * @default\n    */\n    this.isFinished = false;\n\n    /**\n    * @property {boolean} isPlaying - The playing state of the Animation. Set to false once playback completes, true during playback.\n    * @default\n    */\n    this.isPlaying = false;\n\n    /**\n    * @property {boolean} isPaused - The paused state of the Animation.\n    * @default\n    */\n    this.isPaused = false;\n\n    /**\n    * @property {boolean} _pauseStartTime - The time the animation paused.\n    * @private\n    * @default\n    */\n    this._pauseStartTime = 0;\n\n    /**\n    * @property {number} _frameIndex\n    * @private\n    * @default\n    */\n    this._frameIndex = 0;\n\n    /**\n    * @property {number} _frameDiff\n    * @private\n    * @default\n    */\n    this._frameDiff = 0;\n\n    /**\n    * @property {number} _frameSkip\n    * @private\n    * @default\n    */\n    this._frameSkip = 1;\n\n    /**\n    * @property {Phaser.Frame} currentFrame - The currently displayed frame of the Animation.\n    */\n    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n    /**\n    * @property {Phaser.Signal} onStart - This event is dispatched when this Animation starts playback.\n    */\n    this.onStart = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onComplete - This event is dispatched when this Animation completes playback. If the animation is set to loop this is never fired, listen for onAnimationLoop instead.\n    */\n    this.onComplete = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onLoop - This event is dispatched when this Animation loops.\n    */\n    this.onLoop = new Phaser.Signal();\n\n    //  Set-up some event listeners\n    this.game.onPause.add(this.onPause, this);\n    this.game.onResume.add(this.onResume, this);\n\n};\n\nPhaser.Animation.prototype = {\n\n    /**\n    * Plays this animation.\n    *\n    * @method Phaser.Animation#play\n    * @param {number} [frameRate=null] - The framerate to play the animation at. The speed is given in frames per second. If not provided the previously set frameRate of the Animation is used.\n    * @param {boolean} [loop=false] - Should the animation be looped after playback. If not provided the previously set loop value of the Animation is used.\n    * @param {boolean} [killOnComplete=false] - If set to true when the animation completes (only happens if loop=false) the parent Sprite will be killed.\n    * @return {Phaser.Animation} - A reference to this Animation instance.\n    */\n    play: function (frameRate, loop, killOnComplete) {\n\n        if (typeof frameRate === 'number')\n        {\n            //  If they set a new frame rate then use it, otherwise use the one set on creation\n            this.delay = 1000 / frameRate;\n        }\n\n        if (typeof loop === 'boolean')\n        {\n            //  If they set a new loop value then use it, otherwise use the one set on creation\n            this.loop = loop;\n        }\n\n        if (typeof killOnComplete !== 'undefined')\n        {\n            //  Remove the parent sprite once the animation has finished?\n            this.killOnComplete = killOnComplete;\n        }\n\n        this.isPlaying = true;\n        this.isFinished = false;\n        this.paused = false;\n        this.loopCount = 0;\n\n        this._timeLastFrame = this.game.time.now;\n        this._timeNextFrame = this.game.time.now + this.delay;\n\n        this._frameIndex = 0;\n\n        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n        this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n        //  TODO: Double check if required\n        if (this._parent.__tilePattern)\n        {\n            this._parent.__tilePattern = false;\n            this._parent.tilingTexture = false;\n        }\n\n        this._parent.events.onAnimationStart.dispatch(this._parent, this);\n        this.onStart.dispatch(this._parent, this);\n\n        return this;\n\n    },\n\n    /**\n    * Sets this animation back to the first frame and restarts the animation.\n    *\n    * @method Phaser.Animation#restart\n    */\n    restart: function () {\n\n        this.isPlaying = true;\n        this.isFinished = false;\n        this.paused = false;\n        this.loopCount = 0;\n\n        this._timeLastFrame = this.game.time.now;\n        this._timeNextFrame = this.game.time.now + this.delay;\n\n        this._frameIndex = 0;\n\n        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n        this.onStart.dispatch(this._parent, this);\n\n    },\n\n    /**\n    * Sets this animations playback to a given frame with the given ID.\n    *\n    * @method Phaser.Animation#setFrame\n    * @param {string|number} [frameId] - The identifier of the frame to set. Can be the name of the frame, the sprite index of the frame, or the animation-local frame index.\n    * @param {boolean} [useLocalFrameIndex=false] - If you provide a number for frameId, should it use the numeric indexes of the frameData, or the 0-indexed frame index local to the animation.\n    */\n    setFrame: function(frameId, useLocalFrameIndex) {\n\n        var frameIndex;\n\n        if (typeof useLocalFrameIndex === 'undefined')\n        {\n            useLocalFrameIndex = false;\n        }\n\n        //  Find the index to the desired frame.\n        if (typeof frameId === \"string\")\n        {\n            for (var i = 0; i < this._frames.length; i++)\n            {\n                if (this._frameData.getFrame(this._frames[i]).name === frameId)\n                {\n                    frameIndex = i;\n                }\n            }\n        }\n        else if (typeof frameId === \"number\")\n        {\n            if (useLocalFrameIndex)\n            {\n                frameIndex = frameId;\n            }\n            else\n            {\n                for (var i = 0; i < this._frames.length; i++)\n                {\n                    if (this.frames[i] === frameIndex)\n                    {\n                        frameIndex = i;\n                    }\n                }\n            }\n        }\n\n        if (frameIndex)\n        {\n            //  Set the current frame index to the found index. Subtract 1 so that it animates to the desired frame on update.\n            this._frameIndex = frameIndex - 1;\n\n            //  Make the animation update at next update\n            this._timeNextFrame = this.game.time.now;\n\n            this.update();\n        }\n\n    },\n\n    /**\n    * Stops playback of this animation and set it to a finished state. If a resetFrame is provided it will stop playback and set frame to the first in the animation.\n    * If `dispatchComplete` is true it will dispatch the complete events, otherwise they'll be ignored.\n    *\n    * @method Phaser.Animation#stop\n    * @param {boolean} [resetFrame=false] - If true after the animation stops the currentFrame value will be set to the first frame in this animation.\n    * @param {boolean} [dispatchComplete=false] - Dispatch the Animation.onComplete and parent.onAnimationComplete events?\n    */\n    stop: function (resetFrame, dispatchComplete) {\n\n        if (typeof resetFrame === 'undefined') { resetFrame = false; }\n        if (typeof dispatchComplete === 'undefined') { dispatchComplete = false; }\n\n        this.isPlaying = false;\n        this.isFinished = true;\n        this.paused = false;\n\n        if (resetFrame)\n        {\n            this.currentFrame = this._frameData.getFrame(this._frames[0]);\n        }\n\n        if (dispatchComplete)\n        {\n            this._parent.events.onAnimationComplete.dispatch(this._parent, this);\n            this.onComplete.dispatch(this._parent, this);\n        }\n\n    },\n\n    /**\n    * Called when the Game enters a paused state.\n    *\n    * @method Phaser.Animation#onPause\n    */\n    onPause: function () {\n\n        if (this.isPlaying)\n        {\n            this._frameDiff = this._timeNextFrame - this.game.time.now;\n        }\n\n    },\n\n    /**\n    * Called when the Game resumes from a paused state.\n    *\n    * @method Phaser.Animation#onResume\n    */\n    onResume: function () {\n\n        if (this.isPlaying)\n        {\n            this._timeNextFrame = this.game.time.now + this._frameDiff;\n        }\n\n    },\n\n    /**\n    * Updates this animation. Called automatically by the AnimationManager.\n    *\n    * @method Phaser.Animation#update\n    */\n    update: function () {\n\n        if (this.isPaused)\n        {\n            return false;\n        }\n\n        if (this.isPlaying === true && this.game.time.now >= this._timeNextFrame)\n        {\n            this._frameSkip = 1;\n\n            //  Lagging?\n            this._frameDiff = this.game.time.now - this._timeNextFrame;\n\n            this._timeLastFrame = this.game.time.now;\n\n            if (this._frameDiff > this.delay)\n            {\n                //  We need to skip a frame, work out how many\n                this._frameSkip = Math.floor(this._frameDiff / this.delay);\n\n                this._frameDiff -= (this._frameSkip * this.delay);\n            }\n\n            //  And what's left now?\n            this._timeNextFrame = this.game.time.now + (this.delay - this._frameDiff);\n\n            this._frameIndex += this._frameSkip;\n\n            if (this._frameIndex >= this._frames.length)\n            {\n                if (this.loop)\n                {\n                    this._frameIndex %= this._frames.length;\n                    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n                    if (this.currentFrame)\n                    {\n                        this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n                        if (this._parent.__tilePattern)\n                        {\n                            this._parent.__tilePattern = false;\n                            this._parent.tilingTexture = false;\n                        }\n                    }\n\n                    this.loopCount++;\n                    this._parent.events.onAnimationLoop.dispatch(this._parent, this);\n                    this.onLoop.dispatch(this._parent, this);\n                }\n                else\n                {\n                    this.complete();\n                }\n            }\n            else\n            {\n                this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);\n\n                if (this.currentFrame)\n                {\n                    this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n\n                    if (this._parent.__tilePattern)\n                    {\n                        this._parent.__tilePattern = false;\n                        this._parent.tilingTexture = false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Cleans up this animation ready for deletion. Nulls all values and references.\n    *\n    * @method Phaser.Animation#destroy\n    */\n    destroy: function () {\n        this.game.onPause.remove(this.onPause, this);\n        this.game.onResume.remove(this.onResume, this);\n        \n        this.game = null;\n        this._parent = null;\n        this._frames = null;\n        this._frameData = null;\n        this.currentFrame = null;\n        this.isPlaying = false;\n\n        this.onStart.dispose();\n        this.onLoop.dispose();\n        this.onComplete.dispose();\n\n    },\n\n    /**\n    * Called internally when the animation finishes playback.\n    * Sets the isPlaying and isFinished states and dispatches the onAnimationComplete event if it exists on the parent and local onComplete event.\n    *\n    * @method Phaser.Animation#complete\n    */\n    complete: function () {\n\n        this.isPlaying = false;\n        this.isFinished = true;\n        this.paused = false;\n\n        this._parent.events.onAnimationComplete.dispatch(this._parent, this);\n\n        this.onComplete.dispatch(this._parent, this);\n\n        if (this.killOnComplete)\n        {\n            this._parent.kill();\n        }\n\n    }\n\n};\n\nPhaser.Animation.prototype.constructor = Phaser.Animation;\n\n/**\n* @name Phaser.Animation#paused\n* @property {boolean} paused - Gets and sets the paused state of this Animation.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'paused', {\n\n    get: function () {\n\n        return this.isPaused;\n\n    },\n\n    set: function (value) {\n\n        this.isPaused = value;\n\n        if (value)\n        {\n            //  Paused\n            this._pauseStartTime = this.game.time.now;\n        }\n        else\n        {\n            //  Un-paused\n            if (this.isPlaying)\n            {\n                this._timeNextFrame = this.game.time.now + this.delay;\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Animation#frameTotal\n* @property {number} frameTotal - The total number of frames in the currently loaded FrameData, or -1 if no FrameData is loaded.\n* @readonly\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'frameTotal', {\n\n    get: function () {\n        return this._frames.length;\n    }\n\n});\n\n/**\n* @name Phaser.Animation#frame\n* @property {number} frame - Gets or sets the current frame index and updates the Texture Cache for display.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'frame', {\n\n    get: function () {\n\n        if (this.currentFrame !== null)\n        {\n            return this.currentFrame.index;\n        }\n        else\n        {\n            return this._frameIndex;\n        }\n\n    },\n\n    set: function (value) {\n\n        this.currentFrame = this._frameData.getFrame(this._frames[value]);\n\n        if (this.currentFrame !== null)\n        {\n            this._frameIndex = value;\n            this._parent.setTexture(PIXI.TextureCache[this.currentFrame.uuid]);\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Animation#speed\n* @property {number} speed - Gets or sets the current speed of the animation, the time between each frame of the animation, given in ms. Takes effect from the NEXT frame. Minimum value is 1.\n*/\nObject.defineProperty(Phaser.Animation.prototype, 'speed', {\n\n    get: function () {\n\n        return Math.round(1000 / this.delay);\n\n    },\n\n    set: function (value) {\n\n        if (value >= 1)\n        {\n            this.delay = 1000 / value;\n        }\n\n    }\n\n});\n\n/**\n* Really handy function for when you are creating arrays of animation data but it's using frame names and not numbers.\n* For example imagine you've got 30 frames named: 'explosion_0001-large' to 'explosion_0030-large'\n* You could use this function to generate those by doing: Phaser.Animation.generateFrameNames('explosion_', 1, 30, '-large', 4);\n*\n* @method Phaser.Animation.generateFrameNames\n* @param {string} prefix - The start of the filename. If the filename was 'explosion_0001-large' the prefix would be 'explosion_'.\n* @param {number} start - The number to start sequentially counting from. If your frames are named 'explosion_0001' to 'explosion_0034' the start is 1.\n* @param {number} stop - The number to count to. If your frames are named 'explosion_0001' to 'explosion_0034' the stop value is 34.\n* @param {string} [suffix=''] - The end of the filename. If the filename was 'explosion_0001-large' the prefix would be '-large'.\n* @param {number} [zeroPad=0] - The number of zeroes to pad the min and max values with. If your frames are named 'explosion_0001' to 'explosion_0034' then the zeroPad is 4.\n* @return {array} An array of framenames.\n*/\nPhaser.Animation.generateFrameNames = function (prefix, start, stop, suffix, zeroPad) {\n\n    if (typeof suffix == 'undefined') { suffix = ''; }\n\n    var output = [];\n    var frame = '';\n\n    if (start < stop)\n    {\n        for (var i = start; i <= stop; i++)\n        {\n            if (typeof zeroPad == 'number')\n            {\n                //  str, len, pad, dir\n                frame = Phaser.Utils.pad(i.toString(), zeroPad, '0', 1);\n            }\n            else\n            {\n                frame = i.toString();\n            }\n\n            frame = prefix + frame + suffix;\n\n            output.push(frame);\n        }\n    }\n    else\n    {\n        for (var i = start; i >= stop; i--)\n        {\n            if (typeof zeroPad == 'number')\n            {\n                //  str, len, pad, dir\n                frame = Phaser.Utils.pad(i.toString(), zeroPad, '0', 1);\n            }\n            else\n            {\n                frame = i.toString();\n            }\n\n            frame = prefix + frame + suffix;\n\n            output.push(frame);\n        }\n    }\n\n    return output;\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Frame is a single frame of an animation and is part of a FrameData collection.\n*\n* @class Phaser.Frame\n* @constructor\n* @param {number} index - The index of this Frame within the FrameData set it is being added to.\n* @param {number} x - X position of the frame within the texture image.\n* @param {number} y - Y position of the frame within the texture image.\n* @param {number} width - Width of the frame within the texture image.\n* @param {number} height - Height of the frame within the texture image.\n* @param {string} name - The name of the frame. In Texture Atlas data this is usually set to the filename.\n* @param {string} uuid - Internal UUID key.\n*/\nPhaser.Frame = function (index, x, y, width, height, name, uuid) {\n\n    /**\n    * @property {number} index - The index of this Frame within the FrameData set it is being added to.\n    */\n    this.index = index;\n\n    /**\n    * @property {number} x - X position within the image to cut from.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - Y position within the image to cut from.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} width - Width of the frame.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - Height of the frame.\n    */\n    this.height = height;\n\n    /**\n    * @property {string} name - Useful for Texture Atlas files (is set to the filename value).\n    */\n    this.name = name;\n\n    /**\n    * @property {string} uuid - A link to the PIXI.TextureCache entry.\n    */\n    this.uuid = uuid;\n\n    /**\n    * @property {number} centerX - Center X position within the image to cut from.\n    */\n    this.centerX = Math.floor(width / 2);\n\n    /**\n    * @property {number} centerY - Center Y position within the image to cut from.\n    */\n    this.centerY = Math.floor(height / 2);\n\n    /**\n    * @property {number} distance - The distance from the top left to the bottom-right of this Frame.\n    */\n    this.distance = Phaser.Math.distance(0, 0, width, height);\n\n    /**\n    * @property {boolean} rotated - Rotated? (not yet implemented)\n    * @default\n    */\n    this.rotated = false;\n\n    /**\n    * @property {string} rotationDirection - Either 'cw' or 'ccw', rotation is always 90 degrees.\n    * @default 'cw'\n    */\n    this.rotationDirection = 'cw';\n\n    /**\n    * @property {boolean} trimmed - Was it trimmed when packed?\n    * @default\n    */\n    this.trimmed = false;\n\n    /**\n    * @property {number} sourceSizeW - Width of the original sprite.\n    */\n    this.sourceSizeW = width;\n\n    /**\n    * @property {number} sourceSizeH - Height of the original sprite.\n    */\n    this.sourceSizeH = height;\n\n    /**\n    * @property {number} spriteSourceSizeX - X position of the trimmed sprite inside original sprite.\n    * @default\n    */\n    this.spriteSourceSizeX = 0;\n\n    /**\n    * @property {number} spriteSourceSizeY - Y position of the trimmed sprite inside original sprite.\n    * @default\n    */\n    this.spriteSourceSizeY = 0;\n\n    /**\n    * @property {number} spriteSourceSizeW - Width of the trimmed sprite.\n    * @default\n    */\n    this.spriteSourceSizeW = 0;\n\n    /**\n    * @property {number} spriteSourceSizeH - Height of the trimmed sprite.\n    * @default\n    */\n    this.spriteSourceSizeH = 0;\n\n};\n\nPhaser.Frame.prototype = {\n\n    /**\n    * If the frame was trimmed when added to the Texture Atlas this records the trim and source data.\n    *\n    * @method Phaser.Frame#setTrim\n    * @param {boolean} trimmed - If this frame was trimmed or not.\n    * @param {number} actualWidth - The width of the frame before being trimmed.\n    * @param {number} actualHeight - The height of the frame before being trimmed.\n    * @param {number} destX - The destination X position of the trimmed frame for display.\n    * @param {number} destY - The destination Y position of the trimmed frame for display.\n    * @param {number} destWidth - The destination width of the trimmed frame for display.\n    * @param {number} destHeight - The destination height of the trimmed frame for display.\n    */\n    setTrim: function (trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) {\n\n        this.trimmed = trimmed;\n\n        if (trimmed)\n        {\n            this.width = actualWidth;\n            this.height = actualHeight;\n            this.sourceSizeW = actualWidth;\n            this.sourceSizeH = actualHeight;\n            this.centerX = Math.floor(actualWidth / 2);\n            this.centerY = Math.floor(actualHeight / 2);\n            this.spriteSourceSizeX = destX;\n            this.spriteSourceSizeY = destY;\n            this.spriteSourceSizeW = destWidth;\n            this.spriteSourceSizeH = destHeight;\n        }\n\n    },\n\n    /**\n    * Returns a Rectangle set to the dimensions of this Frame.\n    *\n    * @method Phaser.Frame#getRect\n    * @param {Phaser.Rectangle} [out] - A rectangle to copy the frame dimensions to.\n    * @return {Phaser.Rectangle} A rectangle.\n    */\n    getRect: function (out) {\n\n        if (typeof out === 'undefined')\n        {\n            out = new Phaser.Rectangle(this.x, this.y, this.width, this.height);\n        }\n        else\n        {\n            out.setTo(this.x, this.y, this.width, this.height);\n        }\n\n        return out;\n\n    }\n\n};\n\nPhaser.Frame.prototype.constructor = Phaser.Frame;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* FrameData is a container for Frame objects, which are the internal representation of animation data in Phaser.\n*\n* @class Phaser.FrameData\n* @constructor\n*/\nPhaser.FrameData = function () {\n\n    /**\n    * @property {Array} _frames - Local array of frames.\n    * @private\n    */\n    this._frames = [];\n\n\n    /**\n    * @property {Array} _frameNames - Local array of frame names for name to index conversions.\n    * @private\n    */\n    this._frameNames = [];\n\n};\n\nPhaser.FrameData.prototype = {\n\n    /**\n    * Adds a new Frame to this FrameData collection. Typically called by the Animation.Parser and not directly.\n    *\n    * @method Phaser.FrameData#addFrame\n    * @param {Phaser.Frame} frame - The frame to add to this FrameData set.\n    * @return {Phaser.Frame} The frame that was just added.\n    */\n    addFrame: function (frame) {\n\n        frame.index = this._frames.length;\n\n        this._frames.push(frame);\n\n        if (frame.name !== '')\n        {\n            this._frameNames[frame.name] = frame.index;\n        }\n\n        return frame;\n\n    },\n\n    /**\n    * Get a Frame by its numerical index.\n    *\n    * @method Phaser.FrameData#getFrame\n    * @param {number} index - The index of the frame you want to get.\n    * @return {Phaser.Frame} The frame, if found.\n    */\n    getFrame: function (index) {\n\n        if (index > this._frames.length)\n        {\n            index = 0;\n        }\n\n        return this._frames[index];\n\n    },\n\n    /**\n    * Get a Frame by its frame name.\n    *\n    * @method Phaser.FrameData#getFrameByName\n    * @param {string} name - The name of the frame you want to get.\n    * @return {Phaser.Frame} The frame, if found.\n    */\n    getFrameByName: function (name) {\n\n        if (typeof this._frameNames[name] === 'number')\n        {\n            return this._frames[this._frameNames[name]];\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Check if there is a Frame with the given name.\n    *\n    * @method Phaser.FrameData#checkFrameName\n    * @param {string} name - The name of the frame you want to check.\n    * @return {boolean} True if the frame is found, otherwise false.\n    */\n    checkFrameName: function (name) {\n\n        if (this._frameNames[name] == null)\n        {\n            return false;\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Returns a range of frames based on the given start and end frame indexes and returns them in an Array.\n    *\n    * @method Phaser.FrameData#getFrameRange\n    * @param {number} start - The starting frame index.\n    * @param {number} end - The ending frame index.\n    * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.\n    * @return {Array} An array of Frames between the start and end index values, or an empty array if none were found.\n    */\n    getFrameRange: function (start, end, output) {\n\n        if (typeof output === \"undefined\") { output = []; }\n\n        for (var i = start; i <= end; i++)\n        {\n            output.push(this._frames[i]);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Returns all of the Frames in this FrameData set where the frame index is found in the input array.\n    * The frames are returned in the output array, or if none is provided in a new Array object.\n    *\n    * @method Phaser.FrameData#getFrames\n    * @param {Array} frames - An Array containing the indexes of the frames to retrieve. If the array is empty then all frames in the FrameData are returned.\n    * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings? (false)\n    * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.\n    * @return {Array} An array of all Frames in this FrameData set matching the given names or IDs.\n    */\n    getFrames: function (frames, useNumericIndex, output) {\n\n        if (typeof useNumericIndex === \"undefined\") { useNumericIndex = true; }\n        if (typeof output === \"undefined\") { output = []; }\n\n        if (typeof frames === \"undefined\" || frames.length === 0)\n        {\n            //  No input array, so we loop through all frames\n            for (var i = 0; i < this._frames.length; i++)\n            {\n                //  We only need the indexes\n                output.push(this._frames[i]);\n            }\n        }\n        else\n        {\n            //  Input array given, loop through that instead\n            for (var i = 0, len = frames.length; i < len; i++)\n            {\n                //  Does the input array contain names or indexes?\n                if (useNumericIndex)\n                {\n                    //  The actual frame\n                    output.push(this.getFrame(frames[i]));\n                }\n                else\n                {\n                    //  The actual frame\n                    output.push(this.getFrameByName(frames[i]));\n                }\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Returns all of the Frame indexes in this FrameData set.\n    * The frames indexes are returned in the output array, or if none is provided in a new Array object.\n    *\n    * @method Phaser.FrameData#getFrameIndexes\n    * @param {Array} frames - An Array containing the indexes of the frames to retrieve. If the array is empty then all frames in the FrameData are returned.\n    * @param {boolean} [useNumericIndex=true] - Are the given frames using numeric indexes (default) or strings? (false)\n    * @param {Array} [output] - If given the results will be appended to the end of this array otherwise a new array will be created.\n    * @return {Array} An array of all Frame indexes matching the given names or IDs.\n    */\n    getFrameIndexes: function (frames, useNumericIndex, output) {\n\n        if (typeof useNumericIndex === \"undefined\") { useNumericIndex = true; }\n        if (typeof output === \"undefined\") { output = []; }\n\n        if (typeof frames === \"undefined\" || frames.length === 0)\n        {\n            //  No frames array, so we loop through all frames\n            for (var i = 0, len = this._frames.length; i < len; i++)\n            {\n                output.push(this._frames[i].index);\n            }\n        }\n        else\n        {\n            //  Input array given, loop through that instead\n            for (var i = 0, len = frames.length; i < len; i++)\n            {\n                //  Does the frames array contain names or indexes?\n                if (useNumericIndex)\n                {\n                    output.push(frames[i]);\n                }\n                else\n                {\n                    if (this.getFrameByName(frames[i]))\n                    {\n                        output.push(this.getFrameByName(frames[i]).index);\n                    }\n                }\n            }\n        }\n\n        return output;\n\n    }\n\n};\n\nPhaser.FrameData.prototype.constructor = Phaser.FrameData;\n\n/**\n* @name Phaser.FrameData#total\n* @property {number} total - The total number of frames in this FrameData set.\n* @readonly\n*/\nObject.defineProperty(Phaser.FrameData.prototype, \"total\", {\n\n    get: function () {\n        return this._frames.length;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Responsible for parsing sprite sheet and JSON data into the internal FrameData format that Phaser uses for animations.\n*\n* @class Phaser.AnimationParser\n*/\nPhaser.AnimationParser = {\n\n    /**\n    * Parse a Sprite Sheet and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.spriteSheet\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {string} key - The Game.Cache asset key of the Sprite Sheet image.\n    * @param {number} frameWidth - The fixed width of each frame of the animation.\n    * @param {number} frameHeight - The fixed height of each frame of the animation.\n    * @param {number} [frameMax=-1] - The total number of animation frames to extact from the Sprite Sheet. The default value of -1 means \"extract all frames\".\n    * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\n    * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    spriteSheet: function (game, key, frameWidth, frameHeight, frameMax, margin, spacing) {\n\n        //  How big is our image?\n        var img = game.cache.getImage(key);\n\n        if (img == null)\n        {\n            return null;\n        }\n\n        var width = img.width;\n        var height = img.height;\n\n        if (frameWidth <= 0)\n        {\n            frameWidth = Math.floor(-width / Math.min(-1, frameWidth));\n        }\n\n        if (frameHeight <= 0)\n        {\n            frameHeight = Math.floor(-height / Math.min(-1, frameHeight));\n        }\n\n        var row = Math.floor((width - margin) / (frameWidth + spacing));\n        var column = Math.floor((height - margin) / (frameHeight + spacing));\n        var total = row * column;\n\n        if (frameMax !== -1)\n        {\n            total = frameMax;\n        }\n\n        //  Zero or smaller than frame sizes?\n        if (width === 0 || height === 0 || width < frameWidth || height < frameHeight || total === 0)\n        {\n            console.warn(\"Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight\");\n            return null;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n        var x = margin;\n        var y = margin;\n\n        for (var i = 0; i < total; i++)\n        {\n            var uuid = game.rnd.uuid();\n\n            data.addFrame(new Phaser.Frame(i, x, y, frameWidth, frameHeight, '', uuid));\n\n            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[key], {\n                x: x,\n                y: y,\n                width: frameWidth,\n                height: frameHeight\n            });\n\n            x += frameWidth + spacing;\n\n            if (x + frameWidth > width)\n            {\n                x = margin;\n                y += frameHeight + spacing;\n            }\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Parse the JSON data and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.JSONData\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {Object} json - The JSON data from the Texture Atlas. Must be in Array format.\n    * @param {string} cacheKey - The Game.Cache asset key of the texture image.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    JSONData: function (game, json, cacheKey) {\n\n        //  Malformed?\n        if (!json['frames'])\n        {\n            console.warn(\"Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array\");\n            console.log(json);\n            return;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n\n        //  By this stage frames is a fully parsed array\n        var frames = json['frames'];\n        var newFrame;\n\n        for (var i = 0; i < frames.length; i++)\n        {\n            var uuid = game.rnd.uuid();\n\n            newFrame = data.addFrame(new Phaser.Frame(\n                i,\n                frames[i].frame.x,\n                frames[i].frame.y,\n                frames[i].frame.w,\n                frames[i].frame.h,\n                frames[i].filename,\n                uuid\n            ));\n\n            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {\n                x: frames[i].frame.x,\n                y: frames[i].frame.y,\n                width: frames[i].frame.w,\n                height: frames[i].frame.h\n            });\n\n            if (frames[i].trimmed)\n            {\n                newFrame.setTrim(\n                    frames[i].trimmed,\n                    frames[i].sourceSize.w,\n                    frames[i].sourceSize.h,\n                    frames[i].spriteSourceSize.x,\n                    frames[i].spriteSourceSize.y,\n                    frames[i].spriteSourceSize.w,\n                    frames[i].spriteSourceSize.h\n                );\n\n                PIXI.TextureCache[uuid].trim = new Phaser.Rectangle(frames[i].spriteSourceSize.x, frames[i].spriteSourceSize.y, frames[i].sourceSize.w, frames[i].sourceSize.h);\n            }\n\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Parse the JSON data and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.JSONDataHash\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {Object} json - The JSON data from the Texture Atlas. Must be in JSON Hash format.\n    * @param {string} cacheKey - The Game.Cache asset key of the texture image.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    JSONDataHash: function (game, json, cacheKey) {\n\n        //  Malformed?\n        if (!json['frames'])\n        {\n            console.warn(\"Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object\");\n            console.log(json);\n            return;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n\n        //  By this stage frames is a fully parsed array\n        var frames = json['frames'];\n        var newFrame;\n        var i = 0;\n\n        for (var key in frames)\n        {\n            var uuid = game.rnd.uuid();\n\n            newFrame = data.addFrame(new Phaser.Frame(\n                i,\n                frames[key].frame.x,\n                frames[key].frame.y,\n                frames[key].frame.w,\n                frames[key].frame.h,\n                key,\n                uuid\n            ));\n\n            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {\n                x: frames[key].frame.x,\n                y: frames[key].frame.y,\n                width: frames[key].frame.w,\n                height: frames[key].frame.h\n            });\n\n            if (frames[key].trimmed)\n            {\n                newFrame.setTrim(\n                    frames[key].trimmed,\n                    frames[key].sourceSize.w,\n                    frames[key].sourceSize.h,\n                    frames[key].spriteSourceSize.x,\n                    frames[key].spriteSourceSize.y,\n                    frames[key].spriteSourceSize.w,\n                    frames[key].spriteSourceSize.h\n                );\n\n                PIXI.TextureCache[uuid].trim = new Phaser.Rectangle(frames[key].spriteSourceSize.x, frames[key].spriteSourceSize.y, frames[key].sourceSize.w, frames[key].sourceSize.h);\n            }\n\n            i++;\n        }\n\n        return data;\n\n    },\n\n    /**\n    * Parse the XML data and extract the animation frame data from it.\n    *\n    * @method Phaser.AnimationParser.XMLData\n    * @param {Phaser.Game} game - A reference to the currently running game.\n    * @param {Object} xml - The XML data from the Texture Atlas. Must be in Starling XML format.\n    * @param {string} cacheKey - The Game.Cache asset key of the texture image.\n    * @return {Phaser.FrameData} A FrameData object containing the parsed frames.\n    */\n    XMLData: function (game, xml, cacheKey) {\n\n        //  Malformed?\n        if (!xml.getElementsByTagName('TextureAtlas'))\n        {\n            console.warn(\"Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag\");\n            return;\n        }\n\n        //  Let's create some frames then\n        var data = new Phaser.FrameData();\n        var frames = xml.getElementsByTagName('SubTexture');\n        var newFrame;\n\n        var uuid;\n        var name;\n        var frame;\n        var x;\n        var y;\n        var width;\n        var height;\n        var frameX;\n        var frameY;\n        var frameWidth;\n        var frameHeight;\n\n        for (var i = 0; i < frames.length; i++)\n        {\n            uuid = game.rnd.uuid();\n\n            frame = frames[i].attributes;\n\n            name = frame.name.nodeValue;\n            x = parseInt(frame.x.nodeValue, 10);\n            y = parseInt(frame.y.nodeValue, 10);\n            width = parseInt(frame.width.nodeValue, 10);\n            height = parseInt(frame.height.nodeValue, 10);\n\n            frameX = null;\n            frameY = null;\n\n            if (frame.frameX)\n            {\n                frameX = Math.abs(parseInt(frame.frameX.nodeValue, 10));\n                frameY = Math.abs(parseInt(frame.frameY.nodeValue, 10));\n                frameWidth = parseInt(frame.frameWidth.nodeValue, 10);\n                frameHeight = parseInt(frame.frameHeight.nodeValue, 10);\n            }\n\n            newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name, uuid));\n\n            PIXI.TextureCache[uuid] = new PIXI.Texture(PIXI.BaseTextureCache[cacheKey], {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            });\n\n            //  Trimmed?\n            if (frameX !== null || frameY !== null)\n            {\n                newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight);\n\n                PIXI.TextureCache[uuid].trim = new Phaser.Rectangle(frameX, frameY, width, height);\n            }\n        }\n\n        return data;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Cache constructor.\n*\n* @class Phaser.Cache\n* @classdesc A game only has one instance of a Cache and it is used to store all externally loaded assets such as images, sounds and data files as a result of Loader calls. Cached items use string based keys for look-up.\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Cache = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {object} game - Canvas key-value container.\n    * @private\n    */\n    this._canvases = {};\n\n    /**\n    * @property {object} _images - Image key-value container.\n    * @private\n    */\n    this._images = {};\n\n    /**\n    * @property {object} _textures - RenderTexture key-value container.\n    * @private\n    */\n    this._textures = {};\n\n    /**\n    * @property {object} _sounds - Sound key-value container.\n    * @private\n    */\n    this._sounds = {};\n\n    /**\n    * @property {object} _text - Text key-value container.\n    * @private\n    */\n    this._text = {};\n\n    /**\n    * @property {object} _text - Text key-value container.\n    * @private\n    */\n    this._json = {};\n\n    /**\n    * @property {object} _physics - Physics data key-value container.\n    * @private\n    */\n    this._physics = {};\n\n    /**\n    * @property {object} _tilemaps - Tilemap key-value container.\n    * @private\n    */\n    this._tilemaps = {};\n\n    /**\n    * @property {object} _binary - Binary file key-value container.\n    * @private\n    */\n    this._binary = {};\n\n    /**\n    * @property {object} _bitmapDatas - BitmapData key-value container.\n    * @private\n    */\n    this._bitmapDatas = {};\n\n    /**\n    * @property {object} _bitmapFont - BitmapFont key-value container.\n    * @private\n    */\n    this._bitmapFont = {};\n\n    this.addDefaultImage();\n    this.addMissingImage();\n\n    /**\n    * @property {Phaser.Signal} onSoundUnlock - This event is dispatched when the sound system is unlocked via a touch event on cellular devices.\n    */\n    this.onSoundUnlock = new Phaser.Signal();\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.CANVAS = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.IMAGE = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.TEXTURE = 3;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.SOUND = 4;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.TEXT = 5;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.PHYSICS = 6;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.TILEMAP = 7;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.BINARY = 8;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.BITMAPDATA = 9;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.BITMAPFONT = 10;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Cache.JSON = 11;\n\nPhaser.Cache.prototype = {\n\n    /**\n    * Add a new canvas object in to the cache.\n    *\n    * @method Phaser.Cache#addCanvas\n    * @param {string} key - Asset key for this canvas.\n    * @param {HTMLCanvasElement} canvas - Canvas DOM element.\n    * @param {CanvasRenderingContext2D} context - Render context of this canvas.\n    */\n    addCanvas: function (key, canvas, context) {\n\n        this._canvases[key] = { canvas: canvas, context: context };\n\n    },\n\n    /**\n    * Add a binary object in to the cache.\n    *\n    * @method Phaser.Cache#addBinary\n    * @param {string} key - Asset key for this binary data.\n    * @param {object} binaryData - The binary object to be addded to the cache.\n    */\n    addBinary: function (key, binaryData) {\n\n        this._binary[key] = binaryData;\n\n    },\n\n    /**\n    * Add a BitmapData object in to the cache.\n    *\n    * @method Phaser.Cache#addBitmapData\n    * @param {string} key - Asset key for this BitmapData.\n    * @param {Phaser.BitmapData} bitmapData - The BitmapData object to be addded to the cache.\n    * @return {Phaser.BitmapData} The BitmapData object to be addded to the cache.\n    */\n    addBitmapData: function (key, bitmapData) {\n\n        this._bitmapDatas[key] = bitmapData;\n\n        return bitmapData;\n\n    },\n\n    /**\n    * Add a new Phaser.RenderTexture in to the cache.\n    *\n    * @method Phaser.Cache#addRenderTexture\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {Phaser.Texture} texture - The texture to use as the base of the RenderTexture.\n    */\n    addRenderTexture: function (key, texture) {\n\n        var frame = new Phaser.Frame(0, 0, 0, texture.width, texture.height, '', '');\n\n        this._textures[key] = { texture: texture, frame: frame };\n\n    },\n\n    /**\n    * Add a new sprite sheet in to the cache.\n    *\n    * @method Phaser.Cache#addSpriteSheet\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {string} url - URL of this sprite sheet file.\n    * @param {object} data - Extra sprite sheet data.\n    * @param {number} frameWidth - Width of the sprite sheet.\n    * @param {number} frameHeight - Height of the sprite sheet.\n    * @param {number} [frameMax=-1] - How many frames stored in the sprite sheet. If -1 then it divides the whole sheet evenly.\n    * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\n    * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\n    */\n    addSpriteSheet: function (key, url, data, frameWidth, frameHeight, frameMax, margin, spacing) {\n\n        this._images[key] = { url: url, data: data, spriteSheet: true, frameWidth: frameWidth, frameHeight: frameHeight, margin: margin, spacing: spacing };\n\n        PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);\n        PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);\n\n        this._images[key].frameData = Phaser.AnimationParser.spriteSheet(this.game, key, frameWidth, frameHeight, frameMax, margin, spacing);\n\n    },\n\n    /**\n    * Add a new tilemap to the Cache.\n    *\n    * @method Phaser.Cache#addTilemap\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {string} url - URL of the tilemap image.\n    * @param {object} mapData - The tilemap data object (either a CSV or JSON file).\n    * @param {number} format - The format of the tilemap data.\n    */\n    addTilemap: function (key, url, mapData, format) {\n\n        this._tilemaps[key] = { url: url, data: mapData, format: format };\n\n    },\n\n    /**\n    * Add a new texture atlas to the Cache.\n    *\n    * @method Phaser.Cache#addTextureAtlas\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {string} url - URL of this texture atlas file.\n    * @param {object} data - Extra texture atlas data.\n    * @param {object} atlasData  - Texture atlas frames data.\n    * @param {number} format - The format of the texture atlas.\n    */\n    addTextureAtlas: function (key, url, data, atlasData, format) {\n\n        this._images[key] = { url: url, data: data, spriteSheet: true };\n\n        PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);\n        PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);\n\n        if (format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY)\n        {\n            this._images[key].frameData = Phaser.AnimationParser.JSONData(this.game, atlasData, key);\n        }\n        else if (format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH)\n        {\n            this._images[key].frameData = Phaser.AnimationParser.JSONDataHash(this.game, atlasData, key);\n        }\n        else if (format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING)\n        {\n            this._images[key].frameData = Phaser.AnimationParser.XMLData(this.game, atlasData, key);\n        }\n\n    },\n\n    /**\n    * Add a new Bitmap Font to the Cache.\n    *\n    * @method Phaser.Cache#addBitmapFont\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {string} url - URL of this font xml file.\n    * @param {object} data - Extra font data.\n    * @param {object} xmlData - Texture atlas frames data.\n    * @param {number} [xSpacing=0] - If you'd like to add additional horizontal spacing between the characters then set the pixel value here.\n    * @param {number} [ySpacing=0] - If you'd like to add additional vertical spacing between the lines then set the pixel value here.\n    */\n    addBitmapFont: function (key, url, data, xmlData, xSpacing, ySpacing) {\n\n        this._images[key] = { url: url, data: data, spriteSheet: true };\n\n        PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);\n        PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);\n\n        Phaser.LoaderParser.bitmapFont(this.game, xmlData, key, xSpacing, ySpacing);\n\n    },\n\n    /**\n    * Add a new physics data object to the Cache.\n    *\n    * @method Phaser.Cache#addTilemap\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {string} url - URL of the physics json data.\n    * @param {object} JSONData - The physics data object (a JSON file).\n    * @param {number} format - The format of the physics data.\n    */\n    addPhysicsData: function (key, url, JSONData, format) {\n\n        this._physics[key] = { url: url, data: JSONData, format: format };\n\n    },\n\n    /**\n    * Adds a default image to be used in special cases such as WebGL Filters. Is mapped to the key __default.\n    *\n    * @method Phaser.Cache#addDefaultImage\n    * @protected\n    */\n    addDefaultImage: function () {\n\n        var img = new Image();\n        img.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==\";\n\n        this._images['__default'] = { url: null, data: img, spriteSheet: false };\n        this._images['__default'].frame = new Phaser.Frame(0, 0, 0, 32, 32, '', '');\n\n        PIXI.BaseTextureCache['__default'] = new PIXI.BaseTexture(img);\n        PIXI.TextureCache['__default'] = new PIXI.Texture(PIXI.BaseTextureCache['__default']);\n\n    },\n\n    /**\n    * Adds an image to be used when a key is wrong / missing. Is mapped to the key __missing.\n    *\n    * @method Phaser.Cache#addMissingImage\n    * @protected\n    */\n    addMissingImage: function () {\n\n        var img = new Image();\n        img.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==\";\n\n        this._images['__missing'] = { url: null, data: img, spriteSheet: false };\n        this._images['__missing'].frame = new Phaser.Frame(0, 0, 0, 32, 32, '', '');\n\n        PIXI.BaseTextureCache['__missing'] = new PIXI.BaseTexture(img);\n        PIXI.TextureCache['__missing'] = new PIXI.Texture(PIXI.BaseTextureCache['__missing']);\n\n    },\n\n    /**\n    * Add a new text data.\n    *\n    * @method Phaser.Cache#addText\n    * @param {string} key - Asset key for the text data.\n    * @param {string} url - URL of this text data file.\n    * @param {object} data - Extra text data.\n    */\n    addText: function (key, url, data) {\n\n        this._text[key] = { url: url, data: data };\n\n    },\n\n    /**\n    * Add a new json object into the cache.\n    *\n    * @method Phaser.Cache#addJSON\n    * @param {string} key - Asset key for the text data.\n    * @param {string} url - URL of this text data file.\n    * @param {object} data - Extra text data.\n    */\n    addJSON: function (key, url, data) {\n\n        this._json[key] = { url: url, data: data };\n\n    },\n\n    /**\n    * Add a new image.\n    *\n    * @method Phaser.Cache#addImage\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {string} url - URL of this image file.\n    * @param {object} data - Extra image data.\n    */\n    addImage: function (key, url, data) {\n\n        this._images[key] = { url: url, data: data, spriteSheet: false };\n\n        this._images[key].frame = new Phaser.Frame(0, 0, 0, data.width, data.height, key, this.game.rnd.uuid());\n\n        PIXI.BaseTextureCache[key] = new PIXI.BaseTexture(data);\n        PIXI.TextureCache[key] = new PIXI.Texture(PIXI.BaseTextureCache[key]);\n\n    },\n\n    /**\n    * Add a new sound.\n    *\n    * @method Phaser.Cache#addSound\n    * @param {string} key - Asset key for the sound.\n    * @param {string} url - URL of this sound file.\n    * @param {object} data - Extra sound data.\n    * @param {boolean} webAudio - True if the file is using web audio.\n    * @param {boolean} audioTag - True if the file is using legacy HTML audio.\n    */\n    addSound: function (key, url, data, webAudio, audioTag) {\n\n        webAudio = webAudio || true;\n        audioTag = audioTag || false;\n\n        var decoded = false;\n\n        if (audioTag)\n        {\n            decoded = true;\n        }\n\n        this._sounds[key] = { url: url, data: data, isDecoding: false, decoded: decoded, webAudio: webAudio, audioTag: audioTag, locked: this.game.sound.touchLocked };\n\n    },\n\n    /**\n    * Reload a sound.\n    *\n    * @method Phaser.Cache#reloadSound\n    * @param {string} key - Asset key for the sound.\n    */\n    reloadSound: function (key) {\n\n        var _this = this;\n\n        if (this._sounds[key])\n        {\n            this._sounds[key].data.src = this._sounds[key].url;\n\n            this._sounds[key].data.addEventListener('canplaythrough', function () {\n                return _this.reloadSoundComplete(key);\n            }, false);\n\n            this._sounds[key].data.load();\n        }\n    },\n\n    /**\n    * Fires the onSoundUnlock event when the sound has completed reloading.\n    *\n    * @method Phaser.Cache#reloadSoundComplete\n    * @param {string} key - Asset key for the sound.\n    */\n    reloadSoundComplete: function (key) {\n\n        if (this._sounds[key])\n        {\n            this._sounds[key].locked = false;\n            this.onSoundUnlock.dispatch(key);\n        }\n\n    },\n\n    /**\n    * Updates the sound object in the cache.\n    *\n    * @method Phaser.Cache#updateSound\n    * @param {string} key - Asset key for the sound.\n    */\n    updateSound: function (key, property, value) {\n\n        if (this._sounds[key])\n        {\n            this._sounds[key][property] = value;\n        }\n\n    },\n\n    /**\n    * Add a new decoded sound.\n    *\n    * @method Phaser.Cache#decodedSound\n    * @param {string} key - Asset key for the sound.\n    * @param {object} data - Extra sound data.\n    */\n    decodedSound: function (key, data) {\n\n        this._sounds[key].data = data;\n        this._sounds[key].decoded = true;\n        this._sounds[key].isDecoding = false;\n\n    },\n\n    /**\n    * Get a canvas object from the cache by its key.\n    *\n    * @method Phaser.Cache#getCanvas\n    * @param {string} key - Asset key of the canvas to retrieve from the Cache.\n    * @return {object} The canvas object.\n    */\n    getCanvas: function (key) {\n\n        if (this._canvases[key])\n        {\n            return this._canvases[key].canvas;\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getCanvas: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get a BitmapData object from the cache by its key.\n    *\n    * @method Phaser.Cache#getBitmapData\n    * @param {string} key - Asset key of the BitmapData object to retrieve from the Cache.\n    * @return {Phaser.BitmapData} The requested BitmapData object if found, or null if not.\n    */\n    getBitmapData: function (key) {\n\n        if (this._bitmapDatas[key])\n        {\n            return this._bitmapDatas[key];\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getBitmapData: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get a BitmapFont object from the cache by its key.\n    *\n    * @method Phaser.Cache#getBitmapFont\n    * @param {string} key - Asset key of the BitmapFont object to retrieve from the Cache.\n    * @return {Phaser.BitmapFont} The requested BitmapFont object if found, or null if not.\n    */\n    getBitmapFont: function (key) {\n\n        if (this._bitmapFont[key])\n        {\n            return this._bitmapFont[key];\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getBitmapFont: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get a physics data object from the cache by its key. You can get either the entire data set, a single object or a single fixture of an object from it.\n    *\n    * @method Phaser.Cache#getPhysicsData\n    * @param {string} key - Asset key of the physics data object to retrieve from the Cache.\n    * @param {string} [object=null] - If specified it will return just the physics object that is part of the given key, if null it will return them all.\n    * @param {string} fixtureKey - Fixture key of fixture inside an object. This key can be set per fixture with the Phaser Exporter.\n    * @return {object} The requested physics object data if found.\n    */\n    getPhysicsData: function (key, object, fixtureKey) {\n\n        if (typeof object === 'undefined' || object === null)\n        {\n            //  Get 'em all\n            if (this._physics[key])\n            {\n                return this._physics[key].data;\n            }\n            else\n            {\n                console.warn('Phaser.Cache.getPhysicsData: Invalid key: \"' + key + '\"');\n            }\n        }\n        else\n        {\n            if (this._physics[key] && this._physics[key].data[object])\n            {\n                var fixtures = this._physics[key].data[object];\n\n                //try to find a fixture by it's fixture key if given\n                if (fixtures && fixtureKey)\n                {\n                    for (var fixture in fixtures)\n                    {\n                        //  This contains the fixture data of a polygon or a circle\n                        fixture = fixtures[fixture];\n\n                        //  Test the key\n                        if (fixture.fixtureKey === fixtureKey)\n                        {\n                            return fixture;\n                        }\n\n                    }\n                    \n                    //  We did not find the requested fixture\n                    console.warn('Phaser.Cache.getPhysicsData: Could not find given fixtureKey: \"' + fixtureKey + ' in ' + key + '\"');\n                }\n                else\n                {\n                    return fixtures;\n                }\n            }\n            else\n            {\n                console.warn('Phaser.Cache.getPhysicsData: Invalid key/object: \"' + key + ' / ' + object + '\"');\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Checks if an image key exists.\n    *\n    * @method Phaser.Cache#checkImageKey\n    * @param {string} key - Asset key of the image to check is in the Cache.\n    * @return {boolean} True if the key exists, otherwise false.\n    */\n    checkImageKey: function (key) {\n\n        if (this._images[key])\n        {\n            return true;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Get image data by key.\n    *\n    * @method Phaser.Cache#getImage\n    * @param {string} key - Asset key of the image to retrieve from the Cache.\n    * @return {object} The image data.\n    */\n    getImage: function (key) {\n\n        if (this._images[key])\n        {\n            return this._images[key].data;\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getImage: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get tilemap data by key.\n    *\n    * @method Phaser.Cache#getTilemap\n    * @param {string} key - Asset key of the tilemap data to retrieve from the Cache.\n    * @return {Object} The raw tilemap data in CSV or JSON format.\n    */\n    getTilemapData: function (key) {\n\n        if (this._tilemaps[key])\n        {\n            return this._tilemaps[key];\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getTilemapData: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get frame data by key.\n    *\n    * @method Phaser.Cache#getFrameData\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @return {Phaser.FrameData} The frame data.\n    */\n    getFrameData: function (key) {\n\n        if (this._images[key] && this._images[key].frameData)\n        {\n            return this._images[key].frameData;\n        }\n\n        return null;\n    },\n\n    /**\n    * Replaces a set of frameData with a new Phaser.FrameData object.\n    *\n    * @method Phaser.Cache#updateFrameData\n    * @param {string} key - The unique key by which you will reference this object.\n    * @param {number} frameData - The new FrameData.\n    */\n    updateFrameData: function (key, frameData) {\n\n        if (this._images[key])\n        {\n            this._images[key].spriteSheet = true;\n            this._images[key].frameData = frameData;\n        }\n\n    },\n\n    /**\n    * Get a single frame out of a frameData set by key.\n    *\n    * @method Phaser.Cache#getFrameByIndex\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @return {Phaser.Frame} The frame object.\n    */\n    getFrameByIndex: function (key, frame) {\n\n        if (this._images[key] && this._images[key].frameData)\n        {\n            return this._images[key].frameData.getFrame(frame);\n        }\n\n        return null;\n    },\n\n    /**\n    * Get a single frame out of a frameData set by key.\n    *\n    * @method Phaser.Cache#getFrameByName\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @return {Phaser.Frame} The frame object.\n    */\n    getFrameByName: function (key, frame) {\n\n        if (this._images[key] && this._images[key].frameData)\n        {\n            return this._images[key].frameData.getFrameByName(frame);\n        }\n\n        return null;\n    },\n\n    /**\n    * Get a single frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.\n    *\n    * @method Phaser.Cache#getFrame\n    * @param {string} key - Asset key of the frame data to retrieve from the Cache.\n    * @return {Phaser.Frame} The frame data.\n    */\n    getFrame: function (key) {\n\n        if (this._images[key] && this._images[key].spriteSheet === false)\n        {\n            return this._images[key].frame;\n        }\n\n        return null;\n    },\n\n    /**\n    * Get a single texture frame by key. You'd only do this to get the default Frame created for a non-atlas/spritesheet image.\n    *\n    * @method Phaser.Cache#getTextureFrame\n    * @param {string} key - Asset key of the frame to retrieve from the Cache.\n    * @return {Phaser.Frame} The frame data.\n    */\n    getTextureFrame: function (key) {\n\n        if (this._textures[key])\n        {\n            return this._textures[key].frame;\n        }\n\n        return null;\n    },\n\n    /**\n    * Get a RenderTexture by key.\n    *\n    * @method Phaser.Cache#getTexture\n    * @param {string} key - Asset key of the RenderTexture to retrieve from the Cache.\n    * @return {Phaser.RenderTexture} The RenderTexture object.\n    */\n    getTexture: function (key) {\n\n        if (this._textures[key])\n        {\n            return this._textures[key];\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getTexture: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get sound by key.\n    *\n    * @method Phaser.Cache#getSound\n    * @param {string} key - Asset key of the sound to retrieve from the Cache.\n    * @return {Phaser.Sound} The sound object.\n    */\n    getSound: function (key) {\n\n        if (this._sounds[key])\n        {\n            return this._sounds[key];\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getSound: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get sound data by key.\n    *\n    * @method Phaser.Cache#getSoundData\n    * @param {string} key - Asset key of the sound to retrieve from the Cache.\n    * @return {object} The sound data.\n    */\n    getSoundData: function (key) {\n\n        if (this._sounds[key])\n        {\n            return this._sounds[key].data;\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getSoundData: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Check if the given sound has finished decoding.\n    *\n    * @method Phaser.Cache#isSoundDecoded\n    * @param {string} key - Asset key of the sound in the Cache.\n    * @return {boolean} The decoded state of the Sound object.\n    */\n    isSoundDecoded: function (key) {\n\n        if (this._sounds[key])\n        {\n            return this._sounds[key].decoded;\n        }\n\n    },\n\n    /**\n    * Check if the given sound is ready for playback. A sound is considered ready when it has finished decoding and the device is no longer touch locked.\n    *\n    * @method Phaser.Cache#isSoundReady\n    * @param {string} key - Asset key of the sound in the Cache.\n    * @return {boolean} True if the sound is decoded and the device is not touch locked.\n    */\n    isSoundReady: function (key) {\n\n        return (this._sounds[key] && this._sounds[key].decoded && this.game.sound.touchLocked === false);\n\n    },\n\n    /**\n    * Check whether an image asset is sprite sheet or not.\n    *\n    * @method Phaser.Cache#isSpriteSheet\n    * @param {string} key - Asset key of the sprite sheet you want.\n    * @return {boolean} True if the image is a sprite sheet.\n    */\n    isSpriteSheet: function (key) {\n\n        if (this._images[key])\n        {\n            return this._images[key].spriteSheet;\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Get text data by key.\n    *\n    * @method Phaser.Cache#getText\n    * @param {string} key - Asset key of the text data to retrieve from the Cache.\n    * @return {object} The text data.\n    */\n    getText: function (key) {\n\n        if (this._text[key])\n        {\n            return this._text[key].data;\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getText: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get a JSON object by key from the cache.\n    *\n    * @method Phaser.Cache#getJSON\n    * @param {string} key - Asset key of the json object to retrieve from the Cache.\n    * @return {object} The JSON object.\n    */\n    getJSON: function (key) {\n\n        if (this._json[key])\n        {\n            return this._json[key].data;\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getJSON: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Get binary data by key.\n    *\n    * @method Phaser.Cache#getBinary\n    * @param {string} key - Asset key of the binary data object to retrieve from the Cache.\n    * @return {object} The binary data object.\n    */\n    getBinary: function (key) {\n\n        if (this._binary[key])\n        {\n            return this._binary[key];\n        }\n        else\n        {\n            console.warn('Phaser.Cache.getBinary: Invalid key: \"' + key + '\"');\n        }\n\n    },\n\n    /**\n    * Gets all keys used by the Cache for the given data type.\n    *\n    * @method Phaser.Cache#getKeys\n    * @param {number} [type=Phaser.Cache.IMAGE] - The type of Cache keys you wish to get. Can be Cache.CANVAS, Cache.IMAGE, Cache.SOUND, etc.\n    * @return {Array} The array of item keys.\n    */\n    getKeys: function (type) {\n\n        var array = null;\n\n        switch (type)\n        {\n            case Phaser.Cache.CANVAS:\n                array = this._canvases;\n                break;\n\n            case Phaser.Cache.IMAGE:\n                array = this._images;\n                break;\n\n            case Phaser.Cache.TEXTURE:\n                array = this._textures;\n                break;\n\n            case Phaser.Cache.SOUND:\n                array = this._sounds;\n                break;\n\n            case Phaser.Cache.TEXT:\n                array = this._text;\n                break;\n\n            case Phaser.Cache.PHYSICS:\n                array = this._physics;\n                break;\n\n            case Phaser.Cache.TILEMAP:\n                array = this._tilemaps;\n                break;\n\n            case Phaser.Cache.BINARY:\n                array = this._binary;\n                break;\n\n            case Phaser.Cache.BITMAPDATA:\n                array = this._bitmapDatas;\n                break;\n\n            case Phaser.Cache.BITMAPFONT:\n                array = this._bitmapFont;\n                break;\n\n            case Phaser.Cache.JSON:\n                array = this._json;\n                break;\n        }\n\n        if (!array)\n        {\n            return;\n        }\n\n        var output = [];\n\n        for (var item in array)\n        {\n            if (item !== '__default' && item !== '__missing')\n            {\n                output.push(item);\n            }\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Removes a canvas from the cache.\n    *\n    * @method Phaser.Cache#removeCanvas\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeCanvas: function (key) {\n        delete this._canvases[key];\n    },\n\n    /**\n    * Removes an image from the cache.\n    *\n    * @method Phaser.Cache#removeImage\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeImage: function (key) {\n        delete this._images[key];\n    },\n\n    /**\n    * Removes a sound from the cache.\n    *\n    * @method Phaser.Cache#removeSound\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeSound: function (key) {\n        delete this._sounds[key];\n    },\n\n    /**\n    * Removes a text from the cache.\n    *\n    * @method Phaser.Cache#removeText\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeText: function (key) {\n        delete this._text[key];\n    },\n\n    /**\n    * Removes a json object from the cache.\n    *\n    * @method Phaser.Cache#removeJSON\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeJSON: function (key) {\n        delete this._json[key];\n    },\n\n    /**\n    * Removes a physics data file from the cache.\n    *\n    * @method Phaser.Cache#removePhysics\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removePhysics: function (key) {\n        delete this._physics[key];\n    },\n\n    /**\n    * Removes a tilemap from the cache.\n    *\n    * @method Phaser.Cache#removeTilemap\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeTilemap: function (key) {\n        delete this._tilemaps[key];\n    },\n\n    /**\n    * Removes a binary file from the cache.\n    *\n    * @method Phaser.Cache#removeBinary\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeBinary: function (key) {\n        delete this._binary[key];\n    },\n\n    /**\n    * Removes a bitmap data from the cache.\n    *\n    * @method Phaser.Cache#removeBitmapData\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeBitmapData: function (key) {\n        delete this._bitmapDatas[key];\n    },\n\n    /**\n    * Removes a bitmap font from the cache.\n    *\n    * @method Phaser.Cache#removeBitmapFont\n    * @param {string} key - Key of the asset you want to remove.\n    */\n    removeBitmapFont: function (key) {\n        delete this._bitmapFont[key];\n    },\n\n    /**\n    * Clears the cache. Removes every local cache object reference.\n    *\n    * @method Phaser.Cache#destroy\n    */\n    destroy: function () {\n\n        for (var item in this._canvases)\n        {\n            delete this._canvases[item];\n        }\n\n        for (var item in this._images)\n        {\n            if (item !== '__default' && item !== '__missing')\n            {\n                delete this._images[item];\n            }\n        }\n\n        for (var item in this._sounds)\n        {\n            delete this._sounds[item];\n        }\n\n        for (var item in this._text)\n        {\n            delete this._text[item];\n        }\n\n        for (var item in this._json)\n        {\n            delete this._json[item];\n        }\n\n        for (var item in this._textures)\n        {\n            delete this._textures[item];\n        }\n\n        for (var item in this._physics)\n        {\n            delete this._physics[item];\n        }\n\n        for (var item in this._tilemaps)\n        {\n            delete this._tilemaps[item];\n        }\n\n        for (var item in this._binary)\n        {\n            delete this._binary[item];\n        }\n\n        for (var item in this._bitmapDatas)\n        {\n            delete this._bitmapDatas[item];\n        }\n\n        for (var item in this._bitmapFont)\n        {\n            delete this._bitmapFont[item];\n        }\n\n    }\n\n};\n\nPhaser.Cache.prototype.constructor = Phaser.Cache;\n\n/* jshint wsh:true */\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser loader constructor.\n* The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.\n* It uses a combination of Image() loading and xhr and provides progress and completion callbacks.\n* @class Phaser.Loader\n* @classdesc  The Loader handles loading all external content such as Images, Sounds, Texture Atlases and data files.\n* It uses a combination of Image() loading and xhr and provides progress and completion callbacks.\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Loader = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {array} _fileList - Contains all the assets file infos.\n    * @private\n    */\n    this._fileList = [];\n\n    /**\n    * @property {number} _fileIndex - The index of the current file being loaded.\n    * @private\n    */\n    this._fileIndex = 0;\n\n    /**\n    * @property {number} _progressChunk - Indicates the size of 1 file in terms of a percentage out of 100.\n    * @private\n    * @default\n    */\n    this._progressChunk = 0;\n\n    /**\n    * @property {XMLHttpRequest} - An XMLHttpRequest object used for loading text and audio data.\n    * @private\n    */\n    this._xhr = new XMLHttpRequest();\n\n    /**\n    * @property {XDomainRequest} - An ajax request used specifically by IE9 for CORs loading issues.\n    * @private\n    */\n    this._ajax = null;\n\n    /**\n    * @property {boolean} isLoading - True if the Loader is in the process of loading the queue.\n    * @default\n    */\n    this.isLoading = false;\n\n    /**\n    * @property {boolean} hasLoaded - True if all assets in the queue have finished loading.\n    * @default\n    */\n    this.hasLoaded = false;\n\n    /**\n    * @property {number} progress - The rounded load progress percentage value (from 0 to 100)\n    * @default\n    */\n    this.progress = 0;\n\n    /**\n    * @property {number} progressFloat - The non-rounded load progress value (from 0.0 to 100.0)\n    * @default\n    */\n    this.progressFloat = 0;\n\n    /**\n    * You can optionally link a sprite to the preloader.\n    * If you do so the Sprites width or height will be cropped based on the percentage loaded.\n    * @property {Phaser.Sprite|Phaser.Image} preloadSprite\n    * @default\n    */\n    this.preloadSprite = null;\n\n    /**\n    * @property {boolean|string} crossOrigin - The crossOrigin value applied to loaded images. Very often this needs to be set to 'anonymous'.\n    * @default\n    */\n    this.crossOrigin = false;\n\n    /**\n    * If you want to append a URL before the path of any asset you can set this here.\n    * Useful if you need to allow an asset url to be configured outside of the game code.\n    * MUST have / on the end of it!\n    * @property {string} baseURL\n    * @default\n    */\n    this.baseURL = '';\n\n    /**\n    * @property {Phaser.Signal} onLoadStart - This event is dispatched when the loading process starts, before the first file has been requested.\n    */\n    this.onLoadStart = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onFileStart - This event is dispatched immediately before a file starts loading. It's possible the file may still error (404, etc) after this event is sent.\n    */\n    this.onFileStart = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onFileComplete - This event is dispatched when a file completes loading successfully.\n    */\n    this.onFileComplete = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onFileError - This event is dispatched when a file errors as a result of the load request.\n    */\n    this.onFileError = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onLoadComplete - This event is dispatched when the final file in the load queue has either loaded or failed.\n    */\n    this.onLoadComplete = new Phaser.Signal();\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.TEXTURE_ATLAS_JSON_HASH = 1;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.TEXTURE_ATLAS_XML_STARLING = 2;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.PHYSICS_LIME_CORONA_JSON = 3;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Loader.PHYSICS_PHASER_JSON = 4;\n\nPhaser.Loader.prototype = {\n\n    /**\n    * You can set a Sprite to be a \"preload\" sprite by passing it to this method.\n    * A \"preload\" sprite will have its width or height crop adjusted based on the percentage of the loader in real-time.\n    * This allows you to easily make loading bars for games. Note that Sprite.visible = true will be set when calling this.\n    *\n    * @method Phaser.Loader#setPreloadSprite\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite or image that will be cropped during the load.\n    * @param {number} [direction=0] - A value of zero means the sprite will be cropped horizontally, a value of 1 means its will be cropped vertically.\n    */\n    setPreloadSprite: function (sprite, direction) {\n\n        direction = direction || 0;\n\n        this.preloadSprite = { sprite: sprite, direction: direction, width: sprite.width, height: sprite.height, rect: null };\n\n        if (direction === 0)\n        {\n            //  Horizontal rect\n            this.preloadSprite.rect = new Phaser.Rectangle(0, 0, 1, sprite.height);\n        }\n        else\n        {\n            //  Vertical rect\n            this.preloadSprite.rect = new Phaser.Rectangle(0, 0, sprite.width, 1);\n        }\n\n        sprite.crop(this.preloadSprite.rect);\n\n        sprite.visible = true;\n\n    },\n\n    /**\n    * Check whether asset exists with a specific key.\n    *\n    * @method Phaser.Loader#checkKeyExists\n    * @param {string} type - The type asset you want to check.\n    * @param {string} key - Key of the asset you want to check.\n    * @return {boolean} Return true if exists, otherwise return false.\n    */\n    checkKeyExists: function (type, key) {\n\n        if (this._fileList.length > 0)\n        {\n            for (var i = 0; i < this._fileList.length; i++)\n            {\n                if (this._fileList[i].type === type && this._fileList[i].key === key)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Gets the fileList index for the given key.\n    *\n    * @method Phaser.Loader#getAssetIndex\n    * @param {string} type - The type asset you want to check.\n    * @param {string} key - Key of the asset you want to check.\n    * @return {number} The index of this key in the filelist, or -1 if not found.\n    */\n    getAssetIndex: function (type, key) {\n\n        if (this._fileList.length > 0)\n        {\n            for (var i = 0; i < this._fileList.length; i++)\n            {\n                if (this._fileList[i].type === type && this._fileList[i].key === key)\n                {\n                    return i;\n                }\n            }\n        }\n\n        return -1;\n\n    },\n\n    /**\n    * Gets the asset that is queued for load.\n    *\n    * @method Phaser.Loader#getAsset\n    * @param {string} type - The type asset you want to check.\n    * @param {string} key - Key of the asset you want to check.\n    * @return {any} Returns an object if found that has 2 properties: index and file. Otherwise false.\n    */\n    getAsset: function (type, key) {\n\n        if (this._fileList.length > 0)\n        {\n            for (var i = 0; i < this._fileList.length; i++)\n            {\n                if (this._fileList[i].type === type && this._fileList[i].key === key)\n                {\n                    return { index: i, file: this._fileList[i] };\n                }\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Reset loader, this will remove the load queue.\n    *\n    * @method Phaser.Loader#reset\n    */\n    reset: function () {\n\n        this.preloadSprite = null;\n        this.isLoading = false;\n        this._fileList.length = 0;\n        this._fileIndex = 0;\n\n    },\n\n    /**\n    * Internal function that adds a new entry to the file list. Do not call directly.\n    *\n    * @method Phaser.Loader#addToFileList\n    * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).\n    * @param {string} key - The unique Cache ID key of this resource.\n    * @param {string} url - The URL the asset will be loaded from.\n    * @param {object} properties - Any additional properties needed to load the file.\n    * @protected\n    */\n    addToFileList: function (type, key, url, properties) {\n\n        var entry = {\n            type: type,\n            key: key,\n            url: url,\n            data: null,\n            error: false,\n            loaded: false\n        };\n\n        if (typeof properties !== \"undefined\")\n        {\n            for (var prop in properties)\n            {\n                entry[prop] = properties[prop];\n            }\n        }\n\n        if (this.checkKeyExists(type, key) === false)\n        {\n            this._fileList.push(entry);\n        }\n\n    },\n\n    /**\n    * Internal function that replaces an existing entry in the file list with a new one. Do not call directly.\n    *\n    * @method Phaser.Loader#replaceInFileList\n    * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).\n    * @param {string} key - The unique Cache ID key of this resource.\n    * @param {string} url - The URL the asset will be loaded from.\n    * @param {object} properties - Any additional properties needed to load the file.\n    * @protected\n    */\n    replaceInFileList: function (type, key, url, properties) {\n\n        var entry = {\n            type: type,\n            key: key,\n            url: url,\n            data: null,\n            error: false,\n            loaded: false\n        };\n\n        if (typeof properties !== \"undefined\")\n        {\n            for (var prop in properties)\n            {\n                entry[prop] = properties[prop];\n            }\n        }\n\n        var index = this.getAssetIndex(type, key);\n\n        if (index === -1)\n        {\n            this._fileList.push(entry);\n        }\n        else\n        {\n            this._fileList[index] = entry;\n        }\n\n    },\n\n    /**\n    * Add an image to the Loader.\n    *\n    * @method Phaser.Loader#image\n    * @param {string} key - Unique asset key of this image file.\n    * @param {string} url - URL of image file.\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    image: function (key, url, overwrite) {\n\n        if (typeof overwrite === \"undefined\") { overwrite = false; }\n\n        if (overwrite)\n        {\n            this.replaceInFileList('image', key, url);\n        }\n        else\n        {\n            this.addToFileList('image', key, url);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Add a text file to the Loader.\n    *\n    * @method Phaser.Loader#text\n    * @param {string} key - Unique asset key of the text file.\n    * @param {string} url - URL of the text file.\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    text: function (key, url, overwrite) {\n\n        if (typeof overwrite === \"undefined\") { overwrite = false; }\n\n        if (overwrite)\n        {\n            this.replaceInFileList('text', key, url);\n        }\n        else\n        {\n            this.addToFileList('text', key, url);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Add a json file to the Loader.\n    *\n    * @method Phaser.Loader#json\n    * @param {string} key - Unique asset key of the json file.\n    * @param {string} url - URL of the json file.\n    * @param {boolean} [overwrite=false] - If an unloaded file with a matching key already exists in the queue, this entry will overwrite it.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    json: function (key, url, overwrite) {\n\n        if (typeof overwrite === \"undefined\") { overwrite = false; }\n\n        if (overwrite)\n        {\n            this.replaceInFileList('json', key, url);\n        }\n        else\n        {\n            this.addToFileList('json', key, url);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Add a JavaScript file to the Loader. Once loaded the JavaScript file will be automatically turned into a script tag (and executed), so be careful what you load!\n    * You can also specify a callback. This will be executed as soon as the script tag has been created.\n    *\n    * @method Phaser.Loader#script\n    * @param {string} key - Unique asset key of the script file.\n    * @param {string} url - URL of the JavaScript file.\n    * @param {function} [callback] - Optional callback that will be called after the script tag has loaded, so you can perform additional processing.\n    * @param {function} [callbackContext] - The context under which the callback will be applied. If not specified it will use the callback itself as the context.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    script: function (key, url, callback, callbackContext) {\n\n        if (typeof callback === 'undefined') { callback = false; }\n        if (callback !== false && typeof callbackContext === 'undefined') { callbackContext = callback; }\n\n        this.addToFileList('script', key, url, { callback: callback, callbackContext: callbackContext });\n\n        return this;\n\n    },\n\n    /**\n    * Add a binary file to the Loader. It will be loaded via xhr with a responseType of \"arraybuffer\". You can specify an optional callback to process the file after load.\n    * When the callback is called it will be passed 2 parameters: the key of the file and the file data.\n    * WARNING: If you specify a callback, the file data will be set to whatever your callback returns. So always return the data object, even if you didn't modify it.\n    *\n    * @method Phaser.Loader#binary\n    * @param {string} key - Unique asset key of the binary file.\n    * @param {string} url - URL of the binary file.\n    * @param {function} [callback] - Optional callback that will be passed the file after loading, so you can perform additional processing on it.\n    * @param {function} [callbackContext] - The context under which the callback will be applied. If not specified it will use the callback itself as the context.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    binary: function (key, url, callback, callbackContext) {\n\n        if (typeof callback === 'undefined') { callback = false; }\n        if (callback !== false && typeof callbackContext === 'undefined') { callbackContext = callback; }\n\n        this.addToFileList('binary', key, url, { callback: callback, callbackContext: callbackContext });\n\n        return this;\n\n    },\n\n    /**\n    * Add a new sprite sheet to the loader.\n    *\n    * @method Phaser.Loader#spritesheet\n    * @param {string} key - Unique asset key of the sheet file.\n    * @param {string} url - URL of the sheet file.\n    * @param {number} frameWidth - Width of each single frame.\n    * @param {number} frameHeight - Height of each single frame.\n    * @param {number} [frameMax=-1] - How many frames in this sprite sheet. If not specified it will divide the whole image into frames.\n    * @param {number} [margin=0] - If the frames have been drawn with a margin, specify the amount here.\n    * @param {number} [spacing=0] - If the frames have been drawn with spacing between them, specify the amount here.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    spritesheet: function (key, url, frameWidth, frameHeight, frameMax, margin, spacing) {\n\n        if (typeof frameMax === \"undefined\") { frameMax = -1; }\n        if (typeof margin === \"undefined\") { margin = 0; }\n        if (typeof spacing === \"undefined\") { spacing = 0; }\n\n        this.addToFileList('spritesheet', key, url, { frameWidth: frameWidth, frameHeight: frameHeight, frameMax: frameMax, margin: margin, spacing: spacing });\n\n        return this;\n\n    },\n\n    /**\n    * Add a new audio file to the loader.\n    *\n    * @method Phaser.Loader#audio\n    * @param {string} key - Unique asset key of the audio file.\n    * @param {Array|string} urls - An array containing the URLs of the audio files, i.e.: [ 'jump.mp3', 'jump.ogg', 'jump.m4a' ] or a single string containing just one URL.\n    * @param {boolean} autoDecode - When using Web Audio the audio files can either be decoded at load time or run-time. They can't be played until they are decoded, but this let's you control when that happens. Decoding is a non-blocking async process.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    audio: function (key, urls, autoDecode) {\n\n        if (typeof autoDecode === \"undefined\") { autoDecode = true; }\n\n        this.addToFileList('audio', key, urls, { buffer: null, autoDecode: autoDecode });\n\n        return this;\n\n    },\n\n    /**\n    * Add a new tilemap loading request.\n    *\n    * @method Phaser.Loader#tilemap\n    * @param {string} key - Unique asset key of the tilemap data.\n    * @param {string} [mapDataURL] - The url of the map data file (csv/json)\n    * @param {object} [mapData] - An optional JSON data object. If given then the mapDataURL is ignored and this JSON object is used for map data instead.\n    * @param {number} [format=Phaser.Tilemap.CSV] - The format of the map data. Either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    tilemap: function (key, mapDataURL, mapData, format) {\n\n        if (typeof mapDataURL === \"undefined\") { mapDataURL = null; }\n        if (typeof mapData === \"undefined\") { mapData = null; }\n        if (typeof format === \"undefined\") { format = Phaser.Tilemap.CSV; }\n\n        if (mapDataURL == null && mapData == null)\n        {\n            console.warn('Phaser.Loader.tilemap - Both mapDataURL and mapData are null. One must be set.');\n\n            return this;\n        }\n\n        //  A map data object has been given\n        if (mapData)\n        {\n            switch (format)\n            {\n                //  A csv string or object has been given\n                case Phaser.Tilemap.CSV:\n                    break;\n\n                //  An xml string or object has been given\n                case Phaser.Tilemap.TILED_JSON:\n\n                    if (typeof mapData === 'string')\n                    {\n                        mapData = JSON.parse(mapData);\n                    }\n                    break;\n            }\n\n            this.game.cache.addTilemap(key, null, mapData, format);\n        }\n        else\n        {\n            this.addToFileList('tilemap', key, mapDataURL, { format: format });\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Add a new physics data object loading request.\n    * The data must be in Lime + Corona JSON format. Physics Editor by code'n'web exports in this format natively.\n    *\n    * @method Phaser.Loader#physics\n    * @param {string} key - Unique asset key of the physics json data.\n    * @param {string} [dataURL] - The url of the map data file (csv/json)\n    * @param {object} [jsonData] - An optional JSON data object. If given then the dataURL is ignored and this JSON object is used for physics data instead.\n    * @param {string} [format=Phaser.Physics.LIME_CORONA_JSON] - The format of the physics data.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    physics: function (key, dataURL, jsonData, format) {\n\n        if (typeof dataURL === \"undefined\") { dataURL = null; }\n        if (typeof jsonData === \"undefined\") { jsonData = null; }\n        if (typeof format === \"undefined\") { format = Phaser.Physics.LIME_CORONA_JSON; }\n\n        if (dataURL == null && jsonData == null)\n        {\n            console.warn('Phaser.Loader.physics - Both dataURL and jsonData are null. One must be set.');\n\n            return this;\n        }\n\n        //  A map data object has been given\n        if (jsonData)\n        {\n            if (typeof jsonData === 'string')\n            {\n                jsonData = JSON.parse(jsonData);\n            }\n\n            this.game.cache.addPhysicsData(key, null, jsonData, format);\n        }\n        else\n        {\n            this.addToFileList('physics', key, dataURL, { format: format });\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Add a new bitmap font loading request.\n    *\n    * @method Phaser.Loader#bitmapFont\n    * @param {string} key - Unique asset key of the bitmap font.\n    * @param {string} textureURL - The url of the font image file.\n    * @param {string} [xmlURL] - The url of the font data file (xml/fnt)\n    * @param {object} [xmlData] - An optional XML data object.\n    * @param {number} [xSpacing=0] - If you'd like to add additional horizontal spacing between the characters then set the pixel value here.\n    * @param {number} [ySpacing=0] - If you'd like to add additional vertical spacing between the lines then set the pixel value here.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    bitmapFont: function (key, textureURL, xmlURL, xmlData, xSpacing, ySpacing) {\n\n        if (typeof xmlURL === \"undefined\") { xmlURL = null; }\n        if (typeof xmlData === \"undefined\") { xmlData = null; }\n        if (typeof xSpacing === \"undefined\") { xSpacing = 0; }\n        if (typeof ySpacing === \"undefined\") { ySpacing = 0; }\n\n        //  A URL to a json/xml file has been given\n        if (xmlURL)\n        {\n            this.addToFileList('bitmapfont', key, textureURL, { xmlURL: xmlURL, xSpacing: xSpacing, ySpacing: ySpacing });\n        }\n        else\n        {\n            //  An xml string or object has been given\n            if (typeof xmlData === 'string')\n            {\n                var xml;\n\n                try  {\n                    if (window['DOMParser'])\n                    {\n                        var domparser = new DOMParser();\n                        xml = domparser.parseFromString(xmlData, \"text/xml\");\n                    }\n                    else\n                    {\n                        xml = new ActiveXObject(\"Microsoft.XMLDOM\");\n                        xml.async = 'false';\n                        xml.loadXML(xmlData);\n                    }\n                }\n                catch (e)\n                {\n                    xml = undefined;\n                }\n\n                if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length)\n                {\n                    throw new Error(\"Phaser.Loader. Invalid Bitmap Font XML given\");\n                }\n                else\n                {\n                    this.addToFileList('bitmapfont', key, textureURL, { xmlURL: null, xmlData: xml, xSpacing: xSpacing, ySpacing: ySpacing });\n                }\n            }\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Add a new texture atlas to the loader. This atlas uses the JSON Array data format.\n    *\n    * @method Phaser.Loader#atlasJSONArray\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} textureURL - The url of the texture atlas image file.\n    * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.\n    * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlasJSONArray: function (key, textureURL, atlasURL, atlasData) {\n\n        return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY);\n\n    },\n\n    /**\n    * Add a new texture atlas to the loader. This atlas uses the JSON Hash data format.\n    *\n    * @method Phaser.Loader#atlasJSONHash\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} textureURL - The url of the texture atlas image file.\n    * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.\n    * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlasJSONHash: function (key, textureURL, atlasURL, atlasData) {\n\n        return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_JSON_HASH);\n\n    },\n\n    /**\n    * Add a new texture atlas to the loader. This atlas uses the Starling XML data format.\n    *\n    * @method Phaser.Loader#atlasXML\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} textureURL - The url of the texture atlas image file.\n    * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.\n    * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlasXML: function (key, textureURL, atlasURL, atlasData) {\n\n        return this.atlas(key, textureURL, atlasURL, atlasData, Phaser.Loader.TEXTURE_ATLAS_XML_STARLING);\n\n    },\n\n    /**\n    * Add a new texture atlas to the loader.\n    *\n    * @method Phaser.Loader#atlas\n    * @param {string} key - Unique asset key of the texture atlas file.\n    * @param {string} textureURL - The url of the texture atlas image file.\n    * @param {string} [atlasURL] - The url of the texture atlas data file (json/xml). You don't need this if you are passing an atlasData object instead.\n    * @param {object} [atlasData] - A JSON or XML data object. You don't need this if the data is being loaded from a URL.\n    * @param {number} [format] - A value describing the format of the data, the default is Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY.\n    * @return {Phaser.Loader} This Loader instance.\n    */\n    atlas: function (key, textureURL, atlasURL, atlasData, format) {\n\n        if (typeof atlasURL === \"undefined\") { atlasURL = null; }\n        if (typeof atlasData === \"undefined\") { atlasData = null; }\n        if (typeof format === \"undefined\") { format = Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY; }\n\n        //  A URL to a json/xml file has been given\n        if (atlasURL)\n        {\n            this.addToFileList('textureatlas', key, textureURL, { atlasURL: atlasURL, format: format });\n        }\n        else\n        {\n            switch (format)\n            {\n                //  A json string or object has been given\n                case Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY:\n\n                    if (typeof atlasData === 'string')\n                    {\n                        atlasData = JSON.parse(atlasData);\n                    }\n                    break;\n\n                //  An xml string or object has been given\n                case Phaser.Loader.TEXTURE_ATLAS_XML_STARLING:\n\n                    if (typeof atlasData === 'string')\n                    {\n                        var xml;\n\n                        try  {\n                            if (window['DOMParser'])\n                            {\n                                var domparser = new DOMParser();\n                                xml = domparser.parseFromString(atlasData, \"text/xml\");\n                            }\n                            else\n                            {\n                                xml = new ActiveXObject(\"Microsoft.XMLDOM\");\n                                xml.async = 'false';\n                                xml.loadXML(atlasData);\n                            }\n                        }\n                        catch (e)\n                        {\n                            xml = undefined;\n                        }\n\n                        if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length)\n                        {\n                            throw new Error(\"Phaser.Loader. Invalid Texture Atlas XML given\");\n                        }\n                        else\n                        {\n                            atlasData = xml;\n                        }\n                    }\n                    break;\n            }\n\n            this.addToFileList('textureatlas', key, textureURL, { atlasURL: null, atlasData: atlasData, format: format });\n\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Remove loading request of a file.\n    *\n    * @method Phaser.Loader#removeFile\n    * @param {string} type - The type of resource to add to the list (image, audio, xml, etc).\n    * @param {string} key - Key of the file you want to remove.\n    */\n    removeFile: function (type, key) {\n\n        var file = this.getAsset(type, key);\n\n        if (file !== false)\n        {\n            this._fileList.splice(file.index, 1);\n        }\n\n    },\n\n    /**\n    * Remove all file loading requests.\n    *\n    * @method Phaser.Loader#removeAll\n    */\n    removeAll: function () {\n\n        this._fileList.length = 0;\n\n    },\n\n    /**\n    * Start loading the assets. Normally you don't need to call this yourself as the StateManager will do so.\n    *\n    * @method Phaser.Loader#start\n    */\n    start: function () {\n\n        if (this.isLoading)\n        {\n            return;\n        }\n\n        this.progress = 0;\n        this.progressFloat = 0;\n        this.hasLoaded = false;\n        this.isLoading = true;\n\n        this.onLoadStart.dispatch(this._fileList.length);\n\n        if (this._fileList.length > 0)\n        {\n            this._fileIndex = 0;\n            this._progressChunk = 100 / this._fileList.length;\n            this.loadFile();\n        }\n        else\n        {\n            this.progress = 100;\n            this.progressFloat = 100;\n            this.hasLoaded = true;\n            this.onLoadComplete.dispatch();\n        }\n\n    },\n\n    /**\n    * Load files. Private method ONLY used by loader.\n    *\n    * @method Phaser.Loader#loadFile\n    * @private\n    */\n    loadFile: function () {\n\n        if (!this._fileList[this._fileIndex])\n        {\n            console.warn('Phaser.Loader loadFile invalid index ' + this._fileIndex);\n            return;\n        }\n        \n        var file = this._fileList[this._fileIndex];\n        var _this = this;\n\n        this.onFileStart.dispatch(this.progress, file.key);\n\n        //  Image or Data?\n        switch (file.type)\n        {\n            case 'image':\n            case 'spritesheet':\n            case 'textureatlas':\n            case 'bitmapfont':\n                file.data = new Image();\n                file.data.name = file.key;\n                file.data.onload = function () {\n                    return _this.fileComplete(_this._fileIndex);\n                };\n                file.data.onerror = function () {\n                    return _this.fileError(_this._fileIndex);\n                };\n                if (this.crossOrigin)\n                {\n                    file.data.crossOrigin = this.crossOrigin;\n                }\n                file.data.src = this.baseURL + file.url;\n                break;\n\n            case 'audio':\n                file.url = this.getAudioURL(file.url);\n\n                if (file.url !== null)\n                {\n                    //  WebAudio or Audio Tag?\n                    if (this.game.sound.usingWebAudio)\n                    {\n                        this._xhr.open(\"GET\", this.baseURL + file.url, true);\n                        this._xhr.responseType = \"arraybuffer\";\n                        this._xhr.onload = function () {\n                            return _this.fileComplete(_this._fileIndex);\n                        };\n                        this._xhr.onerror = function () {\n                            return _this.fileError(_this._fileIndex);\n                        };\n                        this._xhr.send();\n                    }\n                    else if (this.game.sound.usingAudioTag)\n                    {\n                        if (this.game.sound.touchLocked)\n                        {\n                            //  If audio is locked we can't do this yet, so need to queue this load request. Bum.\n                            file.data = new Audio();\n                            file.data.name = file.key;\n                            file.data.preload = 'auto';\n                            file.data.src = this.baseURL + file.url;\n                            this.fileComplete(this._fileIndex);\n                        }\n                        else\n                        {\n                            file.data = new Audio();\n                            file.data.name = file.key;\n                            file.data.onerror = function () {\n                                return _this.fileError(_this._fileIndex);\n                            };\n                            file.data.preload = 'auto';\n                            file.data.src = this.baseURL + file.url;\n                            file.data.addEventListener('canplaythrough', Phaser.GAMES[this.game.id].load.fileComplete(this._fileIndex), false);\n                            file.data.load();\n                        }\n                    }\n                }\n                else\n                {\n                    this.fileError(this._fileIndex);\n                }\n\n                break;\n\n            case 'json':\n\n                if (window.XDomainRequest)\n                {\n                    this._ajax = new window.XDomainRequest();\n\n                    // XDomainRequest has a few querks. Occasionally it will abort requests\n                    // A way to avoid this is to make sure ALL callbacks are set even if not used\n                    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n                    this._ajax.timeout = 3000;\n\n                    this._ajax.onerror = function () {\n                        return _this.dataLoadError(_this._fileIndex);\n                    };\n                       \n                    this._ajax.ontimeout = function () {\n                        return _this.dataLoadError(_this._fileIndex);\n                    };\n\n                    this._ajax.onprogress = function() {};\n\n                    this._ajax.onload = function(){\n                        return _this.jsonLoadComplete(_this._fileIndex);\n                    };\n\n                    this._ajax.open('GET', this.baseURL + file.url, true);\n\n                    this._ajax.send();\n                }\n                else\n                {\n                    this._xhr.open(\"GET\", this.baseURL + file.url, true);\n                    this._xhr.responseType = \"text\";\n    \n                    this._xhr.onload = function () {\n                        return _this.jsonLoadComplete(_this._fileIndex);\n                    };\n    \n                    this._xhr.onerror = function () {\n                        return _this.dataLoadError(_this._fileIndex);\n                    };\n    \n                    this._xhr.send();\n                }\n\n                break;\n\n            case 'tilemap':\n                this._xhr.open(\"GET\", this.baseURL + file.url, true);\n                this._xhr.responseType = \"text\";\n\n                if (file.format === Phaser.Tilemap.TILED_JSON)\n                {\n                    this._xhr.onload = function () {\n                        return _this.jsonLoadComplete(_this._fileIndex);\n                    };\n                }\n                else if (file.format === Phaser.Tilemap.CSV)\n                {\n                    this._xhr.onload = function () {\n                        return _this.csvLoadComplete(_this._fileIndex);\n                    };\n                }\n                else\n                {\n                    throw new Error(\"Phaser.Loader. Invalid Tilemap format: \" + file.format);\n                }\n\n                this._xhr.onerror = function () {\n                    return _this.dataLoadError(_this._fileIndex);\n                };\n                this._xhr.send();\n                break;\n\n            case 'text':\n            case 'script':\n            case 'physics':\n                this._xhr.open(\"GET\", this.baseURL + file.url, true);\n                this._xhr.responseType = \"text\";\n                this._xhr.onload = function () {\n                    return _this.fileComplete(_this._fileIndex);\n                };\n                this._xhr.onerror = function () {\n                    return _this.fileError(_this._fileIndex);\n                };\n                this._xhr.send();\n                break;\n\n            case 'binary':\n                this._xhr.open(\"GET\", this.baseURL + file.url, true);\n                this._xhr.responseType = \"arraybuffer\";\n                this._xhr.onload = function () {\n                    return _this.fileComplete(_this._fileIndex);\n                };\n                this._xhr.onerror = function () {\n                    return _this.fileError(_this._fileIndex);\n                };\n                this._xhr.send();\n                break;\n        }\n\n    },\n\n    /**\n    * Private method ONLY used by loader.\n    * @method Phaser.Loader#getAudioURL\n    * @param {array|string} urls - Either an array of audio file URLs or a string containing a single URL path.\n    * @private\n    */\n    getAudioURL: function (urls) {\n\n        var extension;\n\n        if (typeof urls === 'string') { urls = [urls]; }\n\n        for (var i = 0; i < urls.length; i++)\n        {\n            extension = urls[i].toLowerCase();\n            extension = extension.substr((Math.max(0, extension.lastIndexOf(\".\")) || Infinity) + 1);\n\n            if (this.game.device.canPlayAudio(extension))\n            {\n                return urls[i];\n            }\n\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Error occured when loading a file.\n    *\n    * @method Phaser.Loader#fileError\n    * @param {number} index - The index of the file in the file queue that errored.\n    */\n    fileError: function (index) {\n\n        this._fileList[index].loaded = true;\n        this._fileList[index].error = true;\n\n        this.onFileError.dispatch(this._fileList[index].key, this._fileList[index]);\n\n        console.warn(\"Phaser.Loader error loading file: \" + this._fileList[index].key + ' from URL ' + this._fileList[index].url);\n\n        this.nextFile(index, false);\n\n    },\n\n    /**\n    * Called when a file is successfully loaded.\n    *\n    * @method Phaser.Loader#fileComplete\n    * @param {number} index - The index of the file in the file queue that loaded.\n    */\n    fileComplete: function (index) {\n\n        if (!this._fileList[index])\n        {\n            console.warn('Phaser.Loader fileComplete invalid index ' + index);\n            return;\n        }\n\n        var file = this._fileList[index];\n        file.loaded = true;\n\n        var loadNext = true;\n        var _this = this;\n\n        switch (file.type)\n        {\n            case 'image':\n\n                this.game.cache.addImage(file.key, file.url, file.data);\n                break;\n\n            case 'spritesheet':\n\n                this.game.cache.addSpriteSheet(file.key, file.url, file.data, file.frameWidth, file.frameHeight, file.frameMax, file.margin, file.spacing);\n                break;\n\n            case 'textureatlas':\n\n                if (file.atlasURL == null)\n                {\n                    this.game.cache.addTextureAtlas(file.key, file.url, file.data, file.atlasData, file.format);\n                }\n                else\n                {\n                    //  Load the JSON or XML before carrying on with the next file\n                    loadNext = false;\n                    this._xhr.open(\"GET\", this.baseURL + file.atlasURL, true);\n                    this._xhr.responseType = \"text\";\n\n                    if (file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_ARRAY || file.format == Phaser.Loader.TEXTURE_ATLAS_JSON_HASH)\n                    {\n                        this._xhr.onload = function () {\n                            return _this.jsonLoadComplete(index);\n                        };\n                    }\n                    else if (file.format == Phaser.Loader.TEXTURE_ATLAS_XML_STARLING)\n                    {\n                        this._xhr.onload = function () {\n                            return _this.xmlLoadComplete(index);\n                        };\n                    }\n                    else\n                    {\n                        throw new Error(\"Phaser.Loader. Invalid Texture Atlas format: \" + file.format);\n                    }\n\n                    this._xhr.onerror = function () {\n                        return _this.dataLoadError(index);\n                    };\n                    this._xhr.send();\n                }\n                break;\n\n            case 'bitmapfont':\n\n                if (file.xmlURL == null)\n                {\n                    this.game.cache.addBitmapFont(file.key, file.url, file.data, file.xmlData, file.xSpacing, file.ySpacing);\n                }\n                else\n                {\n                    //  Load the XML before carrying on with the next file\n                    loadNext = false;\n                    this._xhr.open(\"GET\", this.baseURL + file.xmlURL, true);\n                    this._xhr.responseType = \"text\";\n\n                    this._xhr.onload = function () {\n                        return _this.xmlLoadComplete(index);\n                    };\n\n                    this._xhr.onerror = function () {\n                        return _this.dataLoadError(index);\n                    };\n                    this._xhr.send();\n                }\n                break;\n\n            case 'audio':\n\n                if (this.game.sound.usingWebAudio)\n                {\n                    file.data = this._xhr.response;\n\n                    this.game.cache.addSound(file.key, file.url, file.data, true, false);\n\n                    if (file.autoDecode)\n                    {\n                        var that = this;\n                        var key = file.key;\n\n                        this.game.cache.updateSound(key, 'isDecoding', true);\n\n                        this.game.sound.context.decodeAudioData(file.data, function (buffer) {\n                            if (buffer)\n                            {\n                                that.game.cache.decodedSound(key, buffer);\n                                that.game.sound.onSoundDecode.dispatch(key, that.game.cache.getSound(key));\n                            }\n                        });\n                    }\n                }\n                else\n                {\n                    file.data.removeEventListener('canplaythrough', Phaser.GAMES[this.game.id].load.fileComplete);\n                    this.game.cache.addSound(file.key, file.url, file.data, false, true);\n                }\n                break;\n\n            case 'text':\n                file.data = this._xhr.responseText;\n                this.game.cache.addText(file.key, file.url, file.data);\n                break;\n\n            case 'physics':\n                var data = JSON.parse(this._xhr.responseText);\n                this.game.cache.addPhysicsData(file.key, file.url, data, file.format);\n                break;\n\n            case 'script':\n                file.data = document.createElement('script');\n                file.data.language = 'javascript';\n                file.data.type = 'text/javascript';\n                file.data.defer = false;\n                file.data.text = this._xhr.responseText;\n                document.head.appendChild(file.data);\n                if (file.callback)\n                {\n                    file.data = file.callback.call(file.callbackContext, file.key, this._xhr.responseText);\n                }\n                break;\n\n            case 'binary':\n                if (file.callback)\n                {\n                    file.data = file.callback.call(file.callbackContext, file.key, this._xhr.response);\n                }\n                else\n                {\n                    file.data = this._xhr.response;\n                }\n\n                this.game.cache.addBinary(file.key, file.data);\n\n                break;\n        }\n\n        if (loadNext)\n        {\n            this.nextFile(index, true);\n        }\n\n    },\n\n    /**\n    * Successfully loaded a JSON file.\n    *\n    * @method Phaser.Loader#jsonLoadComplete\n    * @param {number} index - The index of the file in the file queue that loaded.\n    */\n    jsonLoadComplete: function (index) {\n\n        if (!this._fileList[index])\n        {\n            console.warn('Phaser.Loader jsonLoadComplete invalid index ' + index);\n            return;\n        }\n\n        var file = this._fileList[index];\n        var data = JSON.parse(this._xhr.responseText);\n\n        file.loaded = true;\n\n        if (file.type === 'tilemap')\n        {\n            this.game.cache.addTilemap(file.key, file.url, data, file.format);\n        }\n        else if (file.type === 'json')\n        {\n            this.game.cache.addJSON(file.key, file.url, data);\n        }\n        else\n        {\n            this.game.cache.addTextureAtlas(file.key, file.url, file.data, data, file.format);\n        }\n\n        this.nextFile(index, true);\n\n    },\n\n    /**\n    * Successfully loaded a CSV file.\n    *\n    * @method Phaser.Loader#csvLoadComplete\n    * @param {number} index - The index of the file in the file queue that loaded.\n    */\n    csvLoadComplete: function (index) {\n\n        if (!this._fileList[index])\n        {\n            console.warn('Phaser.Loader csvLoadComplete invalid index ' + index);\n            return;\n        }\n\n        var file = this._fileList[index];\n        var data = this._xhr.responseText;\n\n        file.loaded = true;\n\n        this.game.cache.addTilemap(file.key, file.url, data, file.format);\n\n        this.nextFile(index, true);\n\n    },\n\n    /**\n    * Error occured when load a JSON.\n    *\n    * @method Phaser.Loader#dataLoadError\n    * @param {number} index - The index of the file in the file queue that errored.\n    */\n    dataLoadError: function (index) {\n\n        var file = this._fileList[index];\n\n        file.loaded = true;\n        file.error = true;\n\n        console.warn(\"Phaser.Loader dataLoadError: \" + file.key);\n\n        this.nextFile(index, true);\n\n    },\n\n    /**\n    * Successfully loaded an XML file.\n    *\n    * @method Phaser.Loader#xmlLoadComplete\n    * @param {number} index - The index of the file in the file queue that loaded.\n    */\n    xmlLoadComplete: function (index) {\n\n        var data = this._xhr.responseText;\n        var xml;\n\n        try\n        {\n            if (window['DOMParser'])\n            {\n                var domparser = new DOMParser();\n                xml = domparser.parseFromString(data, \"text/xml\");\n            }\n            else\n            {\n                xml = new ActiveXObject(\"Microsoft.XMLDOM\");\n                xml.async = 'false';\n                xml.loadXML(data);\n            }\n        }\n        catch (e)\n        {\n            xml = undefined;\n        }\n\n        if (!xml || !xml.documentElement || xml.getElementsByTagName(\"parsererror\").length)\n        {\n            throw new Error(\"Phaser.Loader. Invalid XML given\");\n        }\n\n        var file = this._fileList[index];\n        file.loaded = true;\n\n        if (file.type == 'bitmapfont')\n        {\n            this.game.cache.addBitmapFont(file.key, file.url, file.data, xml, file.xSpacing, file.ySpacing);\n        }\n        else if (file.type == 'textureatlas')\n        {\n            this.game.cache.addTextureAtlas(file.key, file.url, file.data, xml, file.format);\n        }\n\n        this.nextFile(index, true);\n\n    },\n\n    /**\n    * Handle loading next file.\n    *\n    * @param {number} previousIndex - Index of the previously loaded asset.\n    * @param {boolean} success - Whether the previous asset loaded successfully or not.\n    * @private\n    */\n    nextFile: function (previousIndex, success) {\n\n        this.progressFloat += this._progressChunk;\n        this.progress = Math.round(this.progressFloat);\n\n        if (this.progress > 100)\n        {\n            this.progress = 100;\n        }\n\n        if (this.preloadSprite !== null)\n        {\n            if (this.preloadSprite.direction === 0)\n            {\n                this.preloadSprite.rect.width = Math.floor((this.preloadSprite.width / 100) * this.progress);\n                this.preloadSprite.sprite.crop(this.preloadSprite.rect);\n            }\n            else\n            {\n                this.preloadSprite.rect.height = Math.floor((this.preloadSprite.height / 100) * this.progress);\n                this.preloadSprite.sprite.crop(this.preloadSprite.rect);\n            }\n        }\n\n        this.onFileComplete.dispatch(this.progress, this._fileList[previousIndex].key, success, this.totalLoadedFiles(), this._fileList.length);\n\n        if (this.totalQueuedFiles() > 0)\n        {\n            this._fileIndex++;\n            this.loadFile();\n        }\n        else\n        {\n            this.hasLoaded = true;\n            this.isLoading = false;\n\n            this.removeAll();\n\n            this.onLoadComplete.dispatch();\n        }\n\n    },\n\n    /**\n    * Returns the number of files that have already been loaded, even if they errored.\n    *\n    * @return {number} The number of files that have already been loaded (even if they errored)\n    */\n    totalLoadedFiles: function () {\n\n        var total = 0;\n\n        for (var i = 0; i < this._fileList.length; i++)\n        {\n            if (this._fileList[i].loaded)\n            {\n                total++;\n            }\n        }\n\n        return total;\n\n    },\n\n    /**\n    * Returns the number of files still waiting to be processed in the load queue. This value decreases as each file is in the queue is loaded.\n    *\n    * @return {number} The number of files that still remain in the load queue.\n    */\n    totalQueuedFiles: function () {\n\n        var total = 0;\n\n        for (var i = 0; i < this._fileList.length; i++)\n        {\n            if (this._fileList[i].loaded === false)\n            {\n                total++;\n            }\n        }\n\n        return total;\n\n    }\n\n};\n\nPhaser.Loader.prototype.constructor = Phaser.Loader;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.LoaderParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into the Cache.\n*\n* @class Phaser.LoaderParser\n*/\nPhaser.LoaderParser = {\n\n    /**\n    * Parse a Bitmap Font from an XML file.\n    * @method Phaser.LoaderParser.bitmapFont\n    * @param {Phaser.Game} game - A reference to the current game.\n    * @param {object} xml - XML data you want to parse.\n    * @param {string} cacheKey - The key of the texture this font uses in the cache.\n    */\n    bitmapFont: function (game, xml, cacheKey, xSpacing, ySpacing) {\n\n        var data = {};\n        var info = xml.getElementsByTagName('info')[0];\n        var common = xml.getElementsByTagName('common')[0];\n\n        data.font = info.getAttribute('face');\n        data.size = parseInt(info.getAttribute('size'), 10);\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) + ySpacing;\n        data.chars = {};\n\n        var letters = xml.getElementsByTagName('char');\n        var texture = PIXI.TextureCache[cacheKey];\n\n        for (var i = 0; i < letters.length; i++)\n        {\n            var charCode = parseInt(letters[i].getAttribute('id'), 10);\n\n            var textureRect = new PIXI.Rectangle(\n                parseInt(letters[i].getAttribute('x'), 10),\n                parseInt(letters[i].getAttribute('y'), 10),\n                parseInt(letters[i].getAttribute('width'), 10),\n                parseInt(letters[i].getAttribute('height'), 10)\n            );\n\n            data.chars[charCode] = {\n                xOffset: parseInt(letters[i].getAttribute('xoffset'), 10),\n                yOffset: parseInt(letters[i].getAttribute('yoffset'), 10),\n                xAdvance: parseInt(letters[i].getAttribute('xadvance'), 10) + xSpacing,\n                kerning: {},\n                texture: PIXI.TextureCache[cacheKey] = new PIXI.Texture(texture, textureRect)\n            };\n        }\n\n        var kernings = xml.getElementsByTagName('kerning');\n\n        for (i = 0; i < kernings.length; i++)\n        {\n            var first = parseInt(kernings[i].getAttribute('first'), 10);\n            var second = parseInt(kernings[i].getAttribute('second'), 10);\n            var amount = parseInt(kernings[i].getAttribute('amount'), 10);\n\n            data.chars[second].kerning[first] = amount;\n        }\n\n        PIXI.BitmapText.fonts[cacheKey] = data;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Sound class constructor.\n*\n* @class Phaser.Sound\n* @classdesc The Sound class\n* @constructor\n* @param {Phaser.Game} game - Reference to the current game instance.\n* @param {string} key - Asset key for the sound.\n* @param {number} [volume=1] - Default value for the volume, between 0 and 1.\n* @param {boolean} [loop=false] - Whether or not the sound will loop.\n*/\nPhaser.Sound = function (game, key, volume, loop, connect) {\n\n    if (typeof volume == 'undefined') { volume = 1; }\n    if (typeof loop == 'undefined') { loop = false; }\n    if (typeof connect === 'undefined') { connect = game.sound.connectToMaster; }\n\n    /**\n    * A reference to the currently running Game.\n    * @property {Phaser.Game} game\n    */\n    this.game = game;\n\n    /**\n    * @property {string} name - Name of the sound.\n    */\n    this.name = key;\n\n    /**\n    * @property {string} key - Asset key for the sound.\n    */\n    this.key = key;\n\n    /**\n    * @property {boolean} loop - Whether or not the sound or current sound marker will loop.\n    */\n    this.loop = loop;\n\n    /**\n    * @property {number} volume - The sound or sound marker volume. A value between 0 (silence) and 1 (full volume).\n    */\n    this.volume = volume;\n\n    /**\n    * @property {object} markers - The sound markers.\n    */\n    this.markers = {};\n\n    /**\n    * @property {AudioContext} context - Reference to the AudioContext instance.\n    */\n    this.context = null;\n\n    /**\n    * @property {boolean} autoplay - Boolean indicating whether the sound should start automatically.\n    */\n    this.autoplay = false;\n\n    /**\n    * @property {number} totalDuration - The total duration of the sound in seconds.\n    */\n    this.totalDuration = 0;\n\n    /**\n    * @property {number} startTime - The time the Sound starts at (typically 0 unless starting from a marker)\n    * @default\n    */\n    this.startTime = 0;\n\n    /**\n    * @property {number} currentTime - The current time the sound is at.\n    */\n    this.currentTime = 0;\n\n    /**\n    * @property {number} duration - The duration of the current sound marker in seconds.\n    */\n    this.duration = 0;\n\n    /**\n    * @property {number} durationMS - The duration of the current sound marker in ms.\n    */\n    this.durationMS = 0;\n\n    /**\n    * @property {number} position - The position of the current sound marker.\n    */\n    this.position = 0;\n\n    /**\n    * @property {number} stopTime - The time the sound stopped.\n    */\n    this.stopTime = 0;\n\n    /**\n    * @property {boolean} paused - true if the sound is paused, otherwise false.\n    * @default\n    */\n    this.paused = false;\n\n    /**\n    * @property {number} pausedPosition - The position the sound had reached when it was paused.\n    */\n    this.pausedPosition = 0;\n\n    /**\n    * @property {number} pausedTime - The game time at which the sound was paused.\n    */\n    this.pausedTime = 0;\n\n    /**\n    * @property {boolean} isPlaying - true if the sound is currently playing, otherwise false.\n    * @default\n    */\n    this.isPlaying = false;\n\n    /**\n    * @property {string} currentMarker - The string ID of the currently playing marker, if any.\n    * @default\n    */\n    this.currentMarker = '';\n\n    /**\n    * @property {boolean} pendingPlayback - true if the sound file is pending playback\n    * @readonly\n    */\n    this.pendingPlayback = false;\n\n    /**\n    * @property {boolean} override - if true when you play this sound it will always start from the beginning.\n    * @default\n    */\n    this.override = false;\n\n    /**\n    * @property {boolean} usingWebAudio - true if this sound is being played with Web Audio.\n    * @readonly\n    */\n    this.usingWebAudio = this.game.sound.usingWebAudio;\n\n    /**\n    * @property {boolean} usingAudioTag - true if the sound is being played via the Audio tag.\n    */\n    this.usingAudioTag = this.game.sound.usingAudioTag;\n\n    /**\n    * @property {object} externalNode - If defined this Sound won't connect to the SoundManager master gain node, but will instead connect to externalNode.input.\n    */\n    this.externalNode = null;\n\n    /**\n    * @property {object} masterGainNode - The master gain node in a Web Audio system.\n    */\n    this.masterGainNode = null;\n\n    /**\n    * @property {object} gainNode - The gain node in a Web Audio system.\n    */\n    this.gainNode = null;\n\n    if (this.usingWebAudio)\n    {\n        this.context = this.game.sound.context;\n        this.masterGainNode = this.game.sound.masterGain;\n\n        if (typeof this.context.createGain === 'undefined')\n        {\n            this.gainNode = this.context.createGainNode();\n        }\n        else\n        {\n            this.gainNode = this.context.createGain();\n        }\n\n        this.gainNode.gain.value = volume * this.game.sound.volume;\n\n        if (connect)\n        {\n            this.gainNode.connect(this.masterGainNode);\n        }\n    }\n    else\n    {\n        if (this.game.cache.getSound(key) && this.game.cache.isSoundReady(key))\n        {\n            this._sound = this.game.cache.getSoundData(key);\n            this.totalDuration = 0;\n\n            if (this._sound.duration)\n            {\n                this.totalDuration = this._sound.duration;\n            }\n        }\n        else\n        {\n            this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this);\n        }\n    }\n\n    /**\n    * @property {Phaser.Signal} onDecoded - The onDecoded event is dispatched when the sound has finished decoding (typically for mp3 files)\n    */\n    this.onDecoded = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onPlay - The onPlay event is dispatched each time this sound is played.\n    */\n    this.onPlay = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onPause - The onPause event is dispatched when this sound is paused.\n    */\n    this.onPause = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onResume - The onResume event is dispatched when this sound is resumed from a paused state.\n    */\n    this.onResume = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onLoop - The onLoop event is dispatched when this sound loops during playback.\n    */\n    this.onLoop = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onStop - The onStop event is dispatched when this sound stops playback.\n    */\n    this.onStop = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onMute - The onMouse event is dispatched when this sound is muted.\n    */\n    this.onMute = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onMarkerComplete - The onMarkerComplete event is dispatched when a marker within this sound completes playback.\n    */\n    this.onMarkerComplete = new Phaser.Signal();\n\n    /**\n    * @property {number} _volume - The global audio volume. A value between 0 (silence) and 1 (full volume).\n    * @private\n    */\n    this._volume = volume;\n\n    /**\n    * @property {any} _buffer - Decoded data buffer / Audio tag.\n    * @private\n    */\n    this._buffer = null;\n\n    /**\n    * @property {boolean} _muted - Boolean indicating whether the sound is muted or not.\n    * @private\n    */\n    this._muted = false;\n\n    /**\n    * @property {number} _tempMarker - Internal marker var.\n    * @private\n    */\n    this._tempMarker = 0;\n\n    /**\n    * @property {number} _tempPosition - Internal marker var.\n    * @private\n    */\n    this._tempPosition = 0;\n\n    /**\n    * @property {number} _tempVolume - Internal marker var.\n    * @private\n    */\n    this._tempVolume = 0;\n\n    /**\n    * @property {boolean} _tempLoop - Internal marker var.\n    * @private\n    */\n    this._tempLoop = 0;\n\n    /**\n    * @property {boolean} _paused - Was this sound paused via code or a game event?\n    * @private\n    */\n    this._paused = false;\n\n};\n\nPhaser.Sound.prototype = {\n\n    /**\n    * Called automatically when this sound is unlocked.\n    * @method Phaser.Sound#soundHasUnlocked\n    * @param {string} key - The Phaser.Cache key of the sound file to check for decoding.\n    * @protected\n    */\n    soundHasUnlocked: function (key) {\n\n        if (key == this.key)\n        {\n            this._sound = this.game.cache.getSoundData(this.key);\n            this.totalDuration = this._sound.duration;\n            // console.log('sound has unlocked' + this._sound);\n        }\n\n    },\n\n    /**\n    * Adds a marker into the current Sound. A marker is represented by a unique key and a start time and duration.\n    * This allows you to bundle multiple sounds together into a single audio file and use markers to jump between them for playback.\n    *\n    * @method Phaser.Sound#addMarker\n    * @param {string} name - A unique name for this marker, i.e. 'explosion', 'gunshot', etc.\n    * @param {number} start - The start point of this marker in the audio file, given in seconds. 2.5 = 2500ms, 0.5 = 500ms, etc.\n    * @param {number} duration - The duration of the marker in seconds. 2.5 = 2500ms, 0.5 = 500ms, etc.\n    * @param {number} [volume=1] - The volume the sound will play back at, between 0 (silent) and 1 (full volume).\n    * @param {boolean} [loop=false] - Sets if the sound will loop or not.\n    */\n    addMarker: function (name, start, duration, volume, loop) {\n\n        if (typeof volume == 'undefined') { volume = 1; }\n        if (typeof loop == 'undefined') { loop = false; }\n\n        this.markers[name] = {\n            name: name,\n            start: start,\n            stop: start + duration,\n            volume: volume,\n            duration: duration,\n            durationMS: duration * 1000,\n            loop: loop\n        };\n\n    },\n\n    /**\n    * Removes a marker from the sound.\n    * @method Phaser.Sound#removeMarker\n    * @param {string} name - The key of the marker to remove.\n    */\n    removeMarker: function (name) {\n\n        delete this.markers[name];\n\n    },\n\n    /**\n    * Called automatically by Phaser.SoundManager.\n    * @method Phaser.Sound#update\n    * @protected\n    */\n    update: function () {\n\n        if (this.pendingPlayback && this.game.cache.isSoundReady(this.key))\n        {\n            this.pendingPlayback = false;\n            this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop);\n        }\n\n        if (this.isPlaying)\n        {\n            this.currentTime = this.game.time.now - this.startTime;\n\n            if (this.currentTime >= this.durationMS)\n            {\n                // console.log(this.currentMarker, 'has hit duration');\n                if (this.usingWebAudio)\n                {\n                    if (this.loop)\n                    {\n                        // console.log('loop1');\n                        //  won't work with markers, needs to reset the position\n                        this.onLoop.dispatch(this);\n\n                        if (this.currentMarker === '')\n                        {\n                            // console.log('loop2');\n                            this.currentTime = 0;\n                            this.startTime = this.game.time.now;\n                        }\n                        else\n                        {\n                            // console.log('loop3');\n                            this.onMarkerComplete.dispatch(this.currentMarker, this);\n                            this.play(this.currentMarker, 0, this.volume, true, true);\n                        }\n                    }\n                    else\n                    {\n                        // console.log('stopping, no loop for marker');\n                        this.stop();\n                    }\n                }\n                else\n                {\n                    if (this.loop)\n                    {\n                        this.onLoop.dispatch(this);\n                        this.play(this.currentMarker, 0, this.volume, true, true);\n                    }\n                    else\n                    {\n                        this.stop();\n                    }\n                }\n            }\n        }\n    },\n\n    /**\n    * Play this sound, or a marked section of it.\n    * @method Phaser.Sound#play\n    * @param {string} [marker=''] - If you want to play a marker then give the key here, otherwise leave blank to play the full sound.\n    * @param {number} [position=0] - The starting position to play the sound from - this is ignored if you provide a marker.\n    * @param {number} [volume=1] - Volume of the sound you want to play. If none is given it will use the volume given to the Sound when it was created (which defaults to 1 if none was specified).\n    * @param {boolean} [loop=false] - Loop when it finished playing?\n    * @param {boolean} [forceRestart=true] - If the sound is already playing you can set forceRestart to restart it from the beginning.\n    * @return {Phaser.Sound} This sound instance.\n    */\n    play: function (marker, position, volume, loop, forceRestart) {\n\n        if (typeof marker === 'undefined') { marker = ''; }\n        if (typeof forceRestart === 'undefined') { forceRestart = true; }\n\n        if (this.isPlaying === true && forceRestart === false && this.override === false)\n        {\n            //  Use Restart instead\n            return;\n        }\n\n        if (this.isPlaying && this.override)\n        {\n            if (this.usingWebAudio)\n            {\n                if (typeof this._sound.stop === 'undefined')\n                {\n                    this._sound.noteOff(0);\n                }\n                else\n                {\n                    this._sound.stop(0);\n                }\n            }\n            else if (this.usingAudioTag)\n            {\n                this._sound.pause();\n                this._sound.currentTime = 0;\n            }\n        }\n\n        this.currentMarker = marker;\n\n        if (marker !== '')\n        {\n            if (this.markers[marker])\n            {\n                //  Playing a marker? Then we default to the marker values\n                this.position = this.markers[marker].start;\n                this.volume = this.markers[marker].volume;\n                this.loop = this.markers[marker].loop;\n                this.duration = this.markers[marker].duration;\n                this.durationMS = this.markers[marker].durationMS;\n\n                if (typeof volume !== 'undefined')\n                {\n                    this.volume = volume;\n                }\n\n                if (typeof loop !== 'undefined')\n                {\n                    this.loop = loop;\n                }\n\n                this._tempMarker = marker;\n                this._tempPosition = this.position;\n                this._tempVolume = this.volume;\n                this._tempLoop = this.loop;\n            }\n            else\n            {\n                console.warn(\"Phaser.Sound.play: audio marker \" + marker + \" doesn't exist\");\n                return;\n            }\n        }\n        else\n        {\n            position = position || 0;\n\n            if (typeof volume === 'undefined') { volume = this._volume; }\n            if (typeof loop === 'undefined') { loop = this.loop; }\n\n            this.position = position;\n            this.volume = volume;\n            this.loop = loop;\n            this.duration = 0;\n            this.durationMS = 0;\n\n            this._tempMarker = marker;\n            this._tempPosition = position;\n            this._tempVolume = volume;\n            this._tempLoop = loop;\n        }\n\n        if (this.usingWebAudio)\n        {\n            //  Does the sound need decoding?\n            if (this.game.cache.isSoundDecoded(this.key))\n            {\n                //  Do we need to do this every time we play? How about just if the buffer is empty?\n                if (this._buffer == null)\n                {\n                    this._buffer = this.game.cache.getSoundData(this.key);\n                }\n\n                this._sound = this.context.createBufferSource();\n                this._sound.buffer = this._buffer;\n\n                if (this.externalNode)\n                {\n                    this._sound.connect(this.externalNode.input);\n                }\n                else\n                {\n                    this._sound.connect(this.gainNode);\n                }\n\n                this.totalDuration = this._sound.buffer.duration;\n\n                if (this.duration === 0)\n                {\n                    // console.log('duration reset');\n                    this.duration = this.totalDuration;\n                    this.durationMS = this.totalDuration * 1000;\n                }\n\n                if (this.loop && marker === '')\n                {\n                    this._sound.loop = true;\n                }\n\n                //  Useful to cache this somewhere perhaps?\n                if (typeof this._sound.start === 'undefined')\n                {\n                    this._sound.noteGrainOn(0, this.position, this.duration);\n                    // this._sound.noteGrainOn(0, this.position, this.duration / 1000);\n                    //this._sound.noteOn(0); // the zero is vitally important, crashes iOS6 without it\n                }\n                else\n                {\n                    // this._sound.start(0, this.position, this.duration / 1000);\n                    this._sound.start(0, this.position, this.duration);\n                }\n\n                this.isPlaying = true;\n                this.startTime = this.game.time.now;\n                this.currentTime = 0;\n                this.stopTime = this.startTime + this.durationMS;\n                this.onPlay.dispatch(this);\n            }\n            else\n            {\n                this.pendingPlayback = true;\n\n                if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding === false)\n                {\n                    this.game.sound.decode(this.key, this);\n                }\n            }\n        }\n        else\n        {\n            // console.log('Sound play Audio');\n            if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked)\n            {\n                // console.log('tried playing locked sound, pending set, reload started');\n                this.game.cache.reloadSound(this.key);\n                this.pendingPlayback = true;\n            }\n            else\n            {\n                // console.log('sound not locked, state?', this._sound.readyState);\n                if (this._sound && (this.game.device.cocoonJS || this._sound.readyState === 4))\n                {\n                    this._sound.play();\n                    //  This doesn't become available until you call play(), wonderful ...\n                    this.totalDuration = this._sound.duration;\n\n                    if (this.duration === 0)\n                    {\n                        this.duration = this.totalDuration;\n                        this.durationMS = this.totalDuration * 1000;\n                    }\n\n                    // console.log('playing', this._sound);\n                    this._sound.currentTime = this.position;\n                    this._sound.muted = this._muted;\n\n                    if (this._muted)\n                    {\n                        this._sound.volume = 0;\n                    }\n                    else\n                    {\n                        this._sound.volume = this._volume;\n                    }\n\n                    this.isPlaying = true;\n                    this.startTime = this.game.time.now;\n                    this.currentTime = 0;\n                    this.stopTime = this.startTime + this.durationMS;\n                    this.onPlay.dispatch(this);\n                }\n                else\n                {\n                    this.pendingPlayback = true;\n                }\n            }\n        }\n    },\n\n    /**\n    * Restart the sound, or a marked section of it.\n    *\n    * @method Phaser.Sound#restart\n    * @param {string} [marker=''] - If you want to play a marker then give the key here, otherwise leave blank to play the full sound.\n    * @param {number} [position=0] - The starting position to play the sound from - this is ignored if you provide a marker.\n    * @param {number} [volume=1] - Volume of the sound you want to play.\n    * @param {boolean} [loop=false] - Loop when it finished playing?\n    */\n    restart: function (marker, position, volume, loop) {\n\n        marker = marker || '';\n        position = position || 0;\n        volume = volume || 1;\n        if (typeof loop == 'undefined') { loop = false; }\n\n        this.play(marker, position, volume, loop, true);\n\n    },\n\n    /**\n    * Pauses the sound.\n    *\n    * @method Phaser.Sound#pause\n    */\n    pause: function () {\n\n        if (this.isPlaying && this._sound)\n        {\n            this.stop();\n            this.isPlaying = false;\n            this.paused = true;\n            this.pausedPosition = this.currentTime;\n            this.pausedTime = this.game.time.now;\n            this.onPause.dispatch(this);\n        }\n\n    },\n\n    /**\n    * Resumes the sound.\n    *\n    * @method Phaser.Sound#resume\n    */\n    resume: function () {\n\n        if (this.paused && this._sound)\n        {\n            if (this.usingWebAudio)\n            {\n                var p = this.position + (this.pausedPosition / 1000);\n\n                this._sound = this.context.createBufferSource();\n                this._sound.buffer = this._buffer;\n\n                if (this.externalNode)\n                {\n                    this._sound.connect(this.externalNode.input);\n                }\n                else\n                {\n                    this._sound.connect(this.gainNode);\n                }\n\n                if (this.loop)\n                {\n                    this._sound.loop = true;\n                }\n\n                if (typeof this._sound.start === 'undefined')\n                {\n                    this._sound.noteGrainOn(0, p, this.duration);\n                    //this._sound.noteOn(0); // the zero is vitally important, crashes iOS6 without it\n                }\n                else\n                {\n                    this._sound.start(0, p, this.duration);\n                }\n            }\n            else\n            {\n                this._sound.play();\n            }\n\n            this.isPlaying = true;\n            this.paused = false;\n            this.startTime += (this.game.time.now - this.pausedTime);\n            this.onResume.dispatch(this);\n        }\n\n    },\n\n    /**\n    * Stop playing this sound.\n    *\n    * @method Phaser.Sound#stop\n    */\n    stop: function () {\n\n        if (this.isPlaying && this._sound)\n        {\n            if (this.usingWebAudio)\n            {\n                if (typeof this._sound.stop === 'undefined')\n                {\n                    this._sound.noteOff(0);\n                }\n                else\n                {\n                    this._sound.stop(0);\n                }\n            }\n            else if (this.usingAudioTag)\n            {\n                this._sound.pause();\n                this._sound.currentTime = 0;\n            }\n        }\n\n        this.isPlaying = false;\n        var prevMarker = this.currentMarker;\n\n        if (this.currentMarker !== '')\n        {\n            this.onMarkerComplete.dispatch(this.currentMarker, this);\n        }\n\n        this.currentMarker = '';\n        this.onStop.dispatch(this, prevMarker);\n\n    },\n\n    /**\n    * Destroys this sound and all associated events and removes it from the SoundManager.\n    *\n    * @method Phaser.Sound#destroy\n    * @param {boolean} [remove=true] - If true this Sound is automatically removed from the SoundManager.\n    */\n    destroy: function (remove) {\n\n        if (typeof remove === 'undefined') { remove = true; }\n\n        this.stop();\n\n        if (remove)\n        {\n            this.game.sound.remove(this);\n        }\n\n        this.markers = {};\n        this.context = null;\n        this._buffer = null;\n        this.externalNode = null;\n        this.onDecoded.dispose();\n        this.onPlay.dispose();\n        this.onPause.dispose();\n        this.onResume.dispose();\n        this.onLoop.dispose();\n        this.onStop.dispose();\n        this.onMute.dispose();\n        this.onMarkerComplete.dispose();\n\n    }\n\n};\n\nPhaser.Sound.prototype.constructor = Phaser.Sound;\n\n/**\n* @name Phaser.Sound#isDecoding\n* @property {boolean} isDecoding - Returns true if the sound file is still decoding.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"isDecoding\", {\n\n    get: function () {\n        return this.game.cache.getSound(this.key).isDecoding;\n    }\n\n});\n\n/**\n* @name Phaser.Sound#isDecoded\n* @property {boolean} isDecoded - Returns true if the sound file has decoded.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"isDecoded\", {\n\n    get: function () {\n        return this.game.cache.isSoundDecoded(this.key);\n    }\n\n});\n\n/**\n* @name Phaser.Sound#mute\n* @property {boolean} mute - Gets or sets the muted state of this sound.\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"mute\", {\n\n    get: function () {\n\n        return (this._muted || this.game.sound.mute);\n\n    },\n\n    set: function (value) {\n\n        value = value || null;\n\n        if (value)\n        {\n            this._muted = true;\n\n            if (this.usingWebAudio)\n            {\n                this._muteVolume = this.gainNode.gain.value;\n                this.gainNode.gain.value = 0;\n            }\n            else if (this.usingAudioTag && this._sound)\n            {\n                this._muteVolume = this._sound.volume;\n                this._sound.volume = 0;\n            }\n        }\n        else\n        {\n            this._muted = false;\n\n            if (this.usingWebAudio)\n            {\n                this.gainNode.gain.value = this._muteVolume;\n            }\n            else if (this.usingAudioTag && this._sound)\n            {\n                this._sound.volume = this._muteVolume;\n            }\n        }\n\n        this.onMute.dispatch(this);\n\n    }\n\n});\n\n/**\n* @name Phaser.Sound#volume\n* @property {number} volume - Gets or sets the volume of this sound, a value between 0 and 1.\n* @readonly\n*/\nObject.defineProperty(Phaser.Sound.prototype, \"volume\", {\n\n    get: function () {\n        return this._volume;\n    },\n\n    set: function (value) {\n\n        if (this.usingWebAudio)\n        {\n            this._volume = value;\n            this.gainNode.gain.value = value;\n        }\n        else if (this.usingAudioTag && this._sound)\n        {\n            //  Causes an Index size error in Firefox if you don't clamp the value\n            if (value >= 0 && value <= 1)\n            {\n                this._volume = value;\n                this._sound.volume = value;\n            }\n        }\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Sound Manager constructor.\n* The Sound Manager is responsible for playing back audio via either the Legacy HTML Audio tag or via Web Audio if the browser supports it.\n* Note: On Firefox 25+ on Linux if you have media.gstreamer disabled in about:config then it cannot play back mp3 or m4a files.\n*\n* @class Phaser.SoundManager\n* @classdesc Phaser Sound Manager.\n* @constructor\n* @param {Phaser.Game} game reference to the current game instance.\n*/\nPhaser.SoundManager = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Signal} onSoundDecode - The event dispatched when a sound decodes (typically only for mp3 files)\n    */\n    this.onSoundDecode = new Phaser.Signal();\n\n    /**\n    * @property {boolean} _codeMuted - Internal mute tracking var.\n    * @private\n    * @default\n    */\n    this._codeMuted = false;\n\n    /**\n    * @property {boolean} _muted - Internal mute tracking var.\n    * @private\n    * @default\n    */\n    this._muted = false;\n\n    /**\n    * @property {Description} _unlockSource - Internal unlock tracking var.\n    * @private\n    * @default\n    */\n    this._unlockSource = null;\n\n    /**\n    * @property {number} _volume - The global audio volume. A value between 0 (silence) and 1 (full volume).\n    * @private\n    * @default\n    */\n    this._volume = 1;\n\n    /**\n    * @property {array} _sounds - An array containing all the sounds\n    * @private\n    */\n    this._sounds = [];\n\n    /**\n    * @property {AudioContext} context - The AudioContext being used for playback.\n    * @default\n    */\n    this.context = null;\n\n    /**\n    * @property {boolean} usingWebAudio - true if this sound is being played with Web Audio.\n    * @readonly\n    */\n    this.usingWebAudio = true;\n\n    /**\n    * @property {boolean} usingAudioTag - true if the sound is being played via the Audio tag.\n    * @readonly\n    */\n    this.usingAudioTag = false;\n\n    /**\n    * @property {boolean} noAudio - Has audio been disabled via the PhaserGlobal object? Useful if you need to use a 3rd party audio library instead.\n    * @default\n    */\n    this.noAudio = false;\n\n    /**\n    * @property {boolean} connectToMaster - Used in conjunction with Sound.externalNode this allows you to stop a Sound node being connected to the SoundManager master gain node.\n    * @default\n    */\n    this.connectToMaster = true;\n\n    /**\n    * @property {boolean} touchLocked - true if the audio system is currently locked awaiting a touch event.\n    * @default\n    */\n    this.touchLocked = false;\n\n    /**\n    * @property {number} channels - The number of audio channels to use in playback.\n    * @default\n    */\n    this.channels = 32;\n\n};\n\nPhaser.SoundManager.prototype = {\n\n    /**\n    * Initialises the sound manager.\n    * @method Phaser.SoundManager#boot\n    * @protected\n    */\n    boot: function () {\n\n        if (this.game.device.iOS && this.game.device.webAudio === false)\n        {\n            this.channels = 1;\n        }\n\n        if (this.game.device.iOS || (window['PhaserGlobal'] && window['PhaserGlobal'].fakeiOSTouchLock))\n        {\n            this.game.input.touch.callbackContext = this;\n            this.game.input.touch.touchStartCallback = this.unlock;\n            this.game.input.mouse.callbackContext = this;\n            this.game.input.mouse.mouseDownCallback = this.unlock;\n            this.touchLocked = true;\n        }\n        else\n        {\n            //  What about iOS5?\n            this.touchLocked = false;\n        }\n\n        if (window['PhaserGlobal'])\n        {\n            //  Check to see if all audio playback is disabled (i.e. handled by a 3rd party class)\n            if (window['PhaserGlobal'].disableAudio === true)\n            {\n                this.usingWebAudio = false;\n                this.noAudio = true;\n                return;\n            }\n\n            //  Check if the Web Audio API is disabled (for testing Audio Tag playback during development)\n            if (window['PhaserGlobal'].disableWebAudio === true)\n            {\n                this.usingWebAudio = false;\n                this.usingAudioTag = true;\n                this.noAudio = false;\n                return;\n            }\n        }\n\n        if (!!window['AudioContext'])\n        {\n            try {\n                this.context = new window['AudioContext']();\n            } catch (error) {\n                this.context = null;\n                this.usingWebAudio = false;\n                this.noAudio = true;\n            }\n        }\n        else if (!!window['webkitAudioContext'])\n        {\n            try {\n                this.context = new window['webkitAudioContext']();\n            } catch (error) {\n                this.context = null;\n                this.usingWebAudio = false;\n                this.noAudio = true;\n            }\n        }\n\n        if (!!window['Audio'] && this.context === null)\n        {\n            this.usingWebAudio = false;\n            this.usingAudioTag = true;\n            this.noAudio = false;\n        }\n\n        if (this.context !== null)\n        {\n            if (typeof this.context.createGain === 'undefined')\n            {\n                this.masterGain = this.context.createGainNode();\n            }\n            else\n            {\n                this.masterGain = this.context.createGain();\n            }\n\n            this.masterGain.gain.value = 1;\n            this.masterGain.connect(this.context.destination);\n        }\n\n    },\n\n    /**\n    * Enables the audio, usually after the first touch.\n    * @method Phaser.SoundManager#unlock\n    */\n    unlock: function () {\n\n        if (this.touchLocked === false)\n        {\n            return;\n        }\n\n        //  Global override (mostly for Audio Tag testing)\n        if (this.game.device.webAudio === false || (window['PhaserGlobal'] && window['PhaserGlobal'].disableWebAudio === true))\n        {\n            //  Create an Audio tag?\n            this.touchLocked = false;\n            this._unlockSource = null;\n            this.game.input.touch.callbackContext = null;\n            this.game.input.touch.touchStartCallback = null;\n            this.game.input.mouse.callbackContext = null;\n            this.game.input.mouse.mouseDownCallback = null;\n        }\n        else\n        {\n            // Create empty buffer and play it\n            var buffer = this.context.createBuffer(1, 1, 22050);\n            this._unlockSource = this.context.createBufferSource();\n            this._unlockSource.buffer = buffer;\n            this._unlockSource.connect(this.context.destination);\n            this._unlockSource.noteOn(0);\n        }\n\n    },\n\n    /**\n    * Stops all the sounds in the game.\n    *\n    * @method Phaser.SoundManager#stopAll\n    */\n    stopAll: function () {\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i])\n            {\n                this._sounds[i].stop();\n            }\n        }\n\n    },\n\n    /**\n    * Pauses all the sounds in the game.\n    *\n    * @method Phaser.SoundManager#pauseAll\n    */\n    pauseAll: function () {\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i])\n            {\n                this._sounds[i].pause();\n            }\n        }\n\n    },\n\n    /**\n    * Resumes every sound in the game.\n    *\n    * @method Phaser.SoundManager#resumeAll\n    */\n    resumeAll: function () {\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i])\n            {\n                this._sounds[i].resume();\n            }\n        }\n\n    },\n\n    /**\n    * Decode a sound by its assets key.\n    *\n    * @method Phaser.SoundManager#decode\n    * @param {string} key - Assets key of the sound to be decoded.\n    * @param {Phaser.Sound} [sound] - Its buffer will be set to decoded data.\n    */\n    decode: function (key, sound) {\n\n        sound = sound || null;\n\n        var soundData = this.game.cache.getSoundData(key);\n\n        if (soundData)\n        {\n            if (this.game.cache.isSoundDecoded(key) === false)\n            {\n                this.game.cache.updateSound(key, 'isDecoding', true);\n\n                var that = this;\n\n                this.context.decodeAudioData(soundData, function (buffer) {\n                    that.game.cache.decodedSound(key, buffer);\n                    if (sound)\n                    {\n                        that.onSoundDecode.dispatch(key, sound);\n                    }\n                });\n            }\n        }\n\n    },\n\n    /**\n    * Updates every sound in the game.\n    *\n    * @method Phaser.SoundManager#update\n    */\n    update: function () {\n\n        if (this.touchLocked)\n        {\n            if (this.game.device.webAudio && this._unlockSource !== null)\n            {\n                if ((this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE))\n                {\n                    this.touchLocked = false;\n                    this._unlockSource = null;\n                    this.game.input.touch.callbackContext = null;\n                    this.game.input.touch.touchStartCallback = null;\n                }\n            }\n        }\n\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            this._sounds[i].update();\n        }\n\n    },\n\n    /**\n    * Adds a new Sound into the SoundManager.\n    *\n    * @method Phaser.SoundManager#add\n    * @param {string} key - Asset key for the sound.\n    * @param {number} [volume=1] - Default value for the volume.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @param {boolean} [connect=true] - Controls if the created Sound object will connect to the master gainNode of the SoundManager when running under WebAudio.\n    * @return {Phaser.Sound} The new sound instance.\n    */\n    add: function (key, volume, loop, connect) {\n\n        if (typeof volume === 'undefined') { volume = 1; }\n        if (typeof loop === 'undefined') { loop = false; }\n        if (typeof connect === 'undefined') { connect = this.connectToMaster; }\n\n        var sound = new Phaser.Sound(this.game, key, volume, loop, connect);\n\n        this._sounds.push(sound);\n\n        return sound;\n\n    },\n\n    /**\n    * Removes a Sound from the SoundManager. The removed Sound is destroyed before removal.\n    *\n    * @method Phaser.SoundManager#remove\n    * @param {Phaser.Sound} sound - The sound object to remove.\n    * @return {boolean} True if the sound was removed successfully, otherwise false.\n    */\n    remove: function (sound) {\n\n        var i = this._sounds.length;\n\n        while (i--)\n        {\n            if (this._sounds[i] === sound)\n            {\n                this._sounds[i].destroy(false);\n                this._sounds.splice(i, 1);\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Removes all Sounds from the SoundManager that have an asset key matching the given value.\n    * The removed Sounds are destroyed before removal.\n    *\n    * @method Phaser.SoundManager#removeByKey\n    * @param {string} key - The key to match when removing sound objects.\n    * @return {number} The number of matching sound objects that were removed.\n    */\n    removeByKey: function (key) {\n\n        var i = this._sounds.length;\n        var removed = 0;\n\n        while (i--)\n        {\n            if (this._sounds[i].key === key)\n            {\n                this._sounds[i].destroy(false);\n                this._sounds.splice(i, 1);\n                removed++;\n            }\n        }\n\n        return removed;\n\n    },\n\n    /**\n    * Adds a new Sound into the SoundManager and starts it playing.\n    *\n    * @method Phaser.SoundManager#play\n    * @param {string} key - Asset key for the sound.\n    * @param {number} [volume=1] - Default value for the volume.\n    * @param {boolean} [loop=false] - Whether or not the sound will loop.\n    * @return {Phaser.Sound} The new sound instance.\n    */\n    play: function (key, volume, loop) {\n\n        var sound = this.add(key, volume, loop);\n\n        sound.play();\n\n        return sound;\n\n    },\n\n    /**\n    * Internal mute handler called automatically by the Sound.mute setter.\n    *\n    * @method Phaser.SoundManager#setMute\n    * @private\n    */\n    setMute: function () {\n\n        if (this._muted)\n        {\n            return;\n        }\n\n        this._muted = true;\n\n        if (this.usingWebAudio)\n        {\n            this._muteVolume = this.masterGain.gain.value;\n            this.masterGain.gain.value = 0;\n        }\n\n        //  Loop through sounds\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i].usingAudioTag)\n            {\n                this._sounds[i].mute = true;\n            }\n        }\n\n    },\n\n    /**\n    * Internal mute handler called automatically by the Sound.mute setter.\n    *\n    * @method Phaser.SoundManager#unsetMute\n    * @private\n    */\n    unsetMute: function () {\n\n        if (!this._muted || this._codeMuted)\n        {\n            return;\n        }\n\n        this._muted = false;\n\n        if (this.usingWebAudio)\n        {\n            this.masterGain.gain.value = this._muteVolume;\n        }\n\n        //  Loop through sounds\n        for (var i = 0; i < this._sounds.length; i++)\n        {\n            if (this._sounds[i].usingAudioTag)\n            {\n                this._sounds[i].mute = false;\n            }\n        }\n\n    }\n\n};\n\nPhaser.SoundManager.prototype.constructor = Phaser.SoundManager;\n\n/**\n* @name Phaser.SoundManager#mute\n* @property {boolean} mute - Gets or sets the muted state of the SoundManager. This effects all sounds in the game.\n*/\nObject.defineProperty(Phaser.SoundManager.prototype, \"mute\", {\n\n    get: function () {\n\n        return this._muted;\n\n    },\n\n    set: function (value) {\n\n        value = value || null;\n\n        if (value)\n        {\n            if (this._muted)\n            {\n                return;\n            }\n\n            this._codeMuted = true;\n            this.setMute();\n        }\n        else\n        {\n            if (!this._muted)\n            {\n                return;\n            }\n\n            this._codeMuted = false;\n            this.unsetMute();\n        }\n    }\n\n});\n\n/**\n* @name Phaser.SoundManager#volume\n* @property {number} volume - Gets or sets the global volume of the SoundManager, a value between 0 and 1.\n*/\nObject.defineProperty(Phaser.SoundManager.prototype, \"volume\", {\n\n    get: function () {\n\n        if (this.usingWebAudio)\n        {\n            return this.masterGain.gain.value;\n        }\n        else\n        {\n            return this._volume;\n        }\n\n    },\n\n    set: function (value) {\n\n        this._volume = value;\n\n        if (this.usingWebAudio)\n        {\n            this.masterGain.gain.value = value;\n        }\n        else\n        {\n            //  Loop through the sound cache and change the volume of all html audio tags\n            for (var i = 0; i < this._sounds.length; i++)\n            {\n                if (this._sounds[i].usingAudioTag)\n                {\n                    this._sounds[i].volume = this._sounds[i].volume * value;\n                }\n            }\n        }\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A collection of methods for displaying debug information about game objects.\n* If your game is running in WebGL then Debug will create a Sprite that is placed at the top of the Stage display list and bind a canvas texture\n* to it, which must be uploaded every frame. Be advised: this is expenive.\n* If your game is using a Canvas renderer then the debug information is literally drawn on the top of the active game canvas and no Sprite is used.\n*\n* @class Phaser.Utils.Debug\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Utils.Debug = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {PIXI.Sprite} sprite - If debugging in WebGL mode we need this.\n    */\n    this.sprite = null;\n\n    /**\n    * @property {HTMLCanvasElement} canvas - The canvas to which this BitmapData draws.\n    */\n    this.canvas = null;\n\n    /**\n    * @property {PIXI.BaseTexture} baseTexture - Required Pixi var.\n    */\n    this.baseTexture = null;\n\n    /**\n    * @property {PIXI.Texture} texture - Required Pixi var.\n    */\n    this.texture = null;\n\n    /**\n    * @property {Phaser.Frame} textureFrame - Dimensions of the renderable area.\n    */\n    this.textureFrame = null;\n\n    /**\n    * @property {CanvasRenderingContext2D} context - The 2d context of the canvas.\n    */\n    this.context = null;\n\n    /**\n    * @property {string} font - The font that the debug information is rendered in.\n    * @default '14px Courier'\n    */\n    this.font = '14px Courier';\n\n    /**\n    * @property {number} columnWidth - The spacing between columns.\n    */\n    this.columnWidth = 100;\n\n    /**\n    * @property {number} lineHeight - The line height between the debug text.\n    */\n    this.lineHeight = 16;\n\n    /**\n    * @property {boolean} renderShadow - Should the text be rendered with a slight shadow? Makes it easier to read on different types of background.\n    */\n    this.renderShadow = true;\n\n    /**\n    * @property {Context} currentX - The current X position the debug information will be rendered at.\n    * @default\n    */\n    this.currentX = 0;\n\n    /**\n    * @property {number} currentY - The current Y position the debug information will be rendered at.\n    * @default\n    */\n    this.currentY = 0;\n\n    /**\n    * @property {number} currentAlpha - The current alpha the debug information will be rendered at.\n    * @default\n    */\n    this.currentAlpha = 1;\n\n    /**\n    * @property {boolean} dirty - Does the canvas need re-rendering?\n    */\n    this.dirty = false;\n\n};\n\nPhaser.Utils.Debug.prototype = {\n\n    /**\n    * Internal method that boots the debug displayer.\n    *\n    * @method Phaser.Utils.Debug#boot\n    * @protected\n    */\n    boot: function () {\n\n        if (this.game.renderType === Phaser.CANVAS)\n        {\n            this.context = this.game.context;\n        }\n        else\n        {\n            this.canvas = Phaser.Canvas.create(this.game.width, this.game.height, '', true);\n            this.context = this.canvas.getContext('2d');\n            this.baseTexture = new PIXI.BaseTexture(this.canvas);\n            this.texture = new PIXI.Texture(this.baseTexture);\n            this.textureFrame = new Phaser.Frame(0, 0, 0, this.game.width, this.game.height, 'debug', this.game.rnd.uuid());\n            this.sprite = this.game.make.image(0, 0, this.texture, this.textureFrame);\n            this.game.stage.addChild(this.sprite);\n        }\n\n    },\n\n    /**\n    * Internal method that clears the canvas (if a Sprite) ready for a new debug session.\n    *\n    * @method Phaser.Utils.Debug#preUpdate\n    */\n    preUpdate: function () {\n\n        if (this.dirty && this.sprite)\n        {\n            this.context.clearRect(0, 0, this.game.width, this.game.height);\n            this.dirty = false;\n        }\n\n    },\n\n    /**\n    * Internal method that resets and starts the debug output values.\n    *\n    * @method Phaser.Utils.Debug#start\n    * @protected\n    * @param {number} [x=0] - The X value the debug info will start from.\n    * @param {number} [y=0] - The Y value the debug info will start from.\n    * @param {string} [color='rgb(255,255,255)'] - The color the debug text will drawn in.\n    * @param {number} [columnWidth=0] - The spacing between columns.\n    */\n    start: function (x, y, color, columnWidth) {\n\n        if (typeof x !== 'number') { x = 0; }\n        if (typeof y !== 'number') { y = 0; }\n        color = color || 'rgb(255,255,255)';\n        if (typeof columnWidth === 'undefined') { columnWidth = 0; }\n\n        this.currentX = x;\n        this.currentY = y;\n        this.currentColor = color;\n        this.currentAlpha = this.context.globalAlpha;\n        this.columnWidth = columnWidth;\n\n        if (this.sprite)\n        {\n            this.dirty = true;\n        }\n\n        this.context.save();\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\n        this.context.strokeStyle = color;\n        this.context.fillStyle = color;\n        this.context.font = this.font;\n        this.context.globalAlpha = 1;\n\n    },\n\n    /**\n    * Internal method that stops the debug output.\n    *\n    * @method Phaser.Utils.Debug#stop\n    * @protected\n    */\n    stop: function () {\n\n        this.context.restore();\n        this.context.globalAlpha = this.currentAlpha;\n\n        if (this.sprite)\n        {\n            PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);\n        }\n\n    },\n\n    /**\n    * Internal method that outputs a single line of text split over as many columns as needed, one per parameter.\n    *\n    * @method Phaser.Utils.Debug#line\n    * @protected\n    */\n    line: function () {\n\n        var x = this.currentX;\n\n        for (var i = 0; i < arguments.length; i++)\n        {\n            if (this.renderShadow)\n            {\n                this.context.fillStyle = 'rgb(0,0,0)';\n                this.context.fillText(arguments[i], x + 1, this.currentY + 1);\n                this.context.fillStyle = this.currentColor;\n            }\n\n            this.context.fillText(arguments[i], x, this.currentY);\n\n            x += this.columnWidth;\n        }\n\n        this.currentY += this.lineHeight;\n\n    },\n\n    /**\n    * Render Sound information, including decoded state, duration, volume and more.\n    *\n    * @method Phaser.Utils.Debug#soundInfo\n    * @param {Phaser.Sound} sound - The sound object to debug.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    soundInfo: function (sound, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Sound: ' + sound.key + ' Locked: ' + sound.game.sound.touchLocked);\n        this.line('Is Ready?: ' + this.game.cache.isSoundReady(sound.key) + ' Pending Playback: ' + sound.pendingPlayback);\n        this.line('Decoded: ' + sound.isDecoded + ' Decoding: ' + sound.isDecoding);\n        this.line('Total Duration: ' + sound.totalDuration + ' Playing: ' + sound.isPlaying);\n        this.line('Time: ' + sound.currentTime);\n        this.line('Volume: ' + sound.volume + ' Muted: ' + sound.mute);\n        this.line('WebAudio: ' + sound.usingWebAudio + ' Audio: ' + sound.usingAudioTag);\n\n        if (sound.currentMarker !== '')\n        {\n            this.line('Marker: ' + sound.currentMarker + ' Duration: ' + sound.duration + ' (ms: ' + sound.durationMS + ')');\n            this.line('Start: ' + sound.markers[sound.currentMarker].start + ' Stop: ' + sound.markers[sound.currentMarker].stop);\n            this.line('Position: ' + sound.position);\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Render camera information including dimensions and location.\n    *\n    * @method Phaser.Utils.Debug#cameraInfo\n    * @param {Phaser.Camera} camera - The Phaser.Camera to show the debug information for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    cameraInfo: function (camera, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Camera (' + camera.width + ' x ' + camera.height + ')');\n        this.line('X: ' + camera.x + ' Y: ' + camera.y);\n        this.line('Bounds x: ' + camera.bounds.x + ' Y: ' + camera.bounds.y + ' w: ' + camera.bounds.width + ' h: ' + camera.bounds.height);\n        this.line('View x: ' + camera.view.x + ' Y: ' + camera.view.y + ' w: ' + camera.view.width + ' h: ' + camera.view.height);\n        this.stop();\n\n    },\n\n    /**\n    * Render Timer information.\n    *\n    * @method Phaser.Utils.Debug#timer\n    * @param {Phaser.Timer} timer - The Phaser.Timer to show the debug information for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    timer: function (timer, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Timer (running: ' + timer.running + ' expired: ' + timer.expired + ')');\n        this.line('Next Tick: ' + timer.next + ' Duration: ' + timer.duration);\n        this.line('Paused: ' + timer.paused + ' Length: ' + timer.length);\n        this.stop();\n\n    },\n\n    /**\n    * Renders the Pointer.circle object onto the stage in green if down or red if up along with debug text.\n    *\n    * @method Phaser.Utils.Debug#pointer\n    * @param {Phaser.Pointer} pointer - The Pointer you wish to display.\n    * @param {boolean} [hideIfUp=false] - Doesn't render the circle if the pointer is up.\n    * @param {string} [downColor='rgba(0,255,0,0.5)'] - The color the circle is rendered in if down.\n    * @param {string} [upColor='rgba(255,0,0,0.5)'] - The color the circle is rendered in if up (and hideIfUp is false).\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    pointer: function (pointer, hideIfUp, downColor, upColor, color) {\n\n        if (pointer == null)\n        {\n            return;\n        }\n\n        if (typeof hideIfUp === 'undefined') { hideIfUp = false; }\n        downColor = downColor || 'rgba(0,255,0,0.5)';\n        upColor = upColor || 'rgba(255,0,0,0.5)';\n\n        if (hideIfUp === true && pointer.isUp === true)\n        {\n            return;\n        }\n\n        this.start(pointer.x, pointer.y - 100, color);\n        this.context.beginPath();\n        this.context.arc(pointer.x, pointer.y, pointer.circle.radius, 0, Math.PI * 2);\n\n        if (pointer.active)\n        {\n            this.context.fillStyle = downColor;\n        }\n        else\n        {\n            this.context.fillStyle = upColor;\n        }\n\n        this.context.fill();\n        this.context.closePath();\n\n        //  Render the points\n        this.context.beginPath();\n        this.context.moveTo(pointer.positionDown.x, pointer.positionDown.y);\n        this.context.lineTo(pointer.position.x, pointer.position.y);\n        this.context.lineWidth = 2;\n        this.context.stroke();\n        this.context.closePath();\n\n        //  Render the text\n        this.line('ID: ' + pointer.id + \" Active: \" + pointer.active);\n        this.line('World X: ' + pointer.worldX + \" World Y: \" + pointer.worldY);\n        this.line('Screen X: ' + pointer.x + \" Screen Y: \" + pointer.y);\n        this.line('Duration: ' + pointer.duration + \" ms\");\n        this.line('is Down: ' + pointer.isDown + \" is Up: \" + pointer.isUp);\n        this.stop();\n\n    },\n\n    /**\n    * Render Sprite Input Debug information.\n    *\n    * @method Phaser.Utils.Debug#spriteInputInfo\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the input data for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    spriteInputInfo: function (sprite, x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Sprite Input: (' + sprite.width + ' x ' + sprite.height + ')');\n        this.line('x: ' + sprite.input.pointerX().toFixed(1) + ' y: ' + sprite.input.pointerY().toFixed(1));\n        this.line('over: ' + sprite.input.pointerOver() + ' duration: ' + sprite.input.overDuration().toFixed(0));\n        this.line('down: ' + sprite.input.pointerDown() + ' duration: ' + sprite.input.downDuration().toFixed(0));\n        this.line('just over: ' + sprite.input.justOver() + ' just out: ' + sprite.input.justOut());\n        this.stop();\n\n    },\n\n    /**\n    * Renders Phaser.Key object information.\n    *\n    * @method Phaser.Utils.Debug#key\n    * @param {Phaser.Key} key - The Key to render the information for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    key: function (key, x, y, color) {\n\n        this.start(x, y, color, 150);\n\n        this.line('Key:', key.keyCode, 'isDown:', key.isDown);\n        this.line('justPressed:', key.justPressed(), 'justReleased:', key.justReleased());\n        this.line('Time Down:', key.timeDown.toFixed(0), 'duration:', key.duration.toFixed(0));\n\n        this.stop();\n\n    },\n\n    /**\n    * Render debug information about the Input object.\n    *\n    * @method Phaser.Utils.Debug#inputInfo\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    inputInfo: function (x, y, color) {\n\n        this.start(x, y, color);\n        this.line('Input');\n        this.line('X: ' + this.game.input.x + ' Y: ' + this.game.input.y);\n        this.line('World X: ' + this.game.input.worldX + ' World Y: ' + this.game.input.worldY);\n        this.line('Scale X: ' + this.game.input.scale.x.toFixed(1) + ' Scale Y: ' + this.game.input.scale.x.toFixed(1));\n        this.line('Screen X: ' + this.game.input.activePointer.screenX + ' Screen Y: ' + this.game.input.activePointer.screenY);\n        this.stop();\n\n    },\n\n    /**\n    * Renders the Sprites bounds. Note: This is really expensive as it has to calculate the bounds every time you call it!\n    *\n    * @method Phaser.Utils.Debug#spriteBounds\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the bounds of.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {boolean} [filled=true] - Render the rectangle as a fillRect (default, true) or a strokeRect (false)\n    */\n    spriteBounds: function (sprite, color, filled) {\n\n        var bounds = sprite.getBounds();\n\n        bounds.x += this.game.camera.x;\n        bounds.y += this.game.camera.y;\n\n        this.rectangle(bounds, color, filled);\n\n    },\n\n    /**\n    * Render debug infos (including name, bounds info, position and some other properties) about the Sprite.\n    *\n    * @method Phaser.Utils.Debug#spriteInfo\n    * @param {Phaser.Sprite} sprite - The Sprite to display the information of.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    spriteInfo: function (sprite, x, y, color) {\n\n        this.start(x, y, color);\n\n        this.line('Sprite: ' + ' (' + sprite.width + ' x ' + sprite.height + ') anchor: ' + sprite.anchor.x + ' x ' + sprite.anchor.y);\n        this.line('x: ' + sprite.x.toFixed(1) + ' y: ' + sprite.y.toFixed(1));\n        this.line('angle: ' + sprite.angle.toFixed(1) + ' rotation: ' + sprite.rotation.toFixed(1));\n        this.line('visible: ' + sprite.visible + ' in camera: ' + sprite.inCamera);\n\n        this.stop();\n\n    },\n\n    /**\n    * Renders the sprite coordinates in local, positional and world space.\n    *\n    * @method Phaser.Utils.Debug#spriteCoords\n    * @param {Phaser.Sprite|Phaser.Image} sprite - The sprite to display the coordinates for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    spriteCoords: function (sprite, x, y, color) {\n\n        this.start(x, y, color, 100);\n\n        if (sprite.name)\n        {\n            this.line(sprite.name);\n        }\n\n        this.line('x:', sprite.x.toFixed(2), 'y:', sprite.y.toFixed(2));\n        this.line('pos x:', sprite.position.x.toFixed(2), 'pos y:', sprite.position.y.toFixed(2));\n        this.line('world x:', sprite.world.x.toFixed(2), 'world y:', sprite.world.y.toFixed(2));\n\n        this.stop();\n\n    },\n\n    /**\n    * Renders Line information in the given color.\n    *\n    * @method Phaser.Utils.Debug#lineInfo\n    * @param {Phaser.Line} line - The Line to display the data for.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    lineInfo: function (line, x, y, color) {\n\n        this.start(x, y, color, 80);\n        this.line('start.x:', line.start.x.toFixed(2), 'start.y:', line.start.y.toFixed(2));\n        this.line('end.x:', line.end.x.toFixed(2), 'end.y:', line.end.y.toFixed(2));\n        this.line('length:', line.length.toFixed(2), 'angle:', line.angle);\n        this.stop();\n\n    },\n\n    /**\n    * Renders a single pixel at the given size.\n    *\n    * @method Phaser.Utils.Debug#pixel\n    * @param {number} x - X position of the pixel to be rendered.\n    * @param {number} y - Y position of the pixel to be rendered.\n    * @param {string} [color] - Color of the pixel (format is css color string).\n    * @param {number} [size=2] - The 'size' to render the pixel at.\n    */\n    pixel: function (x, y, color, size) {\n\n        size = size || 2;\n\n        this.start();\n        this.context.fillStyle = color;\n        this.context.fillRect(x, y, size, size);\n        this.stop();\n\n    },\n\n    /**\n    * Renders a Phaser geometry object including Rectangle, Circle, Point or Line.\n    *\n    * @method Phaser.Utils.Debug#geom\n    * @param {Phaser.Rectangle|Phaser.Circle|Phaser.Point|Phaser.Line} object - The geometry object to render.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)\n    * @param {number} [forceType=0] - Force rendering of a specific type. If 0 no type will be forced, otherwise 1 = Rectangle, 2 = Circle, 3 = Point and 4 = Line.\n    */\n    geom: function (object, color, filled, forceType) {\n\n        if (typeof filled === 'undefined') { filled = true; }\n        if (typeof forceType === 'undefined') { forceType = 0; }\n\n        color = color || 'rgba(0,255,0,0.4)';\n\n        this.start();\n\n        this.context.fillStyle = color;\n        this.context.strokeStyle = color;\n\n        if (object instanceof Phaser.Rectangle || forceType === 1)\n        {\n            if (filled)\n            {\n                this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n            }\n            else\n            {\n                this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n            }\n        }\n        else if (object instanceof Phaser.Circle || forceType === 2)\n        {\n            this.context.beginPath();\n            this.context.arc(object.x - this.game.camera.x, object.y - this.game.camera.y, object.radius, 0, Math.PI * 2, false);\n            this.context.closePath();\n\n            if (filled)\n            {\n                this.context.fill();\n            }\n            else\n            {\n                this.context.stroke();\n            }\n        }\n        else if (object instanceof Phaser.Point || forceType === 3)\n        {\n            this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, 4, 4);\n        }\n        else if (object instanceof Phaser.Line || forceType === 4)\n        {\n            this.context.lineWidth = 1;\n            this.context.beginPath();\n            this.context.moveTo((object.start.x + 0.5) - this.game.camera.x, (object.start.y + 0.5) - this.game.camera.y);\n            this.context.lineTo((object.end.x + 0.5) - this.game.camera.x, (object.end.y + 0.5) - this.game.camera.y);\n            this.context.closePath();\n            this.context.stroke();\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Renders a Rectangle.\n    *\n    * @method Phaser.Utils.Debug#geom\n    * @param {Phaser.Rectangle|object} object - The geometry object to render.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)\n    */\n    rectangle: function (object, color, filled) {\n\n        if (typeof filled === 'undefined') { filled = true; }\n\n        color = color || 'rgba(0, 255, 0, 0.4)';\n\n        this.start();\n\n        if (filled)\n        {\n            this.context.fillStyle = color;\n            this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n        }\n        else\n        {\n            this.context.strokeStyle = color;\n            this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height);\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Render a string of text.\n    *\n    * @method Phaser.Utils.Debug#text\n    * @param {string} text - The line of text to draw.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color] - Color of the debug info to be rendered (format is css color string).\n    * @param {string} [font] - The font of text to draw.\n    */\n    text: function (text, x, y, color, font) {\n\n        color = color || 'rgb(255,255,255)';\n        font = font || '16px Courier';\n\n        this.start();\n        this.context.font = font;\n\n        if (this.renderShadow)\n        {\n            this.context.fillStyle = 'rgb(0,0,0)';\n            this.context.fillText(text, x + 1, y + 1);\n        }\n\n        this.context.fillStyle = color;\n        this.context.fillText(text, x, y);\n\n        this.stop();\n\n    },\n\n    /**\n    * Visually renders a QuadTree to the display.\n    *\n    * @method Phaser.Utils.Debug#quadTree\n    * @param {Phaser.QuadTree} quadtree - The quadtree to render.\n    * @param {string} color - The color of the lines in the quadtree.\n    */\n    quadTree: function (quadtree, color) {\n\n        color = color || 'rgba(255,0,0,0.3)';\n\n        this.start();\n\n        var bounds = quadtree.bounds;\n\n        if (quadtree.nodes.length === 0)\n        {\n            this.context.strokeStyle = color;\n            this.context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);\n            this.text('size: ' + quadtree.objects.length, bounds.x + 4, bounds.y + 16, 'rgb(0,200,0)', '12px Courier');\n\n            this.context.strokeStyle = 'rgb(0,255,0)';\n\n            for (var i = 0; i < quadtree.objects.length; i++)\n            {\n                this.context.strokeRect(quadtree.objects[i].x, quadtree.objects[i].y, quadtree.objects[i].width, quadtree.objects[i].height);\n            }\n        }\n        else\n        {\n            for (var i = 0; i < quadtree.nodes.length; i++)\n            {\n                this.quadTree(quadtree.nodes[i]);\n            }\n        }\n\n        this.stop();\n\n    },\n\n    /**\n    * Render a Sprites Physics body if it has one set. Note this only works for Arcade Physics.\n    * To display a P2 body you should enable debug mode on the body when creating it.\n    *\n    * @method Phaser.Utils.Debug#body\n    * @param {Phaser.Sprite} sprite - The sprite whos body will be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    * @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)\n    */\n    body: function (sprite, color, filled) {\n\n        if (sprite.body)\n        {\n            if (sprite.body.type === Phaser.Physics.ARCADE)\n            {\n                this.start();\n                Phaser.Physics.Arcade.Body.render(this.context, sprite.body, color, filled);\n                this.stop();\n            }\n        }\n\n    },\n\n    /**\n    * Render a Sprites Physic Body information.\n    *\n    * @method Phaser.Utils.Debug#bodyInfo\n    * @param {Phaser.Sprite} sprite - The sprite to be rendered.\n    * @param {number} x - X position of the debug info to be rendered.\n    * @param {number} y - Y position of the debug info to be rendered.\n    * @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n    */\n    bodyInfo: function (sprite, x, y, color) {\n\n        if (sprite.body)\n        {\n            if (sprite.body.type === Phaser.Physics.ARCADE)\n            {\n                this.start(x, y, color, 210);\n                Phaser.Physics.Arcade.Body.renderBodyInfo(this, sprite.body);\n                this.stop();\n            }\n        }\n\n    }\n\n};\n\nPhaser.Utils.Debug.prototype.constructor = Phaser.Utils.Debug;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Phaser.Color class is a set of static methods that assist in color manipulation and conversion.\n*\n* @class Phaser.Color\n*/\nPhaser.Color = {\n\n    /**\n    * Packs the r, g, b, a components into a single integer, for use with Int32Array.\n    * If device is little endian then ABGR order is used. Otherwise RGBA order is used.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.packPixel\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} a - The alpha color component, in the range 0 - 255.\n    * @return {number} The packed color\n    */\n    packPixel: function (r, g, b, a) {\n\n        if (Phaser.Device.LITTLE_ENDIAN)\n        {\n            return (a << 24) | (b << 16) | (g <<  8) | r;\n        }\n        else\n        {\n            return (r << 24) | (g << 16) | (b <<  8) | a;\n        }\n\n    },\n\n    /**\n    * Unpacks the r, g, b, a components into the specified color object, or a new\n    * object, for use with Int32Array. If little endian, then ABGR order is used when \n    * unpacking, otherwise, RGBA order is used. The resulting color object has the\n    * `r, g, b, a` properties which are unrelated to endianness.\n    *\n    * Note that the integer is assumed to be packed in the correct endianness. On little-endian\n    * the format is 0xAABBGGRR and on big-endian the format is 0xRRGGBBAA. If you want a\n    * endian-independent method, use fromRGBA(rgba) and toRGBA(r, g, b, a).\n    * \n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.unpackPixel\n    * @static\n    * @param {number} rgba - The integer, packed in endian order by packPixel.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @param {boolean} [hsl=false] - Also convert the rgb values into hsl?\n    * @param {boolean} [hsv=false] - Also convert the rgb values into hsv?\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    unpackPixel: function (rgba, out, hsl, hsv) {\n\n        if (typeof out === 'undefined' || out === null) { out = Phaser.Color.createColor(); }\n        if (typeof hsl === 'undefined' || hsl === null) { hsl = false; }\n        if (typeof hsv === 'undefined' || hsv === null) { hsv = false; }\n\n        if (Phaser.Device.LITTLE_ENDIAN)\n        {\n            out.a = ((rgba & 0xff000000) >>> 24);\n            out.b = ((rgba & 0x00ff0000) >>> 16);\n            out.g = ((rgba & 0x0000ff00) >>> 8);\n            out.r = ((rgba & 0x000000ff));\n        }\n        else\n        {\n            out.r = ((rgba & 0xff000000) >>> 24);\n            out.g = ((rgba & 0x00ff0000) >>> 16);\n            out.b = ((rgba & 0x0000ff00) >>> 8);\n            out.a = ((rgba & 0x000000ff));\n        }\n        \n        out.color = rgba;\n        out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + (out.a / 255) + ')';\n\n        if (hsl)\n        {\n            Phaser.Color.RGBtoHSL(out.r, out.g, out.b, out);\n        }\n\n        if (hsv)\n        {\n            Phaser.Color.RGBtoHSV(out.r, out.g, out.b, out);\n        }\n\n        return out;\n\n    },\n\n    /**\n    * A utility to convert an integer in 0xRRGGBBAA format to a color object.\n    * This does not rely on endianness.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.fromRGBA\n    * @static\n    * @param {number} rgba - An RGBA hex\n    * @param {object} [out] - The object to use, optional.\n    * @return {object} A color object.\n    */\n    fromRGBA: function (rgba, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor();\n        }\n\n        out.r = ((rgba & 0xff000000) >>> 24);\n        out.g = ((rgba & 0x00ff0000) >>> 16);\n        out.b = ((rgba & 0x0000ff00) >>> 8);\n        out.a = ((rgba & 0x000000ff));\n\n        out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + out.a + ')';\n\n        return out;\n\n    },\n\n    /**\n    * A utility to convert RGBA components to a 32 bit integer in RRGGBBAA format.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.toRGBA\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} a - The alpha color component, in the range 0 - 255.\n    * @return {number} A RGBA-packed 32 bit integer\n    */\n    toRGBA: function (r, g, b, a) {\n\n        return (r << 24) | (g << 16) | (b <<  8) | a;\n\n    },\n\n    /**\n    * Converts an RGB color value to HSL (hue, saturation and lightness).\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes RGB values are contained in the set [0, 255] and returns h, s and l in the set [0, 1].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.RGBtoHSL\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {object} [out] - An object into which 3 properties will be created, h, s and l. If not provided a new object will be created.\n    * @return {object} An object with the hue, saturation and lightness values set in the h, s and l properties.\n    */\n    RGBtoHSL: function (r, g, b, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor(r, g, b, 1);\n        }\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n\n        // achromatic by default\n        out.h = 0;\n        out.s = 0;\n        out.l = (max + min) / 2;\n\n        if (max !== min)\n        {\n            var d = max - min;\n\n            out.s = out.l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n            if (max === r)\n            {\n                out.h = (g - b) / d + (g < b ? 6 : 0);\n            }\n            else if (max === g)\n            {\n                out.h = (b - r) / d + 2;\n            }\n            else if (max === b)\n            {\n                out.h = (r - g) / d + 4;\n            }\n\n            out.h /= 6;\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Converts an HSL (hue, saturation and lightness) color value to RGB.\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes HSL values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.HSLtoRGB\n    * @static\n    * @param {number} h - The hue, in the range 0 - 1.\n    * @param {number} s - The saturation, in the range 0 - 1.\n    * @param {number} l - The lightness, in the range 0 - 1.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    HSLtoRGB: function (h, s, l, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor(l, l, l);\n        }\n        else\n        {\n            // achromatic by default\n            out.r = l;\n            out.g = l;\n            out.b = l;\n        }\n\n        if (s !== 0)\n        {\n            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            var p = 2 * l - q;\n            out.r = Phaser.Color.hueToColor(p, q, h + 1 / 3);\n            out.g = Phaser.Color.hueToColor(p, q, h);\n            out.b = Phaser.Color.hueToColor(p, q, h - 1 / 3);\n        }\n\n        // out.r = (out.r * 255 | 0);\n        // out.g = (out.g * 255 | 0);\n        // out.b = (out.b * 255 | 0);\n\n        out.r = Math.floor((out.r * 255 | 0));\n        out.g = Math.floor((out.g * 255 | 0));\n        out.b = Math.floor((out.b * 255 | 0));\n\n        Phaser.Color.updateColor(out);\n\n        return out;\n\n    },\n\n    /**\n    * Converts an RGB color value to HSV (hue, saturation and value).\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes RGB values are contained in the set [0, 255] and returns h, s and v in the set [0, 1].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.RGBtoHSV\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {object} [out] - An object into which 3 properties will be created, h, s and v. If not provided a new object will be created.\n    * @return {object} An object with the hue, saturation and value set in the h, s and v properties.\n    */\n    RGBtoHSV: function (r, g, b, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor(r, g, b, 255);\n        }\n\n        r /= 255;\n        g /= 255;\n        b /= 255;\n\n        var min = Math.min(r, g, b);\n        var max = Math.max(r, g, b);\n        var d = max - min;\n\n        // achromatic by default\n        out.h = 0;\n        out.s = max === 0 ? 0 : d / max;\n        out.v = max;\n\n        if (max !== min)\n        {\n            if (max === r)\n            {\n                out.h = (g - b) / d + (g < b ? 6 : 0);\n            }\n            else if (max === g)\n            {\n                out.h = (b - r) / d + 2;\n            }\n            else if (max === b)\n            {\n                out.h = (r - g) / d + 4;\n            }\n\n            out.h /= 6;\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Converts an HSV (hue, saturation and value) color value to RGB.\n    * Conversion forumla from http://en.wikipedia.org/wiki/HSL_color_space.\n    * Assumes HSV values are contained in the set [0, 1] and returns r, g and b values in the set [0, 255].\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.HSVtoRGB\n    * @static\n    * @param {number} h - The hue, in the range 0 - 1.\n    * @param {number} s - The saturation, in the range 0 - 1.\n    * @param {number} v - The value, in the range 0 - 1.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    HSVtoRGB: function (h, s, v, out) {\n\n        if (typeof out === 'undefined') { out = Phaser.Color.createColor(0, 0, 0, 1, h, s, 0, v); }\n\n        var r, g, b;\n        var i = Math.floor(h * 6);\n        var f = h * 6 - i;\n        var p = v * (1 - s);\n        var q = v * (1 - f * s);\n        var t = v * (1 - (1 - f) * s);\n\n        switch (i % 6)\n        {\n            case 0:\n                r = v;\n                g = t;\n                b = p;\n                break;\n            case 1:\n                r = q;\n                g = v;\n                b = p;\n                break;\n            case 2:\n                r = p;\n                g = v;\n                b = t;\n                break;\n            case 3:\n                r = p;\n                g = q;\n                b = v;\n                break;\n            case 4:\n                r = t;\n                g = p;\n                b = v;\n                break;\n            case 5:\n                r = v;\n                g = p;\n                b = q;\n                break;\n        }\n\n        out.r = Math.floor(r * 255);\n        out.g = Math.floor(g * 255);\n        out.b = Math.floor(b * 255);\n\n        Phaser.Color.updateColor(out);\n\n        return out;\n\n    },\n\n    /**\n    * Converts a hue to an RGB color.\n    * Based on code by Michael Jackson (https://github.com/mjijackson)\n    *\n    * @method Phaser.Color.hueToColor\n    * @static\n    * @param {number} p\n    * @param {number} q\n    * @param {number} t\n    * @return {number} The color component value.\n    */\n    hueToColor: function (p, q, t) {\n\n        if (t < 0)\n        {\n            t += 1;\n        }\n\n        if (t > 1)\n        {\n            t -= 1;\n        }\n\n        if (t < 1 / 6)\n        {\n            return p + (q - p) * 6 * t;\n        }\n\n        if (t < 1 / 2)\n        {\n            return q;\n        }\n\n        if (t < 2 / 3)\n        {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n\n        return p;\n\n    },\n\n    /**\n    * A utility function to create a lightweight 'color' object with the default components.\n    * Any components that are not specified will default to zero.\n    *\n    * This is useful when you want to use a shared color object for the getPixel and getPixelAt methods.\n    *\n    * @author Matt DesLauriers (@mattdesl)\n    * @method Phaser.Color.createColor\n    * @static\n    * @param {number} [r=0] - The red color component, in the range 0 - 255.\n    * @param {number} [g=0] - The green color component, in the range 0 - 255.\n    * @param {number} [b=0] - The blue color component, in the range 0 - 255.\n    * @param {number} [a=1] - The alpha color component, in the range 0 - 1.\n    * @param {number} [h=0] - The hue, in the range 0 - 1.\n    * @param {number} [s=0] - The saturation, in the range 0 - 1.\n    * @param {number} [l=0] - The lightness, in the range 0 - 1.\n    * @param {number} [v=0] - The value, in the range 0 - 1.\n    * @return {object} The resulting object with r, g, b, a properties and h, s, l and v.\n    */\n    createColor: function (r, g, b, a, h, s, l, v) {\n\n        var out = { r: r || 0, g: g || 0, b: b || 0, a: a || 1, h: h || 0, s: s || 0, l: l || 0, v: v || 0, color: 0 };\n\n        out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + out.a + ')';\n\n        return out;\n\n    },\n\n    /**\n    * Takes a color object and updates the rgba property.\n    *\n    * @method Phaser.Color.updateColor\n    * @static\n    * @param {object} out - The color object to update.\n    * @returns {number} A native color value integer (format: 0xAARRGGBB).\n    */\n    updateColor: function (out) {\n\n        out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + out.a + ')';\n\n        return out;\n\n    },\n\n    /**\n    * Given an alpha and 3 color values this will return an integer representation of it.\n    *\n    * @method Phaser.Color.getColor32\n    * @static\n    * @param {number} a - The alpha color component, in the range 0 - 255.\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @returns {number} A native color value integer (format: 0xAARRGGBB).\n    */\n    getColor32: function (a, r, g, b) {\n\n        return a << 24 | r << 16 | g << 8 | b;\n\n    },\n\n    /**\n    * Given 3 color values this will return an integer representation of it.\n    *\n    * @method Phaser.Color.getColor\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @returns {number} A native color value integer (format: 0xRRGGBB).\n    */\n    getColor: function (r, g, b) {\n\n        return r << 16 | g << 8 | b;\n\n    },\n\n    /**\n    * Converts the given color values into a string.\n    * If prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.\n    *\n    * @method Phaser.Color.RGBtoString\n    * @static\n    * @param {number} r - The red color component, in the range 0 - 255.\n    * @param {number} g - The green color component, in the range 0 - 255.\n    * @param {number} b - The blue color component, in the range 0 - 255.\n    * @param {number} [a=255] - The alpha color component, in the range 0 - 255.\n    * @param {string} [prefix='#'] - The prefix used in the return string. If '#' it will return `#RRGGBB`, else `0xAARRGGBB`.\n    * @return {string} A string containing the color values. If prefix was '#' it will be in the format `#RRGGBB` otherwise `0xAARRGGBB`.\n    */\n    RGBtoString: function (r, g, b, a, prefix) {\n\n        if (typeof a === 'undefined') { a = 255; }\n        if (typeof prefix === 'undefined') { prefix = '#'; }\n\n        if (prefix === '#')\n        {\n            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n        }\n        else\n        {\n            return '0x' + Phaser.Color.componentToHex(a) + Phaser.Color.componentToHex(r) + Phaser.Color.componentToHex(g) + Phaser.Color.componentToHex(b);\n        }\n\n    },\n\n    /**\n    * Converts a hex string into an integer color value.\n    *\n    * @method Phaser.Color.hexToRGB\n    * @static\n    * @param {string} hex - The hex string to convert. Can be in the short-hand format `#03f` or `#0033ff`.\n    * @return {number} The rgb color value in the format 0xAARRGGBB.\n    */\n    hexToRGB: function (hex) {\n\n        var rgb = Phaser.Color.hexToColor(hex);\n\n        if (rgb)\n        {\n            return Phaser.Color.getColor32(rgb.a, rgb.r, rgb.g, rgb.b);\n        }\n\n    },\n\n    /**\n    * Converts a hex string into a Phaser Color object.\n    *\n    * @method Phaser.Color.hexToColor\n    * @static\n    * @param {string} hex - The hex string to convert. Can be in the short-hand format `#03f` or `#0033ff`.\n    * @param {object} [out] - An object into which 3 properties will be created: r, g and b. If not provided a new object will be created.\n    * @return {object} An object with the red, green and blue values set in the r, g and b properties.\n    */\n    hexToColor: function (hex, out) {\n\n        if (!out)\n        {\n            out = Phaser.Color.createColor();\n        }\n\n        // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n        var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n\n        hex = hex.replace(shorthandRegex, function(m, r, g, b) {\n            return r + r + g + g + b + b;\n        });\n\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n        if (result)\n        {\n            out.r = parseInt(result[1], 16);\n            out.g = parseInt(result[2], 16);\n            out.b = parseInt(result[3], 16);\n        }\n\n        return out;\n\n    },\n\n    /**\n    * Return a string containing a hex representation of the given color component.\n    *\n    * @method Phaser.Color.componentToHex\n    * @static\n    * @param {number} color - The color channel to get the hex value for, must be a value between 0 and 255.\n    * @returns {string} A string of length 2 characters, i.e. 255 = ff, 100 = 64.\n    */\n    componentToHex: function (color) {\n\n        var hex = color.toString(16);\n        return hex.length == 1 ? \"0\" + hex : hex;\n\n    },\n\n    /**\n    * Get HSV color wheel values in an array which will be 360 elements in size.\n    *\n    * @method Phaser.Color.HSVColorWheel\n    * @static\n    * @param {number} [s=1] - The saturation, in the range 0 - 1.\n    * @param {number} [v=1] - The value, in the range 0 - 1.\n    * @return {array} An array containing 360 elements corresponding to the HSV color wheel.\n    */\n    HSVColorWheel: function (s, v) {\n\n        if (typeof s === 'undefined') { s = 1.0; }\n        if (typeof v === 'undefined') { v = 1.0; }\n\n        var colors = [];\n\n        for (var c = 0; c <= 359; c++)\n        {\n            colors.push(Phaser.Color.HSVtoRGB(c / 359, s, v));\n        }\n\n        return colors;\n\n    },\n\n    /**\n    * Get HSL color wheel values in an array which will be 360 elements in size.\n    *\n    * @method Phaser.Color.HSLColorWheel\n    * @static\n    * @param {number} [s=0.5] - The saturation, in the range 0 - 1.\n    * @param {number} [l=0.5] - The lightness, in the range 0 - 1.\n    * @return {array} An array containing 360 elements corresponding to the HSL color wheel.\n    */\n    HSLColorWheel: function (s, l) {\n\n        if (typeof s === 'undefined') { s = 0.5; }\n        if (typeof l === 'undefined') { l = 0.5; }\n\n        var colors = [];\n\n        for (var c = 0; c <= 359; c++)\n        {\n            colors.push(Phaser.Color.HSLtoRGB(c / 359, s, l));\n        }\n\n        return colors;\n\n    },\n\n    /**\n    * Interpolates the two given colours based on the supplied step and currentStep properties.\n    *\n    * @method Phaser.Color.interpolateColor\n    * @static\n    * @param {number} color1 - The first color value.\n    * @param {number} color2 - The second color value.\n    * @param {number} steps - The number of steps to run the interpolation over.\n    * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.\n    * @param {number} alpha - The alpha of the returned color.\n    * @returns {number} The interpolated color value.\n    */\n    interpolateColor: function (color1, color2, steps, currentStep, alpha) {\n\n        if (typeof alpha === \"undefined\") { alpha = 255; }\n\n        var src1 = Phaser.Color.getRGB(color1);\n        var src2 = Phaser.Color.getRGB(color2);\n        var r = (((src2.red - src1.red) * currentStep) / steps) + src1.red;\n        var g = (((src2.green - src1.green) * currentStep) / steps) + src1.green;\n        var b = (((src2.blue - src1.blue) * currentStep) / steps) + src1.blue;\n\n        return Phaser.Color.getColor32(alpha, r, g, b);\n\n    },\n\n    /**\n    * Interpolates the two given colours based on the supplied step and currentStep properties.\n    * @method Phaser.Color.interpolateColorWithRGB\n    * @static\n    * @param {number} color - The first color value.\n    * @param {number} r - The red color value, between 0 and 0xFF (255).\n    * @param {number} g - The green color value, between 0 and 0xFF (255).\n    * @param {number} b - The blue color value, between 0 and 0xFF (255).\n    * @param {number} steps - The number of steps to run the interpolation over.\n    * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.\n    * @returns {number} The interpolated color value.\n    */\n    interpolateColorWithRGB: function (color, r, g, b, steps, currentStep) {\n\n        var src = Phaser.Color.getRGB(color);\n        var or = (((r - src.red) * currentStep) / steps) + src.red;\n        var og = (((g - src.green) * currentStep) / steps) + src.green;\n        var ob = (((b - src.blue) * currentStep) / steps) + src.blue;\n\n        return Phaser.Color.getColor(or, og, ob);\n\n    },\n\n    /**\n    * Interpolates the two given colours based on the supplied step and currentStep properties.\n    * @method Phaser.Color.interpolateRGB\n    * @static\n    * @param {number} r1 - The red color value, between 0 and 0xFF (255).\n    * @param {number} g1 - The green color value, between 0 and 0xFF (255).\n    * @param {number} b1 - The blue color value, between 0 and 0xFF (255).\n    * @param {number} r2 - The red color value, between 0 and 0xFF (255).\n    * @param {number} g2 - The green color value, between 0 and 0xFF (255).\n    * @param {number} b2 - The blue color value, between 0 and 0xFF (255).\n    * @param {number} steps - The number of steps to run the interpolation over.\n    * @param {number} currentStep - The currentStep value. If the interpolation will take 100 steps, a currentStep value of 50 would be half-way between the two.\n    * @returns {number} The interpolated color value.\n    */\n    interpolateRGB: function (r1, g1, b1, r2, g2, b2, steps, currentStep) {\n\n        var r = (((r2 - r1) * currentStep) / steps) + r1;\n        var g = (((g2 - g1) * currentStep) / steps) + g1;\n        var b = (((b2 - b1) * currentStep) / steps) + b1;\n\n        return Phaser.Color.getColor(r, g, b);\n\n    },\n\n    /**\n    * Returns a random color value between black and white\n    * Set the min value to start each channel from the given offset.\n    * Set the max value to restrict the maximum color used per channel.\n    *\n    * @method Phaser.Color.getRandomColor\n    * @static\n    * @param {number} min - The lowest value to use for the color.\n    * @param {number} max - The highest value to use for the color.\n    * @param {number} alpha - The alpha value of the returning color (default 255 = fully opaque).\n    * @returns {number} 32-bit color value with alpha.\n    */\n    getRandomColor: function (min, max, alpha) {\n\n        if (typeof min === \"undefined\") { min = 0; }\n        if (typeof max === \"undefined\") { max = 255; }\n        if (typeof alpha === \"undefined\") { alpha = 255; }\n\n        //  Sanity checks\n        if (max > 255 || min > max)\n        {\n            return Phaser.Color.getColor(255, 255, 255);\n        }\n\n        var red = min + Math.round(Math.random() * (max - min));\n        var green = min + Math.round(Math.random() * (max - min));\n        var blue = min + Math.round(Math.random() * (max - min));\n\n        return Phaser.Color.getColor32(alpha, red, green, blue);\n\n    },\n\n    /**\n    * Return the component parts of a color as an Object with the properties alpha, red, green, blue\n    *\n    * Alpha will only be set if it exist in the given color (0xAARRGGBB)\n    *\n    * @method Phaser.Color.getRGB\n    * @static\n    * @param {number} color - Color in RGB (0xRRGGBB) or ARGB format (0xAARRGGBB).\n    * @returns {object} An Object with properties: alpha, red, green, blue.\n    */\n    getRGB: function (color) {\n\n        return {\n            alpha: color >>> 24,\n            red: color >> 16 & 0xFF,\n            green: color >> 8 & 0xFF,\n            blue: color & 0xFF\n        };\n\n    },\n\n    /**\n    * Returns a CSS friendly string value from the given color.\n    * @method Phaser.Color.getWebRGB\n    * @static\n    * @param {number} color\n    * @returns {string}A string in the format: 'rgba(r,g,b,a)'\n    */\n    getWebRGB: function (color) {\n\n        var alpha = (color >>> 24) / 255;\n        var red = color >> 16 & 0xFF;\n        var green = color >> 8 & 0xFF;\n        var blue = color & 0xFF;\n\n        return 'rgba(' + red.toString() + ',' + green.toString() + ',' + blue.toString() + ',' + alpha.toString() + ')';\n\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getAlpha\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent)).\n    */\n    getAlpha: function (color) {\n        return color >>> 24;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component as a value between 0 and 1.\n    *\n    * @method Phaser.Color.getAlphaFloat\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent)).\n    */\n    getAlphaFloat: function (color) {\n        return (color >>> 24) / 255;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Red component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getRed\n    * @static\n    * @param {number} color In the format 0xAARRGGBB.\n    * @returns {number} The Red component of the color, will be between 0 and 255 (0 being no color, 255 full Red).\n    */\n    getRed: function (color) {\n        return color >> 16 & 0xFF;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Green component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getGreen\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Green component of the color, will be between 0 and 255 (0 being no color, 255 full Green).\n    */\n    getGreen: function (color) {\n        return color >> 8 & 0xFF;\n    },\n\n    /**\n    * Given a native color value (in the format 0xAARRGGBB) this will return the Blue component, as a value between 0 and 255.\n    *\n    * @method Phaser.Color.getBlue\n    * @static\n    * @param {number} color - In the format 0xAARRGGBB.\n    * @returns {number} The Blue component of the color, will be between 0 and 255 (0 being no color, 255 full Blue).\n    */\n    getBlue: function (color) {\n        return color & 0xFF;\n    },\n\n    //   The following are all DEPRECATED\n\n    /**\n    * DEPRECATED: This method will be removed in Phaser 2.1.\n    * Returns a string containing handy information about the given color including string hex value,\n    * RGB format information. Each section starts on a newline, 3 lines in total.\n    *\n    * @method Phaser.Color.getColorInfo\n    * @static\n    * @param {number} color - A color value in the format 0xAARRGGBB.\n    * @returns {string} String containing the 3 lines of information.\n    */\n    getColorInfo: function (color) {\n\n        var argb = Phaser.Color.getRGB(color);\n\n        //  Hex format\n        var result = Phaser.Color.RGBtoHexstring(color) + \"\\n\";\n\n        //  RGB format\n        result = result.concat(\"Alpha: \" + argb.alpha + \" Red: \" + argb.red + \" Green: \" + argb.green + \" Blue: \" + argb.blue) + \"\\n\";\n\n        return result;\n\n    },\n\n    /**\n    * DEPRECATED: This method will be removed in Phaser 2.1. Please use Phaser.Color.RGBtoString instead.\n    * Return a string representation of the color in the format 0xAARRGGBB.\n    *\n    * @method Phaser.Color.RGBtoHexstring\n    * @static\n    * @param {number} color - The color to get the string representation for\n    * @returns {string} A string of length 10 characters in the format 0xAARRGGBB\n    */\n    RGBtoHexstring: function (color) {\n\n        var argb = Phaser.Color.getRGB(color);\n\n        return \"0x\" + Phaser.Color.colorToHexstring(argb.alpha) + Phaser.Color.colorToHexstring(argb.red) + Phaser.Color.colorToHexstring(argb.green) + Phaser.Color.colorToHexstring(argb.blue);\n\n    },\n\n    /**\n    * DEPRECATED: This method will be removed in Phaser 2.1. Please use Phaser.Color.RGBtoString instead.\n    * Return a string representation of the color in the format #RRGGBB.\n    *\n    * @method Phaser.Color.RGBtoWebstring\n    * @static\n    * @param {number} color - The color to get the string representation for.\n    * @returns {string} A string of length 10 characters in the format 0xAARRGGBB.\n    */\n    RGBtoWebstring: function (color) {\n\n        var argb = Phaser.Color.getRGB(color);\n\n        return \"#\" + Phaser.Color.colorToHexstring(argb.red) + Phaser.Color.colorToHexstring(argb.green) + Phaser.Color.colorToHexstring(argb.blue);\n\n    },\n\n    /**\n    * DEPRECATED: This method will be removed in Phaser 2.1. Please use Phaser.Color.componentToHex instead.\n    * Return a string containing a hex representation of the given color.\n    *\n    * @method Phaser.Color.colorToHexstring\n    * @static\n    * @param {number} color - The color channel to get the hex value for, must be a value between 0 and 255).\n    * @returns {string} A string of length 2 characters, i.e. 255 = FF, 0 = 00.\n    */\n    colorToHexstring: function (color) {\n\n        var digits = \"0123456789ABCDEF\";\n        var lsd = color % 16;\n        var msd = (color - lsd) / 16;\n        var hexified = digits.charAt(msd) + digits.charAt(lsd);\n        return hexified;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Physics Manager is responsible for looking after all of the running physics systems.\n* Phaser supports 3 physics systems: Arcade Physics, P2 and Ninja Physics (with Box2D and Chipmunk in development)\n* Game Objects can belong to only 1 physics system, but you can have multiple systems active in a single game.\n*\n* For example you could have P2 managing a polygon-built terrain landscape that an vehicle drives over, while it could be firing bullets that use the\n* faster (due to being much simpler) Arcade Physics system.\n*\n* @class Phaser.Physics\n*\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n* @param {object} [physicsConfig=null] - A physics configuration object to pass to the Physics world on creation.\n*/\nPhaser.Physics = function (game, config) {\n\n    config = config || {};\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {object} config - The physics configuration object as passed to the game on creation.\n    */\n    this.config = config;\n\n    /**\n    * @property {Phaser.Physics.Arcade} arcade - The Arcade Physics system.\n    */\n    this.arcade = null;\n\n    /**\n    * @property {Phaser.Physics.P2} p2 - The P2.JS Physics system.\n    */\n    this.p2 = null;\n\n    /**\n    * @property {Phaser.Physics.Ninja} ninja - The N+ Ninja Physics System.\n    */\n    this.ninja = null;\n\n    /**\n    * @property {Phaser.Physics.Box2D} box2d - The Box2D Physics system (to be done).\n    */\n    this.box2d = null;\n\n    /**\n    * @property {Phaser.Physics.Chipmunk} chipmunk - The Chipmunk Physics system (to be done).\n    */\n    this.chipmunk = null;\n\n    this.parseConfig();\n\n};\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.ARCADE = 0;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.P2JS = 1;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.NINJA = 2;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.BOX2D = 3;\n\n/**\n* @const\n* @type {number}\n*/\nPhaser.Physics.CHIPMUNK = 5;\n\nPhaser.Physics.prototype = {\n\n    /**\n    * Parses the Physics Configuration object passed to the Game constructor and starts any physics systems specified within.\n    *\n    * @method Phaser.Physics#parseConfig\n    */\n    parseConfig: function () {\n\n        if ((!this.config.hasOwnProperty('arcade') || this.config['arcade'] === true) && Phaser.Physics.hasOwnProperty('Arcade'))\n        {\n            //  If Arcade isn't specified, we create it automatically if we can\n            this.arcade = new Phaser.Physics.Arcade(this.game);\n            this.game.time.deltaCap = 0.2;\n        }\n\n        if (this.config.hasOwnProperty('ninja') && this.config['ninja'] === true && Phaser.Physics.hasOwnProperty('Ninja'))\n        {\n            this.ninja = new Phaser.Physics.Ninja(this.game);\n        }\n\n        if (this.config.hasOwnProperty('p2') && this.config['p2'] === true && Phaser.Physics.hasOwnProperty('P2'))\n        {\n            this.p2 = new Phaser.Physics.P2(this.game, this.config);\n        }\n\n    },\n\n    /**\n    * This will create an instance of the requested physics simulation.\n    * Phaser.Physics.Arcade is running by default, but all others need activating directly.\n    * You can start the following physics systems:\n    * Phaser.Physics.P2JS - A full-body advanced physics system by Stefan Hedman.\n    * Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system.\n    * Phaser.Physics.BOX2D and Phaser.Physics.CHIPMUNK are still in development.\n    *\n    * @method Phaser.Physics#startSystem\n    * @param {number} The physics system to start.\n    */\n    startSystem: function (system) {\n\n        if (system === Phaser.Physics.ARCADE)\n        {\n            this.arcade = new Phaser.Physics.Arcade(this.game);\n        }\n        else if (system === Phaser.Physics.P2JS)\n        {\n            this.p2 = new Phaser.Physics.P2(this.game, this.config);\n        }\n        if (system === Phaser.Physics.NINJA)\n        {\n            this.ninja = new Phaser.Physics.Ninja(this.game);\n        }\n        else if (system === Phaser.Physics.BOX2D && this.box2d === null)\n        {\n            throw new Error('The Box2D physics system has not been implemented yet.');\n        }\n        else if (system === Phaser.Physics.CHIPMUNK && this.chipmunk === null)\n        {\n            throw new Error('The Chipmunk physics system has not been implemented yet.');\n        }\n\n    },\n\n    /**\n    * This will create a default physics body on the given game object or array of objects.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    * It can be for any of the physics systems that have been started:\n    *\n    * Phaser.Physics.Arcade - A light weight AABB based collision system with basic separation.\n    * Phaser.Physics.P2JS - A full-body advanced physics system supporting multiple object shapes, polygon loading, contact materials, springs and constraints.\n    * Phaser.Physics.NINJA - A port of Metanet Softwares N+ physics system. Advanced AABB and Circle vs. Tile collision.\n    * Phaser.Physics.BOX2D and Phaser.Physics.CHIPMUNK are still in development.\n    *\n    * If you require more control over what type of body is created, for example to create a Ninja Physics Circle instead of the default AABB, then see the\n    * individual physics systems `enable` methods instead of using this generic one.\n    *\n    * @method Phaser.Physics#enable\n    * @param {object|array} object - The game object to create the physics body on. Can also be an array of objects, a body will be created on every object in the array.\n    * @param {number} [system=Phaser.Physics.ARCADE] - The physics system that will be used to create the body. Defaults to Arcade Physics.\n    * @param {boolean} [debug=false] - Enable the debug drawing for this body. Defaults to false.\n    */\n    enable: function (object, system, debug) {\n\n        if (typeof system === 'undefined') { system = Phaser.Physics.ARCADE; }\n        if (typeof debug === 'undefined') { debug = false; }\n\n        if (system === Phaser.Physics.ARCADE)\n        {\n            this.arcade.enable(object);\n        }\n        else if (system === Phaser.Physics.P2JS && this.p2)\n        {\n            this.p2.enable(object, debug);\n        }\n        else if (system === Phaser.Physics.NINJA && this.ninja)\n        {\n            this.ninja.enableAABB(object);\n        }\n\n    },\n\n    /**\n    * preUpdate checks.\n    *\n    * @method Phaser.Physics#preUpdate\n    * @protected\n    */\n    preUpdate: function () {\n\n        //  ArcadePhysics / Ninja don't have a core to preUpdate\n\n        if (this.p2)\n        {\n            this.p2.preUpdate();\n        }\n\n    },\n\n    /**\n    * Updates all running physics systems.\n    *\n    * @method Phaser.Physics#update\n    * @protected\n    */\n    update: function () {\n\n        //  ArcadePhysics / Ninja don't have a core to update\n\n        if (this.p2)\n        {\n            this.p2.update();\n        }\n\n    },\n\n    /**\n    * Updates the physics bounds to match the world dimensions.\n    *\n    * @method Phaser.Physics#setBoundsToWorld\n    * @protected\n    */\n    setBoundsToWorld: function () {\n\n        if (this.arcade)\n        {\n            this.arcade.setBoundsToWorld();\n        }\n\n        if (this.ninja)\n        {\n            this.ninja.setBoundsToWorld();\n        }\n\n        if (this.p2)\n        {\n            this.p2.setBoundsToWorld();\n        }\n\n    },\n\n    /**\n    * Clears down all active physics systems. This doesn't destroy them, it just clears them of objects and is called when the State changes.\n    *\n    * @method Phaser.Physics#clear\n    * @protected\n    */\n    clear: function () {\n\n        if (this.p2)\n        {\n            this.p2.clear();\n        }\n\n    },\n\n    /**\n    * Destroys all active physics systems. Usually only called on a Game Shutdown, not on a State swap.\n    *\n    * @method Phaser.Physics#destroy\n    */\n    destroy: function () {\n\n        if (this.p2)\n        {\n            this.p2.destroy();\n        }\n\n        this.arcade = null;\n        this.ninja = null;\n        this.p2 = null;\n\n    }\n\n};\n\nPhaser.Physics.prototype.constructor = Phaser.Physics;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Arcade Physics constructor.\n*\n* @class Phaser.Physics.Arcade\n* @classdesc Arcade Physics Constructor\n* @constructor\n* @param {Phaser.Game} game reference to the current game instance.\n*/\nPhaser.Physics.Arcade = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Point} gravity - The World gravity setting. Defaults to x: 0, y: 0, or no gravity.\n    */\n    this.gravity = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Rectangle} bounds - The bounds inside of which the physics world exists. Defaults to match the world bounds.\n    */\n    this.bounds = new Phaser.Rectangle(0, 0, game.world.width, game.world.height);\n\n    /**\n    * Set the checkCollision properties to control for which bounds collision is processed.\n    * For example checkCollision.down = false means Bodies cannot collide with the World.bounds.bottom.\n    * @property {object} checkCollision - An object containing allowed collision flags.\n    */\n    this.checkCollision = { up: true, down: true, left: true, right: true };\n\n    /**\n    * @property {number} maxObjects - Used by the QuadTree to set the maximum number of objects per quad.\n    */\n    this.maxObjects = 10;\n\n    /**\n    * @property {number} maxLevels - Used by the QuadTree to set the maximum number of iteration levels.\n    */\n    this.maxLevels = 4;\n\n    /**\n    * @property {number} OVERLAP_BIAS - A value added to the delta values during collision checks.\n    */\n    this.OVERLAP_BIAS = 4;\n\n    /**\n    * @property {number} TILE_BIAS - A value added to the delta values during collision with tiles. Adjust this if you get tunnelling.\n    */\n    this.TILE_BIAS = 16;\n\n    /**\n    * @property {boolean} forceX - If true World.separate will always separate on the X axis before Y. Otherwise it will check gravity totals first.\n    */\n    this.forceX = false;\n\n    /**\n    * @property {Phaser.QuadTree} quadTree - The world QuadTree.\n    */\n    this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);\n\n    //  Avoid gc spikes by caching these values for re-use\n\n    /**\n    * @property {number} _overlap - Internal cache var.\n    * @private\n    */\n    this._overlap = 0;\n\n    /**\n    * @property {number} _maxOverlap - Internal cache var.\n    * @private\n    */\n    this._maxOverlap = 0;\n\n    /**\n    * @property {number} _velocity1 - Internal cache var.\n    * @private\n    */\n    this._velocity1 = 0;\n\n    /**\n    * @property {number} _velocity2 - Internal cache var.\n    * @private\n    */\n    this._velocity2 = 0;\n\n    /**\n    * @property {number} _newVelocity1 - Internal cache var.\n    * @private\n    */\n    this._newVelocity1 = 0;\n\n    /**\n    * @property {number} _newVelocity2 - Internal cache var.\n    * @private\n    */\n    this._newVelocity2 = 0;\n\n    /**\n    * @property {number} _average - Internal cache var.\n    * @private\n    */\n    this._average = 0;\n\n    /**\n    * @property {Array} _mapData - Internal cache var.\n    * @private\n    */\n    this._mapData = [];\n\n    /**\n    * @property {boolean} _result - Internal cache var.\n    * @private\n    */\n    this._result = false;\n\n    /**\n    * @property {number} _total - Internal cache var.\n    * @private\n    */\n    this._total = 0;\n\n    /**\n    * @property {number} _angle - Internal cache var.\n    * @private\n    */\n    this._angle = 0;\n\n    /**\n    * @property {number} _dx - Internal cache var.\n    * @private\n    */\n    this._dx = 0;\n\n    /**\n    * @property {number} _dy - Internal cache var.\n    * @private\n    */\n    this._dy = 0;\n\n};\n\nPhaser.Physics.Arcade.prototype.constructor = Phaser.Physics.Arcade;\n\nPhaser.Physics.Arcade.prototype = {\n\n    /**\n    * Updates the size of this physics world.\n    *\n    * @method Phaser.Physics.Arcade#setBounds\n    * @param {number} x - Top left most corner of the world.\n    * @param {number} y - Top left most corner of the world.\n    * @param {number} width - New width of the world. Can never be smaller than the Game.width.\n    * @param {number} height - New height of the world. Can never be smaller than the Game.height.\n    */\n    setBounds: function (x, y, width, height) {\n\n        this.bounds.setTo(x, y, width, height);\n\n    },\n\n    /**\n    * Updates the size of this physics world to match the size of the game world.\n    *\n    * @method Phaser.Physics.Arcade#setBoundsToWorld\n    */\n    setBoundsToWorld: function () {\n\n        this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);\n\n    },\n\n    /**\n    * This will create an Arcade Physics body on the given game object or array of game objects.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    *\n    * @method Phaser.Physics.Arcade#enable\n    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\n    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\n    */\n    enable: function (object, children) {\n\n        if (typeof children === 'undefined') { children = true; }\n\n        var i = 1;\n\n        if (Array.isArray(object))\n        {\n            i = object.length;\n\n            while (i--)\n            {\n                if (object[i] instanceof Phaser.Group)\n                {\n                    //  If it's a Group then we do it on the children regardless\n                    this.enable(object[i].children, children);\n                }\n                else\n                {\n                    this.enableBody(object[i]);\n\n                    if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0)\n                    {\n                        this.enable(object[i], true);\n                    }\n                }\n            }\n        }\n        else\n        {\n            if (object instanceof Phaser.Group)\n            {\n                //  If it's a Group then we do it on the children regardless\n                this.enable(object.children, children);\n            }\n            else\n            {\n                this.enableBody(object);\n\n                if (children && object.hasOwnProperty('children') && object.children.length > 0)\n                {\n                    this.enable(object.children, true);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Creates an Arcade Physics body on the given game object.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.\n    *\n    * @method Phaser.Physics.Arcade#enableBody\n    * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.\n    */\n    enableBody: function (object) {\n\n        if (object.hasOwnProperty('body') && object.body === null)\n        {\n            object.body = new Phaser.Physics.Arcade.Body(object);\n        }\n\n    },\n\n    /**\n    * Called automatically by a Physics body, it updates all motion related values on the Body.\n    *\n    * @method Phaser.Physics.Arcade#updateMotion\n    * @param {Phaser.Physics.Arcade.Body} The Body object to be updated.\n    */\n    updateMotion: function (body) {\n\n        this._velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular) - body.angularVelocity;\n        body.angularVelocity += this._velocityDelta;\n        body.rotation += (body.angularVelocity * this.game.time.physicsElapsed);\n\n        body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x);\n        body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y);\n\n    },\n\n    /**\n    * A tween-like function that takes a starting velocity and some other factors and returns an altered velocity.\n    * Based on a function in Flixel by @ADAMATOMIC\n    *\n    * @method Phaser.Physics.Arcade#computeVelocity\n    * @param {number} axis - 0 for nothing, 1 for horizontal, 2 for vertical.\n    * @param {Phaser.Physics.Arcade.Body} body - The Body object to be updated.\n    * @param {number} velocity - Any component of velocity (e.g. 20).\n    * @param {number} acceleration - Rate at which the velocity is changing.\n    * @param {number} drag - Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.\n    * @param {number} [max=10000] - An absolute value cap for the velocity.\n    * @return {number} The altered Velocity value.\n    */\n    computeVelocity: function (axis, body, velocity, acceleration, drag, max) {\n\n        max = max || 10000;\n\n        if (axis == 1 && body.allowGravity)\n        {\n            velocity += (this.gravity.x + body.gravity.x) * this.game.time.physicsElapsed;\n        }\n        else if (axis == 2 && body.allowGravity)\n        {\n            velocity += (this.gravity.y + body.gravity.y) * this.game.time.physicsElapsed;\n        }\n\n        if (acceleration)\n        {\n            velocity += acceleration * this.game.time.physicsElapsed;\n        }\n        else if (drag)\n        {\n            this._drag = drag * this.game.time.physicsElapsed;\n\n            if (velocity - this._drag > 0)\n            {\n                velocity -= this._drag;\n            }\n            else if (velocity + this._drag < 0)\n            {\n                velocity += this._drag;\n            }\n            else\n            {\n                velocity = 0;\n            }\n        }\n\n        if (velocity > max)\n        {\n            velocity = max;\n        }\n        else if (velocity < -max)\n        {\n            velocity = -max;\n        }\n\n        return velocity;\n\n    },\n\n    /**\n    * Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.\n    * You can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.\n    * Unlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.\n    * The second parameter can be an array of objects, of differing types.\n    *\n    * @method Phaser.Physics.Arcade#overlap\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter} object1 - The first object to check. Can be an instance of Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|array} object2 - The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.\n    * @param {function} [overlapCallback=null] - An optional callback function that is called if the objects overlap. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then overlapCallback will only be called if processCallback returns true.\n    * @param {object} [callbackContext] - The context in which to run the callbacks.\n    * @return {boolean} True if an overlap occured otherwise false.\n    */\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext) {\n\n        overlapCallback = overlapCallback || null;\n        processCallback = processCallback || null;\n        callbackContext = callbackContext || overlapCallback;\n\n        this._result = false;\n        this._total = 0;\n\n        if (Array.isArray(object2))\n        {\n            for (var i = 0,  len = object2.length; i < len; i++)\n            {\n                this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, true);\n            }\n        }\n        else\n        {\n            this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, true);\n        }\n\n        return (this._total > 0);\n\n    },\n\n    /**\n    * Checks for collision between two game objects. You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.\n    * The second parameter can be an array of objects, of differing types.\n    * The objects are also automatically separated. If you don't require separation then use ArcadePhysics.overlap instead.\n    * An optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,\n    * giving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.\n    * The collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.\n    *\n    * @method Phaser.Physics.Arcade#collide\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap} object1 - The first object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter, or Phaser.Tilemap.\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap|array} object2 - The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter or Phaser.Tilemap.\n    * @param {function} [collideCallback=null] - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them, unless you are colliding Group vs. Sprite, in which case Sprite will always be the first parameter.\n    * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} [callbackContext] - The context in which to run the callbacks.\n    * @return {boolean} True if a collision occured otherwise false.\n    */\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext) {\n\n        collideCallback = collideCallback || null;\n        processCallback = processCallback || null;\n        callbackContext = callbackContext || collideCallback;\n\n        this._result = false;\n        this._total = 0;\n\n        if (Array.isArray(object2))\n        {\n            for (var i = 0,  len = object2.length; i < len; i++)\n            {\n                this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, false);\n            }\n        }\n        else\n        {\n            this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false);\n        }\n\n        return (this._total > 0);\n\n    },\n\n    /**\n    * Internal collision handler.\n    *\n    * @method Phaser.Physics.Arcade#collideHandler\n    * @private\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap} object1 - The first object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter, or Phaser.Tilemap.\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap} object2 - The second object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter or Phaser.Tilemap. Can also be an array of objects to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    */\n    collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        //  Only collide valid objects\n        if (typeof object2 === 'undefined' && (object1.type === Phaser.GROUP || object1.type === Phaser.EMITTER))\n        {\n            this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);\n            return;\n        }\n\n        if (object1 && object2 && object1.exists && object2.exists)\n        {\n            //  SPRITES\n            if (object1.type == Phaser.SPRITE || object1.type == Phaser.TILESPRITE)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.TILEMAPLAYER)\n                {\n                    this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);\n                }\n            }\n            //  GROUPS\n            else if (object1.type == Phaser.GROUP)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.TILEMAPLAYER)\n                {\n                    this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);\n                }\n            }\n            //  TILEMAP LAYERS\n            else if (object1.type == Phaser.TILEMAPLAYER)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);\n                }\n            }\n            //  EMITTER\n            else if (object1.type == Phaser.EMITTER)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.TILEMAPLAYER)\n                {\n                    this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Arcade.collide instead.\n    *\n    * @method Phaser.Physics.Arcade#collideSpriteVsSprite\n    * @private\n    * @param {Phaser.Sprite} sprite1 - The first sprite to check.\n    * @param {Phaser.Sprite} sprite2 - The second sprite to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    * @return {boolean} True if there was a collision, otherwise false.\n    */\n    collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (!sprite1.body || !sprite2.body)\n        {\n            return false;\n        }\n\n        if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly))\n        {\n            if (collideCallback)\n            {\n                collideCallback.call(callbackContext, sprite1, sprite2);\n            }\n\n            this._total++;\n        }\n\n        return true;\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Arcade.collide instead.\n    *\n    * @method Phaser.Physics.Arcade#collideSpriteVsGroup\n    * @private\n    * @param {Phaser.Sprite} sprite - The sprite to check.\n    * @param {Phaser.Group} group - The Group to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    */\n    collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (group.length === 0 || !sprite.body)\n        {\n            return;\n        }\n\n        //  What is the sprite colliding with in the quadtree?\n        this.quadTree.clear();\n\n        this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);\n\n        this.quadTree.populate(group);\n\n        this._potentials = this.quadTree.retrieve(sprite);\n\n        for (var i = 0, len = this._potentials.length; i < len; i++)\n        {\n            //  We have our potential suspects, are they in this group?\n            if (this.separate(sprite.body, this._potentials[i], processCallback, callbackContext, overlapOnly))\n            {\n                if (collideCallback)\n                {\n                    collideCallback.call(callbackContext, sprite, this._potentials[i].sprite);\n                }\n\n                this._total++;\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Arcade.collide instead.\n    *\n    * @method Phaser.Physics.Arcade#collideGroupVsSelf\n    * @private\n    * @param {Phaser.Group} group - The Group to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    * @return {boolean} True if there was a collision, otherwise false.\n    */\n    collideGroupVsSelf: function (group, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (group.length === 0)\n        {\n            return;\n        }\n\n        var len = group.children.length;\n\n        for (var i = 0; i < len; i++)\n        {\n            for (var j = i + 1; j <= len; j++)\n            {\n                if (group.children[i] && group.children[j] && group.children[i].exists && group.children[j].exists)\n                {\n                    this.collideSpriteVsSprite(group.children[i], group.children[j], collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Arcade.collide instead.\n    *\n    * @method Phaser.Physics.Arcade#collideGroupVsGroup\n    * @private\n    * @param {Phaser.Group} group1 - The first Group to check.\n    * @param {Phaser.Group} group2 - The second Group to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    */\n    collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (group1.length === 0 || group2.length === 0)\n        {\n            return;\n        }\n\n        for (var i = 0, len = group1.children.length; i < len; i++)\n        {\n            if (group1.children[i].exists)\n            {\n                this.collideSpriteVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Arcade.collide instead.\n    *\n    * @method Phaser.Physics.Arcade#collideSpriteVsTilemapLayer\n    * @private\n    * @param {Phaser.Sprite} sprite - The sprite to check.\n    * @param {Phaser.TilemapLayer} tilemapLayer - The layer to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    */\n    collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext) {\n\n        if (!sprite.body)\n        {\n            return;\n        }\n\n        this._mapData = tilemapLayer.getTiles(\n            sprite.body.position.x - sprite.body.tilePadding.x,\n            sprite.body.position.y - sprite.body.tilePadding.y,\n            sprite.body.width + sprite.body.tilePadding.x,\n            sprite.body.height + sprite.body.tilePadding.y,\n            false, false);\n\n        if (this._mapData.length === 0)\n        {\n            return;\n        }\n\n        for (var i = 0; i < this._mapData.length; i++)\n        {\n            if (this.separateTile(i, sprite.body, this._mapData[i]))\n            {\n                //  They collided, is there a custom process callback?\n                if (processCallback)\n                {\n                    if (processCallback.call(callbackContext, sprite, this._mapData[i]))\n                    {\n                        this._total++;\n\n                        if (collideCallback)\n                        {\n                            collideCallback.call(callbackContext, sprite, this._mapData[i]);\n                        }\n                    }\n                }\n                else\n                {\n                    this._total++;\n\n                    if (collideCallback)\n                    {\n                        collideCallback.call(callbackContext, sprite, this._mapData[i]);\n                    }\n                }\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Arcade.collide instead.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#collideGroupVsTilemapLayer\n    * @param {Phaser.Group} group - The Group to check.\n    * @param {Phaser.TilemapLayer} tilemapLayer - The layer to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    */\n    collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext) {\n\n        if (group.length === 0)\n        {\n            return;\n        }\n\n        for (var i = 0, len = group.children.length; i < len; i++)\n        {\n            if (group.children[i].exists)\n            {\n                this.collideSpriteVsTilemapLayer(group.children[i], tilemapLayer, collideCallback, processCallback, callbackContext);\n            }\n        }\n\n    },\n\n    /**\n    * The core separation function to separate two physics bodies.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#separate\n    * @param {Phaser.Physics.Arcade.Body} body1 - The first Body object to separate.\n    * @param {Phaser.Physics.Arcade.Body} body2 - The second Body object to separate.\n    * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this function is set then the sprites will only be collided if it returns true.\n    * @param {object} [callbackContext] - The context in which to run the process callback.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    * @return {boolean} Returns true if the bodies collided, otherwise false.\n    */\n    separate: function (body1, body2, processCallback, callbackContext, overlapOnly) {\n\n        if (!this.intersects(body1, body2))\n        {\n            return false;\n        }\n\n        //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\n        if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false)\n        {\n            return false;\n        }\n\n        if (overlapOnly)\n        {\n            //  We already know they intersect from the check above, and we don't need separation, so ...\n            return true;\n        }\n\n        //  Do we separate on x or y first?\n        //  If we weren't having to carry around so much legacy baggage with us, we could do this properly. But alas ...\n        if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x))\n        {\n            this._result = (this.separateX(body1, body2, overlapOnly) || this.separateY(body1, body2, overlapOnly));\n        }\n        else\n        {\n            this._result = (this.separateY(body1, body2, overlapOnly) || this.separateX(body1, body2, overlapOnly));\n        }\n\n        return this._result;\n\n    },\n\n    /**\n    * Check for intersection against two bodies.\n    *\n    * @method Phaser.Physics.Arcade#intersects\n    * @param {Phaser.Physics.Arcade.Body} body1 - The Body object to check.\n    * @param {Phaser.Physics.Arcade.Body} body2 - The Body object to check.\n    * @return {boolean} True if they intersect, otherwise false.\n    */\n    intersects: function (body1, body2) {\n\n        if (body1.right <= body2.position.x)\n        {\n            return false;\n        }\n\n        if (body1.bottom <= body2.position.y)\n        {\n            return false;\n        }\n\n        if (body1.position.x >= body2.right)\n        {\n            return false;\n        }\n\n        if (body1.position.y >= body2.bottom)\n        {\n            return false;\n        }\n\n        return true;\n\n    },\n\n    /**\n    * The core separation function to separate two physics bodies on the x axis.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#separateX\n    * @param {Phaser.Physics.Arcade.Body} body1 - The Body object to separate.\n    * @param {Phaser.Physics.Arcade.Body} body2 - The Body object to separate.\n    * @param {boolean} overlapOnly - If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.\n    * @return {boolean} Returns true if the bodies were separated, otherwise false.\n    */\n    separateX: function (body1, body2, overlapOnly) {\n\n        //  Can't separate two immovable bodies\n        if (body1.immovable && body2.immovable)\n        {\n            return false;\n        }\n\n        this._overlap = 0;\n\n        //  Check if the hulls actually overlap\n        if (this.intersects(body1, body2))\n        {\n            this._maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS;\n\n            if (body1.deltaX() === 0 && body2.deltaX() === 0)\n            {\n                //  They overlap but neither of them are moving\n                body1.embedded = true;\n                body2.embedded = true;\n            }\n            else if (body1.deltaX() > body2.deltaX())\n            {\n                //  Body1 is moving right and/or Body2 is moving left\n                this._overlap = body1.right - body2.x;\n\n                if ((this._overlap > this._maxOverlap) || body1.checkCollision.right === false || body2.checkCollision.left === false)\n                {\n                    this._overlap = 0;\n                }\n                else\n                {\n                    body1.touching.none = false;\n                    body1.touching.right = true;\n                    body2.touching.none = false;\n                    body2.touching.left = true;\n                }\n            }\n            else if (body1.deltaX() < body2.deltaX())\n            {\n                //  Body1 is moving left and/or Body2 is moving right\n                this._overlap = body1.x - body2.width - body2.x;\n\n                if ((-this._overlap > this._maxOverlap) || body1.checkCollision.left === false || body2.checkCollision.right === false)\n                {\n                    this._overlap = 0;\n                }\n                else\n                {\n                    body1.touching.none = false;\n                    body1.touching.left = true;\n                    body2.touching.none = false;\n                    body2.touching.right = true;\n                }\n            }\n\n            //  Then adjust their positions and velocities accordingly (if there was any overlap)\n            if (this._overlap !== 0)\n            {\n                body1.overlapX = this._overlap;\n                body2.overlapX = this._overlap;\n\n                if (overlapOnly || body1.customSeparateX || body2.customSeparateX)\n                {\n                    return true;\n                }\n\n                this._velocity1 = body1.velocity.x;\n                this._velocity2 = body2.velocity.x;\n\n                if (!body1.immovable && !body2.immovable)\n                {\n                    this._overlap *= 0.5;\n\n                    body1.x = body1.x - this._overlap;\n                    body2.x += this._overlap;\n\n                    this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * body2.mass) / body1.mass) * ((this._velocity2 > 0) ? 1 : -1);\n                    this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * body1.mass) / body2.mass) * ((this._velocity1 > 0) ? 1 : -1);\n                    this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\n                    this._newVelocity1 -= this._average;\n                    this._newVelocity2 -= this._average;\n\n                    body1.velocity.x = this._average + this._newVelocity1 * body1.bounce.x;\n                    body2.velocity.x = this._average + this._newVelocity2 * body2.bounce.x;\n                }\n                else if (!body1.immovable)\n                {\n                    body1.x = body1.x - this._overlap;\n                    body1.velocity.x = this._velocity2 - this._velocity1 * body1.bounce.x;\n                }\n                else if (!body2.immovable)\n                {\n                    body2.x += this._overlap;\n                    body2.velocity.x = this._velocity1 - this._velocity2 * body2.bounce.x;\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * The core separation function to separate two physics bodies on the y axis.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#separateY\n    * @param {Phaser.Physics.Arcade.Body} body1 - The Body object to separate.\n    * @param {Phaser.Physics.Arcade.Body} body2 - The Body object to separate.\n    * @param {boolean} overlapOnly - If true the bodies will only have their overlap data set, no separation or exchange of velocity will take place.\n    * @return {boolean} Returns true if the bodies were separated, otherwise false.\n    */\n    separateY: function (body1, body2, overlapOnly) {\n\n        //  Can't separate two immovable or non-existing bodys\n        if (body1.immovable && body2.immovable)\n        {\n            return false;\n        }\n\n        this._overlap = 0;\n\n        //  Check if the hulls actually overlap\n        if (this.intersects(body1, body2))\n        {\n            this._maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS;\n\n            if (body1.deltaY() === 0 && body2.deltaY() === 0)\n            {\n                //  They overlap but neither of them are moving\n                body1.embedded = true;\n                body2.embedded = true;\n            }\n            else if (body1.deltaY() > body2.deltaY())\n            {\n                //  Body1 is moving down and/or Body2 is moving up\n                this._overlap = body1.bottom - body2.y;\n\n                if ((this._overlap > this._maxOverlap) || body1.checkCollision.down === false || body2.checkCollision.up === false)\n                {\n                    this._overlap = 0;\n                }\n                else\n                {\n                    body1.touching.none = false;\n                    body1.touching.down = true;\n                    body2.touching.none = false;\n                    body2.touching.up = true;\n                }\n            }\n            else if (body1.deltaY() < body2.deltaY())\n            {\n                //  Body1 is moving up and/or Body2 is moving down\n                this._overlap = body1.y - body2.bottom;\n\n                if ((-this._overlap > this._maxOverlap) || body1.checkCollision.up === false || body2.checkCollision.down === false)\n                {\n                    this._overlap = 0;\n                }\n                else\n                {\n                    body1.touching.none = false;\n                    body1.touching.up = true;\n                    body2.touching.none = false;\n                    body2.touching.down = true;\n                }\n            }\n\n            //  Then adjust their positions and velocities accordingly (if there was any overlap)\n            if (this._overlap !== 0)\n            {\n                body1.overlapY = this._overlap;\n                body2.overlapY = this._overlap;\n\n                if (overlapOnly || body1.customSeparateY || body2.customSeparateY)\n                {\n                    return true;\n                }\n\n                this._velocity1 = body1.velocity.y;\n                this._velocity2 = body2.velocity.y;\n\n                if (!body1.immovable && !body2.immovable)\n                {\n                    this._overlap *= 0.5;\n\n                    body1.y = body1.y - this._overlap;\n                    body2.y += this._overlap;\n\n                    this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * body2.mass) / body1.mass) * ((this._velocity2 > 0) ? 1 : -1);\n                    this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * body1.mass) / body2.mass) * ((this._velocity1 > 0) ? 1 : -1);\n                    this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;\n                    this._newVelocity1 -= this._average;\n                    this._newVelocity2 -= this._average;\n\n                    body1.velocity.y = this._average + this._newVelocity1 * body1.bounce.y;\n                    body2.velocity.y = this._average + this._newVelocity2 * body2.bounce.y;\n                }\n                else if (!body1.immovable)\n                {\n                    body1.y = body1.y - this._overlap;\n                    body1.velocity.y = this._velocity2 - this._velocity1 * body1.bounce.y;\n\n                    //  This is special case code that handles things like horizontal moving platforms you can ride\n                    if (body2.moves)\n                    {\n                        body1.x += body2.x - body2.prev.x;\n                    }\n                }\n                else if (!body2.immovable)\n                {\n                    body2.y += this._overlap;\n                    body2.velocity.y = this._velocity1 - this._velocity2 * body2.bounce.y;\n\n                    //  This is special case code that handles things like horizontal moving platforms you can ride\n                    if (body1.moves)\n                    {\n                        body2.x += body1.x - body1.prev.x;\n                    }\n                }\n\n                return true;\n            }\n\n        }\n\n        return false;\n\n    },\n\n    /**\n    * The core separation function to separate a physics body and a tile.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#separateTile\n    * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\n    * @param {Phaser.Tile} tile - The tile to collide against.\n    * @return {boolean} Returns true if the body was separated, otherwise false.\n    */\n    separateTile: function (i, body, tile) {\n\n        //  We re-check for collision in case body was separated in a previous step\n        if (!tile.intersects(body.position.x, body.position.y, body.right, body.bottom))\n        {\n            //  no collision so bail out (separted in a previous step)\n            return false;\n        }\n\n        //  They overlap. Any custom callbacks?\n\n        //  A local callback always takes priority over a layer level callback\n        if (tile.collisionCallback && !tile.collisionCallback.call(tile.collisionCallbackContext, body.sprite, tile))\n        {\n            //  If it returns true then we can carry on, otherwise we should abort.\n            return false;\n        }\n        else if (tile.layer.callbacks[tile.index] && !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, body.sprite, tile))\n        {\n            //  If it returns true then we can carry on, otherwise we should abort.\n            return false;\n        }\n\n        //  We don't need to go any further if this tile doesn't actually separate\n        if (!tile.faceLeft && !tile.faceRight && !tile.faceTop && !tile.faceBottom)\n        {\n            //   This could happen if the tile was meant to be collided with re: a callback, but otherwise isn't needed for separation\n            return false;\n        }\n\n        var ox = 0;\n        var oy = 0;\n        var minX = 0;\n        var minY = 1;\n\n        if (body.deltaAbsX() > body.deltaAbsY())\n        {\n            //  Moving faster horizontally, check X axis first\n            minX = -1;\n        }\n        else if (body.deltaAbsX() < body.deltaAbsY())\n        {\n            //  Moving faster vertically, check Y axis first\n            minY = -1;\n        }\n\n        if (body.deltaX() !== 0 && body.deltaY() !== 0 && (tile.faceLeft || tile.faceRight) && (tile.faceTop || tile.faceBottom))\n        {\n            //  We only need do this if both axis have checking faces AND we're moving in both directions\n            minX = Math.min(Math.abs(body.position.x - tile.right), Math.abs(body.right - tile.left));\n            minY = Math.min(Math.abs(body.position.y - tile.bottom), Math.abs(body.bottom - tile.top));\n\n            // console.log('checking faces', minX, minY);\n        }\n\n        if (minX < minY)\n        {\n            if (tile.faceLeft || tile.faceRight)\n            {\n                ox = this.tileCheckX(body, tile);\n\n                //  That's horizontal done, check if we still intersects? If not then we can return now\n                if (ox !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom))\n                {\n                    return true;\n                }\n            }\n\n            if (tile.faceTop || tile.faceBottom)\n            {\n                oy = this.tileCheckY(body, tile);\n            }\n        }\n        else\n        {\n            if (tile.faceTop || tile.faceBottom)\n            {\n                oy = this.tileCheckY(body, tile);\n\n                //  That's vertical done, check if we still intersects? If not then we can return now\n                if (oy !== 0 && !tile.intersects(body.position.x, body.position.y, body.right, body.bottom))\n                {\n                    return true;\n                }\n            }\n\n            if (tile.faceLeft || tile.faceRight)\n            {\n                ox = this.tileCheckX(body, tile);\n            }\n        }\n\n        return (ox !== 0 || oy !== 0);\n\n    },\n\n    /**\n    * Check the body against the given tile on the X axis.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#tileCheckX\n    * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\n    * @param {Phaser.Tile} tile - The tile to check.\n    * @return {number} The amount of separation that occured.\n    */\n    tileCheckX: function (body, tile) {\n\n        var ox = 0;\n\n        if (body.deltaX() < 0 && !body.blocked.left && tile.collideRight && body.checkCollision.left)\n        {\n            //  Body is moving LEFT\n            if (tile.faceRight && body.x < tile.right)\n            {\n                ox = body.x - tile.right;\n\n                if (ox < -this.TILE_BIAS)\n                {\n                    ox = 0;\n                }\n            }\n        }\n        else if (body.deltaX() > 0 && !body.blocked.right && tile.collideLeft && body.checkCollision.right)\n        {\n            //  Body is moving RIGHT\n            if (tile.faceLeft && body.right > tile.left)\n            {\n                ox = body.right - tile.left;\n\n                if (ox > this.TILE_BIAS)\n                {\n                    ox = 0;\n                }\n            }\n        }\n\n        if (ox !== 0)\n        {\n            this.processTileSeparationX(body, ox);\n        }\n\n        return ox;\n\n    },\n\n    /**\n    * Check the body against the given tile on the Y axis.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#tileCheckY\n    * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\n    * @param {Phaser.Tile} tile - The tile to check.\n    * @return {number} The amount of separation that occured.\n    */\n    tileCheckY: function (body, tile) {\n\n        var oy = 0;\n\n        if (body.deltaY() < 0 && !body.blocked.up && tile.collideDown && body.checkCollision.up)\n        {\n            //  Body is moving UP\n            if (tile.faceBottom && body.y < tile.bottom)\n            {\n                oy = body.y - tile.bottom;\n\n                if (oy < -this.TILE_BIAS)\n                {\n                    oy = 0;\n                }\n            }\n        }\n        else if (body.deltaY() > 0 && !body.blocked.down && tile.collideUp && body.checkCollision.down)\n        {\n            //  Body is moving DOWN\n            if (tile.faceTop && body.bottom > tile.top)\n            {\n                oy = body.bottom - tile.top;\n\n                if (oy > this.TILE_BIAS)\n                {\n                    oy = 0;\n                }\n            }\n        }\n\n        if (oy !== 0)\n        {\n            this.processTileSeparationY(body, oy);\n        }\n\n        return oy;\n\n    },\n\n    /**\n    * Internal function to process the separation of a physics body from a tile.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#processTileSeparationX\n    * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\n    * @param {number} x - The x separation amount.\n    * @return {boolean} Returns true as a pass-thru to the separateTile method.\n    */\n    processTileSeparationX: function (body, x) {\n\n        if (x < 0)\n        {\n            body.blocked.left = true;\n        }\n        else if (x > 0)\n        {\n            body.blocked.right = true;\n        }\n\n        body.position.x -= x;\n\n        if (body.bounce.x === 0)\n        {\n            body.velocity.x = 0;\n        }\n        else\n        {\n            body.velocity.x = -body.velocity.x * body.bounce.x;\n        }\n\n    },\n\n    /**\n    * Internal function to process the separation of a physics body from a tile.\n    *\n    * @private\n    * @method Phaser.Physics.Arcade#processTileSeparationY\n    * @param {Phaser.Physics.Arcade.Body} body - The Body object to separate.\n    * @param {number} y - The y separation amount.\n    */\n    processTileSeparationY: function (body, y) {\n\n        if (y < 0)\n        {\n            body.blocked.up = true;\n        }\n        else if (y > 0)\n        {\n            body.blocked.down = true;\n        }\n\n        body.position.y -= y;\n\n        if (body.bounce.y === 0)\n        {\n            body.velocity.y = 0;\n        }\n        else\n        {\n            body.velocity.y = -body.velocity.y * body.bounce.y;\n        }\n\n    },\n\n    /**\n    * Move the given display object towards the destination object at a steady velocity.\n    * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\n    * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n    * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n    * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n    * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n    *\n    * @method Phaser.Physics.Arcade#moveToObject\n    * @param {any} displayObject - The display object to move.\n    * @param {any} destination - The display object to move towards. Can be any object but must have visible x/y properties.\n    * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n    * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n    * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n    */\n    moveToObject: function (displayObject, destination, speed, maxTime) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        if (typeof maxTime === 'undefined') { maxTime = 0; }\n\n        this._angle = Math.atan2(destination.y - displayObject.y, destination.x - displayObject.x);\n\n        if (maxTime > 0)\n        {\n            //  We know how many pixels we need to move, but how fast?\n            speed = this.distanceBetween(displayObject, destination) / (maxTime / 1000);\n        }\n\n        displayObject.body.velocity.x = Math.cos(this._angle) * speed;\n        displayObject.body.velocity.y = Math.sin(this._angle) * speed;\n\n        return this._angle;\n\n    },\n\n    /**\n    * Move the given display object towards the pointer at a steady velocity. If no pointer is given it will use Phaser.Input.activePointer.\n    * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\n    * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n    * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n    * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n    *\n    * @method Phaser.Physics.Arcade#moveToPointer\n    * @param {any} displayObject - The display object to move.\n    * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n    * @param {Phaser.Pointer} [pointer] - The pointer to move towards. Defaults to Phaser.Input.activePointer.\n    * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n    * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n    */\n    moveToPointer: function (displayObject, speed, pointer, maxTime) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        pointer = pointer || this.game.input.activePointer;\n        if (typeof maxTime === 'undefined') { maxTime = 0; }\n\n        this._angle = this.angleToPointer(displayObject, pointer);\n\n        if (maxTime > 0)\n        {\n            //  We know how many pixels we need to move, but how fast?\n            speed = this.distanceToPointer(displayObject, pointer) / (maxTime / 1000);\n        }\n\n        displayObject.body.velocity.x = Math.cos(this._angle) * speed;\n        displayObject.body.velocity.y = Math.sin(this._angle) * speed;\n\n        return this._angle;\n\n    },\n\n    /**\n    * Move the given display object towards the x/y coordinates at a steady velocity.\n    * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\n    * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n    * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n    * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n    * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n    *\n    * @method Phaser.Physics.Arcade#moveToXY\n    * @param {any} displayObject - The display object to move.\n    * @param {number} x - The x coordinate to move towards.\n    * @param {number} y - The y coordinate to move towards.\n    * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n    * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n    * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n    */\n    moveToXY: function (displayObject, x, y, speed, maxTime) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        if (typeof maxTime === 'undefined') { maxTime = 0; }\n\n        this._angle = Math.atan2(y - displayObject.y, x - displayObject.x);\n\n        if (maxTime > 0)\n        {\n            //  We know how many pixels we need to move, but how fast?\n            speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1000);\n        }\n\n        displayObject.body.velocity.x = Math.cos(this._angle) * speed;\n        displayObject.body.velocity.y = Math.sin(this._angle) * speed;\n\n        return this._angle;\n\n    },\n\n    /**\n    * Given the angle (in degrees) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\n    * One way to use this is: velocityFromAngle(angle, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.\n    *\n    * @method Phaser.Physics.Arcade#velocityFromAngle\n    * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\n    * @param {number} [speed=60] - The speed it will move, in pixels per second sq.\n    * @param {Phaser.Point|object} [point] - The Point object in which the x and y properties will be set to the calculated velocity.\n    * @return {Phaser.Point} - A Point where point.x contains the velocity x value and point.y contains the velocity y value.\n    */\n    velocityFromAngle: function (angle, speed, point) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        point = point || new Phaser.Point();\n\n        return point.setTo((Math.cos(this.game.math.degToRad(angle)) * speed), (Math.sin(this.game.math.degToRad(angle)) * speed));\n\n    },\n\n    /**\n    * Given the rotation (in radians) and speed calculate the velocity and return it as a Point object, or set it to the given point object.\n    * One way to use this is: velocityFromRotation(rotation, 200, sprite.velocity) which will set the values directly to the sprites velocity and not create a new Point object.\n    *\n    * @method Phaser.Physics.Arcade#velocityFromRotation\n    * @param {number} rotation - The angle in radians.\n    * @param {number} [speed=60] - The speed it will move, in pixels per second sq.\n    * @param {Phaser.Point|object} [point] - The Point object in which the x and y properties will be set to the calculated velocity.\n    * @return {Phaser.Point} - A Point where point.x contains the velocity x value and point.y contains the velocity y value.\n    */\n    velocityFromRotation: function (rotation, speed, point) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        point = point || new Phaser.Point();\n\n        return point.setTo((Math.cos(rotation) * speed), (Math.sin(rotation) * speed));\n\n    },\n\n    /**\n    * Given the rotation (in radians) and speed calculate the acceleration and return it as a Point object, or set it to the given point object.\n    * One way to use this is: accelerationFromRotation(rotation, 200, sprite.acceleration) which will set the values directly to the sprites acceleration and not create a new Point object.\n    *\n    * @method Phaser.Physics.Arcade#accelerationFromRotation\n    * @param {number} rotation - The angle in radians.\n    * @param {number} [speed=60] - The speed it will move, in pixels per second sq.\n    * @param {Phaser.Point|object} [point] - The Point object in which the x and y properties will be set to the calculated acceleration.\n    * @return {Phaser.Point} - A Point where point.x contains the acceleration x value and point.y contains the acceleration y value.\n    */\n    accelerationFromRotation: function (rotation, speed, point) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        point = point || new Phaser.Point();\n\n        return point.setTo((Math.cos(rotation) * speed), (Math.sin(rotation) * speed));\n\n    },\n\n    /**\n    * Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)\n    * You must give a maximum speed value, beyond which the display object won't go any faster.\n    * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n    * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n    *\n    * @method Phaser.Physics.Arcade#accelerateToObject\n    * @param {any} displayObject - The display object to move.\n    * @param {any} destination - The display object to move towards. Can be any object but must have visible x/y properties.\n    * @param {number} [speed=60] - The speed it will accelerate in pixels per second.\n    * @param {number} [xSpeedMax=500] - The maximum x velocity the display object can reach.\n    * @param {number} [ySpeedMax=500] - The maximum y velocity the display object can reach.\n    * @return {number} The angle (in radians) that the object should be visually set to in order to match its new trajectory.\n    */\n    accelerateToObject: function (displayObject, destination, speed, xSpeedMax, ySpeedMax) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        if (typeof xSpeedMax === 'undefined') { xSpeedMax = 1000; }\n        if (typeof ySpeedMax === 'undefined') { ySpeedMax = 1000; }\n\n        this._angle = this.angleBetween(displayObject, destination);\n\n        displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);\n        displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);\n\n        return this._angle;\n\n    },\n\n    /**\n    * Sets the acceleration.x/y property on the display object so it will move towards the target at the given speed (in pixels per second sq.)\n    * You must give a maximum speed value, beyond which the display object won't go any faster.\n    * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n    * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n    *\n    * @method Phaser.Physics.Arcade#accelerateToPointer\n    * @param {any} displayObject - The display object to move.\n    * @param {Phaser.Pointer} [pointer] - The pointer to move towards. Defaults to Phaser.Input.activePointer.\n    * @param {number} [speed=60] - The speed it will accelerate in pixels per second.\n    * @param {number} [xSpeedMax=500] - The maximum x velocity the display object can reach.\n    * @param {number} [ySpeedMax=500] - The maximum y velocity the display object can reach.\n    * @return {number} The angle (in radians) that the object should be visually set to in order to match its new trajectory.\n    */\n    accelerateToPointer: function (displayObject, pointer, speed, xSpeedMax, ySpeedMax) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        if (typeof pointer === 'undefined') { pointer = this.game.input.activePointer; }\n        if (typeof xSpeedMax === 'undefined') { xSpeedMax = 1000; }\n        if (typeof ySpeedMax === 'undefined') { ySpeedMax = 1000; }\n\n        this._angle = this.angleToPointer(displayObject, pointer);\n\n        displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);\n        displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);\n\n        return this._angle;\n\n    },\n\n    /**\n    * Sets the acceleration.x/y property on the display object so it will move towards the x/y coordinates at the given speed (in pixels per second sq.)\n    * You must give a maximum speed value, beyond which the display object won't go any faster.\n    * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n    * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n    *\n    * @method Phaser.Physics.Arcade#accelerateToXY\n    * @param {any} displayObject - The display object to move.\n    * @param {number} x - The x coordinate to accelerate towards.\n    * @param {number} y - The y coordinate to accelerate towards.\n    * @param {number} [speed=60] - The speed it will accelerate in pixels per second.\n    * @param {number} [xSpeedMax=500] - The maximum x velocity the display object can reach.\n    * @param {number} [ySpeedMax=500] - The maximum y velocity the display object can reach.\n    * @return {number} The angle (in radians) that the object should be visually set to in order to match its new trajectory.\n    */\n    accelerateToXY: function (displayObject, x, y, speed, xSpeedMax, ySpeedMax) {\n\n        if (typeof speed === 'undefined') { speed = 60; }\n        if (typeof xSpeedMax === 'undefined') { xSpeedMax = 1000; }\n        if (typeof ySpeedMax === 'undefined') { ySpeedMax = 1000; }\n\n        this._angle = this.angleToXY(displayObject, x, y);\n\n        displayObject.body.acceleration.setTo(Math.cos(this._angle) * speed, Math.sin(this._angle) * speed);\n        displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax);\n\n        return this._angle;\n\n    },\n\n    /**\n    * Find the distance between two display objects (like Sprites).\n    *\n    * @method Phaser.Physics.Arcade#distanceBetween\n    * @param {any} source - The Display Object to test from.\n    * @param {any} target - The Display Object to test to.\n    * @return {number} The distance between the source and target objects.\n    */\n    distanceBetween: function (source, target) {\n\n        this._dx = source.x - target.x;\n        this._dy = source.y - target.y;\n\n        return Math.sqrt(this._dx * this._dx + this._dy * this._dy);\n\n    },\n\n    /**\n    * Find the distance between a display object (like a Sprite) and the given x/y coordinates.\n    * The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.\n    * If you need to calculate from the center of a display object instead use the method distanceBetweenCenters()\n    *\n    * @method Phaser.Physics.Arcade#distanceToXY\n    * @param {any} displayObject - The Display Object to test from.\n    * @param {number} x - The x coordinate to move towards.\n    * @param {number} y - The y coordinate to move towards.\n    * @return {number} The distance between the object and the x/y coordinates.\n    */\n    distanceToXY: function (displayObject, x, y) {\n\n        this._dx = displayObject.x - x;\n        this._dy = displayObject.y - y;\n\n        return Math.sqrt(this._dx * this._dx + this._dy * this._dy);\n\n    },\n\n    /**\n    * Find the distance between a display object (like a Sprite) and a Pointer. If no Pointer is given the Input.activePointer is used.\n    * The calculation is made from the display objects x/y coordinate. This may be the top-left if its anchor hasn't been changed.\n    * If you need to calculate from the center of a display object instead use the method distanceBetweenCenters()\n    *\n    * @method Phaser.Physics.Arcade#distanceToPointer\n    * @param {any} displayObject - The Display Object to test from.\n    * @param {Phaser.Pointer} [pointer] - The Phaser.Pointer to test to. If none is given then Input.activePointer is used.\n    * @return {number} The distance between the object and the Pointer.\n    */\n    distanceToPointer: function (displayObject, pointer) {\n\n        pointer = pointer || this.game.input.activePointer;\n\n        this._dx = displayObject.x - pointer.x;\n        this._dy = displayObject.y - pointer.y;\n\n        return Math.sqrt(this._dx * this._dx + this._dy * this._dy);\n\n    },\n\n    /**\n    * Find the angle in radians between two display objects (like Sprites).\n    *\n    * @method Phaser.Physics.Arcade#angleBetween\n    * @param {any} source - The Display Object to test from.\n    * @param {any} target - The Display Object to test to.\n    * @return {number} The angle in radians between the source and target display objects.\n    */\n    angleBetween: function (source, target) {\n\n        this._dx = target.x - source.x;\n        this._dy = target.y - source.y;\n\n        return Math.atan2(this._dy, this._dx);\n\n    },\n\n    /**\n    * Find the angle in radians between a display object (like a Sprite) and the given x/y coordinate.\n    *\n    * @method Phaser.Physics.Arcade#angleToXY\n    * @param {any} displayObject - The Display Object to test from.\n    * @param {number} x - The x coordinate to get the angle to.\n    * @param {number} y - The y coordinate to get the angle to.\n    * @return {number} The angle in radians between displayObject.x/y to Pointer.x/y\n    */\n    angleToXY: function (displayObject, x, y) {\n\n        this._dx = x - displayObject.x;\n        this._dy = y - displayObject.y;\n\n        return Math.atan2(this._dy, this._dx);\n\n    },\n\n    /**\n    * Find the angle in radians between a display object (like a Sprite) and a Pointer, taking their x/y and center into account.\n    *\n    * @method Phaser.Physics.Arcade#angleToPointer\n    * @param {any} displayObject - The Display Object to test from.\n    * @param {Phaser.Pointer} [pointer] - The Phaser.Pointer to test to. If none is given then Input.activePointer is used.\n    * @return {number} The angle in radians between displayObject.x/y to Pointer.x/y\n    */\n    angleToPointer: function (displayObject, pointer) {\n\n        pointer = pointer || this.game.input.activePointer;\n\n        this._dx = pointer.worldX - displayObject.x;\n        this._dy = pointer.worldY - displayObject.y;\n\n        return Math.atan2(this._dy, this._dx);\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than\n* the Sprite itself. For example you can set the velocity, acceleration, bounce values etc all on the Body.\n*\n* @class Phaser.Physics.Arcade.Body\n* @classdesc Arcade Physics Body Constructor\n* @constructor\n* @param {Phaser.Sprite} sprite - The Sprite object this physics body belongs to.\n*/\nPhaser.Physics.Arcade.Body = function (sprite) {\n\n    /**\n    * @property {Phaser.Sprite} sprite - Reference to the parent Sprite.\n    */\n    this.sprite = sprite;\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = sprite.game;\n\n    /**\n    * @property {number} type - The type of physics system this body belongs to.\n    */\n    this.type = Phaser.Physics.ARCADE;\n\n    /**\n    * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y position.\n    */\n    this.offset = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} position - The position of the physics body.\n    * @readonly\n    */\n    this.position = new Phaser.Point(sprite.x, sprite.y);\n\n    /**\n    * @property {Phaser.Point} prev - The previous position of the physics body.\n    * @readonly\n    */\n    this.prev = new Phaser.Point(this.position.x, this.position.y);\n\n    /**\n    * @property {boolean} allowRotation - Allow this Body to be rotated? (via angularVelocity, etc)\n    * @default\n    */\n    this.allowRotation = true;\n\n    /**\n    * @property {number} rotation - The amount the Body is rotated.\n    */\n    this.rotation = sprite.rotation;\n\n    /**\n    * @property {number} preRotation - The previous rotation of the physics body.\n    * @readonly\n    */\n    this.preRotation = sprite.rotation;\n\n    /**\n    * @property {number} sourceWidth - The un-scaled original size.\n    * @readonly\n    */\n    this.sourceWidth = sprite.texture.frame.width;\n\n    /**\n    * @property {number} sourceHeight - The un-scaled original size.\n    * @readonly\n    */\n    this.sourceHeight = sprite.texture.frame.height;\n\n    /**\n    * @property {number} width - The calculated width of the physics body.\n    */\n    this.width = sprite.width;\n\n    /**\n    * @property .numInternal ID cache\n    */\n    this.height = sprite.height;\n\n    /**\n    * @property {number} halfWidth - The calculated width / 2 of the physics body.\n    */\n    this.halfWidth = Math.abs(sprite.width / 2);\n\n    /**\n    * @property {number} halfHeight - The calculated height / 2 of the physics body.\n    */\n    this.halfHeight = Math.abs(sprite.height / 2);\n\n    /**\n    * @property {Phaser.Point} center - The center coordinate of the Physics Body.\n    */\n    this.center = new Phaser.Point(sprite.x + this.halfWidth, sprite.y + this.halfHeight);\n\n    /**\n    * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.\n    */\n    this.velocity = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} newVelocity - New velocity.\n    * @readonly\n    */\n    this.newVelocity = new Phaser.Point(0, 0);\n\n    /**\n    * @property {Phaser.Point} deltaMax - The Sprite position is updated based on the delta x/y values. You can set a cap on those (both +-) using deltaMax.\n    */\n    this.deltaMax = new Phaser.Point(0, 0);\n\n    /**\n    * @property {Phaser.Point} acceleration - The velocity in pixels per second sq. of the Body.\n    */\n    this.acceleration = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} drag - The drag applied to the motion of the Body.\n    */\n    this.drag = new Phaser.Point();\n\n    /**\n    * @property {boolean} allowGravity - Allow this Body to be influenced by gravity? Either world or local.\n    * @default\n    */\n    this.allowGravity = true;\n\n    /**\n    * @property {Phaser.Point} gravity - A local gravity applied to this Body. If non-zero this over rides any world gravity, unless Body.allowGravity is set to false.\n    */\n    this.gravity = new Phaser.Point(0, 0);\n\n    /**\n    * @property {Phaser.Point} bounce - The elasticitiy of the Body when colliding. bounce.x/y = 1 means full rebound, bounce.x/y = 0.5 means 50% rebound velocity.\n    */\n    this.bounce = new Phaser.Point();\n\n    /**\n    * @property {Phaser.Point} maxVelocity - The maximum velocity in pixels per second sq. that the Body can reach.\n    * @default\n    */\n    this.maxVelocity = new Phaser.Point(10000, 10000);\n\n    /**\n    * @property {number} angularVelocity - The angular velocity in pixels per second sq. of the Body.\n    * @default\n    */\n    this.angularVelocity = 0;\n\n    /**\n    * @property {number} angularAcceleration - The angular acceleration in pixels per second sq. of the Body.\n    * @default\n    */\n    this.angularAcceleration = 0;\n\n    /**\n    * @property {number} angularDrag - The angular drag applied to the rotation of the Body.\n    * @default\n    */\n    this.angularDrag = 0;\n\n    /**\n    * @property {number} maxAngular - The maximum angular velocity in pixels per second sq. that the Body can reach.\n    * @default\n    */\n    this.maxAngular = 1000;\n\n    /**\n    * @property {number} mass - The mass of the Body.\n    * @default\n    */\n    this.mass = 1;\n\n    /**\n    * @property {number} angle - The angle of the Body in radians as calculated by its velocity, rather than its visual angle.\n    * @readonly\n    */\n    this.angle = 0;\n\n    /**\n    * @property {number} speed - The speed of the Body as calculated by its velocity.\n    * @readonly\n    */\n    this.speed = 0;\n\n    /**\n    * @property {number} facing - A const reference to the direction the Body is traveling or facing.\n    * @default\n    */\n    this.facing = Phaser.NONE;\n\n    /**\n    * @property {boolean} immovable - An immovable Body will not receive any impacts from other bodies.\n    * @default\n    */\n    this.immovable = false;\n\n    /**\n    * If you have a Body that is being moved around the world via a tween or a Group motion, but its local x/y position never\n    * actually changes, then you should set Body.moves = false. Otherwise it will most likely fly off the screen.\n    * If you want the physics system to move the body around, then set moves to true.\n    * @property {boolean} moves - Set to true to allow the Physics system to move this Body, other false to move it manually.\n    * @default\n    */\n    this.moves = true;\n\n    /**\n    * This flag allows you to disable the custom x separation that takes place by Physics.Arcade.separate.\n    * Used in combination with your own collision processHandler you can create whatever type of collision response you need.\n    * @property {boolean} customSeparateX - Use a custom separation system or the built-in one?\n    * @default\n    */\n    this.customSeparateX = false;\n\n    /**\n    * This flag allows you to disable the custom y separation that takes place by Physics.Arcade.separate.\n    * Used in combination with your own collision processHandler you can create whatever type of collision response you need.\n    * @property {boolean} customSeparateY - Use a custom separation system or the built-in one?\n    * @default\n    */\n    this.customSeparateY = false;\n\n    /**\n    * When this body collides with another, the amount of overlap is stored here.\n    * @property {number} overlapX - The amount of horizontal overlap during the collision.\n    */\n    this.overlapX = 0;\n\n    /**\n    * When this body collides with another, the amount of overlap is stored here.\n    * @property {number} overlapY - The amount of vertical overlap during the collision.\n    */\n    this.overlapY = 0;\n\n    /**\n    * If a body is overlapping with another body, but neither of them are moving (maybe they spawned on-top of each other?) this is set to true.\n    * @property {boolean} embedded - Body embed value.\n    */\n    this.embedded = false;\n\n    /**\n    * A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.\n    * @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?\n    */\n    this.collideWorldBounds = false;\n\n    /**\n    * Set the checkCollision properties to control which directions collision is processed for this Body.\n    * For example checkCollision.up = false means it won't collide when the collision happened while moving up.\n    * @property {object} checkCollision - An object containing allowed collision.\n    */\n    this.checkCollision = { none: false, any: true, up: true, down: true, left: true, right: true };\n\n    /**\n    * This object is populated with boolean values when the Body collides with another.\n    * touching.up = true means the collision happened to the top of this Body for example.\n    * @property {object} touching - An object containing touching results.\n    */\n    this.touching = { none: true, up: false, down: false, left: false, right: false };\n\n    /**\n    * This object is populated with previous touching values from the bodies previous collision.\n    * @property {object} wasTouching - An object containing previous touching results.\n    */\n    this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\n\n    /**\n    * This object is populated with boolean values when the Body collides with the World bounds or a Tile.\n    * For example if blocked.up is true then the Body cannot move up.\n    * @property {object} blocked - An object containing on which faces this Body is blocked from moving, if any.\n    */\n    this.blocked = { up: false, down: false, left: false, right: false };\n\n    /**\n    * If this is an especially small or fast moving object then it can sometimes skip over tilemap collisions if it moves through a tile in a step.\n    * Set this padding value to add extra padding to its bounds. tilePadding.x applied to its width, y to its height.\n    * @property {Phaser.Point} tilePadding - Extra padding to be added to this sprites dimensions when checking for tile collision.\n    */\n    this.tilePadding = new Phaser.Point();\n\n    /**\n    * @property {number} phaser - Is this Body in a preUpdate (1) or postUpdate (2) state?\n    */\n    this.phase = 0;\n\n    /**\n    * @property {boolean} _reset - Internal cache var.\n    * @private\n    */\n    this._reset = true;\n\n    /**\n    * @property {number} _sx - Internal cache var.\n    * @private\n    */\n    this._sx = sprite.scale.x;\n\n    /**\n    * @property {number} _sy - Internal cache var.\n    * @private\n    */\n    this._sy = sprite.scale.y;\n\n    /**\n    * @property {number} _dx - Internal cache var.\n    * @private\n    */\n    this._dx = 0;\n\n    /**\n    * @property {number} _dy - Internal cache var.\n    * @private\n    */\n    this._dy = 0;\n\n};\n\nPhaser.Physics.Arcade.Body.prototype = {\n\n    /**\n    * Internal method.\n    *\n    * @method Phaser.Physics.Arcade.Body#updateBounds\n    * @protected\n    */\n    updateBounds: function () {\n\n        var asx = Math.abs(this.sprite.scale.x);\n        var asy = Math.abs(this.sprite.scale.y);\n\n        if (asx !== this._sx || asy !== this._sy)\n        {\n            this.width = this.sourceWidth * asx;\n            this.height = this.sourceHeight * asy;\n            this.halfWidth = Math.floor(this.width / 2);\n            this.halfHeight = Math.floor(this.height / 2);\n            this._sx = asx;\n            this._sy = asy;\n            this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n\n            this._reset = true;\n        }\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method Phaser.Physics.Arcade.Body#preUpdate\n    * @protected\n    */\n    preUpdate: function () {\n\n        this.phase = 1;\n\n        //  Store and reset collision flags\n        this.wasTouching.none = this.touching.none;\n        this.wasTouching.up = this.touching.up;\n        this.wasTouching.down = this.touching.down;\n        this.wasTouching.left = this.touching.left;\n        this.wasTouching.right = this.touching.right;\n\n        this.touching.none = true;\n        this.touching.up = false;\n        this.touching.down = false;\n        this.touching.left = false;\n        this.touching.right = false;\n\n        this.blocked.up = false;\n        this.blocked.down = false;\n        this.blocked.left = false;\n        this.blocked.right = false;\n\n        this.embedded = false;\n\n        this.updateBounds();\n\n        this.position.x = (this.sprite.world.x - (this.sprite.anchor.x * this.width)) + this.offset.x;\n        this.position.y = (this.sprite.world.y - (this.sprite.anchor.y * this.height)) + this.offset.y;\n        this.rotation = this.sprite.angle;\n\n        this.preRotation = this.rotation;\n\n        if (this._reset || this.sprite._cache[4] === 1)\n        {\n            this.prev.x = this.position.x;\n            this.prev.y = this.position.y;\n        }\n\n        if (this.moves)\n        {\n            this.game.physics.arcade.updateMotion(this);\n\n            this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed);\n\n            this.position.x += this.newVelocity.x;\n            this.position.y += this.newVelocity.y;\n\n            if (this.position.x !== this.prev.x || this.position.y !== this.prev.y)\n            {\n                this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y);\n                this.angle = Math.atan2(this.velocity.y, this.velocity.x);\n            }\n\n            //  Now the State update will throw collision checks at the Body\n            //  And finally we'll integrate the new position back to the Sprite in postUpdate\n\n            if (this.collideWorldBounds)\n            {\n                this.checkWorldBounds();\n            }\n        }\n\n        this._dx = this.deltaX();\n        this._dy = this.deltaY();\n\n        this._reset = false;\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method Phaser.Physics.Arcade.Body#postUpdate\n    * @protected\n    */\n    postUpdate: function () {\n\n        //  Only allow postUpdate to be called once per frame\n        if (this.phase === 2)\n        {\n            return;\n        }\n\n        this.phase = 2;\n\n        if (this.deltaX() < 0)\n        {\n            this.facing = Phaser.LEFT;\n        }\n        else if (this.deltaX() > 0)\n        {\n            this.facing = Phaser.RIGHT;\n        }\n\n        if (this.deltaY() < 0)\n        {\n            this.facing = Phaser.UP;\n        }\n        else if (this.deltaY() > 0)\n        {\n            this.facing = Phaser.DOWN;\n        }\n\n        if (this.moves)\n        {\n            this._dx = this.deltaX();\n            this._dy = this.deltaY();\n\n            if (this.deltaMax.x !== 0 && this._dx !== 0)\n            {\n                if (this._dx < 0 && this._dx < -this.deltaMax.x)\n                {\n                    this._dx = -this.deltaMax.x;\n                }\n                else if (this._dx > 0 && this._dx > this.deltaMax.x)\n                {\n                    this._dx = this.deltaMax.x;\n                }\n            }\n\n            if (this.deltaMax.y !== 0 && this._dy !== 0)\n            {\n                if (this._dy < 0 && this._dy < -this.deltaMax.y)\n                {\n                    this._dy = -this.deltaMax.y;\n                }\n                else if (this._dy > 0 && this._dy > this.deltaMax.y)\n                {\n                    this._dy = this.deltaMax.y;\n                }\n            }\n\n            this.sprite.x += this._dx;\n            this.sprite.y += this._dy;\n        }\n\n        this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n\n        if (this.allowRotation)\n        {\n            this.sprite.angle += this.deltaZ();\n        }\n\n        this.prev.x = this.position.x;\n        this.prev.y = this.position.y;\n\n    },\n\n    /**\n    * Removes this bodies reference to its parent sprite, freeing it up for gc.\n    *\n    * @method Phaser.Physics.Arcade.Body#destroy\n    */\n    destroy: function () {\n\n        this.sprite = null;\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method Phaser.Physics.Arcade.Body#checkWorldBounds\n    * @protected\n    */\n    checkWorldBounds: function () {\n\n        if (this.position.x < this.game.physics.arcade.bounds.x && this.game.physics.arcade.checkCollision.left)\n        {\n            this.position.x = this.game.physics.arcade.bounds.x;\n            this.velocity.x *= -this.bounce.x;\n            this.blocked.left = true;\n        }\n        else if (this.right > this.game.physics.arcade.bounds.right && this.game.physics.arcade.checkCollision.right)\n        {\n            this.position.x = this.game.physics.arcade.bounds.right - this.width;\n            this.velocity.x *= -this.bounce.x;\n            this.blocked.right = true;\n        }\n\n        if (this.position.y < this.game.physics.arcade.bounds.y && this.game.physics.arcade.checkCollision.up)\n        {\n            this.position.y = this.game.physics.arcade.bounds.y;\n            this.velocity.y *= -this.bounce.y;\n            this.blocked.up = true;\n        }\n        else if (this.bottom > this.game.physics.arcade.bounds.bottom && this.game.physics.arcade.checkCollision.down)\n        {\n            this.position.y = this.game.physics.arcade.bounds.bottom - this.height;\n            this.velocity.y *= -this.bounce.y;\n            this.blocked.down = true;\n        }\n\n    },\n\n    /**\n    * You can modify the size of the physics Body to be any dimension you need.\n    * So it could be smaller or larger than the parent Sprite. You can also control the x and y offset, which\n    * is the position of the Body relative to the top-left of the Sprite.\n    *\n    * @method Phaser.Physics.Arcade.Body#setSize\n    * @param {number} width - The width of the Body.\n    * @param {number} height - The height of the Body.\n    * @param {number} offsetX - The X offset of the Body from the Sprite position.\n    * @param {number} offsetY - The Y offset of the Body from the Sprite position.\n    */\n    setSize: function (width, height, offsetX, offsetY) {\n\n        offsetX = offsetX || this.offset.x;\n        offsetY = offsetY || this.offset.y;\n\n        this.sourceWidth = width;\n        this.sourceHeight = height;\n        this.width = this.sourceWidth * this._sx;\n        this.height = this.sourceHeight * this._sy;\n        this.halfWidth = Math.floor(this.width / 2);\n        this.halfHeight = Math.floor(this.height / 2);\n        this.offset.setTo(offsetX, offsetY);\n\n        this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n\n    },\n\n    /**\n    * Resets all Body values (velocity, acceleration, rotation, etc)\n    *\n    * @method Phaser.Physics.Arcade.Body#reset\n    * @param {number} x - The new x position of the Body.\n    * @param {number} y - The new y position of the Body.\n    */\n    reset: function (x, y) {\n\n        this.velocity.set(0);\n        this.acceleration.set(0);\n\n        this.angularVelocity = 0;\n        this.angularAcceleration = 0;\n\n        this.position.x = (x - (this.sprite.anchor.x * this.width)) + this.offset.x;\n        this.position.y = (y - (this.sprite.anchor.y * this.height)) + this.offset.y;\n\n        this.prev.x = this.position.x;\n        this.prev.y = this.position.y;\n\n        this.rotation = this.sprite.angle;\n        this.preRotation = this.rotation;\n\n        this._sx = this.sprite.scale.x;\n        this._sy = this.sprite.scale.y;\n        \n        this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n\n    },\n\n    /**\n    * Tests if a world point lies within this Body.\n    *\n    * @method Phaser.Physics.Arcade.Body#hitTest\n    * @param {number} x - The world x coordinate to test.\n    * @param {number} y - The world y coordinate to test.\n    * @return {boolean} True if the given coordinates are inside this Body, otherwise false.\n    */\n    hitTest: function (x, y) {\n\n        return Phaser.Rectangle.contains(this, x, y);\n\n    },\n\n    /**\n    * Returns true if the bottom of this Body is in contact with either the world bounds or a tile.\n    *\n    * @method Phaser.Physics.Arcade.Body#onFloor\n    * @return {boolean} True if in contact with either the world bounds or a tile.\n    */\n    onFloor: function () {\n        return this.blocked.down;\n    },\n\n    /**\n    * Returns true if either side of this Body is in contact with either the world bounds or a tile.\n    *\n    * @method Phaser.Physics.Arcade.Body#onWall\n    * @return {boolean} True if in contact with either the world bounds or a tile.\n    */\n    onWall: function () {\n        return (this.blocked.left || this.blocked.right);\n    },\n\n    /**\n    * Returns the absolute delta x value.\n    *\n    * @method Phaser.Physics.Arcade.Body#deltaAbsX\n    * @return {number} The absolute delta value.\n    */\n    deltaAbsX: function () {\n        return (this.deltaX() > 0 ? this.deltaX() : -this.deltaX());\n    },\n\n    /**\n    * Returns the absolute delta y value.\n    *\n    * @method Phaser.Physics.Arcade.Body#deltaAbsY\n    * @return {number} The absolute delta value.\n    */\n    deltaAbsY: function () {\n        return (this.deltaY() > 0 ? this.deltaY() : -this.deltaY());\n    },\n\n    /**\n    * Returns the delta x value. The difference between Body.x now and in the previous step.\n    *\n    * @method Phaser.Physics.Arcade.Body#deltaX\n    * @return {number} The delta value. Positive if the motion was to the right, negative if to the left.\n    */\n    deltaX: function () {\n        return this.position.x - this.prev.x;\n    },\n\n    /**\n    * Returns the delta y value. The difference between Body.y now and in the previous step.\n    *\n    * @method Phaser.Physics.Arcade.Body#deltaY\n    * @return {number} The delta value. Positive if the motion was downwards, negative if upwards.\n    */\n    deltaY: function () {\n        return this.position.y - this.prev.y;\n    },\n\n    /**\n    * Returns the delta z value. The difference between Body.rotation now and in the previous step.\n    *\n    * @method Phaser.Physics.Arcade.Body#deltaZ\n    * @return {number} The delta value. Positive if the motion was clockwise, negative if anti-clockwise.\n    */\n    deltaZ: function () {\n        return this.rotation - this.preRotation;\n    }\n\n};\n\n/**\n* @name Phaser.Physics.Arcade.Body#bottom\n* @property {number} bottom - The bottom value of this Body (same as Body.y + Body.height)\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Arcade.Body.prototype, \"bottom\", {\n\n    get: function () {\n        return this.position.y + this.height;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Arcade.Body#right\n* @property {number} right - The right value of this Body (same as Body.x + Body.width)\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Arcade.Body.prototype, \"right\", {\n\n    get: function () {\n        return this.position.x + this.width;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Arcade.Body#x\n* @property {number} x - The x position.\n*/\nObject.defineProperty(Phaser.Physics.Arcade.Body.prototype, \"x\", {\n\n    get: function () {\n        return this.position.x;\n    },\n\n    set: function (value) {\n\n        this.position.x = value;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Arcade.Body#y\n* @property {number} y - The y position.\n*/\nObject.defineProperty(Phaser.Physics.Arcade.Body.prototype, \"y\", {\n\n    get: function () {\n        return this.position.y;\n    },\n\n    set: function (value) {\n\n        this.position.y = value;\n\n    }\n\n});\n\n/**\n* Render Sprite Body.\n*\n* @method Phaser.Physics.Arcade.Body#renderDebug\n* @param {object} context - The context to render to.\n* @param {Phaser.Physics.Arcade.Body} body - The Body to render the info of.\n* @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n* @param {boolean} [filled=true] - Render the objected as a filled (default, true) or a stroked (false)\n*/\nPhaser.Physics.Arcade.Body.render = function (context, body, filled, color) {\n\n    if (typeof filled === 'undefined') { filled = true; }\n\n    color = color || 'rgba(0,255,0,0.4)';\n\n    if (filled)\n    {\n        context.fillStyle = color;\n        context.fillRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);\n    }\n    else\n    {\n        context.strokeStyle = color;\n        context.strokeRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height);\n    }\n\n};\n\n/**\n* Render Sprite Body Physics Data as text.\n*\n* @method Phaser.Physics.Arcade.Body#renderBodyInfo\n* @param {Phaser.Physics.Arcade.Body} body - The Body to render the info of.\n* @param {number} x - X position of the debug info to be rendered.\n* @param {number} y - Y position of the debug info to be rendered.\n* @param {string} [color='rgb(255,255,255)'] - color of the debug info to be rendered. (format is css color string).\n*/\nPhaser.Physics.Arcade.Body.renderBodyInfo = function (debug, body) {\n\n    debug.line('x: ' + body.x.toFixed(2), 'y: ' + body.y.toFixed(2), 'width: ' + body.width, 'height: ' + body.height);\n    debug.line('velocity x: ' + body.velocity.x.toFixed(2), 'y: ' + body.velocity.y.toFixed(2), 'deltaX: ' + body._dx.toFixed(2), 'deltaY: ' + body._dy.toFixed(2));\n    debug.line('acceleration x: ' + body.acceleration.x.toFixed(2), 'y: ' + body.acceleration.y.toFixed(2), 'speed: ' + body.speed.toFixed(2), 'angle: ' + body.angle.toFixed(2));\n    debug.line('gravity x: ' + body.gravity.x, 'y: ' + body.gravity.y, 'bounce x: ' + body.bounce.x.toFixed(2), 'y: ' + body.bounce.y.toFixed(2));\n    debug.line('touching left: ' + body.touching.left, 'right: ' + body.touching.right, 'up: ' + body.touching.up, 'down: ' + body.touching.down);\n    debug.line('blocked left: ' + body.blocked.left, 'right: ' + body.blocked.right, 'up: ' + body.blocked.up, 'down: ' + body.blocked.down);\n\n};\n\nPhaser.Physics.Arcade.Body.prototype.constructor = Phaser.Physics.Arcade.Body;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.Particles is the Particle Manager for the game. It is called during the game update loop and in turn updates any Emitters attached to it.\n*\n* @class Phaser.Particles\n* @classdesc Phaser Particles\n* @constructor\n* @param {Phaser.Game} game - A reference to the currently running game.\n*/\nPhaser.Particles = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {object} emitters - Internal emitters store.\n    */\n    this.emitters = {};\n\n    /**\n    * @property {number} ID -\n    * @default\n    */\n    this.ID = 0;\n\n};\n\nPhaser.Particles.prototype = {\n\n    /**\n    * Adds a new Particle Emitter to the Particle Manager.\n    * @method Phaser.Particles#add\n    * @param {Phaser.Emitter} emitter - The emitter to be added to the particle manager.\n    * @return {Phaser.Emitter} The emitter that was added.\n    */\n    add: function (emitter) {\n\n        this.emitters[emitter.name] = emitter;\n\n        return emitter;\n\n    },\n\n    /**\n    * Removes an existing Particle Emitter from the Particle Manager.\n    * @method Phaser.Particles#remove\n    * @param {Phaser.Emitter} emitter - The emitter to remove.\n    */\n    remove: function (emitter) {\n\n        delete this.emitters[emitter.name];\n\n    },\n\n    /**\n    * Called by the core game loop. Updates all Emitters who have their exists value set to true.\n    * @method Phaser.Particles#update\n    * @protected\n    */\n    update: function () {\n\n        for (var key in this.emitters)\n        {\n            if (this.emitters[key].exists)\n            {\n                this.emitters[key].update();\n            }\n        }\n\n    }\n\n};\n\nPhaser.Particles.prototype.constructor = Phaser.Particles;\n\nPhaser.Particles.Arcade = {};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser - ArcadeEmitter\n*\n* @class Phaser.Particles.Arcade.Emitter\n* @classdesc Emitter is a lightweight particle emitter. It can be used for one-time explosions or for\n* continuous effects like rain and fire. All it really does is launch Particle objects out\n* at set intervals, and fixes their positions and velocities accorindgly.\n* @constructor\n* @extends Phaser.Group\n* @param {Phaser.Game} game - Current game instance.\n* @param {number} [x=0] - The x coordinate within the Emitter that the particles are emitted from.\n* @param {number} [y=0] - The y coordinate within the Emitter that the particles are emitted from.\n* @param {number} [maxParticles=50] - The total number of particles in this emitter..\n*/\n\nPhaser.Particles.Arcade.Emitter = function (game, x, y, maxParticles) {\n\n    /**\n    * @property {number} maxParticles - The total number of particles in this emitter..\n    * @default\n    */\n    this.maxParticles = maxParticles || 50;\n\n    Phaser.Group.call(this, game);\n\n    /**\n    * @property {string} name - A handy string name for this emitter. Can be set to anything.\n    */\n    this.name = 'emitter' + this.game.particles.ID++;\n\n    /**\n    * @property {number} type - Internal Phaser Type value.\n    * @protected\n    */\n    this.type = Phaser.EMITTER;\n\n    /**\n    * @property {number} width - The width of the emitter.  Particles can be randomly generated from anywhere within this box.\n    * @default\n    */\n    this.width = 1;\n\n    /**\n    * @property {number} height - The height of the emitter.  Particles can be randomly generated from anywhere within this box.\n    * @default\n    */\n    this.height = 1;\n\n    /**\n    * @property {Phaser.Point} minParticleSpeed - The minimum possible velocity of a particle.\n    * @default\n    */\n    this.minParticleSpeed = new Phaser.Point(-100, -100);\n\n    /**\n    * @property {Phaser.Point} maxParticleSpeed - The maximum possible velocity of a particle.\n    * @default\n    */\n    this.maxParticleSpeed = new Phaser.Point(100, 100);\n\n    /**\n    * @property {number} minParticleScale - The minimum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see minParticleScaleX.\n    * @default\n    */\n    this.minParticleScale = 1;\n\n    /**\n    * @property {number} maxParticleScale - The maximum possible scale of a particle. This is applied to the X and Y axis. If you need to control each axis see maxParticleScaleX.\n    * @default\n    */\n    this.maxParticleScale = 1;\n\n    /**\n    * @property {array} scaleData - An array of the calculated scale easing data applied to particles with scaleRates > 0.\n    */\n    this.scaleData = null;\n\n    /**\n    * @property {number} minRotation - The minimum possible angular velocity of a particle.\n    * @default\n    */\n    this.minRotation = -360;\n\n    /**\n    * @property {number} maxRotation - The maximum possible angular velocity of a particle.\n    * @default\n    */\n    this.maxRotation = 360;\n\n    /**\n    * @property {number} minParticleAlpha - The minimum possible alpha value of a particle.\n    * @default\n    */\n    this.minParticleAlpha = 1;\n\n    /**\n    * @property {number} maxParticleAlpha - The maximum possible alpha value of a particle.\n    * @default\n    */\n    this.maxParticleAlpha = 1;\n\n    /**\n    * @property {array} alphaData - An array of the calculated alpha easing data applied to particles with alphaRates > 0.\n    */\n    this.alphaData = null;\n\n    /**\n    * @property {number} gravity - Sets the `body.gravity.y` of each particle sprite to this value on launch.\n    * @default\n    */\n    this.gravity = 100;\n\n    /**\n    * @property {any} particleClass - For emitting your own particle class types. They must extend Phaser.Particle.\n    * @default\n    */\n    this.particleClass = Phaser.Particle;\n\n    /**\n    * @property {Phaser.Point} particleDrag - The X and Y drag component of particles launched from the emitter.\n    */\n    this.particleDrag = new Phaser.Point();\n\n    /**\n    * @property {number} angularDrag - The angular drag component of particles launched from the emitter if they are rotating.\n    * @default\n    */\n    this.angularDrag = 0;\n\n    /**\n    * @property {boolean} frequency - How often a particle is emitted in ms (if emitter is started with Explode === false).\n    * @default\n    */\n    this.frequency = 100;\n\n    /**\n    * @property {number} lifespan - How long each particle lives once it is emitted in ms. Default is 2 seconds. Set lifespan to 'zero' for particles to live forever.\n    * @default\n    */\n    this.lifespan = 2000;\n\n    /**\n    * @property {Phaser.Point} bounce - How much each particle should bounce on each axis. 1 = full bounce, 0 = no bounce.\n    */\n    this.bounce = new Phaser.Point();\n\n    /**\n    * @property {boolean} on - Determines whether the emitter is currently emitting particles. It is totally safe to directly toggle this.\n    * @default\n    */\n    this.on = false;\n\n    /**\n    * @property {Phaser.Point} particleAnchor - When a particle is created its anchor will be set to match this Point object (defaults to x/y: 0.5 to aid in rotation)\n    * @default\n    */\n    this.particleAnchor = new Phaser.Point(0.5, 0.5);\n\n    /**\n    * @property {number} blendMode - The blendMode as set on the particle when emitted from the Emitter. Defaults to NORMAL. Needs browser capable of supporting canvas blend-modes (most not available in WebGL)\n    * @default\n    */\n    this.blendMode = Phaser.blendModes.NORMAL;\n\n    /**\n    * The point the particles are emitted from.\n    * Emitter.x and Emitter.y control the containers location, which updates all current particles\n    * Emitter.emitX and Emitter.emitY control the emission location relative to the x/y position.\n    * @property {number} emitX\n    */\n    this.emitX = x;\n\n    /**\n    * The point the particles are emitted from.\n    * Emitter.x and Emitter.y control the containers location, which updates all current particles\n    * Emitter.emitX and Emitter.emitY control the emission location relative to the x/y position.\n    * @property {number} emitY\n    */\n    this.emitY = y;\n\n    /**\n    * @property {boolean} autoScale - When a new Particle is emitted this controls if it will automatically scale in size. Use Emitter.setScale to configure.\n    */\n    this.autoScale = false;\n\n    /**\n    * @property {boolean} autoAlpha - When a new Particle is emitted this controls if it will automatically change alpha. Use Emitter.setAlpha to configure.\n    */\n    this.autoAlpha = false;\n\n    /**\n    * @property {boolean} particleBringToTop - If this is `true` then when the Particle is emitted it will be bought to the top of the Emitters display list.\n    * @default\n    */\n    this.particleBringToTop = false;\n\n    /**\n    * @property {boolean} particleSendToBack - If this is `true` then when the Particle is emitted it will be sent to the back of the Emitters display list.\n    * @default\n    */\n    this.particleSendToBack = false;\n\n    /**\n    * @property {Phaser.Point} _minParticleScale - Internal particle scale var.\n    * @private\n    */\n    this._minParticleScale = new Phaser.Point(1, 1);\n\n    /**\n    * @property {Phaser.Point} _maxParticleScale - Internal particle scale var.\n    * @private\n    */\n    this._maxParticleScale = new Phaser.Point(1, 1);\n\n    /**\n    * @property {number} _quantity - Internal helper for deciding how many particles to launch.\n    * @private\n    */\n    this._quantity = 0;\n\n    /**\n    * @property {number} _timer - Internal helper for deciding when to launch particles or kill them.\n    * @private\n    */\n    this._timer = 0;\n\n    /**\n    * @property {number} _counter - Internal counter for figuring out how many particles to launch.\n    * @private\n    */\n    this._counter = 0;\n\n    /**\n    * @property {boolean} _explode - Internal helper for the style of particle emission (all at once, or one at a time).\n    * @private\n    */\n    this._explode = true;\n\n    /**\n    * @property {any} _frames - Internal helper for the particle frame.\n    * @private\n    */\n    this._frames = null;\n\n};\n\nPhaser.Particles.Arcade.Emitter.prototype = Object.create(Phaser.Group.prototype);\nPhaser.Particles.Arcade.Emitter.prototype.constructor = Phaser.Particles.Arcade.Emitter;\n\n/**\n* Called automatically by the game loop, decides when to launch particles and when to \"die\".\n* @method Phaser.Particles.Arcade.Emitter#update\n*/\nPhaser.Particles.Arcade.Emitter.prototype.update = function () {\n\n    if (this.on)\n    {\n        if (this._explode)\n        {\n            this._counter = 0;\n\n            do\n            {\n                this.emitParticle();\n                this._counter++;\n            }\n            while (this._counter < this._quantity);\n\n            this.on = false;\n        }\n        else\n        {\n            if (this.game.time.now >= this._timer)\n            {\n                this.emitParticle();\n\n                this._counter++;\n\n                if (this._quantity > 0)\n                {\n                    if (this._counter >= this._quantity)\n                    {\n                        this.on = false;\n                    }\n                }\n\n                this._timer = this.game.time.now + this.frequency;\n            }\n        }\n    }\n\n    var i = this.children.length;\n\n    while (i--)\n    {\n        if (this.children[i].exists)\n        {\n            this.children[i].update();\n        }\n    }\n\n};\n\n/**\n* This function generates a new set of particles for use by this emitter.\n* The particles are stored internally waiting to be emitted via Emitter.start.\n*\n* @method Phaser.Particles.Arcade.Emitter#makeParticles\n* @param {array|string} keys - A string or an array of strings that the particle sprites will use as their texture. If an array one is picked at random.\n* @param {array|number} [frames=0] - A frame number, or array of frames that the sprite will use. If an array one is picked at random.\n* @param {number} [quantity] - The number of particles to generate. If not given it will use the value of Emitter.maxParticles.\n* @param {boolean} [collide=false] - If you want the particles to be able to collide with other Arcade Physics bodies then set this to true.\n* @param {boolean} [collideWorldBounds=false] - A particle can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.\n* @return {Phaser.Particles.Arcade.Emitter} This Emitter instance.\n*/\nPhaser.Particles.Arcade.Emitter.prototype.makeParticles = function (keys, frames, quantity, collide, collideWorldBounds) {\n\n    if (typeof frames === 'undefined') { frames = 0; }\n    if (typeof quantity === 'undefined') { quantity = this.maxParticles; }\n    if (typeof collide === 'undefined') { collide = false; }\n    if (typeof collideWorldBounds === 'undefined') { collideWorldBounds = false; }\n\n    var particle;\n    var i = 0;\n    var rndKey = keys;\n    var rndFrame = frames;\n    this._frames = frames;\n\n    while (i < quantity)\n    {\n        if (typeof keys === 'object')\n        {\n            rndKey = this.game.rnd.pick(keys);\n        }\n\n        if (typeof frames === 'object')\n        {\n            rndFrame = this.game.rnd.pick(frames);\n        }\n\n        particle = new this.particleClass(this.game, 0, 0, rndKey, rndFrame);\n\n        this.game.physics.arcade.enable(particle, false);\n\n        if (collide)\n        {\n            particle.body.checkCollision.any = true;\n            particle.body.checkCollision.none = false;\n        }\n        else\n        {\n            particle.body.checkCollision.none = true;\n        }\n\n        particle.body.collideWorldBounds = collideWorldBounds;\n\n        particle.exists = false;\n        particle.visible = false;\n        particle.anchor.copyFrom(this.particleAnchor);\n\n        this.add(particle);\n\n        i++;\n    }\n\n    return this;\n\n};\n\n/**\n* Call this function to turn off all the particles and the emitter.\n*\n* @method Phaser.Particles.Arcade.Emitter#kill\n*/\nPhaser.Particles.Arcade.Emitter.prototype.kill = function () {\n\n    this.on = false;\n    this.alive = false;\n    this.exists = false;\n\n};\n\n/**\n* Handy for bringing game objects \"back to life\". Just sets alive and exists back to true.\n*\n* @method Phaser.Particles.Arcade.Emitter#revive\n*/\nPhaser.Particles.Arcade.Emitter.prototype.revive = function () {\n\n    this.alive = true;\n    this.exists = true;\n\n};\n\n/**\n* Call this function to start emitting particles.\n* @method Phaser.Particles.Arcade.Emitter#start\n* @param {boolean} [explode=true] - Whether the particles should all burst out at once (true) or at the frequency given (false).\n* @param {number} [lifespan=0] - How long each particle lives once emitted in ms. 0 = forever.\n* @param {number} [frequency=250] - Ignored if Explode is set to true. Frequency is how often to emit 1 particle. Value given in ms.\n* @param {number} [quantity=0] - How many particles to launch. 0 = \"all of the particles\".\n*/\nPhaser.Particles.Arcade.Emitter.prototype.start = function (explode, lifespan, frequency, quantity) {\n\n    if (typeof explode === 'undefined') { explode = true; }\n    if (typeof lifespan === 'undefined') { lifespan = 0; }\n    if (typeof frequency === 'undefined' || frequency === null) { frequency = 250; }\n    if (typeof quantity === 'undefined') { quantity = 0; }\n\n    this.revive();\n\n    this.visible = true;\n    this.on = true;\n\n    this._explode = explode;\n    this.lifespan = lifespan;\n    this.frequency = frequency;\n\n    if (explode)\n    {\n        this._quantity = quantity;\n    }\n    else\n    {\n        this._quantity += quantity;\n    }\n\n    this._counter = 0;\n    this._timer = this.game.time.now + frequency;\n\n};\n\n/**\n* This function can be used both internally and externally to emit the next particle in the queue.\n*\n* @method Phaser.Particles.Arcade.Emitter#emitParticle\n*/\nPhaser.Particles.Arcade.Emitter.prototype.emitParticle = function () {\n\n    var particle = this.getFirstExists(false);\n\n    if (particle === null)\n    {\n        return;\n    }\n\n    if (this.width > 1 || this.height > 1)\n    {\n        particle.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom));\n    }\n    else\n    {\n        particle.reset(this.emitX, this.emitY);\n    }\n\n    particle.angle = 0;\n    particle.lifespan = this.lifespan;\n\n    if (this.particleBringToTop)\n    {\n        this.bringToTop(particle);\n    }\n    else if (this.particleSendToBack)\n    {\n        this.sendToBack(particle);\n    }\n\n    if (this.autoScale)\n    {\n        particle.setScaleData(this.scaleData);\n    }\n    else if (this.minParticleScale !== 1 || this.maxParticleScale !== 1)\n    {\n        particle.scale.set(this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale));\n    }\n    else if ((this._minParticleScale.x !== this._maxParticleScale.x) || (this._minParticleScale.y !== this._maxParticleScale.y))\n    {\n        particle.scale.set(this.game.rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), this.game.rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y));\n    }\n\n    if (Array.isArray(this._frames === 'object'))\n    {\n        particle.frame = this.game.rnd.pick(this._frames);\n    }\n    else\n    {\n        particle.frame = this._frames;\n    }\n\n    if (this.autoAlpha)\n    {\n        particle.setAlphaData(this.alphaData);\n    }\n    else\n    {\n        particle.alpha = this.game.rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha);\n    }\n\n    particle.blendMode = this.blendMode;\n\n    particle.body.updateBounds();\n\n    particle.body.bounce.setTo(this.bounce.x, this.bounce.y);\n\n    particle.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x);\n    particle.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y);\n    particle.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation);\n\n    particle.body.gravity.y = this.gravity;\n\n    particle.body.drag.x = this.particleDrag.x;\n    particle.body.drag.y = this.particleDrag.y;\n\n    particle.body.angularDrag = this.angularDrag;\n\n    particle.onEmit();\n\n};\n\n/**\n* A more compact way of setting the width and height of the emitter.\n* @method Phaser.Particles.Arcade.Emitter#setSize\n* @param {number} width - The desired width of the emitter (particles are spawned randomly within these dimensions).\n* @param {number} height - The desired height of the emitter.\n*/\nPhaser.Particles.Arcade.Emitter.prototype.setSize = function (width, height) {\n\n    this.width = width;\n    this.height = height;\n\n};\n\n/**\n* A more compact way of setting the X velocity range of the emitter.\n* @method Phaser.Particles.Arcade.Emitter#setXSpeed\n* @param {number} [min=0] - The minimum value for this range.\n* @param {number} [max=0] - The maximum value for this range.\n*/\nPhaser.Particles.Arcade.Emitter.prototype.setXSpeed = function (min, max) {\n\n    min = min || 0;\n    max = max || 0;\n\n    this.minParticleSpeed.x = min;\n    this.maxParticleSpeed.x = max;\n\n};\n\n/**\n* A more compact way of setting the Y velocity range of the emitter.\n* @method Phaser.Particles.Arcade.Emitter#setYSpeed\n* @param {number} [min=0] - The minimum value for this range.\n* @param {number} [max=0] - The maximum value for this range.\n*/\nPhaser.Particles.Arcade.Emitter.prototype.setYSpeed = function (min, max) {\n\n    min = min || 0;\n    max = max || 0;\n\n    this.minParticleSpeed.y = min;\n    this.maxParticleSpeed.y = max;\n\n};\n\n/**\n* A more compact way of setting the angular velocity constraints of the particles.\n*\n* @method Phaser.Particles.Arcade.Emitter#setRotation\n* @param {number} [min=0] - The minimum value for this range.\n* @param {number} [max=0] - The maximum value for this range.\n*/\nPhaser.Particles.Arcade.Emitter.prototype.setRotation = function (min, max) {\n\n    min = min || 0;\n    max = max || 0;\n\n    this.minRotation = min;\n    this.maxRotation = max;\n\n};\n\n/**\n* A more compact way of setting the alpha constraints of the particles.\n* The rate parameter, if set to a value above zero, lets you set the speed at which the Particle change in alpha from min to max.\n* If rate is zero, which is the default, the particle won't change alpha - instead it will pick a random alpha between min and max on emit.\n*\n* @method Phaser.Particles.Arcade.Emitter#setAlpha\n* @param {number} [min=1] - The minimum value for this range.\n* @param {number} [max=1] - The maximum value for this range.\n* @param {number} [rate=0] - The rate (in ms) at which the particles will change in alpha from min to max, or set to zero to pick a random alpha between the two.\n* @param {number} [ease=Phaser.Easing.Linear.None] - If you've set a rate > 0 this is the easing formula applied between the min and max values.\n* @param {boolean} [yoyo=false] - If you've set a rate > 0 you can set if the ease will yoyo or not (i.e. ease back to its original values)\n*/\nPhaser.Particles.Arcade.Emitter.prototype.setAlpha = function (min, max, rate, ease, yoyo) {\n\n    if (typeof min === 'undefined') { min = 1; }\n    if (typeof max === 'undefined') { max = 1; }\n    if (typeof rate === 'undefined') { rate = 0; }\n    if (typeof ease === 'undefined') { ease = Phaser.Easing.Linear.None; }\n    if (typeof yoyo === 'undefined') { yoyo = false; }\n\n    this.minParticleAlpha = min;\n    this.maxParticleAlpha = max;\n    this.autoAlpha = false;\n\n    if (rate > 0 && min !== max)\n    {\n        var tweenData = { v: min };\n        var tween = this.game.make.tween(tweenData).to( { v: max }, rate, ease);\n        tween.yoyo(yoyo);\n\n        this.alphaData = tween.generateData(60);\n\n        //  Inverse it so we don't have to do array length look-ups in Particle update loops\n        this.alphaData.reverse();\n        this.autoAlpha = true;\n    }\n\n};\n\n/**\n* A more compact way of setting the scale constraints of the particles.\n* The rate parameter, if set to a value above zero, lets you set the speed and ease which the Particle uses to change in scale from min to max across both axis.\n* If rate is zero, which is the default, the particle won't change scale during update, instead it will pick a random scale between min and max on emit.\n*\n* @method Phaser.Particles.Arcade.Emitter#setScale\n* @param {number} [minX=1] - The minimum value of Particle.scale.x.\n* @param {number} [maxX=1] - The maximum value of Particle.scale.x.\n* @param {number} [minY=1] - The minimum value of Particle.scale.y.\n* @param {number} [maxY=1] - The maximum value of Particle.scale.y.\n* @param {number} [rate=0] - The rate (in ms) at which the particles will change in scale from min to max, or set to zero to pick a random size between the two.\n* @param {number} [ease=Phaser.Easing.Linear.None] - If you've set a rate > 0 this is the easing formula applied between the min and max values.\n* @param {boolean} [yoyo=false] - If you've set a rate > 0 you can set if the ease will yoyo or not (i.e. ease back to its original values)\n*/\nPhaser.Particles.Arcade.Emitter.prototype.setScale = function (minX, maxX, minY, maxY, rate, ease, yoyo) {\n\n    if (typeof minX === 'undefined') { minX = 1; }\n    if (typeof maxX === 'undefined') { maxX = 1; }\n    if (typeof minY === 'undefined') { minY = 1; }\n    if (typeof maxY === 'undefined') { maxY = 1; }\n    if (typeof rate === 'undefined') { rate = 0; }\n    if (typeof ease === 'undefined') { ease = Phaser.Easing.Linear.None; }\n    if (typeof yoyo === 'undefined') { yoyo = false; }\n\n    //  Reset these\n    this.minParticleScale = 1;\n    this.maxParticleScale = 1;\n\n    this._minParticleScale.set(minX, minY);\n    this._maxParticleScale.set(maxX, maxY);\n\n    this.autoScale = false;\n\n    if (rate > 0 && (minX !== maxX) || (minY !== maxY))\n    {\n        var tweenData = { x: minX, y: minY };\n        var tween = this.game.make.tween(tweenData).to( { x: maxX, y: maxY }, rate, ease);\n        tween.yoyo(yoyo);\n\n        this.scaleData = tween.generateData(60);\n\n        //  Inverse it so we don't have to do array length look-ups in Particle update loops\n        this.scaleData.reverse();\n        this.autoScale = true;\n    }\n\n};\n\n/**\n* Change the emitters center to match the center of any object with a `center` property, such as a Sprite.\n* If the object doesn't have a center property it will be set to object.x + object.width / 2\n*\n* @method Phaser.Particles.Arcade.Emitter#at\n* @param {object|Phaser.Sprite|Phaser.Image|Phaser.TileSprite|Phaser.Text|PIXI.DisplayObject} object - The object that you wish to match the center with.\n*/\nPhaser.Particles.Arcade.Emitter.prototype.at = function (object) {\n\n    if (object.center)\n    {\n        this.emitX = object.center.x;\n        this.emitY = object.center.y;\n    }\n    else\n    {\n        this.emitX = object.world.x + (object.anchor.x * object.width);\n        this.emitY = object.world.y + (object.anchor.y * object.height);\n    }\n\n};\n\n/**\n* @name Phaser.Particles.Arcade.Emitter#x\n* @property {number} x - Gets or sets the x position of the Emitter.\n*/\nObject.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, \"x\", {\n\n    get: function () {\n        return this.emitX;\n    },\n\n    set: function (value) {\n        this.emitX = value;\n    }\n\n});\n\n/**\n* @name Phaser.Particles.Arcade.Emitter#y\n* @property {number} y - Gets or sets the y position of the Emitter.\n*/\nObject.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, \"y\", {\n\n    get: function () {\n        return this.emitY;\n    },\n\n    set: function (value) {\n        this.emitY = value;\n    }\n\n});\n\n/**\n* @name Phaser.Particles.Arcade.Emitter#left\n* @property {number} left - Gets the left position of the Emitter.\n* @readonly\n*/\nObject.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, \"left\", {\n\n    get: function () {\n        return Math.floor(this.x - (this.width / 2));\n    }\n\n});\n\n/**\n* @name Phaser.Particles.Arcade.Emitter#right\n* @property {number} right - Gets the right position of the Emitter.\n* @readonly\n*/\nObject.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, \"right\", {\n\n    get: function () {\n        return Math.floor(this.x + (this.width / 2));\n    }\n\n});\n\n/**\n* @name Phaser.Particles.Arcade.Emitter#top\n* @property {number} top - Gets the top position of the Emitter.\n* @readonly\n*/\nObject.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, \"top\", {\n\n    get: function () {\n        return Math.floor(this.y - (this.height / 2));\n    }\n\n});\n\n/**\n* @name Phaser.Particles.Arcade.Emitter#bottom\n* @property {number} bottom - Gets the bottom position of the Emitter.\n* @readonly\n*/\nObject.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, \"bottom\", {\n\n    get: function () {\n        return Math.floor(this.y + (this.height / 2));\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Create a new `Tile` object.\n*\n* @class Phaser.Tile\n* @classdesc A Tile is a representation of a single tile within the Tilemap.\n* @constructor\n* @param {object} layer - The layer in the Tilemap data that this tile belongs to.\n* @param {number} index - The index of this tile type in the core map data.\n* @param {number} x - The x coordinate of this tile.\n* @param {number} y - The y coordinate of this tile.\n* @param {number} width - Width of the tile.\n* @param {number} height - Height of the tile.\n*/\nPhaser.Tile = function (layer, index, x, y, width, height) {\n\n    /**\n    * @property {object} layer - The layer in the Tilemap data that this tile belongs to.\n    */\n    this.layer = layer;\n\n    /**\n    * @property {number} index - The index of this tile within the map data corresponding to the tileset, or -1 if this represents a blank/null tile.\n    */\n    this.index = index;\n\n    /**\n    * @property {number} x - The x map coordinate of this tile.\n    */\n    this.x = x;\n\n    /**\n    * @property {number} y - The y map coordinate of this tile.\n    */\n    this.y = y;\n\n    /**\n    * @property {number} x - The x map coordinate of this tile.\n    */\n    this.worldX = x * width;\n\n    /**\n    * @property {number} y - The y map coordinate of this tile.\n    */\n    this.worldY = y * height;\n\n    /**\n    * @property {number} width - The width of the tile in pixels.\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height of the tile in pixels.\n    */\n    this.height = height;\n\n    /**\n    * @property {number} width - The width of the tile in pixels.\n    */\n    this.centerX = Math.abs(width / 2);\n\n    /**\n    * @property {number} height - The height of the tile in pixels.\n    */\n    this.centerY = Math.abs(height / 2);\n\n    /**\n    * @property {number} alpha - The alpha value at which this tile is drawn to the canvas.\n    */\n    this.alpha = 1;\n\n    /**\n    * @property {object} properties - Tile specific properties.\n    */\n    this.properties = {};\n\n    /**\n    * @property {boolean} scanned - Has this tile been walked / turned into a poly?\n    */\n    this.scanned = false;\n\n    /**\n    * @property {boolean} faceTop - Is the top of this tile an interesting edge?\n    */\n    this.faceTop = false;\n\n    /**\n    * @property {boolean} faceBottom - Is the bottom of this tile an interesting edge?\n    */\n    this.faceBottom = false;\n\n    /**\n    * @property {boolean} faceLeft - Is the left of this tile an interesting edge?\n    */\n    this.faceLeft = false;\n\n    /**\n    * @property {boolean} faceRight - Is the right of this tile an interesting edge?\n    */\n    this.faceRight = false;\n\n    /**\n    * @property {boolean} collideLeft - Indicating collide with any object on the left.\n    * @default\n    */\n    this.collideLeft = false;\n\n    /**\n    * @property {boolean} collideRight - Indicating collide with any object on the right.\n    * @default\n    */\n    this.collideRight = false;\n\n    /**\n    * @property {boolean} collideUp - Indicating collide with any object on the top.\n    * @default\n    */\n    this.collideUp = false;\n\n    /**\n    * @property {boolean} collideDown - Indicating collide with any object on the bottom.\n    * @default\n    */\n    this.collideDown = false;\n\n    /**\n    * @property {function} collisionCallback - Tile collision callback.\n    * @default\n    */\n    this.collisionCallback = null;\n\n    /**\n    * @property {object} collisionCallbackContext - The context in which the collision callback will be called.\n    * @default\n    */\n    this.collisionCallbackContext = this;\n\n};\n\nPhaser.Tile.prototype = {\n\n    /**\n    * Check if the given x and y world coordinates are within this Tile.\n    *\n    * @method Phaser.Tile#containsPoint\n    * @param {number} x - The x coordinate to test.\n    * @param {number} y - The y coordinate to test.\n    * @return {boolean} True if the coordinates are within this Tile, otherwise false.\n    */\n    containsPoint: function (x, y) {\n\n        return !(x < this.worldX || y < this.worldY || x > this.right || y > this.bottom);\n\n    },\n\n    /**\n    * Check for intersection with this tile.\n    *\n    * @method Phaser.Tile#intersects\n    * @param {number} x - The x axis in pixels.\n    * @param {number} y - The y axis in pixels.\n    * @param {number} right - The right point.\n    * @param {number} bottom - The bottom point.\n    */\n    intersects: function (x, y, right, bottom) {\n\n        if (right <= this.worldX)\n        {\n            return false;\n        }\n\n        if (bottom <= this.worldY)\n        {\n            return false;\n        }\n\n        if (x >= this.worldX + this.width)\n        {\n            return false;\n        }\n\n        if (y >= this.worldY + this.height)\n        {\n            return false;\n        }\n\n        return true;\n\n    },\n\n    /**\n    * Set a callback to be called when this tile is hit by an object.\n    * The callback must true true for collision processing to take place.\n    *\n    * @method Phaser.Tile#setCollisionCallback\n    * @param {function} callback - Callback function.\n    * @param {object} context - Callback will be called within this context.\n    */\n    setCollisionCallback: function (callback, context) {\n\n        this.collisionCallback = callback;\n        this.collisionCallbackContext = context;\n\n    },\n\n    /**\n    * Clean up memory.\n    *\n    * @method Phaser.Tile#destroy\n    */\n    destroy: function () {\n\n        this.collisionCallback = null;\n        this.collisionCallbackContext = null;\n        this.properties = null;\n\n    },\n\n    /**\n    * Set collision settings on this tile.\n    *\n    * @method Phaser.Tile#setCollision\n    * @param {boolean} left - Indicating collide with any object on the left.\n    * @param {boolean} right - Indicating collide with any object on the right.\n    * @param {boolean} up - Indicating collide with any object on the top.\n    * @param {boolean} down - Indicating collide with any object on the bottom.\n    */\n    setCollision: function (left, right, up, down) {\n\n        this.collideLeft = left;\n        this.collideRight = right;\n        this.collideUp = up;\n        this.collideDown = down;\n\n    },\n\n    /**\n    * Reset collision status flags.\n    *\n    * @method Phaser.Tile#resetCollision\n    */\n    resetCollision: function () {\n\n        this.collideLeft = false;\n        this.collideRight = false;\n        this.collideUp = false;\n        this.collideDown = false;\n\n        this.faceTop = false;\n        this.faceBottom = false;\n        this.faceLeft = false;\n        this.faceRight = false;\n\n    },\n\n    /**\n    * Is this tile interesting?\n    *\n    * @method Phaser.Tile#isInteresting\n    * @param {boolean} collides - If true will check any collides value.\n    * @param {boolean} faces - If true will check any face value.\n    * @return {boolean} True if the Tile is interesting, otherwise false.\n    */\n    isInteresting: function (collides, faces) {\n\n        if (collides && faces)\n        {\n            //  Does this tile have any collide flags OR interesting face?\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback);\n        }\n        else if (collides)\n        {\n            //  Does this tile collide?\n            return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\n        }\n        else if (faces)\n        {\n            //  Does this tile have an interesting face?\n            return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight);\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Copies the tile data and properties from the given tile to this tile.\n    *\n    * @method Phaser.Tile#copy\n    * @param {Phaser.Tile} tile - The tile to copy from.\n    */\n    copy: function (tile) {\n\n        this.index = tile.index;\n        this.alpha = tile.alpha;\n        this.properties = tile.properties;\n\n        this.collideUp = tile.collideUp;\n        this.collideDown = tile.collideDown;\n        this.collideLeft = tile.collideLeft;\n        this.collideRight = tile.collideRight;\n\n        this.collisionCallback = tile.collisionCallback;\n        this.collisionCallbackContext = tile.collisionCallbackContext;\n\n    }\n\n};\n\nPhaser.Tile.prototype.constructor = Phaser.Tile;\n\n/**\n* @name Phaser.Tile#collides\n* @property {boolean} collides - True if this tile can collide on any of its faces.\n* @readonly\n*/\nObject.defineProperty(Phaser.Tile.prototype, \"collides\", {\n\n    get: function () {\n        return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown);\n    }\n\n});\n\n/**\n* @name Phaser.Tile#canCollide\n* @property {boolean} canCollide - True if this tile can collide on any of its faces or has a collision callback set.\n* @readonly\n*/\nObject.defineProperty(Phaser.Tile.prototype, \"canCollide\", {\n\n    get: function () {\n        return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback);\n    }\n\n});\n\n/**\n* @name Phaser.Tile#left\n* @property {number} left - The x value in pixels.\n* @readonly\n*/\nObject.defineProperty(Phaser.Tile.prototype, \"left\", {\n\n    get: function () {\n        return this.worldX;\n    }\n\n});\n\n/**\n* @name Phaser.Tile#right\n* @property {number} right - The sum of the x and width properties.\n* @readonly\n*/\nObject.defineProperty(Phaser.Tile.prototype, \"right\", {\n\n    get: function () {\n        return this.worldX + this.width;\n    }\n\n});\n\n/**\n* @name Phaser.Tile#top\n* @property {number} top - The y value.\n* @readonly\n*/\nObject.defineProperty(Phaser.Tile.prototype, \"top\", {\n\n    get: function () {\n        return this.worldY;\n    }\n\n});\n\n/**\n* @name Phaser.Tile#bottom\n* @property {number} bottom - The sum of the y and height properties.\n* @readonly\n*/\nObject.defineProperty(Phaser.Tile.prototype, \"bottom\", {\n\n    get: function () {\n        return this.worldY + this.height;\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a new Phaser.Tilemap object. The map can either be populated with data from a Tiled JSON file or from a CSV file.\n* To do this pass the Cache key as the first parameter. When using Tiled data you need only provide the key.\n* When using CSV data you must provide the key and the tileWidth and tileHeight parameters.\n* If creating a blank tilemap to be populated later, you can either specify no parameters at all and then use `Tilemap.create` or pass the map and tile dimensions here.\n* Note that all Tilemaps use a base tile size to calculate dimensions from, but that a TilemapLayer may have its own unique tile size that overrides it.\n* A Tile map is rendered to the display using a TilemapLayer. It is not added to the display list directly itself.\n* A map may have multiple layers. You can perform operations on the map data such as copying, pasting, filling and shuffling the tiles around.\n*\n* @class Phaser.Tilemap\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n* @param {string} [key] - The key of the tilemap data as stored in the Cache. If you're creating a blank map either leave this parameter out or pass `null`.\n* @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n* @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n* @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n* @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n*/\nPhaser.Tilemap = function (game, key, tileWidth, tileHeight, width, height) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {string} key - The key of this map data in the Phaser.Cache.\n    */\n    this.key = key;\n\n    var data = Phaser.TilemapParser.parse(this.game, key, tileWidth, tileHeight, width, height);\n\n    if (data === null)\n    {\n        return;\n    }\n\n    /**\n    * @property {number} width - The width of the map (in tiles).\n    */\n    this.width = data.width;\n\n    /**\n    * @property {number} height - The height of the map (in tiles).\n    */\n    this.height = data.height;\n\n    /**\n    * @property {number} tileWidth - The base width of the tiles in the map (in pixels).\n    */\n    this.tileWidth = data.tileWidth;\n\n    /**\n    * @property {number} tileHeight - The base height of the tiles in the map (in pixels).\n    */\n    this.tileHeight = data.tileHeight;\n\n    /**\n    * @property {string} orientation - The orientation of the map data (as specified in Tiled), usually 'orthogonal'.\n    */\n    this.orientation = data.orientation;\n\n    /**\n    * @property {number} format - The format of the map data, either Phaser.Tilemap.CSV or Phaser.Tilemap.TILED_JSON.\n    */\n    this.format = data.format;\n\n    /**\n    * @property {number} version - The version of the map data (as specified in Tiled, usually 1).\n    */\n    this.version = data.version;\n\n    /**\n    * @property {object} properties - Map specific properties as specified in Tiled.\n    */\n    this.properties = data.properties;\n\n    /**\n    * @property {number} widthInPixels - The width of the map in pixels based on width * tileWidth.\n    */\n    this.widthInPixels = data.widthInPixels;\n\n    /**\n    * @property {number} heightInPixels - The height of the map in pixels based on height * tileHeight.\n    */\n    this.heightInPixels = data.heightInPixels;\n\n    /**\n    * @property {array} layers - An array of Tilemap layer data.\n    */\n    this.layers = data.layers;\n\n    /**\n    * @property {array} tilesets - An array of Tilesets.\n    */\n    this.tilesets = data.tilesets;\n\n    /**\n    * @property {array} tiles - The super array of Tiles.\n    */\n    this.tiles = data.tiles;\n\n    /**\n    * @property {array} objects - An array of Tiled Object Layers.\n    */\n    this.objects = data.objects;\n\n    /**\n    * @property {array} collideIndexes - An array of tile indexes that collide.\n    */\n    this.collideIndexes = [];\n\n    /**\n    * @property {array} collision - An array of collision data (polylines, etc).\n    */\n    this.collision = data.collision;\n\n    /**\n    * @property {array} images - An array of Tiled Image Layers.\n    */\n    this.images = data.images;\n\n    /**\n    * @property {number} currentLayer - The current layer.\n    */\n    this.currentLayer = 0;\n\n    /**\n    * @property {array} debugMap - Map data used for debug values only.\n    */\n    this.debugMap = [];\n\n    /**\n    * @property {array} _results - Internal var.\n    * @private\n    */\n    this._results = [];\n\n    /**\n    * @property {number} _tempA - Internal var.\n    * @private\n    */\n    this._tempA = 0;\n\n    /**\n    * @property {number} _tempB - Internal var.\n    * @private\n    */\n    this._tempB = 0;\n\n};\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Tilemap.CSV = 0;\n\n/**\n* @constant\n* @type {number}\n*/\nPhaser.Tilemap.TILED_JSON = 1;\n\nPhaser.Tilemap.prototype = {\n\n    /**\n    * Creates an empty map of the given dimensions and one blank layer. If layers already exist they are erased.\n    *\n    * @method Phaser.Tilemap#create\n    * @param {string} name - The name of the default layer of the map.\n    * @param {number} width - The width of the map in tiles.\n    * @param {number} height - The height of the map in tiles.\n    * @param {number} tileWidth - The width of the tiles the map uses for calculations.\n    * @param {number} tileHeight - The height of the tiles the map uses for calculations.\n    * @param {Phaser.Group} [group] - Optional Group to add the layer to. If not specified it will be added to the World group.\n    * @return {Phaser.TilemapLayer} The TilemapLayer object. This is an extension of Phaser.Image and can be moved around the display list accordingly.\n    */\n    create: function (name, width, height, tileWidth, tileHeight, group) {\n\n        if (typeof group === 'undefined') { group = this.game.world; }\n\n        this.width = width;\n        this.height = height;\n\n        this.setTileSize(tileWidth, tileHeight);\n\n        this.layers.length = 0;\n\n        return this.createBlankLayer(name, width, height, tileWidth, tileHeight, group);\n\n    },\n\n    /**\n    * Sets the base tile size for the map.\n    *\n    * @method Phaser.Tilemap#setTileSize\n    * @param {number} tileWidth - The width of the tiles the map uses for calculations.\n    * @param {number} tileHeight - The height of the tiles the map uses for calculations.\n    */\n    setTileSize: function (tileWidth, tileHeight) {\n\n        this.tileWidth = tileWidth;\n        this.tileHeight = tileHeight;\n        this.widthInPixels = this.width * tileWidth;\n        this.heightInPixels = this.height * tileHeight;\n\n    },\n\n    /**\n    * Adds an image to the map to be used as a tileset. A single map may use multiple tilesets.\n    * Note that the tileset name can be found in the JSON file exported from Tiled, or in the Tiled editor.\n    *\n    * @method Phaser.Tilemap#addTilesetImage\n    * @param {string} tileset - The name of the tileset as specified in the map data.\n    * @param {string} [key] - The key of the Phaser.Cache image used for this tileset. If not specified it will look for an image with a key matching the tileset parameter.\n    * @param {number} [tileWidth=32] - The width of the tiles in the Tileset Image. If not given it will default to the map.tileWidth value, if that isn't set then 32.\n    * @param {number} [tileHeight=32] - The height of the tiles in the Tileset Image. If not given it will default to the map.tileHeight value, if that isn't set then 32.\n    * @param {number} [tileMargin=0] - The width of the tiles in the Tileset Image. If not given it will default to the map.tileWidth value.\n    * @param {number} [tileSpacing=0] - The height of the tiles in the Tileset Image. If not given it will default to the map.tileHeight value.\n    * @param {number} [gid=0] - If adding multiple tilesets to a blank/dynamic map, specify the starting GID the set will use here.\n    * @return {Phaser.Tileset} Returns the Tileset object that was created or updated, or null if it failed.\n    */\n    addTilesetImage: function (tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) {\n\n        if (typeof tileWidth === 'undefined') { tileWidth = this.tileWidth; }\n        if (typeof tileHeight === 'undefined') { tileHeight = this.tileHeight; }\n        if (typeof tileMargin === 'undefined') { tileMargin = 0; }\n        if (typeof tileSpacing === 'undefined') { tileSpacing = 0; }\n        if (typeof gid === 'undefined') { gid = 0; }\n\n        //  In-case we're working from a blank map\n        if (tileWidth === 0)\n        {\n            tileWidth = 32;\n        }\n\n        if (tileHeight === 0)\n        {\n            tileHeight = 32;\n        }\n\n        if (typeof key === 'undefined')\n        {\n            if (typeof tileset === 'string')\n            {\n                key = tileset;\n\n                if (!this.game.cache.checkImageKey(key))\n                {\n                    console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: \"' + key + '\"');\n                    return null;\n                }\n            }\n            else\n            {\n                return null;\n            }\n        }\n\n        if (typeof tileset === 'string')\n        {\n            tileset = this.getTilesetIndex(tileset);\n\n            if (tileset === null && this.format === Phaser.Tilemap.TILED_JSON)\n            {\n                console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: \"' + key + '\"');\n                return null;\n            }\n        }\n\n        if (this.tilesets[tileset])\n        {\n            this.tilesets[tileset].setImage(this.game.cache.getImage(key));\n            return this.tilesets[tileset];\n        }\n        else\n        {\n            var newSet = new Phaser.Tileset(key, gid, tileWidth, tileHeight, tileMargin, tileSpacing, {});\n\n            newSet.setImage(this.game.cache.getImage(key));\n\n            this.tilesets.push(newSet);\n\n            var i = this.tilesets.length - 1;\n            var x = tileMargin;\n            var y = tileMargin;\n\n            var count = 0;\n            var countX = 0;\n            var countY = 0;\n\n            for (var t = gid; t < gid + newSet.total; t++)\n            {\n                this.tiles[t] = [x, y, i];\n\n                x += tileWidth + tileSpacing;\n\n                count++;\n\n                if (count === newSet.total)\n                {\n                    break;\n                }\n\n                countX++;\n\n                if (countX === newSet.columns)\n                {\n                    x = tileMargin;\n                    y += tileHeight + tileSpacing;\n\n                    countX = 0;\n                    countY++;\n\n                    if (countY === newSet.rows)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            return newSet;\n\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Creates a Sprite for every object matching the given gid in the map data. You can optionally specify the group that the Sprite will be created in. If none is\n    * given it will be created in the World. All properties from the map data objectgroup are copied across to the Sprite, so you can use this as an easy way to\n    * configure Sprite properties from within the map editor. For example giving an object a property of alpha: 0.5 in the map editor will duplicate that when the\n    * Sprite is created. You could also give it a value like: body.velocity.x: 100 to set it moving automatically.\n    *\n    * @method Phaser.Tilemap#createFromObjects\n    * @param {string} name - The name of the Object Group to create Sprites from.\n    * @param {number} gid - The layer array index value, or if a string is given the layer name within the map data.\n    * @param {string} key - The Game.cache key of the image that this Sprite will use.\n    * @param {number|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.\n    * @param {boolean} [exists=true] - The default exists state of the Sprite.\n    * @param {boolean} [autoCull=false] - The default autoCull state of the Sprite. Sprites that are autoCulled are culled from the camera if out of its range.\n    * @param {Phaser.Group} [group=Phaser.World] - Group to add the Sprite to. If not specified it will be added to the World group.\n    * @param {object} [CustomClass=Phaser.Sprite] - If you wish to create your own class, rather than Phaser.Sprite, pass the class here. Your class must extend Phaser.Sprite and have the same constructor parameters.\n    * @param {boolean} [adjustY=true] - By default the Tiled map editor uses a bottom-left coordinate system. Phaser uses top-left. So most objects will appear too low down. This parameter moves them up by their height.\n    */\n    createFromObjects: function (name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) {\n\n        if (typeof exists === 'undefined') { exists = true; }\n        if (typeof autoCull === 'undefined') { autoCull = false; }\n        if (typeof group === 'undefined') { group = this.game.world; }\n        if (typeof CustomClass === 'undefined') { CustomClass = Phaser.Sprite; }\n        if (typeof adjustY === 'undefined') { adjustY = true; }\n\n        if (!this.objects[name])\n        {\n            console.warn('Tilemap.createFromObjects: Invalid objectgroup name given: ' + name);\n            return;\n        }\n\n        var sprite;\n\n        for (var i = 0, len = this.objects[name].length; i < len; i++)\n        {\n            if (this.objects[name][i].gid === gid)\n            {\n                sprite = new CustomClass(this.game, this.objects[name][i].x, this.objects[name][i].y, key, frame);\n\n                sprite.name = this.objects[name][i].name;\n                sprite.visible = this.objects[name][i].visible;\n                sprite.autoCull = autoCull;\n                sprite.exists = exists;\n\n                if (adjustY)\n                {\n                    sprite.y -= sprite.height;\n                }\n\n                group.add(sprite);\n\n                for (var property in this.objects[name][i].properties)\n                {\n                    group.set(sprite, property, this.objects[name][i].properties[property], false, false, 0);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Creates a new TilemapLayer object. By default TilemapLayers are fixed to the camera.\n    * The `layer` parameter is important. If you've created your map in Tiled then you can get this by looking in Tiled and looking at the Layer name.\n    * Or you can open the JSON file it exports and look at the layers[].name value. Either way it must match.\n    * If you wish to create a blank layer to put your own tiles on then see Tilemap.createBlankLayer.\n    *\n    * @method Phaser.Tilemap#createLayer\n    * @param {number|string} layer - The layer array index value, or if a string is given the layer name, within the map data that this TilemapLayer represents.\n    * @param {number} [width] - The rendered width of the layer, should never be wider than Game.width. If not given it will be set to Game.width.\n    * @param {number} [height] - The rendered height of the layer, should never be wider than Game.height. If not given it will be set to Game.height.\n    * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n    * @return {Phaser.TilemapLayer} The TilemapLayer object. This is an extension of Phaser.Sprite and can be moved around the display list accordingly.\n    */\n    createLayer: function (layer, width, height, group) {\n\n        //  Add Buffer support for the left of the canvas\n\n        if (typeof width === 'undefined') { width = this.game.width; }\n        if (typeof height === 'undefined') { height = this.game.height; }\n        if (typeof group === 'undefined') { group = this.game.world; }\n\n        var index = layer;\n\n        if (typeof layer === 'string')\n        {\n            index = this.getLayerIndex(layer);\n        }\n\n        if (index === null || index > this.layers.length)\n        {\n            console.warn('Tilemap.createLayer: Invalid layer ID given: ' + index);\n            return;\n        }\n\n        return group.add(new Phaser.TilemapLayer(this.game, this, index, width, height));\n\n    },\n\n    /**\n    * Creates a new and empty layer on this Tilemap. By default TilemapLayers are fixed to the camera.\n    *\n    * @method Phaser.Tilemap#createLayer\n    * @param {string} name - The name of this layer. Must be unique within the map.\n    * @param {number} width - The width of the layer in tiles.\n    * @param {number} height - The height of the layer in tiles.\n    * @param {number} tileWidth - The width of the tiles the layer uses for calculations.\n    * @param {number} tileHeight - The height of the tiles the layer uses for calculations.\n    * @param {Phaser.Group} [group] - Optional Group to add the layer to. If not specified it will be added to the World group.\n    * @return {Phaser.TilemapLayer} The TilemapLayer object. This is an extension of Phaser.Image and can be moved around the display list accordingly.\n    */\n    createBlankLayer: function (name, width, height, tileWidth, tileHeight, group) {\n\n        if (typeof group === 'undefined') { group = this.game.world; }\n\n        if (this.getLayerIndex(name) !== null)\n        {\n            console.warn('Tilemap.createBlankLayer: Layer with matching name already exists');\n            return;\n        }\n\n        var layer = {\n\n            name: name,\n            x: 0,\n            y: 0,\n            width: width,\n            height: height,\n            widthInPixels: width * tileWidth,\n            heightInPixels: height * tileHeight,\n            alpha: 1,\n            visible: true,\n            properties: {},\n            indexes: [],\n            callbacks: [],\n            bodies: [],\n            data: null\n\n        };\n\n        var row;\n        var output = [];\n\n        for (var y = 0; y < height; y++)\n        {\n            row = [];\n\n            for (var x = 0; x < width; x++)\n            {\n                // row.push(null);\n                row.push(new Phaser.Tile(layer, -1, x, y, tileWidth, tileHeight));\n            }\n\n            output.push(row);\n        }\n\n        layer.data = output;\n\n        this.layers.push(layer);\n\n        this.currentLayer = this.layers.length - 1;\n\n        var w = layer.widthInPixels;\n        var h = layer.heightInPixels;\n\n        if (w > this.game.width)\n        {\n            w = this.game.width;\n        }\n\n        if (h > this.game.height)\n        {\n            h = this.game.height;\n        }\n\n        var output = new Phaser.TilemapLayer(this.game, this, this.layers.length - 1, w, h);\n        output.name = name;\n\n        return group.add(output);\n\n    },\n\n    /**\n    * Gets the layer index based on the layers name.\n    *\n    * @method Phaser.Tilemap#getIndex\n    * @protected\n    * @param {array} location - The local array to search.\n    * @param {string} name - The name of the array element to get.\n    * @return {number} The index of the element in the array, or null if not found.\n    */\n    getIndex: function (location, name) {\n\n        for (var i = 0; i < location.length; i++)\n        {\n            if (location[i].name === name)\n            {\n                return i;\n            }\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Gets the layer index based on its name.\n    *\n    * @method Phaser.Tilemap#getLayerIndex\n    * @param {string} name - The name of the layer to get.\n    * @return {number} The index of the layer in this tilemap, or null if not found.\n    */\n    getLayerIndex: function (name) {\n\n        return this.getIndex(this.layers, name);\n\n    },\n\n    /**\n    * Gets the tileset index based on its name.\n    *\n    * @method Phaser.Tilemap#getTilesetIndex\n    * @param {string} name - The name of the tileset to get.\n    * @return {number} The index of the tileset in this tilemap, or null if not found.\n    */\n    getTilesetIndex: function (name) {\n\n        return this.getIndex(this.tilesets, name);\n\n    },\n\n    /**\n    * Gets the image index based on its name.\n    *\n    * @method Phaser.Tilemap#getImageIndex\n    * @param {string} name - The name of the image to get.\n    * @return {number} The index of the image in this tilemap, or null if not found.\n    */\n    getImageIndex: function (name) {\n\n        return this.getIndex(this.images, name);\n\n    },\n\n    /**\n    * Gets the object index based on its name.\n    *\n    * @method Phaser.Tilemap#getObjectIndex\n    * @param {string} name - The name of the object to get.\n    * @return {number} The index of the object in this tilemap, or null if not found.\n    */\n    getObjectIndex: function (name) {\n\n        return this.getIndex(this.objects, name);\n\n    },\n\n    /**\n    * Sets a global collision callback for the given tile index within the layer. This will affect all tiles on this layer that have the same index.\n    * If a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.\n    * If you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.\n    *\n    * @method Phaser.Tilemap#setTileIndexCallback\n    * @param {number|array} indexes - Either a single tile index, or an array of tile indexes to have a collision callback set for.\n    * @param {function} callback - The callback that will be invoked when the tile is collided with.\n    * @param {object} callbackContext - The context under which the callback is called.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.\n    */\n    setTileIndexCallback: function (indexes, callback, callbackContext, layer) {\n\n        layer = this.getLayer(layer);\n\n        if (typeof indexes === 'number')\n        {\n            //  This may seem a bit wasteful, because it will cause empty array elements to be created, but the look-up cost is much\n            //  less than having to iterate through the callbacks array hunting down tile indexes each frame, so I'll take the small memory hit.\n            this.layers[layer].callbacks[indexes] = { callback: callback, callbackContext: callbackContext };\n        }\n        else\n        {\n            for (var i = 0, len = indexes.length; i < len; i++)\n            {\n                this.layers[layer].callbacks[indexes[i]] = { callback: callback, callbackContext: callbackContext };\n            }\n        }\n\n    },\n\n    /**\n    * Sets a global collision callback for the given map location within the layer. This will affect all tiles on this layer found in the given area.\n    * If a callback is already set for the tile index it will be replaced. Set the callback to null to remove it.\n    * If you want to set a callback for a tile at a specific location on the map then see setTileLocationCallback.\n    *\n    * @method Phaser.Tilemap#setTileLocationCallback\n    * @param {number} x - X position of the top left of the area to copy (given in tiles, not pixels)\n    * @param {number} y - Y position of the top left of the area to copy (given in tiles, not pixels)\n    * @param {number} width - The width of the area to copy (given in tiles, not pixels)\n    * @param {number} height - The height of the area to copy (given in tiles, not pixels)\n    * @param {function} callback - The callback that will be invoked when the tile is collided with.\n    * @param {object} callbackContext - The context under which the callback is called.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.\n    */\n    setTileLocationCallback: function (x, y, width, height, callback, callbackContext, layer) {\n\n        layer = this.getLayer(layer);\n\n        this.copy(x, y, width, height, layer);\n\n        if (this._results.length < 2)\n        {\n            return;\n        }\n\n        for (var i = 1; i < this._results.length; i++)\n        {\n            this._results[i].setCollisionCallback(callback, callbackContext);\n        }\n\n    },\n\n    /**\n    * Sets collision the given tile or tiles. You can pass in either a single numeric index or an array of indexes: [ 2, 3, 15, 20].\n    * The `collides` parameter controls if collision will be enabled (true) or disabled (false).\n    *\n    * @method Phaser.Tilemap#setCollision\n    * @param {number|array} indexes - Either a single tile index, or an array of tile IDs to be checked for collision.\n    * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.\n    */\n    setCollision: function (indexes, collides, layer) {\n\n        if (typeof collides === 'undefined') { collides = true; }\n\n        layer = this.getLayer(layer);\n\n        if (typeof indexes === 'number')\n        {\n            return this.setCollisionByIndex(indexes, collides, layer, true);\n        }\n        else\n        {\n            //  Collide all of the IDs given in the indexes array\n            for (var i = 0, len = indexes.length; i < len; i++)\n            {\n                this.setCollisionByIndex(indexes[i], collides, layer, false);\n            }\n\n            //  Now re-calculate interesting faces\n            this.calculateFaces(layer);\n        }\n\n    },\n\n    /**\n    * Sets collision on a range of tiles where the tile IDs increment sequentially.\n    * Calling this with a start value of 10 and a stop value of 14 would set collision for tiles 10, 11, 12, 13 and 14.\n    * The `collides` parameter controls if collision will be enabled (true) or disabled (false).\n    *\n    * @method Phaser.Tilemap#setCollisionBetween\n    * @param {number} start - The first index of the tile to be set for collision.\n    * @param {number} stop - The last index of the tile to be set for collision.\n    * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.\n    */\n    setCollisionBetween: function (start, stop, collides, layer) {\n\n        if (typeof collides === 'undefined') { collides = true; }\n\n        layer = this.getLayer(layer);\n\n        if (start > stop)\n        {\n            return;\n        }\n\n        for (var index = start; index <= stop; index++)\n        {\n            this.setCollisionByIndex(index, collides, layer, false);\n        }\n\n        //  Now re-calculate interesting faces\n        this.calculateFaces(layer);\n\n    },\n\n    /**\n    * Sets collision on all tiles in the given layer, except for the IDs of those in the given array.\n    * The `collides` parameter controls if collision will be enabled (true) or disabled (false).\n    *\n    * @method Phaser.Tilemap#setCollisionByExclusion\n    * @param {array} indexes - An array of the tile IDs to not be counted for collision.\n    * @param {boolean} [collides=true] - If true it will enable collision. If false it will clear collision.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to this.currentLayer.\n    */\n    setCollisionByExclusion: function (indexes, collides, layer) {\n\n        if (typeof collides === 'undefined') { collides = true; }\n\n        layer = this.getLayer(layer);\n\n        //  Collide everything, except the IDs given in the indexes array\n        for (var i = 0, len = this.tiles.length; i < len; i++)\n        {\n            if (indexes.indexOf(i) === -1)\n            {\n                this.setCollisionByIndex(i, collides, layer, false);\n            }\n        }\n\n        //  Now re-calculate interesting faces\n        this.calculateFaces(layer);\n\n    },\n\n    /**\n    * Sets collision values on a tile in the set.\n    * You shouldn't usually call this method directly, instead use setCollision, setCollisionBetween or setCollisionByExclusion.\n    *\n    * @method Phaser.Tilemap#setCollisionByIndex\n    * @protected\n    * @param {number} index - The index of the tile on the layer.\n    * @param {boolean} [collides=true] - If true it will enable collision on the tile. If false it will clear collision values from the tile.\n    * @param {number} [layer] - The layer to operate on. If not given will default to this.currentLayer.\n    * @param {boolean} [recalculate=true] - Recalculates the tile faces after the update.\n    */\n    setCollisionByIndex: function (index, collides, layer, recalculate) {\n\n        if (typeof collides === 'undefined') { collides = true; }\n        if (typeof layer === 'undefined') { layer = this.currentLayer; }\n        if (typeof recalculate === 'undefined') { recalculate = true; }\n\n        if (collides)\n        {\n            this.collideIndexes.push(index);\n        }\n        else\n        {\n            var i = this.collideIndexes.indexOf(index);\n\n            if (i > -1)\n            {\n                this.collideIndexes.splice(i, 1);\n            }\n        }\n\n        for (var y = 0; y < this.layers[layer].height; y++)\n        {\n            for (var x = 0; x < this.layers[layer].width; x++)\n            {\n                var tile = this.layers[layer].data[y][x];\n\n                if (tile && tile.index === index)\n                {\n                    if (collides)\n                    {\n                        tile.setCollision(true, true, true, true);\n                    }\n                    else\n                    {\n                        tile.resetCollision();\n                    }\n\n                    tile.faceTop = collides;\n                    tile.faceBottom = collides;\n                    tile.faceLeft = collides;\n                    tile.faceRight = collides;\n                }\n            }\n        }\n\n        if (recalculate)\n        {\n            //  Now re-calculate interesting faces\n            this.calculateFaces(layer);\n        }\n\n        return layer;\n\n    },\n\n    /**\n    * Gets the TilemapLayer index as used in the setCollision calls.\n    *\n    * @method Phaser.Tilemap#getLayer\n    * @protected\n    * @param {number|string|Phaser.TilemapLayer} layer - The layer to operate on. If not given will default to this.currentLayer.\n    * @return {number} The TilemapLayer index.\n    */\n    getLayer: function (layer) {\n\n        if (typeof layer === 'undefined')\n        {\n            layer = this.currentLayer;\n        }\n        // else if (typeof layer === 'number')\n        // {\n        //     layer = layer;\n        // }\n        else if (typeof layer === 'string')\n        {\n            layer = this.getLayerIndex(layer);\n        }\n        else if (layer instanceof Phaser.TilemapLayer)\n        {\n            layer = layer.index;\n        }\n\n        return layer;\n\n    },\n\n    /**\n    * Internal function.\n    *\n    * @method Phaser.Tilemap#calculateFaces\n    * @protected\n    * @param {number} layer - The index of the TilemapLayer to operate on.\n    */\n    calculateFaces: function (layer) {\n\n        var above = null;\n        var below = null;\n        var left = null;\n        var right = null;\n\n        for (var y = 0, h = this.layers[layer].height; y < h; y++)\n        {\n            for (var x = 0, w = this.layers[layer].width; x < w; x++)\n            {\n                var tile = this.layers[layer].data[y][x];\n\n                if (tile)\n                {\n                    above = this.getTileAbove(layer, x, y);\n                    below = this.getTileBelow(layer, x, y);\n                    left = this.getTileLeft(layer, x, y);\n                    right = this.getTileRight(layer, x, y);\n\n                    if (tile.collides)\n                    {\n                        tile.faceTop = true;\n                        tile.faceBottom = true;\n                        tile.faceLeft = true;\n                        tile.faceRight = true;\n                    }\n\n                    if (above && above.collides)\n                    {\n                        //  There is a tile above this one that also collides, so the top of this tile is no longer interesting\n                        tile.faceTop = false;\n                    }\n\n                    if (below && below.collides)\n                    {\n                        //  There is a tile below this one that also collides, so the bottom of this tile is no longer interesting\n                        tile.faceBottom = false;\n                    }\n\n                    if (left && left.collides)\n                    {\n                        //  There is a tile left this one that also collides, so the left of this tile is no longer interesting\n                        tile.faceLeft = false;\n                    }\n\n                    if (right && right.collides)\n                    {\n                        //  There is a tile right this one that also collides, so the right of this tile is no longer interesting\n                        tile.faceRight = false;\n                    }\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Gets the tile above the tile coordinates given.\n    * Mostly used as an internal function by calculateFaces.\n    *\n    * @method Phaser.Tilemap#getTileAbove\n    * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().\n    * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n    * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n    */\n    getTileAbove: function (layer, x, y) {\n\n        if (y > 0)\n        {\n            return this.layers[layer].data[y - 1][x];\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Gets the tile below the tile coordinates given.\n    * Mostly used as an internal function by calculateFaces.\n    *\n    * @method Phaser.Tilemap#getTileBelow\n    * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().\n    * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n    * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n    */\n    getTileBelow: function (layer, x, y) {\n\n        if (y < this.layers[layer].height - 1)\n        {\n            return this.layers[layer].data[y + 1][x];\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Gets the tile to the left of the tile coordinates given.\n    * Mostly used as an internal function by calculateFaces.\n    *\n    * @method Phaser.Tilemap#getTileLeft\n    * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().\n    * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n    * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n    */\n    getTileLeft: function (layer, x, y) {\n\n        if (x > 0)\n        {\n            return this.layers[layer].data[y][x - 1];\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Gets the tile to the right of the tile coordinates given.\n    * Mostly used as an internal function by calculateFaces.\n    *\n    * @method Phaser.Tilemap#getTileRight\n    * @param {number} layer - The local layer index to get the tile from. Can be determined by Tilemap.getLayer().\n    * @param {number} x - The x coordinate to get the tile from. In tiles, not pixels.\n    * @param {number} y - The y coordinate to get the tile from. In tiles, not pixels.\n    */\n    getTileRight: function (layer, x, y) {\n\n        if (x < this.layers[layer].width - 1)\n        {\n            return this.layers[layer].data[y][x + 1];\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Sets the current layer to the given index.\n    *\n    * @method Phaser.Tilemap#setLayer\n    * @param {number|string|Phaser.TilemapLayer} layer - The layer to set as current.\n    */\n    setLayer: function (layer) {\n\n        layer = this.getLayer(layer);\n\n        if (this.layers[layer])\n        {\n            this.currentLayer = layer;\n        }\n\n    },\n\n    /**\n    * Checks if there is a tile at the given location.\n    *\n    * @method Phaser.Tilemap#hasTile\n    * @param {number} x - X position to check if a tile exists at (given in tile units, not pixels)\n    * @param {number} y - Y position to check if a tile exists at (given in tile units, not pixels)\n    * @param {number|string|Phaser.TilemapLayer} layer - The layer to set as current.\n    * @return {boolean} True if there is a tile at the given location, otherwise false.\n    */\n    hasTile: function (x, y, layer) {\n\n        layer = this.getLayer(layer);\n\n        return (this.layers[layer].data[y] !== null && this.layers[layer].data[y][x] !== null);\n\n    },\n\n    /**\n    * Removes the tile located at the given coordinates and updates the collision data.\n    *\n    * @method Phaser.Tilemap#removeTile\n    * @param {number} x - X position to place the tile (given in tile units, not pixels)\n    * @param {number} y - Y position to place the tile (given in tile units, not pixels)\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n    * @return {Phaser.Tile} The Tile object that was removed from this map.\n    */\n    removeTile: function (x, y, layer) {\n\n        layer = this.getLayer(layer);\n\n        if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height)\n        {\n            if (this.hasTile(x, y, layer))\n            {\n                var tile = this.layers[layer].data[y][x];\n\n                this.layers[layer].data[y][x] = null;\n\n                this.layers[layer].dirty = true;\n\n                this.calculateFaces(layer);\n\n                return tile;\n            }\n        }\n\n    },\n\n    /**\n    * Removes the tile located at the given coordinates and updates the collision data. The coordinates are given in pixel values.\n    *\n    * @method Phaser.Tilemap#removeTileWorldXY\n    * @param {number} x - X position to insert the tile (given in pixels)\n    * @param {number} y - Y position to insert the tile (given in pixels)\n    * @param {number} tileWidth - The width of the tile in pixels.\n    * @param {number} tileHeight - The height of the tile in pixels.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n    * @return {Phaser.Tile} The Tile object that was removed from this map.\n    */\n    removeTileWorldXY: function (x, y, tileWidth, tileHeight, layer) {\n\n        layer = this.getLayer(layer);\n\n        x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;\n        y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;\n\n        return this.removeTile(x, y, layer);\n\n    },\n\n    /**\n    * Puts a tile of the given index value at the coordinate specified.\n    * If you pass `null` as the tile it will pass your call over to Tilemap.removeTile instead.\n    *\n    * @method Phaser.Tilemap#putTile\n    * @param {Phaser.Tile|number|null} tile - The index of this tile to set or a Phaser.Tile object. If null the tile is removed from the map.\n    * @param {number} x - X position to place the tile (given in tile units, not pixels)\n    * @param {number} y - Y position to place the tile (given in tile units, not pixels)\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n    * @return {Phaser.Tile} The Tile object that was created or added to this map.\n    */\n    putTile: function (tile, x, y, layer) {\n\n        if (tile === null)\n        {\n            return this.removeTile(x, y, layer);\n        }\n\n        layer = this.getLayer(layer);\n\n        if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height)\n        {\n            var index;\n\n            if (tile instanceof Phaser.Tile)\n            {\n                index = tile.index;\n\n                if (this.hasTile(x, y, layer))\n                {\n                    this.layers[layer].data[y][x].copy(tile);\n                }\n                else\n                {\n                    this.layers[layer].data[y][x] = new Phaser.Tile(layer, index, x, y, tile.width, tile.height);\n                }\n            }\n            else\n            {\n                index = tile;\n\n                if (this.hasTile(x, y, layer))\n                {\n                    this.layers[layer].data[y][x].index = index;\n                }\n                else\n                {\n                    this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], index, x, y, this.tileWidth, this.tileHeight);\n                }\n            }\n\n            if (this.collideIndexes.indexOf(index) > -1)\n            {\n                this.layers[layer].data[y][x].setCollision(true, true, true, true);\n            }\n            else\n            {\n                this.layers[layer].data[y][x].resetCollision();\n            }\n\n            this.layers[layer].dirty = true;\n\n            this.calculateFaces(layer);\n\n            return this.layers[layer].data[y][x];\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Puts a tile into the Tilemap layer. The coordinates are given in pixel values.\n    *\n    * @method Phaser.Tilemap#putTileWorldXY\n    * @param {Phaser.Tile|number} tile - The index of this tile to set or a Phaser.Tile object.\n    * @param {number} x - X position to insert the tile (given in pixels)\n    * @param {number} y - Y position to insert the tile (given in pixels)\n    * @param {number} tileWidth - The width of the tile in pixels.\n    * @param {number} tileHeight - The height of the tile in pixels.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to modify.\n    * @return {Phaser.Tile} The Tile object that was created or added to this map.\n    */\n    putTileWorldXY: function (tile, x, y, tileWidth, tileHeight, layer) {\n\n        layer = this.getLayer(layer);\n\n        x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;\n        y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;\n\n        return this.putTile(tile, x, y, layer);\n\n    },\n\n    /**\n    * Gets a tile from the Tilemap Layer. The coordinates are given in tile values.\n    *\n    * @method Phaser.Tilemap#getTile\n    * @param {number} x - X position to get the tile from (given in tile units, not pixels)\n    * @param {number} y - Y position to get the tile from (given in tile units, not pixels)\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to get the tile from.\n    * @return {Phaser.Tile} The tile at the given coordinates.\n    */\n    getTile: function (x, y, layer) {\n\n        layer = this.getLayer(layer);\n\n        if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height)\n        {\n            if (this.layers[layer].data[y][x].index === -1)\n            {\n                return null;\n            }\n            else\n            {\n                return this.layers[layer].data[y][x];\n            }\n        }\n\n    },\n\n    /**\n    * Gets a tile from the Tilemap layer. The coordinates are given in pixel values.\n    *\n    * @method Phaser.Tilemap#getTileWorldXY\n    * @param {number} x - X position to get the tile from (given in pixels)\n    * @param {number} y - Y position to get the tile from (given in pixels)\n    * @param {number} [tileWidth] - The width of the tiles. If not given the map default is used.\n    * @param {number} [tileHeight] - The height of the tiles. If not given the map default is used.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to get the tile from.\n    * @return {Phaser.Tile} The tile at the given coordinates.\n    */\n    getTileWorldXY: function (x, y, tileWidth, tileHeight, layer) {\n\n        if (typeof tileWidth === 'undefined') { tileWidth = this.tileWidth; }\n        if (typeof tileHeight === 'undefined') { tileHeight = this.tileHeight; }\n\n        layer = this.getLayer(layer);\n\n        x = this.game.math.snapToFloor(x, tileWidth) / tileWidth;\n        y = this.game.math.snapToFloor(y, tileHeight) / tileHeight;\n\n        return this.getTile(x, y, layer);\n\n    },\n\n    /**\n    * Copies all of the tiles in the given rectangular block into the tilemap data buffer.\n    *\n    * @method Phaser.Tilemap#copy\n    * @param {number} x - X position of the top left of the area to copy (given in tiles, not pixels)\n    * @param {number} y - Y position of the top left of the area to copy (given in tiles, not pixels)\n    * @param {number} width - The width of the area to copy (given in tiles, not pixels)\n    * @param {number} height - The height of the area to copy (given in tiles, not pixels)\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to copy the tiles from.\n    * @return {array} An array of the tiles that were copied.\n    */\n    copy: function (x, y, width, height, layer) {\n\n        layer = this.getLayer(layer);\n\n        if (!this.layers[layer])\n        {\n            this._results.length = 0;\n            return;\n        }\n\n        if (typeof x === \"undefined\") { x = 0; }\n        if (typeof y === \"undefined\") { y = 0; }\n        if (typeof width === \"undefined\") { width = this.layers[layer].width; }\n        if (typeof height === \"undefined\") { height = this.layers[layer].height; }\n\n        if (x < 0)\n        {\n            x = 0;\n        }\n\n        if (y < 0)\n        {\n            y = 0;\n        }\n\n        if (width > this.layers[layer].width)\n        {\n            width = this.layers[layer].width;\n        }\n\n        if (height > this.layers[layer].height)\n        {\n            height = this.layers[layer].height;\n        }\n\n        this._results.length = 0;\n\n        this._results.push({ x: x, y: y, width: width, height: height, layer: layer });\n\n        for (var ty = y; ty < y + height; ty++)\n        {\n            for (var tx = x; tx < x + width; tx++)\n            {\n                this._results.push(this.layers[layer].data[ty][tx]);\n            }\n        }\n\n        return this._results;\n\n    },\n\n    /**\n    * Pastes a previously copied block of tile data into the given x/y coordinates. Data should have been prepared with Tilemap.copy.\n    *\n    * @method Phaser.Tilemap#paste\n    * @param {number} x - X position of the top left of the area to paste to (given in tiles, not pixels)\n    * @param {number} y - Y position of the top left of the area to paste to (given in tiles, not pixels)\n    * @param {array} tileblock - The block of tiles to paste.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to paste the tiles into.\n    */\n    paste: function (x, y, tileblock, layer) {\n\n        if (typeof x === \"undefined\") { x = 0; }\n        if (typeof y === \"undefined\") { y = 0; }\n\n        layer = this.getLayer(layer);\n\n        if (!tileblock || tileblock.length < 2)\n        {\n            return;\n        }\n\n        //  Find out the difference between tileblock[1].x/y and x/y and use it as an offset, as it's the top left of the block to paste\n        var diffX = tileblock[1].x - x;\n        var diffY = tileblock[1].y - y;\n\n        for (var i = 1; i < tileblock.length; i++)\n        {\n            this.layers[layer].data[ diffY + tileblock[i].y ][ diffX + tileblock[i].x ].copy(tileblock[i]);\n        }\n\n\t\tthis.layers[layer].dirty = true;\n        this.calculateFaces(layer);\n\n    },\n\n    /**\n    * Scans the given area for tiles with an index matching tileA and swaps them with tileB.\n    *\n    * @method Phaser.Tilemap#swap\n    * @param {number} tileA - First tile index.\n    * @param {number} tileB - Second tile index.\n    * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} width - The width in tiles of the area to operate on.\n    * @param {number} height - The height in tiles of the area to operate on.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.\n    */\n    swap: function (tileA, tileB, x, y, width, height, layer) {\n\n        layer = this.getLayer(layer);\n\n        this.copy(x, y, width, height, layer);\n\n        if (this._results.length < 2)\n        {\n            return;\n        }\n\n        this._tempA = tileA;\n        this._tempB = tileB;\n\n        this._results.forEach(this.swapHandler, this);\n\n        this.paste(x, y, this._results, layer);\n\n    },\n\n    /**\n    * Internal function that handles the swapping of tiles.\n    *\n    * @method Phaser.Tilemap#swapHandler\n    * @private\n    * @param {number} value\n    * @param {number} index\n    */\n    swapHandler: function (value, index) {\n\n        if (value.index === this._tempA)\n        {\n            this._results[index].index = this._tempB;\n        }\n        if (value.index === this._tempB)\n        {\n            this._results[index].index = this._tempA;\n        }\n\n    },\n\n    /**\n    * For each tile in the given area defined by x/y and width/height run the given callback.\n    *\n    * @method Phaser.Tilemap#forEach\n    * @param {number} callback - The callback. Each tile in the given area will be passed to this callback as the first and only parameter.\n    * @param {number} context - The context under which the callback should be run.\n    * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} width - The width in tiles of the area to operate on.\n    * @param {number} height - The height in tiles of the area to operate on.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.\n    */\n    forEach: function (callback, context, x, y, width, height, layer) {\n\n        layer = this.getLayer(layer);\n\n        this.copy(x, y, width, height, layer);\n\n        if (this._results.length < 2)\n        {\n            return;\n        }\n\n        this._results.forEach(callback, context);\n\n        this.paste(x, y, this._results, layer);\n\n    },\n\n    /**\n    * Scans the given area for tiles with an index matching `source` and updates their index to match `dest`.\n    *\n    * @method Phaser.Tilemap#replace\n    * @param {number} source - The tile index value to scan for.\n    * @param {number} dest - The tile index value to replace found tiles with.\n    * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} width - The width in tiles of the area to operate on.\n    * @param {number} height - The height in tiles of the area to operate on.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.\n    */\n    replace: function (source, dest, x, y, width, height, layer) {\n\n        layer = this.getLayer(layer);\n\n        this.copy(x, y, width, height, layer);\n\n        if (this._results.length < 2)\n        {\n            return;\n        }\n\n        for (var i = 1; i < this._results.length; i++)\n        {\n            if (this._results[i].index === source)\n            {\n                this._results[i].index = dest;\n            }\n        }\n\n        this.paste(x, y, this._results, layer);\n\n    },\n\n    /**\n    * Randomises a set of tiles in a given area.\n    *\n    * @method Phaser.Tilemap#random\n    * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} width - The width in tiles of the area to operate on.\n    * @param {number} height - The height in tiles of the area to operate on.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.\n    */\n    random: function (x, y, width, height, layer) {\n\n        layer = this.getLayer(layer);\n\n        this.copy(x, y, width, height, layer);\n\n        if (this._results.length < 2)\n        {\n            return;\n        }\n\n        var indexes = [];\n\n        for (var t = 1; t < this._results.length; t++)\n        {\n            if (this._results[t].index)\n            {\n                var idx = this._results[t].index;\n\n                if (indexes.indexOf(idx) === -1)\n                {\n                    indexes.push(idx);\n                }\n            }\n        }\n\n        for (var i = 1; i < this._results.length; i++)\n        {\n            this._results[i].index = this.game.rnd.pick(indexes);\n        }\n\n        this.paste(x, y, this._results, layer);\n\n    },\n\n    /**\n    * Shuffles a set of tiles in a given area. It will only randomise the tiles in that area, so if they're all the same nothing will appear to have changed!\n    *\n    * @method Phaser.Tilemap#shuffle\n    * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} width - The width in tiles of the area to operate on.\n    * @param {number} height - The height in tiles of the area to operate on.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.\n    */\n    shuffle: function (x, y, width, height, layer) {\n\n        layer = this.getLayer(layer);\n\n        this.copy(x, y, width, height, layer);\n\n        if (this._results.length < 2)\n        {\n            return;\n        }\n\n        var indexes = [];\n\n        for (var t = 1; t < this._results.length; t++)\n        {\n            if (this._results[t].index)\n            {\n                indexes.push(this._results[t].index);\n            }\n        }\n\n        Phaser.Utils.shuffle(indexes);\n\n        for (var i = 1; i < this._results.length; i++)\n        {\n            this._results[i].index = indexes[i - 1];\n        }\n\n        this.paste(x, y, this._results, layer);\n\n    },\n\n    /**\n    * Fills the given area with the specified tile.\n    *\n    * @method Phaser.Tilemap#fill\n    * @param {number} index - The index of the tile that the area will be filled with.\n    * @param {number} x - X position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} y - Y position of the top left of the area to operate one, given in tiles, not pixels.\n    * @param {number} width - The width in tiles of the area to operate on.\n    * @param {number} height - The height in tiles of the area to operate on.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on.\n    */\n    fill: function (index, x, y, width, height, layer) {\n\n        layer = this.getLayer(layer);\n\n        this.copy(x, y, width, height, layer);\n\n        if (this._results.length < 2)\n        {\n            return;\n        }\n\n        for (var i = 1; i < this._results.length; i++)\n        {\n            this._results[i].index = index;\n        }\n\n        this.paste(x, y, this._results, layer);\n\n    },\n\n    /**\n    * Removes all layers from this tile map.\n    *\n    * @method Phaser.Tilemap#removeAllLayers\n    */\n    removeAllLayers: function () {\n\n        this.layers.length = 0;\n        this.currentLayer = 0;\n\n    },\n\n    /**\n    * Dumps the tilemap data out to the console.\n    *\n    * @method Phaser.Tilemap#dump\n    */\n    dump: function () {\n\n        var txt = '';\n        var args = [''];\n\n        for (var y = 0; y < this.layers[this.currentLayer].height; y++)\n        {\n            for (var x = 0; x < this.layers[this.currentLayer].width; x++)\n            {\n                txt += \"%c  \";\n\n                if (this.layers[this.currentLayer].data[y][x] > 1)\n                {\n                    if (this.debugMap[this.layers[this.currentLayer].data[y][x]])\n                    {\n                        args.push(\"background: \" + this.debugMap[this.layers[this.currentLayer].data[y][x]]);\n                    }\n                    else\n                    {\n                        args.push(\"background: #ffffff\");\n                    }\n                }\n                else\n                {\n                    args.push(\"background: rgb(0, 0, 0)\");\n                }\n            }\n\n            txt += \"\\n\";\n        }\n\n        args[0] = txt;\n        console.log.apply(console, args);\n\n    },\n\n    /**\n    * Removes all layer data from this tile map and nulls the game reference.\n    * Note: You are responsible for destroying any TilemapLayer objects you generated yourself, as Tilemap doesn't keep a reference to them.\n    *\n    * @method Phaser.Tilemap#destroy\n    */\n    destroy: function () {\n\n        this.removeAllLayers();\n        this.data = [];\n        this.game = null;\n\n    }\n\n};\n\nPhaser.Tilemap.prototype.constructor = Phaser.Tilemap;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Tilemap Layer is a set of map data combined with a Tileset in order to render that data to the game.\n*\n* @class Phaser.TilemapLayer\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n* @param {Phaser.Tilemap} tilemap - The tilemap to which this layer belongs.\n* @param {number} index - The layer index within the map that this TilemapLayer represents.\n* @param {number} width - Width of the renderable area of the layer.\n* @param {number} height - Height of the renderable area of the layer.\n*/\nPhaser.TilemapLayer = function (game, tilemap, index, width, height) {\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running Game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Tilemap} map - The Tilemap to which this layer is bound.\n    */\n    this.map = tilemap;\n\n    /**\n    * @property {number} index - The index of this layer within the Tilemap.\n    */\n    this.index = index;\n\n    /**\n    * @property {object} layer - The layer object within the Tilemap that this layer represents.\n    */\n    this.layer = tilemap.layers[index];\n\n    /**\n    * @property {HTMLCanvasElement} canvas - The canvas to which this TilemapLayer draws.\n    */\n    this.canvas = Phaser.Canvas.create(width, height, '', true);\n\n    /**\n    * @property {CanvasRenderingContext2D} context - The 2d context of the canvas.\n    */\n    this.context = this.canvas.getContext('2d');\n\n    /**\n    * @property {PIXI.BaseTexture} baseTexture - Required Pixi var.\n    */\n    this.baseTexture = new PIXI.BaseTexture(this.canvas);\n\n    /**\n    * @property {PIXI.Texture} texture - Required Pixi var.\n    */\n    this.texture = new PIXI.Texture(this.baseTexture);\n\n    /**\n    * @property {Phaser.Frame} textureFrame - Dimensions of the renderable area.\n    */\n    this.textureFrame = new Phaser.Frame(0, 0, 0, width, height, 'tilemapLayer', game.rnd.uuid());\n\n    Phaser.Image.call(this, this.game, 0, 0, this.texture, this.textureFrame);\n\n    /**\n    * @property {string} name - The name of the layer.\n    */\n    this.name = '';\n\n    /**\n    * @property {number} type - The const type of this object.\n    * @default\n    */\n    this.type = Phaser.TILEMAPLAYER;\n\n    /**\n    * An object that is fixed to the camera ignores the position of any ancestors in the display list and uses its x/y coordinates as offsets from the top left of the camera.\n    * @property {boolean} fixedToCamera - Fixes this object to the Camera.\n    * @default\n    */\n    this.fixedToCamera = true;\n\n    /**\n    * @property {Phaser.Point} cameraOffset - If this object is fixed to the camera then use this Point to specify how far away from the Camera x/y it's rendered.\n    */\n    this.cameraOffset = new Phaser.Point(0, 0);\n\n    /**\n    * @property {string} tileColor - If no tileset is given the tiles will be rendered as rectangles in this color. Provide in hex or rgb/rgba string format.\n    * @default\n    */\n    this.tileColor = 'rgb(255, 255, 255)';\n\n    /**\n    * @property {boolean} debug - If set to true the collideable tile edges path will be rendered. Only works when game is running in Phaser.CANVAS mode.\n    * @default\n    */\n    this.debug = false;\n\n    /**\n    * @property {number} debugAlpha - If debug is true then the tileset is rendered with this alpha level, to make the tile edges clearer.\n    * @default\n    */\n    this.debugAlpha = 0.5;\n\n    /**\n    * @property {string} debugColor - If debug is true this is the color used to outline the edges of collidable tiles. Provide in hex or rgb/rgba string format.\n    * @default\n    */\n    this.debugColor = 'rgba(0, 255, 0, 1)';\n\n    /**\n    * @property {boolean} debugFill - If true the debug tiles are filled with debugFillColor AND stroked around.\n    * @default\n    */\n    this.debugFill = false;\n\n    /**\n    * @property {string} debugFillColor - If debugFill is true this is the color used to fill the tiles. Provide in hex or rgb/rgba string format.\n    * @default\n    */\n    this.debugFillColor = 'rgba(0, 255, 0, 0.2)';\n\n    /**\n    * @property {string} debugCallbackColor - If debug is true this is the color used to outline the edges of tiles that have collision callbacks. Provide in hex or rgb/rgba string format.\n    * @default\n    */\n    this.debugCallbackColor = 'rgba(255, 0, 0, 1)';\n\n    /**\n    * @property {number} scrollFactorX - speed at which this layer scrolls\n    * horizontally, relative to the camera (e.g. scrollFactorX of 0.5 scrolls\n    * half as quickly as the 'normal' camera-locked layers do)\n    * @default 1\n    */\n    this.scrollFactorX = 1;\n\n    /**\n    * @property {number} scrollFactorY - speed at which this layer scrolls\n    * vertically, relative to the camera (e.g. scrollFactorY of 0.5 scrolls\n    * half as quickly as the 'normal' camera-locked layers do)\n    * @default 1\n    */\n    this.scrollFactorY = 1;\n\n    /**\n    * @property {boolean} dirty - Flag controlling when to re-render the layer.\n    */\n    this.dirty = true;\n\n    /**\n    * @property {number} rayStepRate - When ray-casting against tiles this is the number of steps it will jump. For larger tile sizes you can increase this to improve performance.\n    * @default\n    */\n    this.rayStepRate = 4;\n\n    /**\n    * @property {object} _mc - Local map data and calculation cache.\n    * @private\n    */\n    this._mc = {\n\n        cw: tilemap.tileWidth,\n        ch: tilemap.tileHeight,\n        ga: 1,\n        dx: 0,\n        dy: 0,\n        dw: 0,\n        dh: 0,\n        tx: 0,\n        ty: 0,\n        tw: 0,\n        th: 0,\n        tl: 0,\n        maxX: 0,\n        maxY: 0,\n        startX: 0,\n        startY: 0,\n        x: 0,\n        y: 0,\n        prevX: 0,\n        prevY: 0\n\n    };\n\n    /**\n    * @property {array} _results - Local render loop var to help avoid gc spikes.\n    * @private\n    */\n    this._results = [];\n\n    this.updateMax();\n\n};\n\nPhaser.TilemapLayer.prototype = Object.create(Phaser.Image.prototype);\nPhaser.TilemapLayer.prototype.constructor = Phaser.TilemapLayer;\n\n/**\n* Automatically called by World.postUpdate. Handles cache updates.\n*\n* @method Phaser.TilemapLayer#postUpdate\n* @memberof Phaser.TilemapLayer\n*/\nPhaser.TilemapLayer.prototype.postUpdate = function () {\n\n// console.log('layer pu');\n\n    Phaser.Image.prototype.postUpdate.call(this);\n\n    //  Stops you being able to auto-scroll the camera if it's not following a sprite\n    this.scrollX = this.game.camera.x * this.scrollFactorX;\n    this.scrollY = this.game.camera.y * this.scrollFactorY;\n\n    this.render();\n\n    //  Fixed to Camera?\n    if (this._cache[7] === 1)\n    {\n        this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x;\n        this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y;\n    }\n\n    //  Update any Children\n    // for (var i = 0, len = this.children.length; i < len; i++)\n    // {\n        // this.children[i].postUpdate();\n    // }\n\n};\n\n/**\n* Sets the world size to match the size of this layer.\n*\n* @method Phaser.TilemapLayer#resizeWorld\n* @memberof Phaser.TilemapLayer\n*/\nPhaser.TilemapLayer.prototype.resizeWorld = function () {\n\n    this.game.world.setBounds(0, 0, this.layer.widthInPixels, this.layer.heightInPixels);\n\n};\n\n/**\n* Take an x coordinate that doesn't account for scrollFactorX and 'fix' it\n* into a scrolled local space. Used primarily internally\n* @method Phaser.TilemapLayer#_fixX\n* @memberof Phaser.TilemapLayer\n* @private\n* @param {number} x - x coordinate in camera space\n* @return {number} x coordinate in scrollFactor-adjusted dimensions\n*/\nPhaser.TilemapLayer.prototype._fixX = function(x) {\n\n    if (x < 0)\n    {\n        x = 0;\n    }\n\n    if (this.scrollFactorX === 1)\n    {\n        return x;\n    }\n\n    return this._mc.x + (x - (this._mc.x / this.scrollFactorX));\n\n};\n\n/**\n* Take an x coordinate that _does_ account for scrollFactorX and 'unfix' it\n* back to camera space. Used primarily internally\n* @method Phaser.TilemapLayer#_unfixX\n* @memberof Phaser.TilemapLayer\n* @private\n* @param {number} x - x coordinate in scrollFactor-adjusted dimensions\n* @return {number} x coordinate in camera space\n*/\nPhaser.TilemapLayer.prototype._unfixX = function(x) {\n\n    if (this.scrollFactorX === 1)\n    {\n        return x;\n    }\n\n    return (this._mc.x / this.scrollFactorX) + (x - this._mc.x);\n\n};\n\n/**\n* Take a y coordinate that doesn't account for scrollFactorY and 'fix' it\n* into a scrolled local space. Used primarily internally\n* @method Phaser.TilemapLayer#_fixY\n* @memberof Phaser.TilemapLayer\n* @private\n* @param {number} y - y coordinate in camera space\n* @return {number} y coordinate in scrollFactor-adjusted dimensions\n*/\nPhaser.TilemapLayer.prototype._fixY = function(y) {\n\n    if (y < 0)\n    {\n        y = 0;\n    }\n\n    if (this.scrollFactorY === 1)\n    {\n        return y;\n    }\n\n    return this._mc.y + (y - (this._mc.y / this.scrollFactorY));\n\n};\n\n/**\n* Take a y coordinate that _does_ account for scrollFactorY and 'unfix' it\n* back to camera space. Used primarily internally\n* @method Phaser.TilemapLayer#_unfixY\n* @memberof Phaser.TilemapLayer\n* @private\n* @param {number} y - y coordinate in scrollFactor-adjusted dimensions\n* @return {number} y coordinate in camera space\n*/\nPhaser.TilemapLayer.prototype._unfixY = function(y) {\n\n    if (this.scrollFactorY === 1)\n    {\n        return y;\n    }\n\n    return (this._mc.y / this.scrollFactorY) + (y - this._mc.y);\n\n};\n\n/**\n* Convert a pixel value to a tile coordinate.\n* @method Phaser.TilemapLayer#getTileX\n* @memberof Phaser.TilemapLayer\n* @param {number} x - X position of the point in target tile.\n* @return {Phaser.Tile} The tile with specific properties.\n*/\nPhaser.TilemapLayer.prototype.getTileX = function (x) {\n\n    // var tileWidth = this.tileWidth * this.scale.x;\n\n    return this.game.math.snapToFloor(this._fixX(x), this.map.tileWidth) / this.map.tileWidth;\n\n};\n\n/**\n* Convert a pixel value to a tile coordinate.\n* @method Phaser.TilemapLayer#getTileY\n* @memberof Phaser.TilemapLayer\n* @param {number} y - Y position of the point in target tile.\n* @return {Phaser.Tile} The tile with specific properties.\n*/\nPhaser.TilemapLayer.prototype.getTileY = function (y) {\n\n    // var tileHeight = this.tileHeight * this.scale.y;\n\n    return this.game.math.snapToFloor(this._fixY(y), this.map.tileHeight) / this.map.tileHeight;\n\n};\n\n/**\n* Convert a pixel value to a tile coordinate.\n* @method Phaser.TilemapLayer#getTileXY\n* @memberof Phaser.TilemapLayer\n* @param {number} x - X position of the point in target tile.\n* @param {number} y - Y position of the point in target tile.\n* @param {Phaser.Point|object} point - The Point object to set the x and y values on.\n* @return {Phaser.Point|object} A Point object with its x and y properties set.\n*/\nPhaser.TilemapLayer.prototype.getTileXY = function (x, y, point) {\n\n    point.x = this.getTileX(x);\n    point.y = this.getTileY(y);\n\n    return point;\n\n};\n\n/**\n* Gets all tiles that intersect with the given line.\n*\n* @method Phaser.TilemapLayer#getRayCastTiles\n* @memberof Phaser.TilemapLayer\n* @param {Phaser.Line} line - The line used to determine which tiles to return.\n* @param {number} [stepRate] - How many steps through the ray will we check? If undefined or null it uses TilemapLayer.rayStepRate.\n* @param {boolean} [collides=false] - If true only return tiles that collide on one or more faces.\n* @param {boolean} [interestingFace=false] - If true only return tiles that have interesting faces.\n* @return {array<Phaser.Tile>} An array of Phaser.Tiles.\n*/\nPhaser.TilemapLayer.prototype.getRayCastTiles = function (line, stepRate, collides, interestingFace) {\n\n    if (typeof stepRate === 'undefined' || stepRate === null) { stepRate = this.rayStepRate; }\n    if (typeof collides === 'undefined') { collides = false; }\n    if (typeof interestingFace === 'undefined') { interestingFace = false; }\n\n    //  First get all tiles that touch the bounds of the line\n    var tiles = this.getTiles(line.x, line.y, line.width, line.height, collides, interestingFace);\n\n    if (tiles.length === 0)\n    {\n        return [];\n    }\n\n    //  Now we only want the tiles that intersect with the points on this line\n    var coords = line.coordinatesOnLine(stepRate);\n    var total = coords.length;\n    var results = [];\n\n    for (var i = 0; i < tiles.length; i++)\n    {\n        for (var t = 0; t < total; t++)\n        {\n            if (tiles[i].containsPoint(coords[t][0], coords[t][1]))\n            {\n                results.push(tiles[i]);\n                break;\n            }\n        }\n    }\n\n    return results;\n\n};\n\n/**\n* Get all tiles that exist within the given area, defined by the top-left corner, width and height. Values given are in pixels, not tiles.\n* @method Phaser.TilemapLayer#getTiles\n* @memberof Phaser.TilemapLayer\n* @param {number} x - X position of the top left corner.\n* @param {number} y - Y position of the top left corner.\n* @param {number} width - Width of the area to get.\n* @param {number} height - Height of the area to get.\n* @param {boolean} [collides=false] - If true only return tiles that collide on one or more faces.\n* @param {boolean} [interestingFace=false] - If true only return tiles that have interesting faces.\n* @return {array<Phaser.Tile>} An array of Phaser.Tiles.\n*/\nPhaser.TilemapLayer.prototype.getTiles = function (x, y, width, height, collides, interestingFace) {\n\n    //  Should we only get tiles that have at least one of their collision flags set? (true = yes, false = no just get them all)\n    if (typeof collides === 'undefined') { collides = false; }\n    if (typeof interestingFace === 'undefined') { interestingFace = false; }\n\n    // adjust the x,y coordinates for scrollFactor\n    x = this._fixX(x);\n    y = this._fixY(y);\n\n    if (width > this.layer.widthInPixels)\n    {\n        width = this.layer.widthInPixels;\n    }\n\n    if (height > this.layer.heightInPixels)\n    {\n        height = this.layer.heightInPixels;\n    }\n\n    //  Convert the pixel values into tile coordinates\n    this._mc.tx = this.game.math.snapToFloor(x, this._mc.cw) / this._mc.cw;\n    this._mc.ty = this.game.math.snapToFloor(y, this._mc.ch) / this._mc.ch;\n    this._mc.tw = (this.game.math.snapToCeil(width, this._mc.cw) + this._mc.cw) / this._mc.cw;\n    this._mc.th = (this.game.math.snapToCeil(height, this._mc.ch) + this._mc.ch) / this._mc.ch;\n\n    //  This should apply the layer x/y here\n    this._results.length = 0;\n\n    for (var wy = this._mc.ty; wy < this._mc.ty + this._mc.th; wy++)\n    {\n        for (var wx = this._mc.tx; wx < this._mc.tx + this._mc.tw; wx++)\n        {\n            if (this.layer.data[wy] && this.layer.data[wy][wx])\n            {\n                if ((!collides && !interestingFace) || this.layer.data[wy][wx].isInteresting(collides, interestingFace))\n                {\n                    this._results.push(this.layer.data[wy][wx]);\n                }\n            }\n        }\n    }\n\n    return this._results;\n\n};\n\n/**\n* Internal function to update maximum values.\n* @method Phaser.TilemapLayer#updateMax\n* @memberof Phaser.TilemapLayer\n*/\nPhaser.TilemapLayer.prototype.updateMax = function () {\n\n    this._mc.maxX = this.game.math.ceil(this.canvas.width / this.map.tileWidth) + 1;\n    this._mc.maxY = this.game.math.ceil(this.canvas.height / this.map.tileHeight) + 1;\n\n    if (this.layer)\n    {\n        if (this._mc.maxX > this.layer.width)\n        {\n            this._mc.maxX = this.layer.width;\n        }\n\n        if (this._mc.maxY > this.layer.height)\n        {\n            this._mc.maxY = this.layer.height;\n        }\n    }\n\n    this.dirty = true;\n\n};\n\n/**\n* Renders the tiles to the layer canvas and pushes to the display.\n* @method Phaser.TilemapLayer#render\n* @memberof Phaser.TilemapLayer\n*/\nPhaser.TilemapLayer.prototype.render = function () {\n\n    if (this.layer.dirty)\n    {\n        this.dirty = true;\n    }\n\n    if (!this.dirty || !this.visible)\n    {\n        return;\n    }\n\n    this._mc.prevX = this._mc.dx;\n    this._mc.prevY = this._mc.dy;\n\n    this._mc.dx = -(this._mc.x - (this._mc.startX * this.map.tileWidth));\n    this._mc.dy = -(this._mc.y - (this._mc.startY * this.map.tileHeight));\n\n    this._mc.tx = this._mc.dx;\n    this._mc.ty = this._mc.dy;\n\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.context.fillStyle = this.tileColor;\n\n    var tile;\n    var set;\n\n    if (this.debug)\n    {\n        this.context.globalAlpha = this.debugAlpha;\n    }\n\n    for (var y = this._mc.startY, lenY = this._mc.startY + this._mc.maxY; y < lenY; y++)\n    {\n        this._column = this.layer.data[y];\n\n        for (var x = this._mc.startX, lenX = this._mc.startX + this._mc.maxX; x < lenX; x++)\n        {\n            if (this._column[x])\n            {\n                tile = this._column[x];\n\n                if (tile.index > -1)\n                {\n                    set = this.map.tilesets[this.map.tiles[tile.index][2]];\n\n                    if (this.debug === false && tile.alpha !== this.context.globalAlpha)\n                    {\n                        this.context.globalAlpha = tile.alpha;\n                    }\n\n                    set.draw(this.context, Math.floor(this._mc.tx), Math.floor(this._mc.ty), tile.index);\n\n                    if (tile.debug)\n                    {\n                        this.context.fillStyle = 'rgba(0, 255, 0, 0.4)';\n                        this.context.fillRect(Math.floor(this._mc.tx), Math.floor(this._mc.ty), this.map.tileWidth, this.map.tileHeight);\n                    }\n                }\n            }\n\n            this._mc.tx += this.map.tileWidth;\n\n        }\n\n        this._mc.tx = this._mc.dx;\n        this._mc.ty += this.map.tileHeight;\n\n    }\n\n    if (this.debug)\n    {\n        this.context.globalAlpha = 1;\n        this.renderDebug();\n    }\n\n    if (this.game.renderType === Phaser.WEBGL)\n    {\n        // PIXI.updateWebGLTexture(this.baseTexture, renderSession.gl);\n        PIXI.updateWebGLTexture(this.baseTexture, this.game.renderer.gl);\n    }\n\n    this.dirty = false;\n    this.layer.dirty = false;\n\n    return true;\n\n};\n\n/**\n* Renders a collision debug overlay on-top of the canvas. Called automatically by render when debug = true.\n* @method Phaser.TilemapLayer#renderDebug\n* @memberof Phaser.TilemapLayer\n*/\nPhaser.TilemapLayer.prototype.renderDebug = function () {\n\n    this._mc.tx = this._mc.dx;\n    this._mc.ty = this._mc.dy;\n\n    this.context.strokeStyle = this.debugColor;\n    this.context.fillStyle = this.debugFillColor;\n\n    for (var y = this._mc.startY, lenY = this._mc.startY + this._mc.maxY; y < lenY; y++)\n    {\n        this._column = this.layer.data[y];\n\n        for (var x = this._mc.startX, lenX = this._mc.startX + this._mc.maxX; x < lenX; x++)\n        {\n            var tile = this._column[x];\n\n            if (tile && (tile.faceTop || tile.faceBottom || tile.faceLeft || tile.faceRight))\n            {\n                this._mc.tx = Math.floor(this._mc.tx);\n\n                if (this.debugFill)\n                {\n                    this.context.fillRect(this._mc.tx, this._mc.ty, this._mc.cw, this._mc.ch);\n                }\n\n                this.context.beginPath();\n\n                if (tile.faceTop)\n                {\n                    this.context.moveTo(this._mc.tx, this._mc.ty);\n                    this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty);\n                }\n\n                if (tile.faceBottom)\n                {\n                    this.context.moveTo(this._mc.tx, this._mc.ty + this._mc.ch);\n                    this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch);\n                }\n\n                if (tile.faceLeft)\n                {\n                    this.context.moveTo(this._mc.tx, this._mc.ty);\n                    this.context.lineTo(this._mc.tx, this._mc.ty + this._mc.ch);\n                }\n\n                if (tile.faceRight)\n                {\n                    this.context.moveTo(this._mc.tx + this._mc.cw, this._mc.ty);\n                    this.context.lineTo(this._mc.tx + this._mc.cw, this._mc.ty + this._mc.ch);\n                }\n\n                this.context.stroke();\n            }\n\n            this._mc.tx += this.map.tileWidth;\n\n        }\n\n        this._mc.tx = this._mc.dx;\n        this._mc.ty += this.map.tileHeight;\n\n    }\n\n};\n\n/**\n* @name Phaser.TilemapLayer#scrollX\n* @property {number} scrollX - Scrolls the map horizontally or returns the current x position.\n*/\nObject.defineProperty(Phaser.TilemapLayer.prototype, \"scrollX\", {\n\n    get: function () {\n        return this._mc.x;\n    },\n\n    set: function (value) {\n\n        if (value !== this._mc.x && value >= 0 && this.layer.widthInPixels > this.width)\n        {\n            this._mc.x = value;\n\n            if (this._mc.x > (this.layer.widthInPixels - this.width))\n            {\n                this._mc.x = this.layer.widthInPixels - this.width;\n            }\n\n            this._mc.startX = this.game.math.floor(this._mc.x / this.map.tileWidth);\n\n            if (this._mc.startX < 0)\n            {\n                this._mc.startX = 0;\n            }\n\n            if (this._mc.startX + this._mc.maxX > this.layer.width)\n            {\n                this._mc.startX = this.layer.width - this._mc.maxX;\n            }\n\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.TilemapLayer#scrollY\n* @property {number} scrollY - Scrolls the map vertically or returns the current y position.\n*/\nObject.defineProperty(Phaser.TilemapLayer.prototype, \"scrollY\", {\n\n    get: function () {\n        return this._mc.y;\n    },\n\n    set: function (value) {\n\n        if (value !== this._mc.y && value >= 0 && this.layer.heightInPixels > this.height)\n        {\n            this._mc.y = value;\n\n            if (this._mc.y > (this.layer.heightInPixels - this.height))\n            {\n                this._mc.y = this.layer.heightInPixels - this.height;\n            }\n\n            this._mc.startY = this.game.math.floor(this._mc.y / this.map.tileHeight);\n\n            if (this._mc.startY < 0)\n            {\n                this._mc.startY = 0;\n            }\n\n            if (this._mc.startY + this._mc.maxY > this.layer.height)\n            {\n                this._mc.startY = this.layer.height - this._mc.maxY;\n            }\n\n            this.dirty = true;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.TilemapLayer#collisionWidth\n* @property {number} collisionWidth - The width of the collision tiles.\n*/\nObject.defineProperty(Phaser.TilemapLayer.prototype, \"collisionWidth\", {\n\n    get: function () {\n        return this._mc.cw;\n    },\n\n    set: function (value) {\n\n        this._mc.cw = value;\n\n        this.dirty = true;\n\n    }\n\n});\n\n/**\n* @name Phaser.TilemapLayer#collisionHeight\n* @property {number} collisionHeight - The height of the collision tiles.\n*/\nObject.defineProperty(Phaser.TilemapLayer.prototype, \"collisionHeight\", {\n\n    get: function () {\n        return this._mc.ch;\n    },\n\n    set: function (value) {\n\n        this._mc.ch = value;\n\n        this.dirty = true;\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Phaser.TilemapParser parses data objects from Phaser.Loader that need more preparation before they can be inserted into a Tilemap.\n*\n* @class Phaser.TilemapParser\n*/\nPhaser.TilemapParser = {\n\n    /**\n    * Parse tilemap data from the cache and creates a Tilemap object.\n    *\n    * @method Phaser.TilemapParser.parse\n    * @param {Phaser.Game} game - Game reference to the currently running game.\n    * @param {string} key - The key of the tilemap in the Cache.\n    * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [width=10] - The width of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @param {number} [height=10] - The height of the map in tiles. If this map is created from Tiled or CSV data you don't need to specify this.\n    * @return {object} The parsed map object.\n    */\n    parse: function (game, key, tileWidth, tileHeight, width, height) {\n\n        if (typeof tileWidth === 'undefined') { tileWidth = 32; }\n        if (typeof tileHeight === 'undefined') { tileHeight = 32; }\n        if (typeof width === 'undefined') { width = 10; }\n        if (typeof height === 'undefined') { height = 10; }\n\n        if (typeof key === 'undefined')\n        {\n            return this.getEmptyData();\n        }\n\n        if (key === null)\n        {\n            return this.getEmptyData(tileWidth, tileHeight, width, height);\n        }\n\n        var map = game.cache.getTilemapData(key);\n\n        if (map)\n        {\n            if (map.format === Phaser.Tilemap.CSV)\n            {\n                return this.parseCSV(key, map.data, tileWidth, tileHeight);\n            }\n            else if (!map.format || map.format === Phaser.Tilemap.TILED_JSON)\n            {\n                return this.parseTiledJSON(map.data);\n            }\n        }\n        else\n        {\n            console.warn('Phaser.TilemapParser.parse - No map data found for key ' + key);\n        }\n\n    },\n\n    /**\n    * Parses a CSV file into valid map data.\n    *\n    * @method Phaser.TilemapParser.parseCSV\n    * @param {string} data - The CSV file data.\n    * @param {number} [tileWidth=32] - The pixel width of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @param {number} [tileHeight=32] - The pixel height of a single map tile. If using CSV data you must specify this. Not required if using Tiled map data.\n    * @return {object} Generated map data.\n    */\n    parseCSV: function (key, data, tileWidth, tileHeight) {\n\n        var map = this.getEmptyData();\n\n        //  Trim any rogue whitespace from the data\n        data = data.trim();\n\n        var output = [];\n        var rows = data.split(\"\\n\");\n        var height = rows.length;\n        var width = 0;\n\n        for (var y = 0; y < rows.length; y++)\n        {\n            output[y] = [];\n\n            var column = rows[y].split(\",\");\n\n            for (var x = 0; x < column.length; x++)\n            {\n                output[y][x] = new Phaser.Tile(map.layers[0], parseInt(column[x], 10), x, y, tileWidth, tileHeight);\n            }\n\n            if (width === 0)\n            {\n                width = column.length;\n            }\n        }\n\n        map.format = Phaser.Tilemap.CSV;\n        map.name = key;\n        map.width = width;\n        map.height = height;\n        map.tileWidth = tileWidth;\n        map.tileHeight = tileHeight;\n        map.widthInPixels = width * tileWidth;\n        map.heightInPixels = height * tileHeight;\n\n        map.layers[0].width = width;\n        map.layers[0].height = height;\n        map.layers[0].widthInPixels = map.widthInPixels;\n        map.layers[0].heightInPixels = map.heightInPixels;\n        map.layers[0].data = output;\n\n        return map;\n\n    },\n\n    /**\n    * Returns an empty map data object.\n    *\n    * @method Phaser.TilemapParser.getEmptyData\n    * @return {object} Generated map data.\n    */\n    getEmptyData: function (tileWidth, tileHeight, width, height) {\n\n        var map = {};\n\n        map.width = 0;\n        map.height = 0;\n        map.tileWidth = 0;\n        map.tileHeight = 0;\n\n        if (typeof tileWidth !== 'undefined' && tileWidth !== null) { map.tileWidth = tileWidth; }\n        if (typeof tileHeight !== 'undefined' && tileHeight !== null) { map.tileHeight = tileHeight; }\n        if (typeof width !== 'undefined' && width !== null) { map.width = width; }\n        if (typeof height !== 'undefined' && height !== null) { map.height = height; }\n\n        map.orientation = 'orthogonal';\n        map.version = '1';\n        map.properties = {};\n        map.widthInPixels = 0;\n        map.heightInPixels = 0;\n\n        var layers = [];\n\n        var layer = {\n\n            name: 'layer',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            widthInPixels: 0,\n            heightInPixels: 0,\n            alpha: 1,\n            visible: true,\n            properties: {},\n            indexes: [],\n            callbacks: [],\n            data: []\n\n        };\n\n        //  fill with nulls?\n\n        layers.push(layer);\n\n        map.layers = layers;\n        map.images = [];\n        map.objects = {};\n        map.collision = {};\n        map.tilesets = [];\n        map.tiles = [];\n\n        return map;\n\n    },\n\n    /**\n    * Parses a Tiled JSON file into valid map data.\n    * @method Phaser.TilemapParser.parseJSON\n    * @param {object} json - The JSON map data.\n    * @return {object} Generated and parsed map data.\n    */\n    parseTiledJSON: function (json) {\n\n        if (json.orientation !== 'orthogonal')\n        {\n            console.warn('TilemapParser.parseTiledJSON: Only orthogonal map types are supported in this version of Phaser');\n            return null;\n        }\n\n        //  Map data will consist of: layers, objects, images, tilesets, sizes\n        var map = {};\n\n        map.width = json.width;\n        map.height = json.height;\n        map.tileWidth = json.tilewidth;\n        map.tileHeight = json.tileheight;\n        map.orientation = json.orientation;\n        map.format = Phaser.Tilemap.TILED_JSON;\n        map.version = json.version;\n        map.properties = json.properties;\n        map.widthInPixels = map.width * map.tileWidth;\n        map.heightInPixels = map.height * map.tileHeight;\n\n        //  Tile Layers\n        var layers = [];\n\n        for (var i = 0; i < json.layers.length; i++)\n        {\n            if (json.layers[i].type !== 'tilelayer')\n            {\n                continue;\n            }\n\n            var layer = {\n\n                name: json.layers[i].name,\n                x: json.layers[i].x,\n                y: json.layers[i].y,\n                width: json.layers[i].width,\n                height: json.layers[i].height,\n                widthInPixels: json.layers[i].width * json.tilewidth,\n                heightInPixels: json.layers[i].height * json.tileheight,\n                alpha: json.layers[i].opacity,\n                visible: json.layers[i].visible,\n                properties: {},\n                indexes: [],\n                callbacks: [],\n                bodies: []\n\n            };\n\n            if (json.layers[i].properties)\n            {\n                layer.properties = json.layers[i].properties;\n            }\n\n            var x = 0;\n            var row = [];\n            var output = [];\n\n            //  Loop through the data field in the JSON.\n\n            //  This is an array containing the tile indexes, one after the other. -1 = no tile, everything else = the tile index (starting at 1 for Tiled, 0 for CSV)\n            //  If the map contains multiple tilesets then the indexes are relative to that which the set starts from.\n            //  Need to set which tileset in the cache = which tileset in the JSON, if you do this manually it means you can use the same map data but a new tileset.\n\n            for (var t = 0, len = json.layers[i].data.length; t < len; t++)\n            {\n                //  index, x, y, width, height\n                if (json.layers[i].data[t] > 0)\n                {\n                    row.push(new Phaser.Tile(layer, json.layers[i].data[t], x, output.length, json.tilewidth, json.tileheight));\n                }\n                else\n                {\n                    row.push(new Phaser.Tile(layer, -1, x, output.length, json.tilewidth, json.tileheight));\n                }\n\n                x++;\n\n                if (x === json.layers[i].width)\n                {\n                    output.push(row);\n                    x = 0;\n                    row = [];\n                }\n            }\n\n            layer.data = output;\n\n            layers.push(layer);\n\n        }\n\n        map.layers = layers;\n\n        //  Images\n        var images = [];\n\n        for (var i = 0; i < json.layers.length; i++)\n        {\n            if (json.layers[i].type !== 'imagelayer')\n            {\n                continue;\n            }\n\n            var image = {\n\n                name: json.layers[i].name,\n                image: json.layers[i].image,\n                x: json.layers[i].x,\n                y: json.layers[i].y,\n                alpha: json.layers[i].opacity,\n                visible: json.layers[i].visible,\n                properties: {}\n\n            };\n\n            if (json.layers[i].properties)\n            {\n                image.properties = json.layers[i].properties;\n            }\n\n            images.push(image);\n\n        }\n\n        map.images = images;\n\n        //  Tilesets\n        var tilesets = [];\n\n        for (var i = 0; i < json.tilesets.length; i++)\n        {\n            //  name, firstgid, width, height, margin, spacing, properties\n            var set = json.tilesets[i];\n            var newSet = new Phaser.Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties);\n\n            if (set.tileproperties)\n            {\n                newSet.tileProperties = set.tileproperties;\n            }\n\n            newSet.rows = Math.round((set.imageheight - set.margin) / (set.tileheight + set.spacing));\n            newSet.columns = Math.round((set.imagewidth - set.margin) / (set.tilewidth + set.spacing));\n            newSet.total = newSet.rows * newSet.columns;\n\n            if (newSet.rows % 1 !== 0 || newSet.columns % 1 !== 0)\n            {\n                console.warn('TileSet image dimensions do not match expected dimensions. Tileset width/height must be evenly divisible by Tilemap tile width/height.');\n            }\n            else\n            {\n                tilesets.push(newSet);\n            }\n        }\n\n        map.tilesets = tilesets;\n\n        //  Objects & Collision Data (polylines, etc)\n        var objects = {};\n        var collision = {};\n\n        for (var i = 0; i < json.layers.length; i++)\n        {\n            if (json.layers[i].type !== 'objectgroup')\n            {\n                continue;\n            }\n\n            objects[json.layers[i].name] = [];\n            collision[json.layers[i].name] = [];\n\n            for (var v = 0, len = json.layers[i].objects.length; v < len; v++)\n            {\n                //  Object Tiles\n                if (json.layers[i].objects[v].gid)\n                {\n                    var object = {\n\n                        gid: json.layers[i].objects[v].gid,\n                        name: json.layers[i].objects[v].name,\n                        x: json.layers[i].objects[v].x,\n                        y: json.layers[i].objects[v].y,\n                        visible: json.layers[i].objects[v].visible,\n                        properties: json.layers[i].objects[v].properties\n\n                    };\n\n                    objects[json.layers[i].name].push(object);\n                }\n                else if (json.layers[i].objects[v].polyline)\n                {\n                    var object = {\n\n                        name: json.layers[i].objects[v].name,\n                        x: json.layers[i].objects[v].x,\n                        y: json.layers[i].objects[v].y,\n                        width: json.layers[i].objects[v].width,\n                        height: json.layers[i].objects[v].height,\n                        visible: json.layers[i].objects[v].visible,\n                        properties: json.layers[i].objects[v].properties\n\n                    };\n\n                    object.polyline = [];\n\n                    //  Parse the polyline into an array\n                    for (var p = 0; p < json.layers[i].objects[v].polyline.length; p++)\n                    {\n                        object.polyline.push([ json.layers[i].objects[v].polyline[p].x, json.layers[i].objects[v].polyline[p].y ]);\n                    }\n\n                    collision[json.layers[i].name].push(object);\n\n                }\n\n            }\n        }\n\n        map.objects = objects;\n        map.collision = collision;\n\n        map.tiles = [];\n\n        //  Finally lets build our super tileset index\n        for (var i = 0; i < map.tilesets.length; i++)\n        {\n            var set = map.tilesets[i];\n\n            var x = set.tileMargin;\n            var y = set.tileMargin;\n\n            var count = 0;\n            var countX = 0;\n            var countY = 0;\n\n            for (var t = set.firstgid; t < set.firstgid + set.total; t++)\n            {\n                //  Can add extra properties here as needed\n                map.tiles[t] = [x, y, i];\n\n                x += set.tileWidth + set.tileSpacing;\n\n                count++;\n\n                if (count === set.total)\n                {\n                    break;\n                }\n\n                countX++;\n\n                if (countX === set.columns)\n                {\n                    x = set.tileMargin;\n                    y += set.tileHeight + set.tileSpacing;\n\n                    countX = 0;\n                    countY++;\n\n                    if (countY === set.rows)\n                    {\n                        break;\n                    }\n                }\n            }\n\n        }\n\n        return map;\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A Tile set is a combination of an image containing the tiles and collision data per tile.\n* You should not normally instantiate this class directly.\n*\n* @class Phaser.Tileset\n* @constructor\n* @param {string} name - The name of the tileset in the map data.\n* @param {number} firstgid - The Tiled firstgid value. In non-Tiled data this should be considered the starting index value of the first tile in this set.\n* @param {number} [width=32] - Width of each tile in pixels.\n* @param {number} [height=32] - Height of each tile in pixels.\n* @param {number} [margin=0] - The amount of margin around the tilesheet.\n* @param {number} [spacing=0] - The amount of spacing between each tile in the sheet.\n* @param {object} [properties] - Tileset properties.\n*/\nPhaser.Tileset = function (name, firstgid, width, height, margin, spacing, properties) {\n\n    if (typeof width === 'undefined' || width <= 0) { width = 32; }\n    if (typeof height === 'undefined' || height <= 0) { height = 32; }\n    if (typeof margin === 'undefined') { margin = 0; }\n    if (typeof spacing === 'undefined') { spacing = 0; }\n\n    /**\n    * @property {string} name - The name of the Tileset.\n    */\n    this.name = name;\n\n    /**\n    * @property {number} firstgid - The Tiled firstgid value. In non-Tiled data this should be considered the starting index value of the first tile in this set.\n    */\n    this.firstgid = firstgid;\n\n    /**\n    * @property {number} tileWidth - The width of a tile in pixels.\n    */\n    this.tileWidth = width;\n\n    /**\n    * @property {number} tileHeight - The height of a tile in pixels.\n    */\n    this.tileHeight = height;\n\n    /**\n    * @property {number} tileMargin - The margin around the tiles in the tileset.\n    */\n    this.tileMargin = margin;\n\n    /**\n    * @property {number} tileSpacing - The spacing in pixels between each tile in the tileset.\n    */\n    this.tileSpacing = spacing;\n\n    /**\n    * @property {object} properties - Tileset specific properties (typically defined in the Tiled editor).\n    */\n    this.properties = properties;\n\n    /**\n    * @property {object} image - The image used for rendering. This is a reference to the image stored in Phaser.Cache.\n    */\n    this.image = null;\n\n    /**\n    * @property {number} rows - The number of rows in the tile sheet.\n    */\n    this.rows = 0;\n\n    /**\n    * @property {number} columns - The number of columns in the tile sheet.\n    */\n    this.columns = 0;\n\n    /**\n    * @property {number} total - The total number of tiles in the tilesheet.\n    */\n    this.total = 0;\n\n    /**\n    * @property {array} draw - The tile drawImage look-up table\n    * @private\n    */\n    this.drawCoords = [];\n\n};\n\nPhaser.Tileset.prototype = {\n\n    /**\n    * Draws a tile from this Tileset at the given coordinates on the context.\n    *\n    * @method Phaser.Tileset#draw\n    * @param {HTMLCanvasContext} context - The context to draw the tile onto.\n    * @param {number} x - The x coordinate to draw to.\n    * @param {number} y - The y coordinate to draw to.\n    * @param {number} index - The index of the tile within the set to draw.\n    */\n    draw: function (context, x, y, index) {\n\n        if (!this.image || !this.drawCoords[index])\n        {\n            return;\n        }\n\n        context.drawImage(\n            this.image,\n            this.drawCoords[index][0],\n            this.drawCoords[index][1],\n            this.tileWidth,\n            this.tileHeight,\n            x,\n            y,\n            this.tileWidth,\n            this.tileHeight\n        );\n\n    },\n\n    /**\n    * Adds a reference from this Tileset to an Image stored in the Phaser.Cache.\n    *\n    * @method Phaser.Tileset#setImage\n    * @param {Image} image - The image this tileset will use to draw with.\n    */\n    setImage: function (image) {\n\n        this.image = image;\n\n        this.rows = Math.round((image.height - this.tileMargin) / (this.tileHeight + this.tileSpacing));\n        this.columns = Math.round((image.width - this.tileMargin) / (this.tileWidth + this.tileSpacing));\n        this.total = this.rows * this.columns;\n\n        //  Create the index look-up\n        this.drawCoords.length = 0;\n\n        var tx = this.tileMargin;\n        var ty = this.tileMargin;\n        var i = this.firstgid;\n\n        for (var y = 0; y < this.rows; y++)\n        {\n            for (var x = 0; x < this.columns; x++)\n            {\n                this.drawCoords[i] = [ tx, ty ];\n                tx += this.tileWidth + this.tileSpacing;\n                i++;\n            }\n\n            tx = this.tileMargin;\n            ty += this.tileHeight + this.tileSpacing;\n        }\n\n    },\n\n    /**\n    * Sets tile spacing and margins.\n    *\n    * @method Phaser.Tileset#setSpacing\n    * @param {number} [tileMargin] - The margin around the tiles in the sheet.\n    * @param {number} [tileSpacing] - The spacing between the tiles in the sheet.\n    */\n    setSpacing: function (margin, spacing) {\n\n        this.tileMargin = margin;\n        this.tileSpacing = spacing;\n\n        this.setImage(this.image);\n\n    }\n\n};\n\nPhaser.Tileset.prototype.constructor = Phaser.Tileset;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = Phaser;\n        }\n        exports.Phaser = Phaser;\n    } else if (typeof define !== 'undefined' && define.amd) {\n        define('Phaser', (function() { return root.Phaser = Phaser; }) ());\n    } else {\n        root.Phaser = Phaser;\n    }\n}).call(this);\n\n/*\n* \"Don't follow strange women who lure you into woods with beautiful poetry.\" - @djfood\n*/\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Ninja Physics. The Ninja Physics system was created in Flash by Metanet Software and ported to JavaScript by Richard Davey.\n*\n* It allows for AABB and Circle to Tile collision. Tiles can be any of 34 different types, including slopes, convex and concave shapes.\n*\n* It does what it does very well, but is ripe for expansion and optimisation. Here are some features that I'd love to see the community add:\n*\n* * AABB to AABB collision\n* * AABB to Circle collision\n* * AABB and Circle 'immovable' property support\n* * n-way collision, so an AABB/Circle could pass through a tile from below and land upon it.\n* * QuadTree or spatial grid for faster Body vs. Tile Group look-ups.\n* * Optimise the internal vector math and reduce the quantity of temporary vars created.\n* * Expand Gravity and Bounce to allow for separate x/y axis values.\n* * Support Bodies linked to Sprites that don't have anchor set to 0.5\n*\n* Feel free to attempt any of the above and submit a Pull Request with your code! Be sure to include test cases proving they work.\n*\n* @class Phaser.Physics.Ninja\n* @classdesc Ninja Physics Constructor\n* @constructor\n* @param {Phaser.Game} game reference to the current game instance.\n*/\nPhaser.Physics.Ninja = function (game) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Time} time - Local reference to game.time.\n    */\n    this.time = this.game.time;\n\n    /**\n    * @property {number} gravity - The World gravity setting.\n    */\n    this.gravity = 0.2;\n\n    /**\n    * @property {Phaser.Rectangle} bounds - The bounds inside of which the physics world exists. Defaults to match the world bounds.\n    */\n    this.bounds = new Phaser.Rectangle(0, 0, game.world.width, game.world.height);\n\n    /**\n    * @property {number} maxObjects - Used by the QuadTree to set the maximum number of objects per quad.\n    */\n    this.maxObjects = 10;\n\n    /**\n    * @property {number} maxLevels - Used by the QuadTree to set the maximum number of iteration levels.\n    */\n    this.maxLevels = 4;\n\n    /**\n    * @property {Phaser.QuadTree} quadTree - The world QuadTree.\n    */\n    this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);\n\n};\n\nPhaser.Physics.Ninja.prototype.constructor = Phaser.Physics.Ninja;\n\nPhaser.Physics.Ninja.prototype = {\n\n    /**\n    * This will create a Ninja Physics AABB body on the given game object. Its dimensions will match the width and height of the object at the point it is created.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    *\n    * @method Phaser.Physics.Ninja#enableAABB\n    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\n    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\n    */\n    enableAABB: function (object, children) {\n\n        this.enable(object, 1, 0, 0, children);\n\n    },\n\n    /**\n    * This will create a Ninja Physics Circle body on the given game object.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    *\n    * @method Phaser.Physics.Ninja#enableCircle\n    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\n    * @param {number} radius - The radius of the Circle.\n    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\n    */\n    enableCircle: function (object, radius, children) {\n\n        this.enable(object, 2, 0, radius, children);\n\n    },\n\n    /**\n    * This will create a Ninja Physics Tile body on the given game object. There are 34 different types of tile you can create, including 45 degree slopes,\n    * convex and concave circles and more. The id parameter controls which Tile type is created, but you can also change it at run-time.\n    * Note that for all degree based tile types they need to have an equal width and height. If the given object doesn't have equal width and height it will use the width.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    *\n    * @method Phaser.Physics.Ninja#enableTile\n    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\n    * @param {number} [id=1] - The type of Tile this will use, i.e. Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn, Phaser.Physics.Ninja.Tile.CONVEXpp, etc.\n    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\n    */\n    enableTile: function (object, id, children) {\n\n        this.enable(object, 3, id, 0, children);\n\n    },\n\n    /**\n    * This will create a Ninja Physics body on the given game object or array of game objects.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    *\n    * @method Phaser.Physics.Ninja#enable\n    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\n    * @param {number} [type=1] - The type of Ninja shape to create. 1 = AABB, 2 = Circle or 3 = Tile.\n    * @param {number} [id=1] - If this body is using a Tile shape, you can set the Tile id here, i.e. Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn, Phaser.Physics.Ninja.Tile.CONVEXpp, etc.\n    * @param {number} [radius=0] - If this body is using a Circle shape this controls the radius.\n    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\n    */\n    enable: function (object, type, id, radius, children) {\n\n        if (typeof type === 'undefined') { type = 1; }\n        if (typeof id === 'undefined') { id = 1; }\n        if (typeof radius === 'undefined') { radius = 0; }\n        if (typeof children === 'undefined') { children = true; }\n\n        if (Array.isArray(object))\n        {\n            var i = object.length;\n\n            while (i--)\n            {\n                if (object[i] instanceof Phaser.Group)\n                {\n                    //  If it's a Group then we do it on the children regardless\n                    this.enable(object[i].children, type, id, radius, children);\n                }\n                else\n                {\n                    this.enableBody(object[i], type, id, radius);\n\n                    if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0)\n                    {\n                        this.enable(object[i], type, id, radius, true);\n                    }\n                }\n            }\n        }\n        else\n        {\n            if (object instanceof Phaser.Group)\n            {\n                //  If it's a Group then we do it on the children regardless\n                this.enable(object.children, type, id, radius, children);\n            }\n            else\n            {\n                this.enableBody(object, type, id, radius);\n\n                if (children && object.hasOwnProperty('children') && object.children.length > 0)\n                {\n                    this.enable(object.children, type, id, radius, true);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Creates a Ninja Physics body on the given game object.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.\n    *\n    * @method Phaser.Physics.Ninja#enableBody\n    * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.\n    */\n    enableBody: function (object, type, id, radius) {\n\n        if (object.hasOwnProperty('body') && object.body === null)\n        {\n            object.body = new Phaser.Physics.Ninja.Body(this, object, type, id, radius);\n            object.anchor.set(0.5);\n        }\n\n    },\n\n    /**\n    * Updates the size of this physics world.\n    *\n    * @method Phaser.Physics.Ninja#setBounds\n    * @param {number} x - Top left most corner of the world.\n    * @param {number} y - Top left most corner of the world.\n    * @param {number} width - New width of the world. Can never be smaller than the Game.width.\n    * @param {number} height - New height of the world. Can never be smaller than the Game.height.\n    */\n    setBounds: function (x, y, width, height) {\n\n        this.bounds.setTo(x, y, width, height);\n\n    },\n\n    /**\n    * Updates the size of this physics world to match the size of the game world.\n    *\n    * @method Phaser.Physics.Ninja#setBoundsToWorld\n    */\n    setBoundsToWorld: function () {\n\n        this.bounds.setTo(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height);\n\n    },\n\n    /**\n    * Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.\n    *\n    * @method Phaser.Physics.Ninja#clearTilemapLayerBodies\n    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.\n    */\n    clearTilemapLayerBodies: function (map, layer) {\n\n        layer = map.getLayer(layer);\n\n        var i = map.layers[layer].bodies.length;\n\n        while (i--)\n        {\n            map.layers[layer].bodies[i].destroy();\n        }\n\n        map.layers[layer].bodies.length = [];\n\n    },\n\n    /**\n    * Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics tiles.\n    * Only call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.\n    * Every time you call this method it will destroy any previously created bodies and remove them from the world.\n    * Therefore understand it's a very expensive operation and not to be done in a core game update loop.\n    *\n    * In Ninja the Tiles have an ID from 0 to 33, where 0 is 'empty', 1 is a full tile, 2 is a 45-degree slope, etc. You can find the ID\n    * list either at the very bottom of `Tile.js`, or in a handy visual reference in the `resources/Ninja Physics Debug Tiles` folder in the repository.\n    * The slopeMap parameter is an array that controls how the indexes of the tiles in your tilemap data will map to the Ninja Tile IDs.\n    * For example if you had 6 tiles in your tileset: Imagine the first 4 should be converted into fully solid Tiles and the other 2 are 45-degree slopes.\n    * Your slopeMap array would look like this: `[ 1, 1, 1, 1, 2, 3 ]`.\n    * Where each element of the array is a tile in your tilemap and the resulting Ninja Tile it should create.\n    *\n    * @method Phaser.Physics.Ninja#convertTilemap\n    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.\n    * @param {object} [slopeMap] - The tilemap index to Tile ID map.\n    * @return {array} An array of the Phaser.Physics.Ninja.Tile objects that were created.\n    */\n    convertTilemap: function (map, layer, slopeMap) {\n\n        layer = map.getLayer(layer);\n\n        //  If the bodies array is already populated we need to nuke it\n        this.clearTilemapLayerBodies(map, layer);\n\n        for (var y = 0, h = map.layers[layer].height; y < h; y++)\n        {\n            for (var x = 0, w = map.layers[layer].width; x < w; x++)\n            {\n                var tile = map.layers[layer].data[y][x];\n\n                if (tile && slopeMap.hasOwnProperty(tile.index))\n                {\n                    var body = new Phaser.Physics.Ninja.Body(this, null, 3, slopeMap[tile.index], 0, tile.worldX + tile.centerX, tile.worldY + tile.centerY, tile.width, tile.height);\n\n                    map.layers[layer].bodies.push(body);\n                }\n            }\n        }\n\n        return map.layers[layer].bodies;\n\n    },\n\n    /**\n    * Checks for overlaps between two game objects. The objects can be Sprites, Groups or Emitters.\n    * You can perform Sprite vs. Sprite, Sprite vs. Group and Group vs. Group overlap checks.\n    * Unlike collide the objects are NOT automatically separated or have any physics applied, they merely test for overlap results.\n    * The second parameter can be an array of objects, of differing types.\n    *\n    * @method Phaser.Physics.Ninja#overlap\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter} object1 - The first object to check. Can be an instance of Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|array} object2 - The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group or Phaser.Particles.Emitter.\n    * @param {function} [overlapCallback=null] - An optional callback function that is called if the objects overlap. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then overlapCallback will only be called if processCallback returns true.\n    * @param {object} [callbackContext] - The context in which to run the callbacks.\n    * @returns {boolean} True if an overlap occured otherwise false.\n    */\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext) {\n\n        overlapCallback = overlapCallback || null;\n        processCallback = processCallback || null;\n        callbackContext = callbackContext || overlapCallback;\n\n        this._result = false;\n        this._total = 0;\n\n        if (Array.isArray(object2))\n        {\n            for (var i = 0,  len = object2.length; i < len; i++)\n            {\n                this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, true);\n            }\n        }\n        else\n        {\n            this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, true);\n        }\n\n        return (this._total > 0);\n\n    },\n\n    /**\n    * Checks for collision between two game objects. You can perform Sprite vs. Sprite, Sprite vs. Group, Group vs. Group, Sprite vs. Tilemap Layer or Group vs. Tilemap Layer collisions.\n    * The second parameter can be an array of objects, of differing types.\n    * The objects are also automatically separated. If you don't require separation then use ArcadePhysics.overlap instead.\n    * An optional processCallback can be provided. If given this function will be called when two sprites are found to be colliding. It is called before any separation takes place,\n    * giving you the chance to perform additional checks. If the function returns true then the collision and separation is carried out. If it returns false it is skipped.\n    * The collideCallback is an optional function that is only called if two sprites collide. If a processCallback has been set then it needs to return true for collideCallback to be called.\n    *\n    * @method Phaser.Physics.Ninja#collide\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap} object1 - The first object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter, or Phaser.Tilemap.\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap|array} object2 - The second object or array of objects to check. Can be Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter or Phaser.Tilemap.\n    * @param {function} [collideCallback=null] - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} [processCallback=null] - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} [callbackContext] - The context in which to run the callbacks.\n    * @returns {boolean} True if a collision occured otherwise false.\n    */\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext) {\n\n        collideCallback = collideCallback || null;\n        processCallback = processCallback || null;\n        callbackContext = callbackContext || collideCallback;\n\n        this._result = false;\n        this._total = 0;\n\n        if (Array.isArray(object2))\n        {\n            for (var i = 0,  len = object2.length; i < len; i++)\n            {\n                this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, false);\n            }\n        }\n        else\n        {\n            this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false);\n        }\n\n        return (this._total > 0);\n\n    },\n\n    /**\n    * Internal collision handler.\n    *\n    * @method Phaser.Physics.Ninja#collideHandler\n    * @private\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap} object1 - The first object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter, or Phaser.Tilemap.\n    * @param {Phaser.Sprite|Phaser.Group|Phaser.Particles.Emitter|Phaser.Tilemap} object2 - The second object to check. Can be an instance of Phaser.Sprite, Phaser.Group, Phaser.Particles.Emitter or Phaser.Tilemap. Can also be an array of objects to check.\n    * @param {function} collideCallback - An optional callback function that is called if the objects collide. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {function} processCallback - A callback function that lets you perform additional checks against the two objects if they overlap. If this is set then collision will only happen if processCallback returns true. The two objects will be passed to this function in the same order in which you specified them.\n    * @param {object} callbackContext - The context in which to run the callbacks.\n    * @param {boolean} overlapOnly - Just run an overlap or a full collision.\n    */\n    collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        //  Only collide valid objects\n        if (typeof object2 === 'undefined' && (object1.type === Phaser.GROUP || object1.type === Phaser.EMITTER))\n        {\n            this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly);\n            return;\n        }\n\n        if (object1 && object2 && object1.exists && object2.exists)\n        {\n            //  SPRITES\n            if (object1.type == Phaser.SPRITE || object1.type == Phaser.TILESPRITE)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.TILEMAPLAYER)\n                {\n                    this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);\n                }\n            }\n            //  GROUPS\n            else if (object1.type == Phaser.GROUP)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.TILEMAPLAYER)\n                {\n                    this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);\n                }\n            }\n            //  TILEMAP LAYERS\n            else if (object1.type == Phaser.TILEMAPLAYER)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext);\n                }\n            }\n            //  EMITTER\n            else if (object1.type == Phaser.EMITTER)\n            {\n                if (object2.type == Phaser.SPRITE || object2.type == Phaser.TILESPRITE)\n                {\n                    this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.GROUP || object2.type == Phaser.EMITTER)\n                {\n                    this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n                else if (object2.type == Phaser.TILEMAPLAYER)\n                {\n                    this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Ninja.collide instead.\n    *\n    * @method Phaser.Physics.Ninja#collideSpriteVsSprite\n    * @private\n    */\n    collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly))\n        {\n            if (collideCallback)\n            {\n                collideCallback.call(callbackContext, sprite1, sprite2);\n            }\n\n            this._total++;\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Ninja.collide instead.\n    *\n    * @method Phaser.Physics.Ninja#collideSpriteVsGroup\n    * @private\n    */\n    collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (group.length === 0)\n        {\n            return;\n        }\n\n        //  What is the sprite colliding with in the quadtree?\n        // this.quadTree.clear();\n\n        // this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);\n\n        // this.quadTree.populate(group);\n\n        // this._potentials = this.quadTree.retrieve(sprite);\n\n        for (var i = 0, len = group.children.length; i < len; i++)\n        {\n            //  We have our potential suspects, are they in this group?\n            if (group.children[i].exists && group.children[i].body && this.separate(sprite.body, group.children[i].body, processCallback, callbackContext, overlapOnly))\n            {\n                if (collideCallback)\n                {\n                    collideCallback.call(callbackContext, sprite, group.children[i]);\n                }\n\n                this._total++;\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Ninja.collide instead.\n    *\n    * @method Phaser.Physics.Ninja#collideGroupVsSelf\n    * @private\n    */\n    collideGroupVsSelf: function (group, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (group.length === 0)\n        {\n            return;\n        }\n\n        var len = group.children.length;\n\n        for (var i = 0; i < len; i++)\n        {\n            for (var j = i + 1; j <= len; j++)\n            {\n                if (group.children[i] && group.children[j] && group.children[i].exists && group.children[j].exists)\n                {\n                    this.collideSpriteVsSprite(group.children[i], group.children[j], collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * An internal function. Use Phaser.Physics.Ninja.collide instead.\n    *\n    * @method Phaser.Physics.Ninja#collideGroupVsGroup\n    * @private\n    */\n    collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {\n\n        if (group1.length === 0 || group2.length === 0)\n        {\n            return;\n        }\n\n        for (var i = 0, len = group1.children.length; i < len; i++)\n        {\n            if (group1.children[i].exists)\n            {\n                this.collideSpriteVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly);\n            }\n        }\n\n    },\n\n    /**\n    * The core separation function to separate two physics bodies.\n    * @method Phaser.Physics.Ninja#separate\n    * @param {Phaser.Physics.Ninja.Body} body1 - The Body object to separate.\n    * @param {Phaser.Physics.Ninja.Body} body2 - The Body object to separate.\n    * @returns {boolean} Returns true if the bodies collided, otherwise false.\n    */\n    separate: function (body1, body2) {\n\n        if (body1.type !== Phaser.Physics.NINJA || body2.type !== Phaser.Physics.NINJA)\n        {\n            return false;\n        }\n\n        if (body1.aabb && body2.aabb)\n        {\n            return body1.aabb.collideAABBVsAABB(body2.aabb);\n        }\n\n        if (body1.aabb && body2.tile)\n        {\n            return body1.aabb.collideAABBVsTile(body2.tile);\n        }\n\n        if (body1.tile && body2.aabb)\n        {\n            return body2.aabb.collideAABBVsTile(body1.tile);\n        }\n\n        if (body1.circle && body2.tile)\n        {\n            return body1.circle.collideCircleVsTile(body2.tile);\n        }\n\n        if (body1.tile && body2.circle)\n        {\n            return body2.circle.collideCircleVsTile(body1.tile);\n        }\n\n    }\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Physics Body is linked to a single Sprite. All physics operations should be performed against the body rather than\n* the Sprite itself. For example you can set the velocity, bounce values etc all on the Body.\n*\n* @class Phaser.Physics.Ninja.Body\n* @classdesc Ninja Physics Body Constructor\n* @constructor\n* @param {Phaser.Physics.Ninja} system - The physics system this Body belongs to.\n* @param {Phaser.Sprite} sprite - The Sprite object this physics body belongs to.\n* @param {number} [type=1] - The type of Ninja shape to create. 1 = AABB, 2 = Circle or 3 = Tile.\n* @param {number} [id=1] - If this body is using a Tile shape, you can set the Tile id here, i.e. Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn, Phaser.Physics.Ninja.Tile.CONVEXpp, etc.\n* @param {number} [radius=16] - If this body is using a Circle shape this controls the radius.\n* @param {number} [x=0] - The x coordinate of this Body. This is only used if a sprite is not provided.\n* @param {number} [y=0] - The y coordinate of this Body. This is only used if a sprite is not provided.\n* @param {number} [width=0] - The width of this Body. This is only used if a sprite is not provided.\n* @param {number} [height=0] - The height of this Body. This is only used if a sprite is not provided.\n*/\nPhaser.Physics.Ninja.Body = function (system, sprite, type, id, radius, x, y, width, height) {\n\n    sprite = sprite || null;\n\n    if (typeof type === 'undefined') { type = 1; }\n    if (typeof id === 'undefined') { id = 1; }\n    if (typeof radius === 'undefined') { radius = 16; }\n\n    /**\n    * @property {Phaser.Sprite} sprite - Reference to the parent Sprite.\n    */\n    this.sprite = sprite;\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = system.game;\n\n    /**\n    * @property {number} type - The type of physics system this body belongs to.\n    */\n    this.type = Phaser.Physics.NINJA;\n\n    /**\n    * @property {Phaser.Physics.Ninja} system - The parent physics system.\n    */\n    this.system = system;\n\n    /**\n    * @property {Phaser.Physics.Ninja.AABB} aabb - The AABB object this body is using for collision.\n    */\n    this.aabb = null;\n\n    /**\n    * @property {Phaser.Physics.Ninja.Tile} tile - The Tile object this body is using for collision.\n    */\n    this.tile = null;\n\n    /**\n    * @property {Phaser.Physics.Ninja.Circle} circle - The Circle object this body is using for collision.\n    */\n    this.circle = null;\n\n    /**\n    * @property {object} shape - A local reference to the body shape.\n    */\n    this.shape = null;\n\n    //  Setting drag to 0 and friction to 0 means you get a normalised speed (px psec)\n\n    /**\n    * @property {number} drag - The drag applied to this object as it moves.\n    * @default\n    */\n    this.drag = 1;\n\n    /**\n    * @property {number} friction - The friction applied to this object as it moves.\n    * @default\n    */\n    this.friction = 0.05;\n\n    /**\n    * @property {number} gravityScale - How much of the world gravity should be applied to this object? 1 = all of it, 0.5 = 50%, etc.\n    * @default\n    */\n    this.gravityScale = 1;\n\n    /**\n    * @property {number} bounce - The bounciness of this object when it collides. A value between 0 and 1. We recommend setting it to 0.999 to avoid jittering.\n    * @default\n    */\n    this.bounce = 0.3;\n\n    /**\n    * @property {Phaser.Point} velocity - The velocity in pixels per second sq. of the Body.\n    */\n    this.velocity = new Phaser.Point();\n\n    /**\n    * @property {number} facing - A const reference to the direction the Body is traveling or facing.\n    * @default\n    */\n    this.facing = Phaser.NONE;\n\n    /**\n    * @property {boolean} immovable - An immovable Body will not receive any impacts from other bodies. Not fully implemented.\n    * @default\n    */\n    this.immovable = false;\n\n    /**\n    * A Body can be set to collide against the World bounds automatically and rebound back into the World if this is set to true. Otherwise it will leave the World.\n    * @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?\n    */\n    this.collideWorldBounds = true;\n\n    /**\n    * Set the checkCollision properties to control which directions collision is processed for this Body.\n    * For example checkCollision.up = false means it won't collide when the collision happened while moving up.\n    * @property {object} checkCollision - An object containing allowed collision.\n    */\n    this.checkCollision = { none: false, any: true, up: true, down: true, left: true, right: true };\n\n    /**\n    * This object is populated with boolean values when the Body collides with another.\n    * touching.up = true means the collision happened to the top of this Body for example.\n    * @property {object} touching - An object containing touching results.\n    */\n    this.touching = { none: true, up: false, down: false, left: false, right: false };\n\n    /**\n    * This object is populated with previous touching values from the bodies previous collision.\n    * @property {object} wasTouching - An object containing previous touching results.\n    */\n    this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\n\n    /**\n    * @property {number} maxSpeed - The maximum speed this body can travel at (taking drag and friction into account)\n    * @default\n    */\n    this.maxSpeed = 8;\n\n    if (sprite)\n    {\n        x = sprite.x;\n        y = sprite.y;\n        width = sprite.width;\n        height = sprite.height;\n\n        if (sprite.anchor.x === 0)\n        {\n            x += (sprite.width * 0.5);\n        }\n\n        if (sprite.anchor.y === 0)\n        {\n            y += (sprite.height * 0.5);\n        }\n    }\n\n    if (type === 1)\n    {\n        this.aabb = new Phaser.Physics.Ninja.AABB(this, x, y, width, height);\n        this.shape = this.aabb;\n    }\n    else if (type === 2)\n    {\n        this.circle = new Phaser.Physics.Ninja.Circle(this, x, y, radius);\n        this.shape = this.circle;\n    }\n    else if (type === 3)\n    {\n        this.tile = new Phaser.Physics.Ninja.Tile(this, x, y, width, height, id);\n        this.shape = this.tile;\n    }\n\n};\n\nPhaser.Physics.Ninja.Body.prototype = {\n\n    /**\n    * Internal method.\n    *\n    * @method Phaser.Physics.Ninja.Body#preUpdate\n    * @protected\n    */\n    preUpdate: function () {\n\n        //  Store and reset collision flags\n        this.wasTouching.none = this.touching.none;\n        this.wasTouching.up = this.touching.up;\n        this.wasTouching.down = this.touching.down;\n        this.wasTouching.left = this.touching.left;\n        this.wasTouching.right = this.touching.right;\n\n        this.touching.none = true;\n        this.touching.up = false;\n        this.touching.down = false;\n        this.touching.left = false;\n        this.touching.right = false;\n\n        this.shape.integrate();\n\n        if (this.collideWorldBounds)\n        {\n            this.shape.collideWorldBounds();\n        }\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method Phaser.Physics.Ninja.Body#postUpdate\n    * @protected\n    */\n    postUpdate: function () {\n\n        if (this.sprite)\n        {\n            if (this.sprite.type === Phaser.TILESPRITE)\n            {\n                //  TileSprites don't use their anchor property, so we need to adjust the coordinates\n                this.sprite.x = this.shape.pos.x - this.shape.xw;\n                this.sprite.y = this.shape.pos.y - this.shape.yw;\n            }\n            else\n            {\n                this.sprite.x = this.shape.pos.x;\n                this.sprite.y = this.shape.pos.y;\n            }\n        }\n\n        if (this.velocity.x < 0)\n        {\n            this.facing = Phaser.LEFT;\n        }\n        else if (this.velocity.x > 0)\n        {\n            this.facing = Phaser.RIGHT;\n        }\n\n        if (this.velocity.y < 0)\n        {\n            this.facing = Phaser.UP;\n        }\n        else if (this.velocity.y > 0)\n        {\n            this.facing = Phaser.DOWN;\n        }\n\n    },\n\n    /**\n    * Stops all movement of this body.\n    *\n    * @method Phaser.Physics.Ninja.Body#setZeroVelocity\n    */\n    setZeroVelocity: function () {\n\n        this.shape.oldpos.x = this.shape.pos.x;\n        this.shape.oldpos.y = this.shape.pos.y;\n\n    },\n\n    /**\n    * Moves the Body forwards based on its current angle and the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.Body#moveTo\n    * @param {number} speed - The speed at which it should move forwards.\n    * @param {number} angle - The angle in which it should move, given in degrees.\n    */\n    moveTo: function (speed, angle) {\n\n        var magnitude = speed * this.game.time.physicsElapsed;\n        var angle = this.game.math.degToRad(angle);\n\n        this.shape.pos.x = this.shape.oldpos.x + (magnitude * Math.cos(angle));\n        this.shape.pos.y = this.shape.oldpos.y + (magnitude * Math.sin(angle));\n\n    },\n\n    /**\n    * Moves the Body backwards based on its current angle and the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.Body#moveBackward\n    * @param {number} speed - The speed at which it should move backwards.\n    * @param {number} angle - The angle in which it should move, given in degrees.\n    */\n    moveFrom: function (speed, angle) {\n\n        var magnitude = -speed * this.game.time.physicsElapsed;\n        var angle = this.game.math.degToRad(angle);\n\n        this.shape.pos.x = this.shape.oldpos.x + (magnitude * Math.cos(angle));\n        this.shape.pos.y = this.shape.oldpos.y + (magnitude * Math.sin(angle));\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it to the left by setting its x velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.Body#moveLeft\n    * @param {number} speed - The speed at which it should move to the left, in pixels per second.\n    */\n    moveLeft: function (speed) {\n\n        var fx = -speed * this.game.time.physicsElapsed;\n\n        this.shape.pos.x = this.shape.oldpos.x + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.x - this.shape.oldpos.x + fx));\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it to the right by setting its x velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.Body#moveRight\n    * @param {number} speed - The speed at which it should move to the right, in pixels per second.\n    */\n    moveRight: function (speed) {\n\n        var fx = speed * this.game.time.physicsElapsed;\n\n        this.shape.pos.x = this.shape.oldpos.x + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.x - this.shape.oldpos.x + fx));\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it up by setting its y velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.Body#moveUp\n    * @param {number} speed - The speed at which it should move up, in pixels per second.\n    */\n    moveUp: function (speed) {\n\n        var fx = -speed * this.game.time.physicsElapsed;\n\n        this.shape.pos.y = this.shape.oldpos.y + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.y - this.shape.oldpos.y + fx));\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it down by setting its y velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.Body#moveDown\n    * @param {number} speed - The speed at which it should move down, in pixels per second.\n    */\n    moveDown: function (speed) {\n\n        var fx = speed * this.game.time.physicsElapsed;\n\n        this.shape.pos.y = this.shape.oldpos.y + Math.min(this.maxSpeed, Math.max(-this.maxSpeed, this.shape.pos.y - this.shape.oldpos.y + fx));\n\n    },\n\n    /**\n    * Resets all Body values and repositions on the Sprite.\n    *\n    * @method Phaser.Physics.Ninja.Body#reset\n    */\n    reset: function () {\n\n        this.velocity.set(0);\n\n        this.shape.pos.x = this.sprite.x;\n        this.shape.pos.y = this.sprite.y;\n\n        this.shape.oldpos.copyFrom(this.shape.pos);\n\n    },\n\n    /**\n    * Returns the absolute delta x value.\n    *\n    * @method Phaser.Physics.Ninja.Body#deltaAbsX\n    * @return {number} The absolute delta value.\n    */\n    deltaAbsX: function () {\n        return (this.deltaX() > 0 ? this.deltaX() : -this.deltaX());\n    },\n\n    /**\n    * Returns the absolute delta y value.\n    *\n    * @method Phaser.Physics.Ninja.Body#deltaAbsY\n    * @return {number} The absolute delta value.\n    */\n    deltaAbsY: function () {\n        return (this.deltaY() > 0 ? this.deltaY() : -this.deltaY());\n    },\n\n    /**\n    * Returns the delta x value. The difference between Body.x now and in the previous step.\n    *\n    * @method Phaser.Physics.Ninja.Body#deltaX\n    * @return {number} The delta value. Positive if the motion was to the right, negative if to the left.\n    */\n    deltaX: function () {\n        return this.shape.pos.x - this.shape.oldpos.x;\n    },\n\n    /**\n    * Returns the delta y value. The difference between Body.y now and in the previous step.\n    *\n    * @method Phaser.Physics.Ninja.Body#deltaY\n    * @return {number} The delta value. Positive if the motion was downwards, negative if upwards.\n    */\n    deltaY: function () {\n        return this.shape.pos.y - this.shape.oldpos.y;\n    },\n\n    /**\n    * Destroys this body's reference to the sprite and system, and destroys its shape.\n    *\n    * @method Phaser.Physics.Ninja.Body#destroy\n    */\n    destroy: function() {\n        this.sprite = null;\n        this.system = null;\n        this.aabb = null;\n        this.tile = null;\n        this.circle = null;\n\n        this.shape.destroy();\n        this.shape = null;\n    }\n};\n\n/**\n* @name Phaser.Physics.Ninja.Body#x\n* @property {number} x - The x position.\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"x\", {\n\n    get: function () {\n        return this.shape.pos.x;\n    },\n\n    set: function (value) {\n        this.shape.pos.x = value;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Body#y\n* @property {number} y - The y position.\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"y\", {\n\n    get: function () {\n        return this.shape.pos.y;\n    },\n\n    set: function (value) {\n        this.shape.pos.y = value;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Body#width\n* @property {number} width - The width of this Body\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"width\", {\n\n    get: function () {\n        return this.shape.width;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Body#height\n* @property {number} height - The height of this Body\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"height\", {\n\n    get: function () {\n        return this.shape.height;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Body#bottom\n* @property {number} bottom - The bottom value of this Body (same as Body.y + Body.height)\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"bottom\", {\n\n    get: function () {\n        return this.shape.pos.y + this.shape.yw;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Body#right\n* @property {number} right - The right value of this Body (same as Body.x + Body.width)\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"right\", {\n\n    get: function () {\n        return this.shape.pos.x + this.shape.xw;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Body#speed\n* @property {number} speed - The speed of this Body\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"speed\", {\n\n    get: function () {\n        return Math.sqrt(this.shape.velocity.x * this.shape.velocity.x + this.shape.velocity.y * this.shape.velocity.y);\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Body#angle\n* @property {number} angle - The angle of this Body\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Body.prototype, \"angle\", {\n\n    get: function () {\n        return Math.atan2(this.shape.velocity.y, this.shape.velocity.x);\n    }\n\n});\n\n\n/* jshint camelcase: false */\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Ninja Physics AABB constructor.\n* Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.\n*\n* @class Phaser.Physics.Ninja.AABB\n* @classdesc Arcade Physics Constructor\n* @constructor\n* @param {Phaser.Physics.Ninja.Body} body - The body that owns this shape.\n* @param {number} x - The x coordinate to create this shape at.\n* @param {number} y - The y coordinate to create this shape at.\n* @param {number} width - The width of this AABB.\n* @param {number} height - The height of this AABB.\n*/\nPhaser.Physics.Ninja.AABB = function (body, x, y, width, height) {\n\n    /**\n    * @property {Phaser.Physics.Ninja.Body} system - A reference to the body that owns this shape.\n    */\n    this.body = body;\n\n    /**\n    * @property {Phaser.Physics.Ninja} system - A reference to the physics system.\n    */\n    this.system = body.system;\n\n    /**\n    * @property {Phaser.Point} pos - The position of this object.\n    */\n    this.pos = new Phaser.Point(x, y);\n\n    /**\n    * @property {Phaser.Point} oldpos - The position of this object in the previous update.\n    */\n    this.oldpos = new Phaser.Point(x, y);\n\n    /**\n    * @property {number} xw - Half the width.\n    * @readonly\n    */\n    this.xw = Math.abs(width / 2);\n\n    /**\n    * @property {number} xw - Half the height.\n    * @readonly\n    */\n    this.yw = Math.abs(height / 2);\n\n    /**\n    * @property {number} width - The width.\n    * @readonly\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height.\n    * @readonly\n    */\n    this.height = height;\n\n    /**\n    * @property {number} oH - Internal var.\n    * @private\n    */\n    this.oH = 0;\n\n    /**\n    * @property {number} oV - Internal var.\n    * @private\n    */\n    this.oV = 0;\n\n    /**\n    * @property {Phaser.Point} velocity - The velocity of this object.\n    */\n    this.velocity = new Phaser.Point();\n\n    /**\n    * @property {object} aabbTileProjections - All of the collision response handlers.\n    */\n    this.aabbTileProjections = {};\n\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_FULL] = this.projAABB_Full;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_45DEG] = this.projAABB_45Deg;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONCAVE] = this.projAABB_Concave;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONVEX] = this.projAABB_Convex;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGs] = this.projAABB_22DegS;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGb] = this.projAABB_22DegB;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGs] = this.projAABB_67DegS;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGb] = this.projAABB_67DegB;\n    this.aabbTileProjections[Phaser.Physics.Ninja.Tile.TYPE_HALF] = this.projAABB_Half;\n\n};\n\nPhaser.Physics.Ninja.AABB.prototype.constructor = Phaser.Physics.Ninja.AABB;\n\nPhaser.Physics.Ninja.AABB.COL_NONE = 0;\nPhaser.Physics.Ninja.AABB.COL_AXIS = 1;\nPhaser.Physics.Ninja.AABB.COL_OTHER = 2;\n\nPhaser.Physics.Ninja.AABB.prototype = {\n\n    /**\n    * Updates this AABBs position.\n    *\n    * @method Phaser.Physics.Ninja.AABB#integrate\n    */\n    integrate: function () {\n\n        var px = this.pos.x;\n        var py = this.pos.y;\n\n        //  integrate\n        this.pos.x += (this.body.drag * this.pos.x) - (this.body.drag * this.oldpos.x);\n        this.pos.y += (this.body.drag * this.pos.y) - (this.body.drag * this.oldpos.y) + (this.system.gravity * this.body.gravityScale);\n\n        //  store\n        this.velocity.set(this.pos.x - px, this.pos.y - py);\n        this.oldpos.set(px, py);\n\n    },\n\n    /**\n    * Process a world collision and apply the resulting forces.\n    *\n    * @method Phaser.Physics.Ninja.AABB#reportCollisionVsWorld\n    * @param {number} px - The tangent velocity\n    * @param {number} py - The tangent velocity\n    * @param {number} dx - Collision normal\n    * @param {number} dy - Collision normal\n    * @param {number} obj - Object this AABB collided with\n    */\n    reportCollisionVsWorld: function (px, py, dx, dy) {\n\n        var p = this.pos;\n        var o = this.oldpos;\n\n        //  Calc velocity\n        var vx = p.x - o.x;\n        var vy = p.y - o.y;\n\n        //  Find component of velocity parallel to collision normal\n        var dp = (vx * dx + vy * dy);\n        var nx = dp * dx;   //project velocity onto collision normal\n\n        var ny = dp * dy;   //nx,ny is normal velocity\n\n        var tx = vx - nx;   //px,py is tangent velocity\n        var ty = vy - ny;\n\n        //  We only want to apply collision response forces if the object is travelling into, and not out of, the collision\n        var b, bx, by, fx, fy;\n\n        if (dp < 0)\n        {\n            fx = tx * this.body.friction;\n            fy = ty * this.body.friction;\n\n            b = 1 + this.body.bounce;\n\n            bx = (nx * b);\n            by = (ny * b);\n\n            if (dx === 1)\n            {\n                this.body.touching.left = true;\n            }\n            else if (dx === -1)\n            {\n                this.body.touching.right = true;\n            }\n\n            if (dy === 1)\n            {\n                this.body.touching.up = true;\n            }\n            else if (dy === -1)\n            {\n                this.body.touching.down = true;\n            }\n        }\n        else\n        {\n            //  Moving out of collision, do not apply forces\n            bx = by = fx = fy = 0;\n        }\n\n        //  Project object out of collision\n        p.x += px;\n        p.y += py;\n\n        //  Apply bounce+friction impulses which alter velocity\n        o.x += px + bx + fx;\n        o.y += py + by + fy;\n\n    },\n\n    reverse: function () {\n\n        var vx = this.pos.x - this.oldpos.x;\n        var vy = this.pos.y - this.oldpos.y;\n\n        if (this.oldpos.x < this.pos.x)\n        {\n            this.oldpos.x = this.pos.x + vx;\n            // this.oldpos.x = this.pos.x + (vx + 1 + this.body.bounce);\n        }\n        else if (this.oldpos.x > this.pos.x)\n        {\n            this.oldpos.x = this.pos.x - vx;\n            // this.oldpos.x = this.pos.x - (vx + 1 + this.body.bounce);\n        }\n\n        if (this.oldpos.y < this.pos.y)\n        {\n            this.oldpos.y = this.pos.y + vy;\n            // this.oldpos.y = this.pos.y + (vy + 1 + this.body.bounce);\n        }\n        else if (this.oldpos.y > this.pos.y)\n        {\n            this.oldpos.y = this.pos.y - vy;\n            // this.oldpos.y = this.pos.y - (vy + 1 + this.body.bounce);\n        }\n\n    },\n\n    /**\n    * Process a body collision and apply the resulting forces. Still very much WIP and doesn't work fully. Feel free to fix!\n    *\n    * @method Phaser.Physics.Ninja.AABB#reportCollisionVsBody\n    * @param {number} px - The tangent velocity\n    * @param {number} py - The tangent velocity\n    * @param {number} dx - Collision normal\n    * @param {number} dy - Collision normal\n    * @param {number} obj - Object this AABB collided with\n    */\n    reportCollisionVsBody: function (px, py, dx, dy, obj) {\n\n        var vx1 = this.pos.x - this.oldpos.x;   //  Calc velocity of this object\n        var vy1 = this.pos.y - this.oldpos.y;\n        var dp1 = (vx1 * dx + vy1 * dy);         //  Find component of velocity parallel to collision normal\n\n        //  We only want to apply collision response forces if the object is travelling into, and not out of, the collision\n        if (this.body.immovable && obj.body.immovable)\n        {\n            //  Split the separation then return, no forces applied as they come to a stand-still\n            px *= 0.5;\n            py *= 0.5;\n\n            this.pos.add(px, py);\n            this.oldpos.set(this.pos.x, this.pos.y);\n\n            obj.pos.subtract(px, py);\n            obj.oldpos.set(obj.pos.x, obj.pos.y);\n\n            return;\n        }\n        else if (!this.body.immovable && !obj.body.immovable)\n        {\n            //  separate\n            px *= 0.5;\n            py *= 0.5;\n\n            this.pos.add(px, py);\n            obj.pos.subtract(px, py);\n\n            if (dp1 < 0)\n            {\n                this.reverse();\n                obj.reverse();\n            }\n        }\n        else if (!this.body.immovable)\n        {\n            this.pos.subtract(px, py);\n\n            if (dp1 < 0)\n            {\n                this.reverse();\n            }\n        }\n        else if (!obj.body.immovable)\n        {\n            obj.pos.subtract(px, py);\n\n            if (dp1 < 0)\n            {\n                obj.reverse();\n            }\n        }\n\n    },\n\n    /**\n    * Collides this AABB against the world bounds.\n    *\n    * @method Phaser.Physics.Ninja.AABB#collideWorldBounds\n    */\n    collideWorldBounds: function () {\n\n        var dx = this.system.bounds.x - (this.pos.x - this.xw);\n\n        if (0 < dx)\n        {\n            this.reportCollisionVsWorld(dx, 0, 1, 0, null);\n        }\n        else\n        {\n            dx = (this.pos.x + this.xw) - this.system.bounds.right;\n\n            if (0 < dx)\n            {\n                this.reportCollisionVsWorld(-dx, 0, -1, 0, null);\n            }\n        }\n\n        var dy = this.system.bounds.y - (this.pos.y - this.yw);\n\n        if (0 < dy)\n        {\n            this.reportCollisionVsWorld(0, dy, 0, 1, null);\n        }\n        else\n        {\n            dy = (this.pos.y + this.yw) - this.system.bounds.bottom;\n\n            if (0 < dy)\n            {\n                this.reportCollisionVsWorld(0, -dy, 0, -1, null);\n            }\n        }\n\n    },\n\n    /**\n    * Collides this AABB against a AABB.\n    *\n    * @method Phaser.Physics.Ninja.AABB#collideAABBVsAABB\n    * @param {Phaser.Physics.Ninja.AABB} aabb - The AABB to collide against.\n    */\n    collideAABBVsAABB: function (aabb) {\n\n        var pos = this.pos;\n        var c = aabb;\n\n        var tx = c.pos.x;\n        var ty = c.pos.y;\n        var txw = c.xw;\n        var tyw = c.yw;\n\n        var dx = pos.x - tx;//tile->obj delta\n        var px = (txw + this.xw) - Math.abs(dx);//penetration depth in x\n\n        if (0 < px)\n        {\n            var dy = pos.y - ty;//tile->obj delta\n            var py = (tyw + this.yw) - Math.abs(dy);//pen depth in y\n\n            if (0 < py)\n            {\n                //object may be colliding with tile; call tile-specific collision function\n\n                //calculate projection vectors\n                if (px < py)\n                {\n                    //project in x\n                    if (dx < 0)\n                    {\n                        //project to the left\n                        px *= -1;\n                        py = 0;\n                    }\n                    else\n                    {\n                        //proj to right\n                        py = 0;\n                    }\n                }\n                else\n                {\n                    //project in y\n                    if (dy < 0)\n                    {\n                        //project up\n                        px = 0;\n                        py *= -1;\n                    }\n                    else\n                    {\n                        //project down\n                        px = 0;\n                    }\n                }\n\n                var l = Math.sqrt(px * px + py * py);\n                this.reportCollisionVsBody(px, py, px / l, py / l, c);\n\n                return Phaser.Physics.Ninja.AABB.COL_AXIS;\n\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Collides this AABB against a Tile.\n    *\n    * @method Phaser.Physics.Ninja.AABB#collideAABBVsTile\n    * @param {Phaser.Physics.Ninja.Tile} tile - The Tile to collide against.\n    */\n    collideAABBVsTile: function (tile) {\n\n        var dx = this.pos.x - tile.pos.x;               //  tile->obj delta\n        var px = (tile.xw + this.xw) - Math.abs(dx);    //  penetration depth in x\n\n        if (0 < px)\n        {\n            var dy = this.pos.y - tile.pos.y;               //  tile->obj delta\n            var py = (tile.yw + this.yw) - Math.abs(dy);    //  pen depth in y\n\n            if (0 < py)\n            {\n                //  Calculate projection vectors\n                if (px < py)\n                {\n                    //  Project in x\n                    if (dx < 0)\n                    {\n                        //  Project to the left\n                        px *= -1;\n                        py = 0;\n                    }\n                    else\n                    {\n                        //  Project to the right\n                        py = 0;\n                    }\n                }\n                else\n                {\n                    //  Project in y\n                    if (dy < 0)\n                    {\n                        //  Project up\n                        px = 0;\n                        py *= -1;\n                    }\n                    else\n                    {\n                        //  Project down\n                        px = 0;\n                    }\n                }\n\n                //  Object may be colliding with tile; call tile-specific collision function\n                return this.resolveTile(px, py, this, tile);\n            }\n        }\n\n        return false;\n\n    },\n\n    /**\n    * Resolves tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#resolveTile\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} body - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} tile - The Tile involved in the collision.\n    * @return {boolean} True if the collision was processed, otherwise false.\n    */\n    resolveTile: function (x, y, body, tile) {\n\n        if (0 < tile.id)\n        {\n            return this.aabbTileProjections[tile.type](x, y, body, tile);\n        }\n        else\n        {\n            // console.warn(\"Ninja.AABB.resolveTile was called with an empty (or unknown) tile!: id=\" + tile.id + \")\");\n            return false;\n        }\n\n    },\n\n    /**\n    * Resolves Full tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_Full\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_Full: function (x, y, obj, t) {\n\n        var l = Math.sqrt(x * x + y * y);\n        obj.reportCollisionVsWorld(x, y, x / l, y / l, t);\n\n        return Phaser.Physics.Ninja.AABB.COL_AXIS;\n\n    },\n\n    /**\n    * Resolves Half tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_Half\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_Half: function (x, y, obj, t) {\n\n        //signx or signy must be 0; the other must be -1 or 1\n        //calculate the projection vector for the half-edge, and then\n        //(if collision is occuring) pick the minimum\n\n        var sx = t.signx;\n        var sy = t.signy;\n\n        var ox = (obj.pos.x - (sx*obj.xw)) - t.pos.x;//this gives is the coordinates of the innermost\n        var oy = (obj.pos.y - (sy*obj.yw)) - t.pos.y;//point on the AABB, relative to the tile center\n\n        //we perform operations analogous to the 45deg tile, except we're using\n        //an axis-aligned slope instead of an angled one..\n\n        //if the dotprod of (ox,oy) and (sx,sy) is negative, the corner is in the slope\n        //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n        var dp = (ox*sx) + (oy*sy);\n\n        if (dp < 0)\n        {\n            //collision; project delta onto slope and use this to displace the object\n            sx *= -dp;//(sx,sy) is now the projection vector\n            sy *= -dp;\n\n            var lenN = Math.sqrt(sx*sx + sy*sy);\n            var lenP = Math.sqrt(x*x + y*y);\n\n            if (lenP < lenN)\n            {\n                //project along axis; note that we're assuming that this tile is horizontal OR vertical\n                //relative to the AABB's current tile, and not diagonal OR the current tile.\n                obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                return Phaser.Physics.Ninja.AABB.COL_AXIS;\n            }\n            else\n            {\n                //note that we could use -= instead of -dp\n                obj.reportCollisionVsWorld(sx,sy,t.signx, t.signy, t);\n\n                return Phaser.Physics.Ninja.AABB.COL_OTHER;\n            }\n        }\n\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n\n    },\n\n    /**\n    * Resolves 45 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_45Deg\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_45Deg: function (x, y, obj, t) {\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        var ox = (obj.pos.x - (signx*obj.xw)) - t.pos.x;//this gives is the coordinates of the innermost\n        var oy = (obj.pos.y - (signy*obj.yw)) - t.pos.y;//point on the AABB, relative to the tile center\n\n        var sx = t.sx;\n        var sy = t.sy;\n\n        //if the dotprod of (ox,oy) and (sx,sy) is negative, the corner is in the slope\n        //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n        var dp = (ox*sx) + (oy*sy);\n\n        if (dp < 0)\n        {\n            //collision; project delta onto slope and use this to displace the object\n            sx *= -dp;//(sx,sy) is now the projection vector\n            sy *= -dp;\n\n            var lenN = Math.sqrt(sx*sx + sy*sy);\n            var lenP = Math.sqrt(x*x + y*y);\n\n            if (lenP < lenN)\n            {\n                //project along axis\n                obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                return Phaser.Physics.Ninja.AABB.COL_AXIS;\n            }\n            else\n            {\n                //project along slope\n                obj.reportCollisionVsWorld(sx,sy,t.sx,t.sy);\n\n                return Phaser.Physics.Ninja.AABB.COL_OTHER;\n            }\n        }\n\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n    },\n\n    /**\n    * Resolves 22 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_22DegS\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_22DegS: function (x, y, obj, t) {\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        //first we need to check to make sure we're colliding with the slope at all\n        var py = obj.pos.y - (signy*obj.yw);\n        var penY = t.pos.y - py;//this is the vector from the innermost point on the box to the highest point on\n                                //the tile; if it is positive, this means the box is above the tile and\n                                //no collision is occuring\n        if (0 < (penY*signy))\n        {\n            var ox = (obj.pos.x - (signx*obj.xw)) - (t.pos.x + (signx*t.xw));//this gives is the coordinates of the innermost\n            var oy = (obj.pos.y - (signy*obj.yw)) - (t.pos.y - (signy*t.yw));//point on the AABB, relative to a point on the slope\n\n            var sx = t.sx;//get slope unit normal\n            var sy = t.sy;\n\n            //if the dotprod of (ox,oy) and (sx,sy) is negative, the corner is in the slope\n            //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n            var dp = (ox*sx) + (oy*sy);\n\n            if (dp < 0)\n            {\n                //collision; project delta onto slope and use this to displace the object\n                sx *= -dp;//(sx,sy) is now the projection vector\n                sy *= -dp;\n\n                var lenN = Math.sqrt(sx*sx + sy*sy);\n                var lenP = Math.sqrt(x*x + y*y);\n\n                var aY = Math.abs(penY);\n\n                if (lenP < lenN)\n                {\n                    if (aY < lenP)\n                    {\n                        obj.reportCollisionVsWorld(0, penY, 0, penY/aY, t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_OTHER;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_AXIS;\n                    }\n                }\n                else\n                {\n                    if (aY < lenN)\n                    {\n                        obj.reportCollisionVsWorld(0, penY, 0, penY/aY, t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_OTHER;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(sx,sy,t.sx,t.sy,t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_OTHER;\n                    }\n                }\n            }\n        }\n\n        //if we've reached this point, no collision has occured\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n    },\n\n    /**\n    * Resolves 22 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_22DegB\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_22DegB: function (x, y, obj, t) {\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        var ox = (obj.pos.x - (signx*obj.xw)) - (t.pos.x - (signx*t.xw));//this gives is the coordinates of the innermost\n        var oy = (obj.pos.y - (signy*obj.yw)) - (t.pos.y + (signy*t.yw));//point on the AABB, relative to a point on the slope\n\n        var sx = t.sx;//get slope unit normal\n        var sy = t.sy;\n\n        //if the dotprod of (ox,oy) and (sx,sy) is negative, the corner is in the slope\n        //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n        var dp = (ox*sx) + (oy*sy);\n\n        if (dp < 0)\n        {\n            //collision; project delta onto slope and use this to displace the object\n            sx *= -dp;//(sx,sy) is now the projection vector\n            sy *= -dp;\n\n            var lenN = Math.sqrt(sx*sx + sy*sy);\n            var lenP = Math.sqrt(x*x + y*y);\n\n            if (lenP < lenN)\n            {\n                obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                return Phaser.Physics.Ninja.AABB.COL_AXIS;\n            }\n            else\n            {\n                obj.reportCollisionVsWorld(sx,sy,t.sx,t.sy,t);\n\n                return Phaser.Physics.Ninja.AABB.COL_OTHER;\n            }\n\n        }\n\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n\n    },\n\n    /**\n    * Resolves 67 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_67DegS\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_67DegS: function (x, y, obj, t) {\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        var px = obj.pos.x - (signx*obj.xw);\n        var penX = t.pos.x - px;\n\n        if (0 < (penX*signx))\n        {\n            var ox = (obj.pos.x - (signx*obj.xw)) - (t.pos.x - (signx*t.xw));//this gives is the coordinates of the innermost\n            var oy = (obj.pos.y - (signy*obj.yw)) - (t.pos.y + (signy*t.yw));//point on the AABB, relative to a point on the slope\n\n            var sx = t.sx;//get slope unit normal\n            var sy = t.sy;\n\n            //if the dotprod of (ox,oy) and (sx,sy) is negative, the corner is in the slope\n            //and we need to project it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n            var dp = (ox*sx) + (oy*sy);\n\n            if (dp < 0)\n            {\n                //collision; project delta onto slope and use this to displace the object\n                sx *= -dp;//(sx,sy) is now the projection vector\n                sy *= -dp;\n\n                var lenN = Math.sqrt(sx*sx + sy*sy);\n                var lenP = Math.sqrt(x*x + y*y);\n\n                var aX = Math.abs(penX);\n\n                if (lenP < lenN)\n                {\n                    if (aX < lenP)\n                    {\n                        obj.reportCollisionVsWorld(penX, 0, penX/aX, 0, t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_OTHER;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_AXIS;\n                    }\n                }\n                else\n                {\n                    if (aX < lenN)\n                    {\n                        obj.reportCollisionVsWorld(penX, 0, penX/aX, 0, t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_OTHER;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(sx,sy,t.sx,t.sy,t);\n\n                        return Phaser.Physics.Ninja.AABB.COL_OTHER;\n                    }\n                }\n            }\n        }\n\n        //if we've reached this point, no collision has occured\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n\n    },\n\n    /**\n    * Resolves 67 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_67DegB\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_67DegB: function (x, y, obj, t) {\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        var ox = (obj.pos.x - (signx*obj.xw)) - (t.pos.x + (signx*t.xw));//this gives is the coordinates of the innermost\n        var oy = (obj.pos.y - (signy*obj.yw)) - (t.pos.y - (signy*t.yw));//point on the AABB, relative to a point on the slope\n\n        var sx = t.sx;//get slope unit normal\n        var sy = t.sy;\n\n        //if the dotprod of (ox,oy) and (sx,sy) is negative, the corner is in the slope\n        //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n        var dp = (ox*sx) + (oy*sy);\n\n        if (dp < 0)\n        {\n            //collision; project delta onto slope and use this to displace the object\n            sx *= -dp;//(sx,sy) is now the projection vector\n            sy *= -dp;\n\n            var lenN = Math.sqrt(sx*sx + sy*sy);\n            var lenP = Math.sqrt(x*x + y*y);\n\n            if (lenP < lenN)\n            {\n                obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                return Phaser.Physics.Ninja.AABB.COL_AXIS;\n            }\n            else\n            {\n                obj.reportCollisionVsWorld(sx,sy,t.sx,t.sy,t);\n\n                return Phaser.Physics.Ninja.AABB.COL_OTHER;\n            }\n        }\n\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n    },\n\n    /**\n    * Resolves Convex tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_Convex\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_Convex: function (x, y, obj, t) {\n\n        //if distance from \"innermost\" corner of AABB is less than than tile radius,\n        //collision is occuring and we need to project\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        var ox = (obj.pos.x - (signx * obj.xw)) - (t.pos.x - (signx * t.xw));//(ox,oy) is the vector from the circle center to\n        var oy = (obj.pos.y - (signy * obj.yw)) - (t.pos.y - (signy * t.yw));//the AABB\n        var len = Math.sqrt(ox * ox + oy * oy);\n\n        var twid = t.xw * 2;\n        var rad = Math.sqrt(twid * twid + 0);//this gives us the radius of a circle centered on the tile's corner and extending to the opposite edge of the tile;\n        //note that this should be precomputed at compile-time since it's constant\n\n        var pen = rad - len;\n\n        if (((signx * ox) < 0) || ((signy * oy) < 0))\n        {\n            //the test corner is \"outside\" the 1/4 of the circle we're interested in\n            var lenP = Math.sqrt(x * x + y * y);\n            obj.reportCollisionVsWorld(x, y, x / lenP, y / lenP, t);\n\n            return Phaser.Physics.Ninja.AABB.COL_AXIS;//we need to report\n        }\n        else if (0 < pen)\n        {\n            //project along corner->circle vector\n            ox /= len;\n            oy /= len;\n            obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n            return Phaser.Physics.Ninja.AABB.COL_OTHER;\n        }\n\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n\n    },\n\n    /**\n    * Resolves Concave tile collision.\n    *\n    * @method Phaser.Physics.Ninja.AABB#projAABB_Concave\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {Phaser.Physics.Ninja.AABB} obj - The AABB involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projAABB_Concave: function (x, y, obj, t) {\n\n        //if distance from \"innermost\" corner of AABB is further than tile radius,\n        //collision is occuring and we need to project\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        var ox = (t.pos.x + (signx * t.xw)) - (obj.pos.x - (signx * obj.xw));//(ox,oy) is the vector form the innermost AABB corner to the\n        var oy = (t.pos.y + (signy * t.yw)) - (obj.pos.y - (signy * obj.yw));//circle's center\n\n        var twid = t.xw * 2;\n        var rad = Math.sqrt(twid * twid + 0);//this gives us the radius of a circle centered on the tile's corner and extending to the opposite edge of the tile;\n        //note that this should be precomputed at compile-time since it's constant\n\n        var len = Math.sqrt(ox * ox + oy * oy);\n        var pen = len - rad;\n\n        if (0 < pen)\n        {\n            //collision; we need to either project along the axes, or project along corner->circlecenter vector\n\n            var lenP = Math.sqrt(x * x + y * y);\n\n            if (lenP < pen)\n            {\n                //it's shorter to move along axis directions\n                obj.reportCollisionVsWorld(x, y, x / lenP, y / lenP, t);\n\n                return Phaser.Physics.Ninja.AABB.COL_AXIS;\n            }\n            else\n            {\n                //project along corner->circle vector\n                ox /= len;//len should never be 0, since if it IS 0, rad should be > than len\n                oy /= len;//and we should never reach here\n\n                obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                return Phaser.Physics.Ninja.AABB.COL_OTHER;\n            }\n\n        }\n\n        return Phaser.Physics.Ninja.AABB.COL_NONE;\n\n    },\n\n    /**\n    * Destroys this AABB's reference to Body and System\n    *\n    * @method Phaser.Physics.Ninja.AABB#destroy\n    */\n    destroy: function() {\n        this.body = null;\n        this.system = null;\n    }\n\n};\n\n/* jshint camelcase: false */\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Ninja Physics Tile constructor.\n* A Tile is defined by its width, height and type. It's type can include slope data, such as 45 degree slopes, or convex slopes.\n* Understand that for any type including a slope (types 2 to 29) the Tile must be SQUARE, i.e. have an equal width and height.\n* Also note that as Tiles are primarily used for levels they have gravity disabled and world bounds collision disabled by default.\n*\n* Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.\n*\n* @class Phaser.Physics.Ninja.Tile\n* @classdesc The Ninja Physics Tile class. Based on code by Metanet Software.\n* @constructor\n* @param {Phaser.Physics.Ninja.Body} body - The body that owns this shape.\n* @param {number} x - The x coordinate to create this shape at.\n* @param {number} y - The y coordinate to create this shape at.\n* @param {number} width - The width of this AABB.\n* @param {number} height - The height of this AABB.\n* @param {number} [type=1] - The type of Ninja shape to create. 1 = AABB, 2 = Circle or 3 = Tile.\n*/\nPhaser.Physics.Ninja.Tile = function (body, x, y, width, height, type) {\n\n    if (typeof type === 'undefined') { type = Phaser.Physics.Ninja.Tile.EMPTY; }\n\n    /**\n    * @property {Phaser.Physics.Ninja.Body} system - A reference to the body that owns this shape.\n    */\n    this.body = body;\n\n    /**\n    * @property {Phaser.Physics.Ninja} system - A reference to the physics system.\n    */\n    this.system = body.system;\n\n    /**\n    * @property {number} id - The ID of this Tile.\n    * @readonly\n    */\n    this.id = type;\n\n    /**\n    * @property {number} type - The type of this Tile.\n    * @readonly\n    */\n    this.type = Phaser.Physics.Ninja.Tile.TYPE_EMPTY;\n\n    /**\n    * @property {Phaser.Point} pos - The position of this object.\n    */\n    this.pos = new Phaser.Point(x, y);\n\n    /**\n    * @property {Phaser.Point} oldpos - The position of this object in the previous update.\n    */\n    this.oldpos = new Phaser.Point(x, y);\n\n    if (this.id > 1 && this.id < 30)\n    {\n        //  Tile Types 2 to 29 require square tile dimensions, so use the width as the base\n        height = width;\n    }\n\n    /**\n    * @property {number} xw - Half the width.\n    * @readonly\n    */\n    this.xw = Math.abs(width / 2);\n\n    /**\n    * @property {number} xw - Half the height.\n    * @readonly\n    */\n    this.yw = Math.abs(height / 2);\n\n    /**\n    * @property {number} width - The width.\n    * @readonly\n    */\n    this.width = width;\n\n    /**\n    * @property {number} height - The height.\n    * @readonly\n    */\n    this.height = height;\n\n    /**\n    * @property {Phaser.Point} velocity - The velocity of this object.\n    */\n    this.velocity = new Phaser.Point();\n\n    /**\n    * @property {number} signx - Internal var.\n    * @private\n    */\n    this.signx = 0;\n\n    /**\n    * @property {number} signy - Internal var.\n    * @private\n    */\n    this.signy = 0;\n\n    /**\n    * @property {number} sx - Internal var.\n    * @private\n    */\n    this.sx = 0;\n\n    /**\n    * @property {number} sy - Internal var.\n    * @private\n    */\n    this.sy = 0;\n\n    //  By default Tiles disable gravity and world bounds collision\n    this.body.gravityScale = 0;\n    this.body.collideWorldBounds = false;\n\n    if (this.id > 0)\n    {\n        this.setType(this.id);\n    }\n\n};\n\nPhaser.Physics.Ninja.Tile.prototype.constructor = Phaser.Physics.Ninja.Tile;\n\nPhaser.Physics.Ninja.Tile.prototype = {\n\n    /**\n    * Updates this objects position.\n    *\n    * @method Phaser.Physics.Ninja.Tile#integrate\n    */\n    integrate: function () {\n\n        var px = this.pos.x;\n        var py = this.pos.y;\n\n        this.pos.x += (this.body.drag * this.pos.x) - (this.body.drag * this.oldpos.x);\n        this.pos.y += (this.body.drag * this.pos.y) - (this.body.drag * this.oldpos.y) + (this.system.gravity * this.body.gravityScale);\n\n        this.velocity.set(this.pos.x - px, this.pos.y - py);\n        this.oldpos.set(px, py);\n\n    },\n\n    /**\n    * Tiles cannot collide with the world bounds, it's up to you to keep them where you want them. But we need this API stub to satisfy the Body.\n    *\n    * @method Phaser.Physics.Ninja.Tile#collideWorldBounds\n    */\n    collideWorldBounds: function () {\n\n        var dx = this.system.bounds.x - (this.pos.x - this.xw);\n\n        if (0 < dx)\n        {\n            this.reportCollisionVsWorld(dx, 0, 1, 0, null);\n        }\n        else\n        {\n            dx = (this.pos.x + this.xw) - this.system.bounds.right;\n\n            if (0 < dx)\n            {\n                this.reportCollisionVsWorld(-dx, 0, -1, 0, null);\n            }\n        }\n\n        var dy = this.system.bounds.y - (this.pos.y - this.yw);\n\n        if (0 < dy)\n        {\n            this.reportCollisionVsWorld(0, dy, 0, 1, null);\n        }\n        else\n        {\n            dy = (this.pos.y + this.yw) - this.system.bounds.bottom;\n\n            if (0 < dy)\n            {\n                this.reportCollisionVsWorld(0, -dy, 0, -1, null);\n            }\n        }\n\n    },\n\n    /**\n    * Process a world collision and apply the resulting forces.\n    *\n    * @method Phaser.Physics.Ninja.Tile#reportCollisionVsWorld\n    * @param {number} px - The tangent velocity\n    * @param {number} py - The tangent velocity\n    * @param {number} dx - Collision normal\n    * @param {number} dy - Collision normal\n    * @param {number} obj - Object this Tile collided with\n    */\n    reportCollisionVsWorld: function (px, py, dx, dy) {\n        var p = this.pos;\n        var o = this.oldpos;\n\n        //  Calc velocity\n        var vx = p.x - o.x;\n        var vy = p.y - o.y;\n\n        //  Find component of velocity parallel to collision normal\n        var dp = (vx * dx + vy * dy);\n        var nx = dp * dx;   //project velocity onto collision normal\n\n        var ny = dp * dy;   //nx,ny is normal velocity\n\n        var tx = vx - nx;   //px,py is tangent velocity\n        var ty = vy - ny;\n\n        //  We only want to apply collision response forces if the object is travelling into, and not out of, the collision\n        var b, bx, by, fx, fy;\n\n        if (dp < 0)\n        {\n            fx = tx * this.body.friction;\n            fy = ty * this.body.friction;\n\n            b = 1 + this.body.bounce;\n\n            bx = (nx * b);\n            by = (ny * b);\n\n            if (dx === 1)\n            {\n                this.body.touching.left = true;\n            }\n            else if (dx === -1)\n            {\n                this.body.touching.right = true;\n            }\n\n            if (dy === 1)\n            {\n                this.body.touching.up = true;\n            }\n            else if (dy === -1)\n            {\n                this.body.touching.down = true;\n            }\n        }\n        else\n        {\n            //  Moving out of collision, do not apply forces\n            bx = by = fx = fy = 0;\n        }\n\n        //  Project object out of collision\n        p.x += px;\n        p.y += py;\n\n        //  Apply bounce+friction impulses which alter velocity\n        o.x += px + bx + fx;\n        o.y += py + by + fy;\n\n    },\n\n    /**\n    * Tiles cannot collide with the world bounds, it's up to you to keep them where you want them. But we need this API stub to satisfy the Body.\n    *\n    * @method Phaser.Physics.Ninja.Tile#setType\n    * @param {number} id - The type of Tile this will use, i.e. Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn, Phaser.Physics.Ninja.Tile.CONVEXpp, etc.\n    */\n    setType: function (id) {\n\n        if (id === Phaser.Physics.Ninja.Tile.EMPTY)\n        {\n            this.clear();\n        }\n        else\n        {\n            this.id = id;\n            this.updateType();\n        }\n\n        return this;\n\n    },\n\n    /**\n    * Sets this tile to be empty.\n    *\n    * @method Phaser.Physics.Ninja.Tile#clear\n    */\n    clear: function () {\n\n        this.id = Phaser.Physics.Ninja.Tile.EMPTY;\n        this.updateType();\n\n    },\n\n    /**\n    * Destroys this Tiles reference to Body and System.\n    *\n    * @method Phaser.Physics.Ninja.Tile#destroy\n    */\n    destroy: function () {\n\n        this.body = null;\n        this.system = null;\n\n    },\n\n    /**\n    * This converts a tile from implicitly-defined (via id), to explicit (via properties).\n    * Don't call directly, instead of setType.\n    *\n    * @method Phaser.Physics.Ninja.Tile#updateType\n    * @private\n    */\n    updateType: function () {\n\n        if (this.id === 0)\n        {\n            //EMPTY\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_EMPTY;\n            this.signx = 0;\n            this.signy = 0;\n            this.sx = 0;\n            this.sy = 0;\n\n            return true;\n        }\n\n        //tile is non-empty; collide\n        if (this.id < Phaser.Physics.Ninja.Tile.TYPE_45DEG)\n        {\n            //FULL\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_FULL;\n            this.signx = 0;\n            this.signy = 0;\n            this.sx = 0;\n            this.sy = 0;\n        }\n        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_CONCAVE)\n        {\n            //  45deg\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_45DEG;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGpn)\n            {\n                this.signx = 1;\n                this.signy = -1;\n                this.sx = this.signx / Math.SQRT2;//get slope _unit_ normal\n                this.sy = this.signy / Math.SQRT2;//since normal is (1,-1), length is sqrt(1*1 + -1*-1) = sqrt(2)\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGnn)\n            {\n                this.signx = -1;\n                this.signy = -1;\n                this.sx = this.signx / Math.SQRT2;//get slope _unit_ normal\n                this.sy = this.signy / Math.SQRT2;//since normal is (1,-1), length is sqrt(1*1 + -1*-1) = sqrt(2)\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGnp)\n            {\n                this.signx = -1;\n                this.signy = 1;\n                this.sx = this.signx / Math.SQRT2;//get slope _unit_ normal\n                this.sy = this.signy / Math.SQRT2;//since normal is (1,-1), length is sqrt(1*1 + -1*-1) = sqrt(2)\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_45DEGpp)\n            {\n                this.signx = 1;\n                this.signy = 1;\n                this.sx = this.signx / Math.SQRT2;//get slope _unit_ normal\n                this.sy = this.signy / Math.SQRT2;//since normal is (1,-1), length is sqrt(1*1 + -1*-1) = sqrt(2)\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_CONVEX)\n        {\n            //  Concave\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_CONCAVE;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEpn)\n            {\n                this.signx = 1;\n                this.signy = -1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEnn)\n            {\n                this.signx = -1;\n                this.signy = -1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEnp)\n            {\n                this.signx = -1;\n                this.signy = 1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.CONCAVEpp)\n            {\n                this.signx = 1;\n                this.signy = 1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_22DEGs)\n        {\n            //  Convex\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_CONVEX;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.CONVEXpn)\n            {\n                this.signx = 1;\n                this.signy = -1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXnn)\n            {\n                this.signx = -1;\n                this.signy = -1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXnp)\n            {\n                this.signx = -1;\n                this.signy = 1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.CONVEXpp)\n            {\n                this.signx = 1;\n                this.signy = 1;\n                this.sx = 0;\n                this.sy = 0;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_22DEGb)\n        {\n            //  22deg small\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_22DEGs;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnS)\n            {\n                this.signx = 1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnS)\n            {\n                this.signx = -1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpS)\n            {\n                this.signx = -1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGppS)\n            {\n                this.signx = 1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_67DEGs)\n        {\n            //  22deg big\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_22DEGb;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGpnB)\n            {\n                this.signx = 1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnnB)\n            {\n                this.signx = -1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGnpB)\n            {\n                this.signx = -1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_22DEGppB)\n            {\n                this.signx = 1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 1) / slen;\n                this.sy = (this.signy * 2) / slen;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_67DEGb)\n        {\n            //  67deg small\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_67DEGs;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnS)\n            {\n                this.signx = 1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnS)\n            {\n                this.signx = -1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpS)\n            {\n                this.signx = -1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGppS)\n            {\n                this.signx = 1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (this.id < Phaser.Physics.Ninja.Tile.TYPE_HALF)\n        {\n            //  67deg big\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_67DEGb;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGpnB)\n            {\n                this.signx = 1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnnB)\n            {\n                this.signx = -1;\n                this.signy = -1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGnpB)\n            {\n                this.signx = -1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.SLOPE_67DEGppB)\n            {\n                this.signx = 1;\n                this.signy = 1;\n                var slen = Math.sqrt(2 * 2 + 1 * 1);\n                this.sx = (this.signx * 2) / slen;\n                this.sy = (this.signy * 1) / slen;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else\n        {\n            //  Half-full tile\n            this.type = Phaser.Physics.Ninja.Tile.TYPE_HALF;\n\n            if (this.id == Phaser.Physics.Ninja.Tile.HALFd)\n            {\n                this.signx = 0;\n                this.signy = -1;\n                this.sx = this.signx;\n                this.sy = this.signy;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.HALFu)\n            {\n                this.signx = 0;\n                this.signy = 1;\n                this.sx = this.signx;\n                this.sy = this.signy;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.HALFl)\n            {\n                this.signx = 1;\n                this.signy = 0;\n                this.sx = this.signx;\n                this.sy = this.signy;\n            }\n            else if (this.id == Phaser.Physics.Ninja.Tile.HALFr)\n            {\n                this.signx = -1;\n                this.signy = 0;\n                this.sx = this.signx;\n                this.sy = this.signy;\n            }\n            else\n            {\n                return false;\n            }\n        }\n    }\n\n};\n\n/**\n* @name Phaser.Physics.Ninja.Tile#x\n* @property {number} x - The x position.\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Tile.prototype, \"x\", {\n\n    get: function () {\n        return this.pos.x - this.xw;\n    },\n\n    set: function (value) {\n        this.pos.x = value;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Tile#y\n* @property {number} y - The y position.\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Tile.prototype, \"y\", {\n\n    get: function () {\n        return this.pos.y - this.yw;\n    },\n\n    set: function (value) {\n        this.pos.y = value;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Tile#bottom\n* @property {number} bottom - The bottom value of this Body (same as Body.y + Body.height)\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Tile.prototype, \"bottom\", {\n\n    get: function () {\n        return this.pos.y + this.yw;\n    }\n\n});\n\n/**\n* @name Phaser.Physics.Ninja.Tile#right\n* @property {number} right - The right value of this Body (same as Body.x + Body.width)\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.Ninja.Tile.prototype, \"right\", {\n\n    get: function () {\n        return this.pos.x + this.xw;\n    }\n\n});\n\nPhaser.Physics.Ninja.Tile.EMPTY = 0;\nPhaser.Physics.Ninja.Tile.FULL = 1;//fullAABB tile\nPhaser.Physics.Ninja.Tile.SLOPE_45DEGpn = 2;//45-degree triangle, whose normal is (+ve,-ve)\nPhaser.Physics.Ninja.Tile.SLOPE_45DEGnn = 3;//(+ve,+ve)\nPhaser.Physics.Ninja.Tile.SLOPE_45DEGnp = 4;//(-ve,+ve)\nPhaser.Physics.Ninja.Tile.SLOPE_45DEGpp = 5;//(-ve,-ve)\nPhaser.Physics.Ninja.Tile.CONCAVEpn = 6;//1/4-circle cutout\nPhaser.Physics.Ninja.Tile.CONCAVEnn = 7;\nPhaser.Physics.Ninja.Tile.CONCAVEnp = 8;\nPhaser.Physics.Ninja.Tile.CONCAVEpp = 9;\nPhaser.Physics.Ninja.Tile.CONVEXpn = 10;//1/4/circle\nPhaser.Physics.Ninja.Tile.CONVEXnn = 11;\nPhaser.Physics.Ninja.Tile.CONVEXnp = 12;\nPhaser.Physics.Ninja.Tile.CONVEXpp = 13;\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGpnS = 14;//22.5 degree slope\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGnnS = 15;\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGnpS = 16;\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGppS = 17;\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGpnB = 18;\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGnnB = 19;\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGnpB = 20;\nPhaser.Physics.Ninja.Tile.SLOPE_22DEGppB = 21;\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGpnS = 22;//67.5 degree slope\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGnnS = 23;\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGnpS = 24;\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGppS = 25;\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGpnB = 26;\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGnnB = 27;\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGnpB = 28;\nPhaser.Physics.Ninja.Tile.SLOPE_67DEGppB = 29;\nPhaser.Physics.Ninja.Tile.HALFd = 30;//half-full tiles\nPhaser.Physics.Ninja.Tile.HALFr = 31;\nPhaser.Physics.Ninja.Tile.HALFu = 32;\nPhaser.Physics.Ninja.Tile.HALFl = 33;\n\nPhaser.Physics.Ninja.Tile.TYPE_EMPTY = 0;\nPhaser.Physics.Ninja.Tile.TYPE_FULL = 1;\nPhaser.Physics.Ninja.Tile.TYPE_45DEG = 2;\nPhaser.Physics.Ninja.Tile.TYPE_CONCAVE = 6;\nPhaser.Physics.Ninja.Tile.TYPE_CONVEX = 10;\nPhaser.Physics.Ninja.Tile.TYPE_22DEGs = 14;\nPhaser.Physics.Ninja.Tile.TYPE_22DEGb = 18;\nPhaser.Physics.Ninja.Tile.TYPE_67DEGs = 22;\nPhaser.Physics.Ninja.Tile.TYPE_67DEGb = 26;\nPhaser.Physics.Ninja.Tile.TYPE_HALF = 30;\n\n/* jshint camelcase: false */\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Ninja Physics Circle constructor.\n* Note: This class could be massively optimised and reduced in size. I leave that challenge up to you.\n*\n* @class Phaser.Physics.Ninja.Circle\n* @classdesc Arcade Physics Constructor\n* @constructor\n* @param {Phaser.Physics.Ninja.Body} body - The body that owns this shape.\n* @param {number} x - The x coordinate to create this shape at.\n* @param {number} y - The y coordinate to create this shape at.\n* @param {number} radius - The radius of this Circle.\n*/\nPhaser.Physics.Ninja.Circle = function (body, x, y, radius) {\n\n    /**\n    * @property {Phaser.Physics.Ninja.Body} system - A reference to the body that owns this shape.\n    */\n    this.body = body;\n\n    /**\n    * @property {Phaser.Physics.Ninja} system - A reference to the physics system.\n    */\n    this.system = body.system;\n\n    /**\n    * @property {Phaser.Point} pos - The position of this object.\n    */\n    this.pos = new Phaser.Point(x, y);\n\n    /**\n    * @property {Phaser.Point} oldpos - The position of this object in the previous update.\n    */\n    this.oldpos = new Phaser.Point(x, y);\n\n    /**\n    * @property {number} radius - The radius of this circle shape.\n    */\n    this.radius = radius;\n\n    /**\n    * @property {number} xw - Half the width.\n    * @readonly\n    */\n    this.xw = radius;\n\n    /**\n    * @property {number} xw - Half the height.\n    * @readonly\n    */\n    this.yw = radius;\n\n    /**\n    * @property {number} width - The width.\n    * @readonly\n    */\n    this.width = radius * 2;\n\n    /**\n    * @property {number} height - The height.\n    * @readonly\n    */\n    this.height = radius * 2;\n\n    /**\n    * @property {number} oH - Internal var.\n    * @private\n    */\n    this.oH = 0;\n\n    /**\n    * @property {number} oV - Internal var.\n    * @private\n    */\n    this.oV = 0;\n\n    /**\n    * @property {Phaser.Point} velocity - The velocity of this object.\n    */\n    this.velocity = new Phaser.Point();\n\n    /**\n    * @property {object} circleTileProjections - All of the collision response handlers.\n    */\n    this.circleTileProjections = {};\n\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_FULL] = this.projCircle_Full;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_45DEG] = this.projCircle_45Deg;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONCAVE] = this.projCircle_Concave;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_CONVEX] = this.projCircle_Convex;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGs] = this.projCircle_22DegS;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_22DEGb] = this.projCircle_22DegB;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGs] = this.projCircle_67DegS;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_67DEGb] = this.projCircle_67DegB;\n    this.circleTileProjections[Phaser.Physics.Ninja.Tile.TYPE_HALF] = this.projCircle_Half;\n\n};\n\nPhaser.Physics.Ninja.Circle.prototype.constructor = Phaser.Physics.Ninja.Circle;\n\nPhaser.Physics.Ninja.Circle.COL_NONE = 0;\nPhaser.Physics.Ninja.Circle.COL_AXIS = 1;\nPhaser.Physics.Ninja.Circle.COL_OTHER = 2;\n\nPhaser.Physics.Ninja.Circle.prototype = {\n\n    /**\n    * Updates this Circles position.\n    *\n    * @method Phaser.Physics.Ninja.Circle#integrate\n    */\n    integrate: function () {\n\n        var px = this.pos.x;\n        var py = this.pos.y;\n\n        //  integrate\n        this.pos.x += (this.body.drag * this.pos.x) - (this.body.drag * this.oldpos.x);\n        this.pos.y += (this.body.drag * this.pos.y) - (this.body.drag * this.oldpos.y) + (this.system.gravity * this.body.gravityScale);\n\n        //  store\n        this.velocity.set(this.pos.x - px, this.pos.y - py);\n        this.oldpos.set(px, py);\n\n    },\n\n    /**\n    * Process a world collision and apply the resulting forces.\n    *\n    * @method Phaser.Physics.Ninja.Circle#reportCollisionVsWorld\n    * @param {number} px - The tangent velocity\n    * @param {number} py - The tangent velocity\n    * @param {number} dx - Collision normal\n    * @param {number} dy - Collision normal\n    * @param {number} obj - Object this Circle collided with\n    */\n    reportCollisionVsWorld: function (px, py, dx, dy) {\n\n        var p = this.pos;\n        var o = this.oldpos;\n\n        //  Calc velocity\n        var vx = p.x - o.x;\n        var vy = p.y - o.y;\n\n        //  Find component of velocity parallel to collision normal\n        var dp = (vx * dx + vy * dy);\n        var nx = dp * dx;   //project velocity onto collision normal\n\n        var ny = dp * dy;   //nx,ny is normal velocity\n\n        var tx = vx - nx;   //px,py is tangent velocity\n        var ty = vy - ny;\n\n        //  We only want to apply collision response forces if the object is travelling into, and not out of, the collision\n        var b, bx, by, fx, fy;\n\n        if (dp < 0)\n        {\n            fx = tx * this.body.friction;\n            fy = ty * this.body.friction;\n\n            b = 1 + this.body.bounce;\n\n            bx = (nx * b);\n            by = (ny * b);\n\n            if (dx === 1)\n            {\n                this.body.touching.left = true;\n            }\n            else if (dx === -1)\n            {\n                this.body.touching.right = true;\n            }\n\n            if (dy === 1)\n            {\n                this.body.touching.up = true;\n            }\n            else if (dy === -1)\n            {\n                this.body.touching.down = true;\n            }\n        }\n        else\n        {\n            //  Moving out of collision, do not apply forces\n            bx = by = fx = fy = 0;\n        }\n\n        //  Project object out of collision\n        p.x += px;\n        p.y += py;\n\n        //  Apply bounce+friction impulses which alter velocity\n        o.x += px + bx + fx;\n        o.y += py + by + fy;\n\n    },\n\n    /**\n    * Collides this Circle against the world bounds.\n    *\n    * @method Phaser.Physics.Ninja.Circle#collideWorldBounds\n    */\n    collideWorldBounds: function () {\n\n        var dx = this.system.bounds.x - (this.pos.x - this.radius);\n\n        if (0 < dx)\n        {\n            this.reportCollisionVsWorld(dx, 0, 1, 0, null);\n        }\n        else\n        {\n            dx = (this.pos.x + this.radius) - this.system.bounds.right;\n\n            if (0 < dx)\n            {\n                this.reportCollisionVsWorld(-dx, 0, -1, 0, null);\n            }\n        }\n\n        var dy = this.system.bounds.y - (this.pos.y - this.radius);\n\n        if (0 < dy)\n        {\n            this.reportCollisionVsWorld(0, dy, 0, 1, null);\n        }\n        else\n        {\n            dy = (this.pos.y + this.radius) - this.system.bounds.bottom;\n\n            if (0 < dy)\n            {\n                this.reportCollisionVsWorld(0, -dy, 0, -1, null);\n            }\n        }\n\n    },\n\n    /**\n    * Collides this Circle with a Tile.\n    *\n    * @method Phaser.Physics.Ninja.Circle#collideCircleVsTile\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {boolean} True if they collide, otherwise false.\n    */\n    collideCircleVsTile: function (tile) {\n\n        var pos = this.pos;\n        var r = this.radius;\n        var c = tile;\n\n        var tx = c.pos.x;\n        var ty = c.pos.y;\n        var txw = c.xw;\n        var tyw = c.yw;\n\n        var dx = pos.x - tx;    //  tile->obj delta\n        var px = (txw + r) - Math.abs(dx);  //  penetration depth in x\n\n        if (0 < px)\n        {\n            var dy = pos.y - ty;    //  tile->obj delta\n            var py = (tyw + r) - Math.abs(dy);  //  pen depth in y\n\n            if (0 < py)\n            {\n                //  object may be colliding with tile\n\n                //  determine grid/voronoi region of circle center\n                this.oH = 0;\n                this.oV = 0;\n\n                if (dx < -txw)\n                {\n                    //  circle is on left side of tile\n                    this.oH = -1;\n                }\n                else if (txw < dx)\n                {\n                    //  circle is on right side of tile\n                    this.oH = 1;\n                }\n\n                if (dy < -tyw)\n                {\n                    //  circle is on top side of tile\n                    this.oV = -1;\n                }\n                else if (tyw < dy)\n                {\n                    //  circle is on bottom side of tile\n                    this.oV = 1;\n                }\n\n                return this.resolveCircleTile(px, py, this.oH, this.oV, this, c);\n\n            }\n        }\n    },\n\n    /**\n    * Resolves tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#resolveCircleTile\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    resolveCircleTile: function (x, y, oH, oV, obj, t) {\n\n        if (0 < t.id)\n        {\n            return this.circleTileProjections[t.type](x, y, oH, oV, obj, t);\n        }\n        else\n        {\n            // console.log(\"ResolveCircleTile() was called with an empty (or unknown) tile!: ID=\" + t.id + \")\");\n            return false;\n        }\n\n    },\n\n    /**\n    * Resolves Full tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_Full\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_Full: function (x, y, oH, oV, obj, t) {\n\n        //if we're colliding vs. the current cell, we need to project along the\n        //smallest penetration vector.\n        //if we're colliding vs. horiz. or vert. neighb, we simply project horiz/vert\n        //if we're colliding diagonally, we need to collide vs. tile corner\n\n        if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //collision with current cell\n                if (x < y)\n                {\n                    //penetration in x is smaller; project in x\n                    var dx = obj.pos.x - t.pos.x;//get sign for projection along x-axis\n\n                    //NOTE: should we handle the delta === 0 case?! and how? (project towards oldpos?)\n                    if (dx < 0)\n                    {\n                        obj.reportCollisionVsWorld(-x, 0, -1, 0, t);\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(x, 0, 1, 0, t);\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                }\n                else\n                {\n                    //penetration in y is smaller; project in y\n                    var dy = obj.pos.y - t.pos.y;//get sign for projection along y-axis\n\n                    //NOTE: should we handle the delta === 0 case?! and how? (project towards oldpos?)\n                    if (dy < 0)\n                    {\n                        obj.reportCollisionVsWorld(0, -y, 0, -1, t);\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(0, y, 0, 1, t);\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                }\n            }\n            else\n            {\n                //collision with vertical neighbor\n                obj.reportCollisionVsWorld(0, y * oV, 0, oV, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n        }\n        else if (oV === 0)\n        {\n            //collision with horizontal neighbor\n            obj.reportCollisionVsWorld(x * oH, 0, oH, 0, t);\n            return Phaser.Physics.Ninja.Circle.COL_AXIS;\n        }\n        else\n        {\n            //diagonal collision\n\n            //get diag vertex position\n            var vx = t.pos.x + (oH * t.xw);\n            var vy = t.pos.y + (oV * t.yw);\n\n            var dx = obj.pos.x - vx;//calc vert->circle vector\n            var dy = obj.pos.y - vy;\n\n            var len = Math.sqrt(dx * dx + dy * dy);\n            var pen = obj.radius - len;\n\n            if (0 < pen)\n            {\n                //vertex is in the circle; project outward\n                if (len === 0)\n                {\n                    //project out by 45deg\n                    dx = oH / Math.SQRT2;\n                    dy = oV / Math.SQRT2;\n                }\n                else\n                {\n                    dx /= len;\n                    dy /= len;\n                }\n\n                obj.reportCollisionVsWorld(dx * pen, dy * pen, dx, dy, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_OTHER;\n            }\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n\n    },\n\n    /**\n    * Resolves 45 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_45Deg\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_45Deg: function (x, y, oH, oV, obj, t) {\n\n        //if we're colliding diagonally:\n        //  -if obj is in the diagonal pointed to by the slope normal: we can't collide, do nothing\n        //  -else, collide vs. the appropriate vertex\n        //if obj is in this tile: perform collision as for aabb-ve-45deg\n        //if obj is horiz OR very neighb in direction of slope: collide only vs. slope\n        //if obj is horiz or vert neigh against direction of slope: collide vs. face\n\n        var signx = t.signx;\n        var signy = t.signy;\n        var lenP;\n\n        if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current tile\n\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var ox = (obj.pos.x - (sx * obj.radius)) - t.pos.x;//this gives is the coordinates of the innermost\n                var oy = (obj.pos.y - (sy * obj.radius)) - t.pos.y;//point on the circle, relative to the tile center\n\n                //if the dotprod of (ox,oy) and (sx,sy) is negative, the innermost point is in the slope\n                //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                var dp = (ox * sx) + (oy * sy);\n\n                if (dp < 0)\n                {\n                    //collision; project delta onto slope and use this as the slope penetration vector\n                    sx *= -dp;//(sx,sy) is now the penetration vector\n                    sy *= -dp;\n\n                    //find the smallest axial projection vector\n                    if (x < y)\n                    {\n                        //penetration in x is smaller\n                        lenP = x;\n                        y = 0;\n\n                        //get sign for projection along x-axis\n                        if ((obj.pos.x - t.pos.x) < 0)\n                        {\n                            x *= -1;\n                        }\n                    }\n                    else\n                    {\n                        //penetration in y is smaller\n                        lenP = y;\n                        x = 0;\n\n                        //get sign for projection along y-axis\n                        if ((obj.pos.y - t.pos.y) < 0)\n                        {\n                            y *= -1;\n                        }\n                    }\n\n                    var lenN = Math.sqrt(sx * sx + sy * sy);\n\n                    if (lenP < lenN)\n                    {\n                        obj.reportCollisionVsWorld(x, y, x / lenP, y / lenP, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(sx, sy, t.sx, t.sy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n\n            }\n            else\n            {\n                //colliding vertically\n                if ((signy * oV) < 0)\n                {\n                    //colliding with face/edge\n                    obj.reportCollisionVsWorld(0, y * oV, 0, oV, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //we could only be colliding vs the slope OR a vertex\n                    //look at the vector form the closest vert to the circle to decide\n\n                    var sx = t.sx;\n                    var sy = t.sy;\n\n                    var ox = obj.pos.x - (t.pos.x - (signx * t.xw));//this gives is the coordinates of the innermost\n                    var oy = obj.pos.y - (t.pos.y + (oV * t.yw));//point on the circle, relative to the closest tile vert\n\n                    //if the component of (ox,oy) parallel to the normal's righthand normal\n                    //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                    //then we project by the vertex, otherwise by the normal.\n                    //note that this is simply a VERY tricky/weird method of determining\n                    //if the circle is in side the slope/face's voronoi region, or that of the vertex.\n                    var perp = (ox * -sy) + (oy * sx);\n                    if (0 < (perp * signx * signy))\n                    {\n                        //collide vs. vertex\n                        var len = Math.sqrt(ox * ox + oy * oy);\n                        var pen = obj.radius - len;\n                        if (0 < pen)\n                        {\n                            //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                            ox /= len;\n                            oy /= len;\n\n                            obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                    else\n                    {\n                        //collide vs. slope\n\n                        //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                        //penetrating the slope. note that this method of penetration calculation doesn't hold\n                        //in general (i.e it won't work if the circle is in the slope), but works in this case\n                        //because we know the circle is in a neighboring cell\n                        var dp = (ox * sx) + (oy * sy);\n                        var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n                        if (0 < pen)\n                        {\n                            //collision; circle out along normal by penetration amount\n                            obj.reportCollisionVsWorld(sx * pen, sy * pen, sx, sy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                }\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally\n            if ((signx * oH) < 0)\n            {\n                //colliding with face/edge\n                obj.reportCollisionVsWorld(x * oH, 0, oH, 0, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n            else\n            {\n                //we could only be colliding vs the slope OR a vertex\n                //look at the vector form the closest vert to the circle to decide\n\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var ox = obj.pos.x - (t.pos.x + (oH * t.xw));//this gives is the coordinates of the innermost\n                var oy = obj.pos.y - (t.pos.y - (signy * t.yw));//point on the circle, relative to the closest tile vert\n\n                //if the component of (ox,oy) parallel to the normal's righthand normal\n                //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                //then we project by the normal, otherwise by the vertex.\n                //(NOTE: this is the opposite logic of the vertical case;\n                // for vertical, if the perp prod and the slope's slope agree, it's outside.\n                // for horizontal, if the perp prod and the slope's slope agree, circle is inside.\n                //  ..but this is only a property of flahs' coord system (i.e the rules might swap\n                // in righthanded systems))\n                //note that this is simply a VERY tricky/weird method of determining\n                //if the circle is in side the slope/face's voronio region, or that of the vertex.\n                var perp = (ox * -sy) + (oy * sx);\n                if ((perp * signx * signy) < 0)\n                {\n                    //collide vs. vertex\n                    var len = Math.sqrt(ox * ox + oy * oy);\n                    var pen = obj.radius - len;\n                    if (0 < pen)\n                    {\n                        //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n                else\n                {\n                    //collide vs. slope\n\n                    //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                    //penetrating the slope. note that this method of penetration calculation doesn't hold\n                    //in general (i.e it won't work if the circle is in the slope), but works in this case\n                    //because we know the circle is in a neighboring cell\n                    var dp = (ox * sx) + (oy * sy);\n                    var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n                    if (0 < pen)\n                    {\n                        //collision; circle out along normal by penetration amount\n                        obj.reportCollisionVsWorld(sx * pen, sy * pen, sx, sy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n            }\n        }\n        else\n        {\n            //colliding diagonally\n            if (0 < ((signx * oH) + (signy * oV)))\n            {\n                //the dotprod of slope normal and cell offset is strictly positive,\n                //therefore obj is in the diagonal neighb pointed at by the normal, and\n                //it cannot possibly reach/touch/penetrate the slope\n                return Phaser.Physics.Ninja.Circle.COL_NONE;\n            }\n            else\n            {\n                //collide vs. vertex\n                //get diag vertex position\n                var vx = t.pos.x + (oH * t.xw);\n                var vy = t.pos.y + (oV * t.yw);\n\n                var dx = obj.pos.x - vx;//calc vert->circle vector\n                var dy = obj.pos.y - vy;\n\n                var len = Math.sqrt(dx * dx + dy * dy);\n                var pen = obj.radius - len;\n                if (0 < pen)\n                {\n                    //vertex is in the circle; project outward\n                    if (len === 0)\n                    {\n                        //project out by 45deg\n                        dx = oH / Math.SQRT2;\n                        dy = oV / Math.SQRT2;\n                    }\n                    else\n                    {\n                        dx /= len;\n                        dy /= len;\n                    }\n\n                    obj.reportCollisionVsWorld(dx * pen, dy * pen, dx, dy, t);\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n\n            }\n\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n    },\n\n    /**\n    * Resolves Concave tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_Concave\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_Concave: function (x, y, oH, oV, obj, t) {\n\n        //if we're colliding diagonally:\n        //  -if obj is in the diagonal pointed to by the slope normal: we can't collide, do nothing\n        //  -else, collide vs. the appropriate vertex\n        //if obj is in this tile: perform collision as for aabb\n        //if obj is horiz OR very neighb in direction of slope: collide vs vert\n        //if obj is horiz or vert neigh against direction of slope: collide vs. face\n\n        var signx = t.signx;\n        var signy = t.signy;\n        var lenP;\n\n        if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current tile\n\n                var ox = (t.pos.x + (signx * t.xw)) - obj.pos.x;//(ox,oy) is the vector from the circle to\n                var oy = (t.pos.y + (signy * t.yw)) - obj.pos.y;//tile-circle's center\n\n                var twid = t.xw * 2;\n                var trad = Math.sqrt(twid * twid + 0);//this gives us the radius of a circle centered on the tile's corner and extending to the opposite edge of the tile;\n                //note that this should be precomputed at compile-time since it's constant\n\n                var len = Math.sqrt(ox * ox + oy * oy);\n                var pen = (len + obj.radius) - trad;\n\n                if (0 < pen)\n                {\n                    //find the smallest axial projection vector\n                    if (x < y)\n                    {\n                        //penetration in x is smaller\n                        lenP = x;\n                        y = 0;\n\n                        //get sign for projection along x-axis\n                        if ((obj.pos.x - t.pos.x) < 0)\n                        {\n                            x *= -1;\n                        }\n                    }\n                    else\n                    {\n                        //penetration in y is smaller\n                        lenP = y;\n                        x = 0;\n\n                        //get sign for projection along y-axis\n                        if ((obj.pos.y - t.pos.y) < 0)\n                        {\n                            y *= -1;\n                        }\n                    }\n\n\n                    if (lenP < pen)\n                    {\n                        obj.reportCollisionVsWorld(x, y, x / lenP, y / lenP, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        //we can assume that len >0, because if we're here then\n                        //(len + obj.radius) > trad, and since obj.radius <= trad\n                        //len MUST be > 0\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n                else\n                {\n                    return Phaser.Physics.Ninja.Circle.COL_NONE;\n                }\n\n            }\n            else\n            {\n                //colliding vertically\n                if ((signy * oV) < 0)\n                {\n                    //colliding with face/edge\n                    obj.reportCollisionVsWorld(0, y * oV, 0, oV, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //we could only be colliding vs the vertical tip\n\n                    //get diag vertex position\n                    var vx = t.pos.x - (signx * t.xw);\n                    var vy = t.pos.y + (oV * t.yw);\n\n                    var dx = obj.pos.x - vx;//calc vert->circle vector\n                    var dy = obj.pos.y - vy;\n\n                    var len = Math.sqrt(dx * dx + dy * dy);\n                    var pen = obj.radius - len;\n                    if (0 < pen)\n                    {\n                        //vertex is in the circle; project outward\n                        if (len === 0)\n                        {\n                            //project out vertically\n                            dx = 0;\n                            dy = oV;\n                        }\n                        else\n                        {\n                            dx /= len;\n                            dy /= len;\n                        }\n\n                        obj.reportCollisionVsWorld(dx * pen, dy * pen, dx, dy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally\n            if ((signx * oH) < 0)\n            {\n                //colliding with face/edge\n                obj.reportCollisionVsWorld(x * oH, 0, oH, 0, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n            else\n            {\n                //we could only be colliding vs the horizontal tip\n\n                //get diag vertex position\n                var vx = t.pos.x + (oH * t.xw);\n                var vy = t.pos.y - (signy * t.yw);\n\n                var dx = obj.pos.x - vx;//calc vert->circle vector\n                var dy = obj.pos.y - vy;\n\n                var len = Math.sqrt(dx * dx + dy * dy);\n                var pen = obj.radius - len;\n                if (0 < pen)\n                {\n                    //vertex is in the circle; project outward\n                    if (len === 0)\n                    {\n                        //project out horizontally\n                        dx = oH;\n                        dy = 0;\n                    }\n                    else\n                    {\n                        dx /= len;\n                        dy /= len;\n                    }\n\n                    obj.reportCollisionVsWorld(dx * pen, dy * pen, dx, dy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n            }\n        }\n        else\n        {\n            //colliding diagonally\n            if (0 < ((signx * oH) + (signy * oV)))\n            {\n                //the dotprod of slope normal and cell offset is strictly positive,\n                //therefore obj is in the diagonal neighb pointed at by the normal, and\n                //it cannot possibly reach/touch/penetrate the slope\n                return Phaser.Physics.Ninja.Circle.COL_NONE;\n            }\n            else\n            {\n                //collide vs. vertex\n                //get diag vertex position\n                var vx = t.pos.x + (oH * t.xw);\n                var vy = t.pos.y + (oV * t.yw);\n\n                var dx = obj.pos.x - vx;//calc vert->circle vector\n                var dy = obj.pos.y - vy;\n\n                var len = Math.sqrt(dx * dx + dy * dy);\n                var pen = obj.radius - len;\n                if (0 < pen)\n                {\n                    //vertex is in the circle; project outward\n                    if (len === 0)\n                    {\n                        //project out by 45deg\n                        dx = oH / Math.SQRT2;\n                        dy = oV / Math.SQRT2;\n                    }\n                    else\n                    {\n                        dx /= len;\n                        dy /= len;\n                    }\n\n                    obj.reportCollisionVsWorld(dx * pen, dy * pen, dx, dy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n\n            }\n\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n\n    },\n\n    /**\n    * Resolves Convex tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_Convex\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_Convex: function (x, y, oH, oV, obj, t) {\n\n        //if the object is horiz AND/OR vertical neighbor in the normal (signx,signy)\n        //direction, collide vs. tile-circle only.\n        //if we're colliding diagonally:\n        //  -else, collide vs. the appropriate vertex\n        //if obj is in this tile: perform collision as for aabb\n        //if obj is horiz or vert neigh against direction of slope: collide vs. face\n\n        var signx = t.signx;\n        var signy = t.signy;\n        var lenP;\n\n        if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current tile\n\n\n                var ox = obj.pos.x - (t.pos.x - (signx * t.xw));//(ox,oy) is the vector from the tile-circle to\n                var oy = obj.pos.y - (t.pos.y - (signy * t.yw));//the circle's center\n\n                var twid = t.xw * 2;\n                var trad = Math.sqrt(twid * twid + 0);//this gives us the radius of a circle centered on the tile's corner and extending to the opposite edge of the tile;\n                //note that this should be precomputed at compile-time since it's constant\n\n                var len = Math.sqrt(ox * ox + oy * oy);\n                var pen = (trad + obj.radius) - len;\n\n                if (0 < pen)\n                {\n                    //find the smallest axial projection vector\n                    if (x < y)\n                    {\n                        //penetration in x is smaller\n                        lenP = x;\n                        y = 0;\n\n                        //get sign for projection along x-axis\n                        if ((obj.pos.x - t.pos.x) < 0)\n                        {\n                            x *= -1;\n                        }\n                    }\n                    else\n                    {\n                        //penetration in y is smaller\n                        lenP = y;\n                        x = 0;\n\n                        //get sign for projection along y-axis\n                        if ((obj.pos.y - t.pos.y) < 0)\n                        {\n                            y *= -1;\n                        }\n                    }\n\n\n                    if (lenP < pen)\n                    {\n                        obj.reportCollisionVsWorld(x, y, x / lenP, y / lenP, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        //note: len should NEVER be === 0, because if it is,\n                        //projeciton by an axis shoudl always be shorter, and we should\n                        //never arrive here\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n\n                    }\n                }\n            }\n            else\n            {\n                //colliding vertically\n                if ((signy * oV) < 0)\n                {\n                    //colliding with face/edge\n                    obj.reportCollisionVsWorld(0, y * oV, 0, oV, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //obj in neighboring cell pointed at by tile normal;\n                    //we could only be colliding vs the tile-circle surface\n\n                    var ox = obj.pos.x - (t.pos.x - (signx * t.xw));//(ox,oy) is the vector from the tile-circle to\n                    var oy = obj.pos.y - (t.pos.y - (signy * t.yw));//the circle's center\n\n                    var twid = t.xw * 2;\n                    var trad = Math.sqrt(twid * twid + 0);//this gives us the radius of a circle centered on the tile's corner and extending to the opposite edge of the tile;\n                    //note that this should be precomputed at compile-time since it's constant\n\n                    var len = Math.sqrt(ox * ox + oy * oy);\n                    var pen = (trad + obj.radius) - len;\n\n                    if (0 < pen)\n                    {\n\n                        //note: len should NEVER be === 0, because if it is,\n                        //obj is not in a neighboring cell!\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally\n            if ((signx * oH) < 0)\n            {\n                //colliding with face/edge\n                obj.reportCollisionVsWorld(x * oH, 0, oH, 0, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n            else\n            {\n                //obj in neighboring cell pointed at by tile normal;\n                //we could only be colliding vs the tile-circle surface\n\n                var ox = obj.pos.x - (t.pos.x - (signx * t.xw));//(ox,oy) is the vector from the tile-circle to\n                var oy = obj.pos.y - (t.pos.y - (signy * t.yw));//the circle's center\n\n                var twid = t.xw * 2;\n                var trad = Math.sqrt(twid * twid + 0);//this gives us the radius of a circle centered on the tile's corner and extending to the opposite edge of the tile;\n                //note that this should be precomputed at compile-time since it's constant\n\n                var len = Math.sqrt(ox * ox + oy * oy);\n                var pen = (trad + obj.radius) - len;\n\n                if (0 < pen)\n                {\n\n                    //note: len should NEVER be === 0, because if it is,\n                    //obj is not in a neighboring cell!\n                    ox /= len;\n                    oy /= len;\n\n                    obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n            }\n        }\n        else\n        {\n            //colliding diagonally\n            if (0 < ((signx * oH) + (signy * oV)))\n            {\n                //obj in diag neighb cell pointed at by tile normal;\n                //we could only be colliding vs the tile-circle surface\n\n                var ox = obj.pos.x - (t.pos.x - (signx * t.xw));//(ox,oy) is the vector from the tile-circle to\n                var oy = obj.pos.y - (t.pos.y - (signy * t.yw));//the circle's center\n\n                var twid = t.xw * 2;\n                var trad = Math.sqrt(twid * twid + 0);//this gives us the radius of a circle centered on the tile's corner and extending to the opposite edge of the tile;\n                //note that this should be precomputed at compile-time since it's constant\n\n                var len = Math.sqrt(ox * ox + oy * oy);\n                var pen = (trad + obj.radius) - len;\n\n                if (0 < pen)\n                {\n\n                    //note: len should NEVER be === 0, because if it is,\n                    //obj is not in a neighboring cell!\n                    ox /= len;\n                    oy /= len;\n\n                    obj.reportCollisionVsWorld(ox * pen, oy * pen, ox, oy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n            }\n            else\n            {\n                //collide vs. vertex\n                //get diag vertex position\n                var vx = t.pos.x + (oH * t.xw);\n                var vy = t.pos.y + (oV * t.yw);\n\n                var dx = obj.pos.x - vx;//calc vert->circle vector\n                var dy = obj.pos.y - vy;\n\n                var len = Math.sqrt(dx * dx + dy * dy);\n                var pen = obj.radius - len;\n                if (0 < pen)\n                {\n                    //vertex is in the circle; project outward\n                    if (len === 0)\n                    {\n                        //project out by 45deg\n                        dx = oH / Math.SQRT2;\n                        dy = oV / Math.SQRT2;\n                    }\n                    else\n                    {\n                        dx /= len;\n                        dy /= len;\n                    }\n\n                    obj.reportCollisionVsWorld(dx * pen, dy * pen, dx, dy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n\n            }\n\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n\n    },\n\n    /**\n    * Resolves Half tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_Half\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_Half: function (x,y,oH,oV,obj,t) {\n\n        //if obj is in a neighbor pointed at by the halfedge normal,\n        //we'll never collide (i.e if the normal is (0,1) and the obj is in the DL.D, or R neighbors)\n        //\n        //if obj is in a neigbor perpendicular to the halfedge normal, it might\n        //collide with the halfedge-vertex, or with the halfedge side.\n        //\n        //if obj is in a neigb pointing opposite the halfedge normal, obj collides with edge\n        //\n        //if obj is in a diagonal (pointing away from the normal), obj collides vs vertex\n        //\n        //if obj is in the halfedge cell, it collides as with aabb\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        var celldp = (oH*signx + oV*signy);//this tells us about the configuration of cell-offset relative to tile normal\n        if (0 < celldp)\n        {\n            //obj is in \"far\" (pointed-at-by-normal) neighbor of halffull tile, and will never hit\n            return Phaser.Physics.Ninja.Circle.COL_NONE;\n        }\n        else if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current tile\n                var r = obj.radius;\n                var ox = (obj.pos.x - (signx*r)) - t.pos.x;//this gives is the coordinates of the innermost\n                var oy = (obj.pos.y - (signy*r)) - t.pos.y;//point on the circle, relative to the tile center\n\n\n                //we perform operations analogous to the 45deg tile, except we're using\n                //an axis-aligned slope instead of an angled one..\n                var sx = signx;\n                var sy = signy;\n\n                //if the dotprod of (ox,oy) and (sx,sy) is negative, the corner is in the slope\n                //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                var dp = (ox*sx) + (oy*sy);\n                if (dp < 0)\n                {\n                    //collision; project delta onto slope and use this to displace the object\n                    sx *= -dp;//(sx,sy) is now the projection vector\n                    sy *= -dp;\n\n\n                    var lenN = Math.sqrt(sx*sx + sy*sy);\n                    var lenP = Math.sqrt(x*x + y*y);\n\n                    if (lenP < lenN)\n                    {\n                        obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP,t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(sx,sy,t.signx,t.signy);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                    return true;\n                }\n\n            }\n            else\n            {\n                //colliding vertically\n\n                if (celldp === 0)\n                {\n\n                    var dx = obj.pos.x - t.pos.x;\n\n                    //we're in a cell perpendicular to the normal, and can collide vs. halfedge vertex\n                    //or halfedge side\n                    if ((dx*signx) < 0)\n                    {\n                        //collision with halfedge side\n                        obj.reportCollisionVsWorld(0,y*oV,0,oV,t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        //collision with halfedge vertex\n                        var dy = obj.pos.y - (t.pos.y + oV*t.yw);//(dx,dy) is now the vector from the appropriate halfedge vertex to the circle\n\n                        var len = Math.sqrt(dx*dx + dy*dy);\n                        var pen = obj.radius - len;\n                        if (0 < pen)\n                        {\n                            //vertex is in the circle; project outward\n                            if (len === 0)\n                            {\n                                //project out by 45deg\n                                dx = signx / Math.SQRT2;\n                                dy = oV / Math.SQRT2;\n                            }\n                            else\n                            {\n                                dx /= len;\n                                dy /= len;\n                            }\n\n                            obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n\n                    }\n                }\n                else\n                {\n                    //due to the first conditional (celldp >0), we know we're in the cell \"opposite\" the normal, and so\n                    //we can only collide with the cell edge\n                    //collision with vertical neighbor\n                    obj.reportCollisionVsWorld(0,y*oV,0,oV,t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally\n            if (celldp === 0)\n            {\n\n                var dy = obj.pos.y - t.pos.y;\n\n                //we're in a cell perpendicular to the normal, and can collide vs. halfedge vertex\n                //or halfedge side\n                if ((dy*signy) < 0)\n                {\n                    //collision with halfedge side\n                    obj.reportCollisionVsWorld(x*oH,0,oH,0,t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //collision with halfedge vertex\n                    var dx = obj.pos.x - (t.pos.x + oH*t.xw);//(dx,dy) is now the vector from the appropriate halfedge vertex to the circle\n\n                    var len = Math.sqrt(dx*dx + dy*dy);\n                    var pen = obj.radius - len;\n                    if (0 < pen)\n                    {\n                        //vertex is in the circle; project outward\n                        if (len === 0)\n                        {\n                            //project out by 45deg\n                            dx = signx / Math.SQRT2;\n                            dy = oV / Math.SQRT2;\n                        }\n                        else\n                        {\n                            dx /= len;\n                            dy /= len;\n                        }\n\n                        obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n\n                }\n            }\n            else\n            {\n                //due to the first conditional (celldp >0), we know w're in the cell \"opposite\" the normal, and so\n                //we can only collide with the cell edge\n                obj.reportCollisionVsWorld(x*oH, 0, oH, 0, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n        }\n        else\n        {\n            //colliding diagonally; we know, due to the initial (celldp >0) test which has failed\n            //if we've reached this point, that we're in a diagonal neighbor on the non-normal side, so\n            //we could only be colliding with the cell vertex, if at all.\n\n            //get diag vertex position\n            var vx = t.pos.x + (oH*t.xw);\n            var vy = t.pos.y + (oV*t.yw);\n\n            var dx = obj.pos.x - vx;//calc vert->circle vector\n            var dy = obj.pos.y - vy;\n\n            var len = Math.sqrt(dx*dx + dy*dy);\n            var pen = obj.radius - len;\n            if (0 < pen)\n            {\n                //vertex is in the circle; project outward\n                if (len === 0)\n                {\n                    //project out by 45deg\n                    dx = oH / Math.SQRT2;\n                    dy = oV / Math.SQRT2;\n                }\n                else\n                {\n                    dx /= len;\n                    dy /= len;\n                }\n\n                obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_OTHER;\n            }\n\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n\n    },\n\n    /**\n    * Resolves 22 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_22DegS\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_22DegS: function (x,y,oH,oV,obj,t) {\n\n        //if the object is in a cell pointed at by signy, no collision will ever occur\n        //otherwise,\n        //\n        //if we're colliding diagonally:\n        //  -collide vs. the appropriate vertex\n        //if obj is in this tile: collide vs slope or vertex\n        //if obj is horiz neighb in direction of slope: collide vs. slope or vertex\n        //if obj is horiz neighb against the slope:\n        //   if (distance in y from circle to 90deg corner of tile < 1/2 tileheight, collide vs. face)\n        //   else(collide vs. corner of slope) (vert collision with a non-grid-aligned vert)\n        //if obj is vert neighb against direction of slope: collide vs. face\n\n        var lenP;\n        var signx = t.signx;\n        var signy = t.signy;\n\n        if (0 < (signy*oV))\n        {\n            //object will never collide vs tile, it can't reach that far\n\n            return Phaser.Physics.Ninja.Circle.COL_NONE;\n        }\n        else if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current tile\n                //we could only be colliding vs the slope OR a vertex\n                //look at the vector form the closest vert to the circle to decide\n\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var r = obj.radius;\n                var ox = obj.pos.x - (t.pos.x - (signx*t.xw));//this gives is the coordinates of the innermost\n                var oy = obj.pos.y - t.pos.y;//point on the circle, relative to the tile corner\n\n                //if the component of (ox,oy) parallel to the normal's righthand normal\n                //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                //then we project by the vertex, otherwise by the normal or axially.\n                //note that this is simply a VERY tricky/weird method of determining\n                //if the circle is in side the slope/face's voronio region, or that of the vertex.\n\n                var perp = (ox*-sy) + (oy*sx);\n                if (0 < (perp*signx*signy))\n                {\n                    //collide vs. vertex\n                    var len = Math.sqrt(ox*ox + oy*oy);\n                    var pen = r - len;\n                    if (0 < pen)\n                    {\n                        //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n                else\n                {\n                    //collide vs. slope or vs axis\n                    ox -= r*sx;//this gives us the vector from\n                    oy -= r*sy;//a point on the slope to the innermost point on the circle\n\n                    //if the dotprod of (ox,oy) and (sx,sy) is negative, the point on the circle is in the slope\n                    //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                    var dp = (ox*sx) + (oy*sy);\n\n                    if (dp < 0)\n                    {\n                        //collision; project delta onto slope and use this to displace the object\n                        sx *= -dp;//(sx,sy) is now the projection vector\n                        sy *= -dp;\n\n                        var lenN = Math.sqrt(sx*sx + sy*sy);\n\n                        //find the smallest axial projection vector\n                        if (x < y)\n                        {\n                            //penetration in x is smaller\n                            lenP = x;\n                            y = 0;\n                            //get sign for projection along x-axis\n                            if ((obj.pos.x - t.pos.x) < 0)\n                            {\n                                x *= -1;\n                            }\n                        }\n                        else\n                        {\n                            //penetration in y is smaller\n                            lenP = y;\n                            x = 0;\n                            //get sign for projection along y-axis\n                            if ((obj.pos.y - t.pos.y)< 0)\n                            {\n                                y *= -1;\n                            }\n                        }\n\n                        if (lenP < lenN)\n                        {\n                            obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                        }\n                        else\n                        {\n                            obj.reportCollisionVsWorld(sx,sy,t.sx,t.sy,t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n\n                    }\n                }\n\n            }\n            else\n            {\n                //colliding vertically; we can assume that (signy*oV) < 0\n                //due to the first conditional far above\n\n                obj.reportCollisionVsWorld(0,y*oV, 0, oV, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally\n            if ((signx*oH) < 0)\n            {\n                //colliding with face/edge OR with corner of wedge, depending on our position vertically\n\n                //collide vs. vertex\n                //get diag vertex position\n                var vx = t.pos.x - (signx*t.xw);\n                var vy = t.pos.y;\n\n                var dx = obj.pos.x - vx;//calc vert->circle vector\n                var dy = obj.pos.y - vy;\n\n                if ((dy*signy) < 0)\n                {\n                    //colliding vs face\n                    obj.reportCollisionVsWorld(x*oH, 0, oH, 0, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //colliding vs. vertex\n\n                    var len = Math.sqrt(dx*dx + dy*dy);\n                    var pen = obj.radius - len;\n                    if (0 < pen)\n                    {\n                        //vertex is in the circle; project outward\n                        if (len === 0)\n                        {\n                            //project out by 45deg\n                            dx = oH / Math.SQRT2;\n                            dy = oV / Math.SQRT2;\n                        }\n                        else\n                        {\n                            dx /= len;\n                            dy /= len;\n                        }\n\n                        obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n            }\n            else\n            {\n                //we could only be colliding vs the slope OR a vertex\n                //look at the vector form the closest vert to the circle to decide\n\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var ox = obj.pos.x - (t.pos.x + (oH*t.xw));//this gives is the coordinates of the innermost\n                var oy = obj.pos.y - (t.pos.y - (signy*t.yw));//point on the circle, relative to the closest tile vert\n\n                //if the component of (ox,oy) parallel to the normal's righthand normal\n                //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                //then we project by the normal, otherwise by the vertex.\n                //(NOTE: this is the opposite logic of the vertical case;\n                // for vertical, if the perp prod and the slope's slope agree, it's outside.\n                // for horizontal, if the perp prod and the slope's slope agree, circle is inside.\n                //  ..but this is only a property of flahs' coord system (i.e the rules might swap\n                // in righthanded systems))\n                //note that this is simply a VERY tricky/weird method of determining\n                //if the circle is in side the slope/face's voronio region, or that of the vertex.\n                var perp = (ox*-sy) + (oy*sx);\n                if ((perp*signx*signy) < 0)\n                {\n                    //collide vs. vertex\n                    var len = Math.sqrt(ox*ox + oy*oy);\n                    var pen = obj.radius - len;\n                    if (0 < pen)\n                    {\n                        //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n                else\n                {\n                    //collide vs. slope\n\n                    //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                    //penetrating the slope. note that this method of penetration calculation doesn't hold\n                    //in general (i.e it won't work if the circle is in the slope), but works in this case\n                    //because we know the circle is in a neighboring cell\n                    var dp = (ox*sx) + (oy*sy);\n                    var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n\n                    if (0 < pen)\n                    {\n                        //collision; circle out along normal by penetration amount\n                        obj.reportCollisionVsWorld(sx*pen, sy*pen, sx, sy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n            }\n        }\n        else\n        {\n\n            //colliding diagonally; due to the first conditional above,\n            //obj is vertically offset against slope, and offset in either direction horizontally\n\n            //collide vs. vertex\n            //get diag vertex position\n            var vx = t.pos.x + (oH*t.xw);\n            var vy = t.pos.y + (oV*t.yw);\n\n            var dx = obj.pos.x - vx;//calc vert->circle vector\n            var dy = obj.pos.y - vy;\n\n            var len = Math.sqrt(dx*dx + dy*dy);\n            var pen = obj.radius - len;\n            if (0 < pen)\n            {\n                //vertex is in the circle; project outward\n                if (len === 0)\n                {\n                    //project out by 45deg\n                    dx = oH / Math.SQRT2;\n                    dy = oV / Math.SQRT2;\n                }\n                else\n                {\n                    dx /= len;\n                    dy /= len;\n                }\n\n                obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_OTHER;\n            }\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n\n    },\n\n    /**\n    * Resolves 22 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_22DegB\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_22DegB: function (x,y,oH, oV, obj,t) {\n\n        //if we're colliding diagonally:\n        //  -if we're in the cell pointed at by the normal, collide vs slope, else\n        //  collide vs. the appropriate corner/vertex\n        //\n        //if obj is in this tile: collide as with aabb\n        //\n        //if obj is horiz or vertical neighbor AGAINST the slope: collide with edge\n        //\n        //if obj is horiz neighb in direction of slope: collide vs. slope or vertex or edge\n        //\n        //if obj is vert neighb in direction of slope: collide vs. slope or vertex\n\n        var lenP;\n        var signx = t.signx;\n        var signy = t.signy;\n\n        if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current cell\n\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var r = obj.radius;\n                var ox = (obj.pos.x - (sx*r)) - (t.pos.x - (signx*t.xw));//this gives is the coordinates of the innermost\n                var oy = (obj.pos.y - (sy*r)) - (t.pos.y + (signy*t.yw));//point on the AABB, relative to a point on the slope\n\n                //if the dotprod of (ox,oy) and (sx,sy) is negative, the point on the circle is in the slope\n                //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                var dp = (ox*sx) + (oy*sy);\n\n                if (dp < 0)\n                {\n                    //collision; project delta onto slope and use this to displace the object\n                    sx *= -dp;//(sx,sy) is now the projection vector\n                    sy *= -dp;\n\n                    var lenN = Math.sqrt(sx*sx + sy*sy);\n\n                    //find the smallest axial projection vector\n                    if (x < y)\n                    {\n                        //penetration in x is smaller\n                        lenP = x;\n                        y = 0;\n                        //get sign for projection along x-axis\n                        if ((obj.pos.x - t.pos.x) < 0)\n                        {\n                            x *= -1;\n                        }\n                    }\n                    else\n                    {\n                        //penetration in y is smaller\n                        lenP = y;\n                        x = 0;\n                        //get sign for projection along y-axis\n                        if ((obj.pos.y - t.pos.y)< 0)\n                        {\n                            y *= -1;\n                        }\n                    }\n\n                    if (lenP < lenN)\n                    {\n                        obj.reportCollisionVsWorld(x, y, x/lenP, y/lenP, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(sx, sy, t.sx, t.sy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n            }\n            else\n            {\n                //colliding vertically\n\n                if ((signy*oV) < 0)\n                {\n                    //colliding with face/edge\n                    obj.reportCollisionVsWorld(0, y*oV, 0, oV, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //we could only be colliding vs the slope OR a vertex\n                    //look at the vector form the closest vert to the circle to decide\n\n                    var sx = t.sx;\n                    var sy = t.sy;\n\n                    var ox = obj.pos.x - (t.pos.x - (signx*t.xw));//this gives is the coordinates of the innermost\n                    var oy = obj.pos.y - (t.pos.y + (signy*t.yw));//point on the circle, relative to the closest tile vert\n\n                    //if the component of (ox,oy) parallel to the normal's righthand normal\n                    //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                    //then we project by the vertex, otherwise by the normal.\n                    //note that this is simply a VERY tricky/weird method of determining\n                    //if the circle is in side the slope/face's voronio region, or that of the vertex.\n                    var perp = (ox*-sy) + (oy*sx);\n                    if (0 < (perp*signx*signy))\n                    {\n                        //collide vs. vertex\n                        var len = Math.sqrt(ox*ox + oy*oy);\n                        var pen = obj.radius - len;\n                        if (0 < pen)\n                        {\n                            //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                            ox /= len;\n                            oy /= len;\n\n                            obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                    else\n                    {\n                        //collide vs. slope\n\n                        //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                        //penetrating the slope. note that this method of penetration calculation doesn't hold\n                        //in general (i.e it won't work if the circle is in the slope), but works in this case\n                        //because we know the circle is in a neighboring cell\n                        var dp = (ox*sx) + (oy*sy);\n                        var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n                        if (0 < pen)\n                        {\n                            //collision; circle out along normal by penetration amount\n                            obj.reportCollisionVsWorld(sx*pen, sy*pen,sx, sy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                }\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally\n\n            if ((signx*oH) < 0)\n            {\n                //colliding with face/edge\n                obj.reportCollisionVsWorld(x*oH, 0, oH, 0, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n            else\n            {\n                //colliding with edge, slope, or vertex\n\n                var ox = obj.pos.x - (t.pos.x + (signx*t.xw));//this gives is the coordinates of the innermost\n                var oy = obj.pos.y - t.pos.y;//point on the circle, relative to the closest tile vert\n\n                if ((oy*signy) < 0)\n                {\n                    //we're colliding with the halfface\n                    obj.reportCollisionVsWorld(x*oH, 0, oH, 0, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //colliding with the vertex or slope\n\n                    var sx = t.sx;\n                    var sy = t.sy;\n\n                    //if the component of (ox,oy) parallel to the normal's righthand normal\n                    //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                    //then we project by the slope, otherwise by the vertex.\n                    //note that this is simply a VERY tricky/weird method of determining\n                    //if the circle is in side the slope/face's voronio region, or that of the vertex.\n                    var perp = (ox*-sy) + (oy*sx);\n                    if ((perp*signx*signy) < 0)\n                    {\n                        //collide vs. vertex\n                        var len = Math.sqrt(ox*ox + oy*oy);\n                        var pen = obj.radius - len;\n                        if (0 < pen)\n                        {\n                            //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                            ox /= len;\n                            oy /= len;\n\n                            obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                    else\n                    {\n                        //collide vs. slope\n\n                        //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                        //penetrating the slope. note that this method of penetration calculation doesn't hold\n                        //in general (i.e it won't work if the circle is in the slope), but works in this case\n                        //because we know the circle is in a neighboring cell\n                        var dp = (ox*sx) + (oy*sy);\n                        var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n                        if (0 < pen)\n                        {\n                            //collision; circle out along normal by penetration amount\n                            obj.reportCollisionVsWorld(sx*pen, sy*pen, t.sx, t.sy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            //colliding diagonally\n            if ( 0 < ((signx*oH) + (signy*oV)) )\n            {\n                //the dotprod of slope normal and cell offset is strictly positive,\n                //therefore obj is in the diagonal neighb pointed at by the normal.\n\n                //collide vs slope\n\n                //we should really precalc this at compile time, but for now, fuck it\n                var slen = Math.sqrt(2*2 + 1*1);//the raw slope is (-2,-1)\n                var sx = (signx*1) / slen;//get slope _unit_ normal;\n                var sy = (signy*2) / slen;//raw RH normal is (1,-2)\n\n                var r = obj.radius;\n                var ox = (obj.pos.x - (sx*r)) - (t.pos.x - (signx*t.xw));//this gives is the coordinates of the innermost\n                var oy = (obj.pos.y - (sy*r)) - (t.pos.y + (signy*t.yw));//point on the circle, relative to a point on the slope\n\n                //if the dotprod of (ox,oy) and (sx,sy) is negative, the point on the circle is in the slope\n                //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                var dp = (ox*sx) + (oy*sy);\n\n                if (dp < 0)\n                {\n                    //collision; project delta onto slope and use this to displace the object\n                    //(sx,sy)*-dp is the projection vector\n                    obj.reportCollisionVsWorld(-sx*dp, -sy*dp, t.sx, t.sy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n                return Phaser.Physics.Ninja.Circle.COL_NONE;\n            }\n            else\n            {\n                //collide vs the appropriate vertex\n                var vx = t.pos.x + (oH*t.xw);\n                var vy = t.pos.y + (oV*t.yw);\n\n                var dx = obj.pos.x - vx;//calc vert->circle vector\n                var dy = obj.pos.y - vy;\n\n                var len = Math.sqrt(dx*dx + dy*dy);\n                var pen = obj.radius - len;\n                if (0 < pen)\n                {\n                    //vertex is in the circle; project outward\n                    if (len === 0)\n                    {\n                        //project out by 45deg\n                        dx = oH / Math.SQRT2;\n                        dy = oV / Math.SQRT2;\n                    }\n                    else\n                    {\n                        dx /= len;\n                        dy /= len;\n                    }\n\n                    obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n\n            }\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n    },\n\n    /**\n    * Resolves 67 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_67DegS\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_67DegS: function (x,y,oH,oV,obj,t) {\n\n        //if the object is in a cell pointed at by signx, no collision will ever occur\n        //otherwise,\n        //\n        //if we're colliding diagonally:\n        //  -collide vs. the appropriate vertex\n        //if obj is in this tile: collide vs slope or vertex or axis\n        //if obj is vert neighb in direction of slope: collide vs. slope or vertex\n        //if obj is vert neighb against the slope:\n        //   if (distance in y from circle to 90deg corner of tile < 1/2 tileheight, collide vs. face)\n        //   else(collide vs. corner of slope) (vert collision with a non-grid-aligned vert)\n        //if obj is horiz neighb against direction of slope: collide vs. face\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        if (0 < (signx*oH))\n        {\n            //object will never collide vs tile, it can't reach that far\n\n            return Phaser.Physics.Ninja.Circle.COL_NONE;\n        }\n        else if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current tile\n                //we could only be colliding vs the slope OR a vertex\n                //look at the vector form the closest vert to the circle to decide\n\n                var lenP;\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var r = obj.radius;\n                var ox = obj.pos.x - t.pos.x;//this gives is the coordinates of the innermost\n                var oy = obj.pos.y - (t.pos.y - (signy*t.yw));//point on the circle, relative to the tile corner\n\n                //if the component of (ox,oy) parallel to the normal's righthand normal\n                //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                //then we project by the normal or axis, otherwise by the corner/vertex\n                //note that this is simply a VERY tricky/weird method of determining\n                //if the circle is in side the slope/face's voronoi region, or that of the vertex.\n\n                var perp = (ox*-sy) + (oy*sx);\n                if ((perp*signx*signy) < 0)\n                {\n                    //collide vs. vertex\n                    var len = Math.sqrt(ox*ox + oy*oy);\n                    var pen = r - len;\n                    if (0 < pen)\n                    {\n                        //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n                else\n                {\n                    //collide vs. slope or vs axis\n                    ox -= r*sx;//this gives us the vector from\n                    oy -= r*sy;//a point on the slope to the innermost point on the circle\n\n                    //if the dotprod of (ox,oy) and (sx,sy) is negative, the point on the circle is in the slope\n                    //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                    var dp = (ox*sx) + (oy*sy);\n\n                    if (dp < 0)\n                    {\n                        //collision; project delta onto slope and use this to displace the object\n                        sx *= -dp;//(sx,sy) is now the projection vector\n                        sy *= -dp;\n\n                        var lenN = Math.sqrt(sx*sx + sy*sy);\n\n                        //find the smallest axial projection vector\n                        if (x < y)\n                        {\n                            //penetration in x is smaller\n                            lenP = x;\n                            y = 0;\n                            //get sign for projection along x-axis\n                            if ((obj.pos.x - t.pos.x) < 0)\n                            {\n                                x *= -1;\n                            }\n                        }\n                        else\n                        {\n                            //penetration in y is smaller\n                            lenP = y;\n                            x = 0;\n                            //get sign for projection along y-axis\n                            if ((obj.pos.y - t.pos.y)< 0)\n                            {\n                                y *= -1;\n                            }\n                        }\n\n                        if (lenP < lenN)\n                        {\n                            obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                        }\n                        else\n                        {\n                            obj.reportCollisionVsWorld(sx,sy,t.sx,t.sy,t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                }\n\n            }\n            else\n            {\n                //colliding vertically\n\n                if ((signy*oV) < 0)\n                {\n                    //colliding with face/edge OR with corner of wedge, depending on our position vertically\n\n                    //collide vs. vertex\n                    //get diag vertex position\n                    var vx = t.pos.x;\n                    var vy = t.pos.y - (signy*t.yw);\n\n                    var dx = obj.pos.x - vx;//calc vert->circle vector\n                    var dy = obj.pos.y - vy;\n\n                    if ((dx*signx) < 0)\n                    {\n                        //colliding vs face\n                        obj.reportCollisionVsWorld(0, y*oV, 0, oV, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        //colliding vs. vertex\n\n                        var len = Math.sqrt(dx*dx + dy*dy);\n                        var pen = obj.radius - len;\n                        if (0 < pen)\n                        {\n                            //vertex is in the circle; project outward\n                            if (len === 0)\n                            {\n                                //project out by 45deg\n                                dx = oH / Math.SQRT2;\n                                dy = oV / Math.SQRT2;\n                            }\n                            else\n                            {\n                                dx /= len;\n                                dy /= len;\n                            }\n\n                            obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                }\n                else\n                {\n                    //we could only be colliding vs the slope OR a vertex\n                    //look at the vector form the closest vert to the circle to decide\n\n                    var sx = t.sx;\n                    var sy = t.sy;\n\n                    var ox = obj.pos.x - (t.pos.x - (signx*t.xw));//this gives is the coordinates of the innermost\n                    var oy = obj.pos.y - (t.pos.y + (oV*t.yw));//point on the circle, relative to the closest tile vert\n\n                    //if the component of (ox,oy) parallel to the normal's righthand normal\n                    //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                    //then we project by the vertex, otherwise by the normal.\n                    //note that this is simply a VERY tricky/weird method of determining\n                    //if the circle is in side the slope/face's voronio region, or that of the vertex.\n                    var perp = (ox*-sy) + (oy*sx);\n                    if (0 < (perp*signx*signy))\n                    {\n                        //collide vs. vertex\n                        var len = Math.sqrt(ox*ox + oy*oy);\n                        var pen = obj.radius - len;\n                        if (0 < pen)\n                        {\n                            //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                            ox /= len;\n                            oy /= len;\n\n                            obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                    else\n                    {\n                        //collide vs. slope\n\n                        //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                        //penetrating the slope. note that this method of penetration calculation doesn't hold\n                        //in general (i.e it won't work if the circle is in the slope), but works in this case\n                        //because we know the circle is in a neighboring cell\n                        var dp = (ox*sx) + (oy*sy);\n                        var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n\n                        if (0 < pen)\n                        {\n                            //collision; circle out along normal by penetration amount\n                            obj.reportCollisionVsWorld(sx*pen, sy*pen, t.sx, t.sy, t);\n\n                            return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                        }\n                    }\n                }\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally; we can assume that (signy*oV) < 0\n            //due to the first conditional far above\n\n            obj.reportCollisionVsWorld(x*oH, 0, oH, 0, t);\n\n            return Phaser.Physics.Ninja.Circle.COL_AXIS;\n        }\n        else\n        {\n            //colliding diagonally; due to the first conditional above,\n            //obj is vertically offset against slope, and offset in either direction horizontally\n\n            //collide vs. vertex\n            //get diag vertex position\n            var vx = t.pos.x + (oH*t.xw);\n            var vy = t.pos.y + (oV*t.yw);\n\n            var dx = obj.pos.x - vx;//calc vert->circle vector\n            var dy = obj.pos.y - vy;\n\n            var len = Math.sqrt(dx*dx + dy*dy);\n            var pen = obj.radius - len;\n            if (0 < pen)\n            {\n                //vertex is in the circle; project outward\n                if (len === 0)\n                {\n                    //project out by 45deg\n                    dx = oH / Math.SQRT2;\n                    dy = oV / Math.SQRT2;\n                }\n                else\n                {\n                    dx /= len;\n                    dy /= len;\n                }\n\n                obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_OTHER;\n            }\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n\n    },\n\n    /**\n    * Resolves 67 Degree tile collision.\n    *\n    * @method Phaser.Physics.Ninja.Circle#projCircle_67DegB\n    * @param {number} x - Penetration depth on the x axis.\n    * @param {number} y - Penetration depth on the y axis.\n    * @param {number} oH - Grid / voronoi region.\n    * @param {number} oV - Grid / voronoi region.\n    * @param {Phaser.Physics.Ninja.Circle} obj - The Circle involved in the collision.\n    * @param {Phaser.Physics.Ninja.Tile} t - The Tile involved in the collision.\n    * @return {number} The result of the collision.\n    */\n    projCircle_67DegB: function (x,y,oH, oV, obj,t) {\n\n        //if we're colliding diagonally:\n        //  -if we're in the cell pointed at by the normal, collide vs slope, else\n        //  collide vs. the appropriate corner/vertex\n        //\n        //if obj is in this tile: collide as with aabb\n        //\n        //if obj is horiz or vertical neighbor AGAINST the slope: collide with edge\n        //\n        //if obj is vert neighb in direction of slope: collide vs. slope or vertex or halfedge\n        //\n        //if obj is horiz neighb in direction of slope: collide vs. slope or vertex\n\n        var signx = t.signx;\n        var signy = t.signy;\n\n        if (oH === 0)\n        {\n            if (oV === 0)\n            {\n                //colliding with current cell\n\n                var lenP;\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var r = obj.radius;\n                var ox = (obj.pos.x - (sx*r)) - (t.pos.x + (signx*t.xw));//this gives is the coordinates of the innermost\n                var oy = (obj.pos.y - (sy*r)) - (t.pos.y - (signy*t.yw));//point on the AABB, relative to a point on the slope\n\n                //if the dotprod of (ox,oy) and (sx,sy) is negative, the point on the circle is in the slope\n                //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                var dp = (ox*sx) + (oy*sy);\n\n                if (dp < 0)\n                {\n                    //collision; project delta onto slope and use this to displace the object\n                    sx *= -dp;//(sx,sy) is now the projection vector\n                    sy *= -dp;\n\n                    var lenN = Math.sqrt(sx*sx + sy*sy);\n\n                    //find the smallest axial projection vector\n                    if (x < y)\n                    {\n                        //penetration in x is smaller\n                        lenP = x;\n                        y = 0;\n                        //get sign for projection along x-axis\n                        if ((obj.pos.x - t.pos.x) < 0)\n                        {\n                            x *= -1;\n                        }\n                    }\n                    else\n                    {\n                        //penetration in y is smaller\n                        lenP = y;\n                        x = 0;\n                        //get sign for projection along y-axis\n                        if ((obj.pos.y - t.pos.y)< 0)\n                        {\n                            y *= -1;\n                        }\n                    }\n\n                    if (lenP < lenN)\n                    {\n                        obj.reportCollisionVsWorld(x,y,x/lenP, y/lenP, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        obj.reportCollisionVsWorld(sx, sy, t.sx, t.sy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n\n                }\n            }\n            else\n            {\n                //colliding vertically\n\n                if ((signy*oV) < 0)\n                {\n                    //colliding with face/edge\n                    obj.reportCollisionVsWorld(0, y*oV, 0, oV, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                }\n                else\n                {\n                    //colliding with edge, slope, or vertex\n\n                    var ox = obj.pos.x - t.pos.x;//this gives is the coordinates of the innermost\n                    var oy = obj.pos.y - (t.pos.y + (signy*t.yw));//point on the circle, relative to the closest tile vert\n\n                    if ((ox*signx) < 0)\n                    {\n                        //we're colliding with the halfface\n                        obj.reportCollisionVsWorld(0, y*oV, 0, oV, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_AXIS;\n                    }\n                    else\n                    {\n                        //colliding with the vertex or slope\n\n                        var sx = t.sx;\n                        var sy = t.sy;\n\n                        //if the component of (ox,oy) parallel to the normal's righthand normal\n                        //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                        //then we project by the vertex, otherwise by the slope.\n                        //note that this is simply a VERY tricky/weird method of determining\n                        //if the circle is in side the slope/face's voronio region, or that of the vertex.\n                        var perp = (ox*-sy) + (oy*sx);\n                        if (0 < (perp*signx*signy))\n                        {\n                            //collide vs. vertex\n                            var len = Math.sqrt(ox*ox + oy*oy);\n                            var pen = obj.radius - len;\n                            if (0 < pen)\n                            {\n                                //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                                ox /= len;\n                                oy /= len;\n\n                                obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n\n                                return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                            }\n                        }\n                        else\n                        {\n                            //collide vs. slope\n\n                            //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                            //penetrating the slope. note that this method of penetration calculation doesn't hold\n                            //in general (i.e it won't work if the circle is in the slope), but works in this case\n                            //because we know the circle is in a neighboring cell\n                            var dp = (ox*sx) + (oy*sy);\n                            var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n                            if (0 < pen)\n                            {\n                                //collision; circle out along normal by penetration amount\n                                obj.reportCollisionVsWorld(sx*pen, sy*pen, sx, sy, t);\n\n                                return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else if (oV === 0)\n        {\n            //colliding horizontally\n\n            if ((signx*oH) < 0)\n            {\n                //colliding with face/edge\n                obj.reportCollisionVsWorld(x*oH, 0, oH, 0, t);\n\n                return Phaser.Physics.Ninja.Circle.COL_AXIS;\n            }\n            else\n            {\n                //we could only be colliding vs the slope OR a vertex\n                //look at the vector form the closest vert to the circle to decide\n\n                var slen = Math.sqrt(2*2 + 1*1);//the raw slope is (-2,-1)\n                var sx = (signx*2) / slen;//get slope _unit_ normal;\n                var sy = (signy*1) / slen;//raw RH normal is (1,-2)\n\n                var ox = obj.pos.x - (t.pos.x + (signx*t.xw));//this gives is the coordinates of the innermost\n                var oy = obj.pos.y - (t.pos.y - (signy*t.yw));//point on the circle, relative to the closest tile vert\n\n                //if the component of (ox,oy) parallel to the normal's righthand normal\n                //has the same sign as the slope of the slope (the sign of the slope's slope is signx*signy)\n                //then we project by the slope, otherwise by the vertex.\n                //note that this is simply a VERY tricky/weird method of determining\n                //if the circle is in side the slope/face's voronio region, or that of the vertex.\n                var perp = (ox*-sy) + (oy*sx);\n                if ((perp*signx*signy) < 0)\n                {\n                    //collide vs. vertex\n                    var len = Math.sqrt(ox*ox + oy*oy);\n                    var pen = obj.radius - len;\n                    if (0 < pen)\n                    {\n                        //note: if len=0, then perp=0 and we'll never reach here, so don't worry about div-by-0\n                        ox /= len;\n                        oy /= len;\n\n                        obj.reportCollisionVsWorld(ox*pen, oy*pen, ox, oy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n                else\n                {\n                    //collide vs. slope\n\n                    //if the component of (ox,oy) parallel to the normal is less than the circle radius, we're\n                    //penetrating the slope. note that this method of penetration calculation doesn't hold\n                    //in general (i.e it won't work if the circle is in the slope), but works in this case\n                    //because we know the circle is in a neighboring cell\n                    var dp = (ox*sx) + (oy*sy);\n                    var pen = obj.radius - Math.abs(dp);//note: we don't need the abs because we know the dp will be positive, but just in case..\n                    if (0 < pen)\n                    {\n                        //collision; circle out along normal by penetration amount\n                        obj.reportCollisionVsWorld(sx*pen, sy*pen, t.sx, t.sy, t);\n\n                        return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                    }\n                }\n            }\n        }\n        else\n        {\n            //colliding diagonally\n            if ( 0 < ((signx*oH) + (signy*oV)) )\n            {\n                //the dotprod of slope normal and cell offset is strictly positive,\n                //therefore obj is in the diagonal neighb pointed at by the normal.\n\n                //collide vs slope\n\n                var sx = t.sx;\n                var sy = t.sy;\n\n                var r = obj.radius;\n                var ox = (obj.pos.x - (sx*r)) - (t.pos.x + (signx*t.xw));//this gives is the coordinates of the innermost\n                var oy = (obj.pos.y - (sy*r)) - (t.pos.y - (signy*t.yw));//point on the circle, relative to a point on the slope\n\n                //if the dotprod of (ox,oy) and (sx,sy) is negative, the point on the circle is in the slope\n                //and we need toproject it out by the magnitude of the projection of (ox,oy) onto (sx,sy)\n                var dp = (ox*sx) + (oy*sy);\n\n                if (dp < 0)\n                {\n                    //collision; project delta onto slope and use this to displace the object\n                    //(sx,sy)*-dp is the projection vector\n\n                    obj.reportCollisionVsWorld(-sx*dp, -sy*dp, t.sx, t.sy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n                return Phaser.Physics.Ninja.Circle.COL_NONE;\n            }\n            else\n            {\n\n                //collide vs the appropriate vertex\n                var vx = t.pos.x + (oH*t.xw);\n                var vy = t.pos.y + (oV*t.yw);\n\n                var dx = obj.pos.x - vx;//calc vert->circle vector\n                var dy = obj.pos.y - vy;\n\n                var len = Math.sqrt(dx*dx + dy*dy);\n                var pen = obj.radius - len;\n                if (0 < pen)\n                {\n                    //vertex is in the circle; project outward\n                    if (len === 0)\n                    {\n                        //project out by 45deg\n                        dx = oH / Math.SQRT2;\n                        dy = oV / Math.SQRT2;\n                    }\n                    else\n                    {\n                        dx /= len;\n                        dy /= len;\n                    }\n\n                    obj.reportCollisionVsWorld(dx*pen, dy*pen, dx, dy, t);\n\n                    return Phaser.Physics.Ninja.Circle.COL_OTHER;\n                }\n\n            }\n        }\n\n        return Phaser.Physics.Ninja.Circle.COL_NONE;\n    },\n\n    /**\n    * Destroys this Circle's reference to Body and System\n    *\n    * @method Phaser.Physics.Ninja.Circle#destroy\n    */\n    destroy: function() {\n        this.body = null;\n        this.system = null;\n    }\n\n};\n\n/**\n * The MIT License (MIT)\n * \n * Copyright (c) 2013 p2.js authors\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n!function(e){\"object\"==typeof exports?module.exports=e():\"function\"==typeof define&&define.amd?define('p2', (function() { return this.p2 = e(); })()):\"undefined\"!=typeof window?window.p2=e():\"undefined\"!=typeof global?self.p2=e():\"undefined\"!=typeof self&&(self.p2=e())}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation \n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\nif(!GLMAT_EPSILON) {\n    var GLMAT_EPSILON = 0.000001;\n}\n\nif(!GLMAT_ARRAY_TYPE) {\n    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\n}\n\n/**\n * @class Common utilities\n * @name glMatrix\n */\nvar glMatrix = {};\n\n/**\n * Sets the type of array used when creating new vectors and matricies\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nglMatrix.setMatrixArrayType = function(type) {\n    GLMAT_ARRAY_TYPE = type;\n}\n\nif(typeof(exports) !== 'undefined') {\n    exports.glMatrix = glMatrix;\n}\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation \n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE \nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 2 Dimensional Vector\n * @name vec2\n */\nvar vec2 = {};\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nvec2.create = function() {\n    var out = new GLMAT_ARRAY_TYPE(2);\n    out[0] = 0;\n    out[1] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nvec2.clone = function(a) {\n    var out = new GLMAT_ARRAY_TYPE(2);\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nvec2.fromValues = function(x, y) {\n    var out = new GLMAT_ARRAY_TYPE(2);\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nvec2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nvec2.set = function(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n};\n\n/**\n * Subtracts two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nvec2.sub = vec2.subtract;\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nvec2.mul = vec2.multiply;\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nvec2.div = vec2.divide;\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    return out;\n};\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nvec2.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nvec2.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nvec2.dist = vec2.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec2.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nvec2.sqrDist = vec2.squaredDistance;\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec2.length = function (a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nvec2.len = vec2.length;\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec2.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nvec2.sqrLen = vec2.squaredLength;\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nvec2.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n};\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nvec2.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x*x + y*y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec2.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n};\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nvec2.cross = function(out, a, b) {\n    var z = a[0] * b[1] - a[1] * b[0];\n    out[0] = out[1] = 0;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nvec2.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2d = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat3 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat4 = function(out, a, m) {\n    var x = a[0], \n        y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec2.forEach = (function() {\n    var vec = vec2.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 2;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec2.str = function (a) {\n    return 'vec2(' + a[0] + ', ' + a[1] + ')';\n};\n\nif(typeof(exports) !== 'undefined') {\n    exports.vec2 = vec2;\n}\n\n},{}],2:[function(require,module,exports){\nvar Scalar = require('./Scalar');\n\nmodule.exports = Line;\n\n/**\n * Container for line-related functions\n * @class Line\n */\nfunction Line(){};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nLine.lineInt = function(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!Scalar.eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n};\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nLine.segmentsIntersect = function(p1, p2, q1, q2){\n   var dx = p2[0] - p1[0];\n   var dy = p2[1] - p1[1];\n   var da = q2[0] - q1[0];\n   var db = q2[1] - q1[1];\n\n   // segments are parallel\n   if(da*dy - db*dx == 0)\n      return false;\n\n   var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx)\n   var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy)\n\n   return (s>=0 && s<=1 && t>=0 && t<=1);\n};\n\n\n},{\"./Scalar\":5}],3:[function(require,module,exports){\nmodule.exports = Point;\n\n/**\n * Point related functions\n * @class Point\n */\nfunction Point(){};\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nPoint.area = function(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n};\n\nPoint.left = function(a,b,c){\n    return Point.area(a,b,c) > 0;\n};\n\nPoint.leftOn = function(a,b,c) {\n    return Point.area(a, b, c) >= 0;\n};\n\nPoint.right = function(a,b,c) {\n    return Point.area(a, b, c) < 0;\n};\n\nPoint.rightOn = function(a,b,c) {\n    return Point.area(a, b, c) <= 0;\n};\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nPoint.collinear = function(a,b,c,thresholdAngle) {\n    if(!thresholdAngle)\n        return Point.area(a, b, c) == 0;\n    else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n};\n\nPoint.sqdist = function(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n};\n\n},{}],4:[function(require,module,exports){\nvar Line = require(\"./Line\")\n,   Point = require(\"./Point\")\n,   Scalar = require(\"./Scalar\")\n\nmodule.exports = Polygon;\n\n/**\n * Polygon class.\n * @class Polygon\n * @constructor\n */\nfunction Polygon(){\n\n    /**\n     * Vertices that this polygon consists of. An array of array of numbers, example: [[0,0],[1,0],..]\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = [];\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nPolygon.prototype.at = function(i){\n    var v = this.vertices,\n        s = v.length;\n    return v[i < 0 ? i % s + s : i % s];\n};\n\n/**\n * Get first vertex\n * @method first\n * @return {Array}\n */\nPolygon.prototype.first = function(){\n    return this.vertices[0];\n};\n\n/**\n * Get last vertex\n * @method last\n * @return {Array}\n */\nPolygon.prototype.last = function(){\n    return this.vertices[this.vertices.length-1];\n};\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nPolygon.prototype.clear = function(){\n    this.vertices.length = 0;\n};\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nPolygon.prototype.append = function(poly,from,to){\n    if(typeof(from) == \"undefined\") throw new Error(\"From is not given!\");\n    if(typeof(to) == \"undefined\")   throw new Error(\"To is not given!\");\n\n    if(to-1 < from)                 throw new Error(\"lol1\");\n    if(to > poly.vertices.length)   throw new Error(\"lol2\");\n    if(from < 0)                    throw new Error(\"lol3\");\n\n    for(var i=from; i<to; i++){\n        this.vertices.push(poly.vertices[i]);\n    }\n};\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nPolygon.prototype.makeCCW = function(){\n    var br = 0,\n        v = this.vertices;\n\n    // find bottom right point\n    for (var i = 1; i < this.vertices.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] == v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!Point.left(this.at(br - 1), this.at(br), this.at(br + 1))) {\n        this.reverse();\n    }\n};\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nPolygon.prototype.reverse = function(){\n    var tmp = [];\n    for(var i=0, N=this.vertices.length; i!==N; i++){\n        tmp.push(this.vertices.pop());\n    }\n    this.vertices = tmp;\n};\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nPolygon.prototype.isReflex = function(i){\n    return Point.right(this.at(i - 1), this.at(i), this.at(i + 1));\n};\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nPolygon.prototype.canSee = function(a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (Point.leftOn(this.at(a + 1), this.at(a), this.at(b)) && Point.rightOn(this.at(a - 1), this.at(a), this.at(b))) {\n        return false;\n    }\n    dist = Point.sqdist(this.at(a), this.at(b));\n    for (var i = 0; i !== this.vertices.length; ++i) { // for each edge\n        if ((i + 1) % this.vertices.length === a || i === a) // ignore incident edges\n            continue;\n        if (Point.leftOn(this.at(a), this.at(b), this.at(i + 1)) && Point.rightOn(this.at(a), this.at(b), this.at(i))) { // if diag intersects an edge\n            l1[0] = this.at(a);\n            l1[1] = this.at(b);\n            l2[0] = this.at(i);\n            l2[1] = this.at(i + 1);\n            p = Line.lineInt(l1,l2);\n            if (Point.sqdist(this.at(a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nPolygon.prototype.copy = function(i,j,targetPoly){\n    var p = targetPoly || new Polygon();\n    p.clear();\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++)\n            p.vertices.push(this.vertices[k]);\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++)\n            p.vertices.push(this.vertices[k]);\n\n        // Insert vertices i to end\n        for(var k=i; k<this.vertices.length; k++)\n            p.vertices.push(this.vertices[k]);\n    }\n\n    return p;\n};\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nPolygon.prototype.getCutEdges = function() {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = new Polygon();\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < this.vertices.length; ++i) {\n        if (this.isReflex(i)) {\n            for (var j = 0; j < this.vertices.length; ++j) {\n                if (this.canSee(i, j)) {\n                    tmp1 = this.copy(i, j, tmpPoly).getCutEdges();\n                    tmp2 = this.copy(j, i, tmpPoly).getCutEdges();\n\n                    for(var k=0; k<tmp2.length; k++)\n                        tmp1.push(tmp2[k]);\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([this.at(i), this.at(j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n};\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nPolygon.prototype.decomp = function(){\n    var edges = this.getCutEdges();\n    if(edges.length > 0)\n        return this.slice(edges);\n    else\n        return [this];\n};\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nPolygon.prototype.slice = function(cutEdges){\n    if(cutEdges.length == 0) return [this];\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length==2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [this];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = poly.slice(cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = this.vertices.indexOf(cutEdge[0]);\n        var j = this.vertices.indexOf(cutEdge[1]);\n\n        if(i != -1 && j != -1){\n            return [this.copy(i,j),\n                    this.copy(j,i)];\n        } else {\n            return false;\n        }\n    }\n};\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nPolygon.prototype.isSimple = function(){\n    var path = this.vertices;\n    // Check\n    for(var i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(Line.segmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(var i=1; i<path.length-2; i++){\n        if(Line.segmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n};\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n    delta = delta || 0;\n   var a1 = p2[1] - p1[1];\n   var b1 = p1[0] - p2[0];\n   var c1 = (a1 * p1[0]) + (b1 * p1[1]);\n   var a2 = q2[1] - q1[1];\n   var b2 = q1[0] - q2[0];\n   var c2 = (a2 * q1[0]) + (b2 * q1[1]);\n   var det = (a1 * b2) - (a2 * b1);\n\n   if(!Scalar.eq(det,0,delta))\n      return [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det]\n   else\n      return [0,0]\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nPolygon.prototype.quickDecomp = function(result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!=\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=new Polygon(), upperPoly=new Polygon(); // polygons\n    var poly = this,\n        v = this.vertices;\n\n    if(v.length < 3) return result;\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < this.vertices.length; ++i) {\n        if (poly.isReflex(i)) {\n            reflexVertices.push(poly.vertices[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < this.vertices.length; ++j) {\n                if (Point.left(poly.at(i - 1), poly.at(i), poly.at(j))\n                        && Point.rightOn(poly.at(i - 1), poly.at(i), poly.at(j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(poly.at(i - 1), poly.at(i), poly.at(j), poly.at(j - 1)); // find the point of intersection\n                    if (Point.right(poly.at(i + 1), poly.at(i), p)) { // make sure it's inside the poly\n                        d = Point.sqdist(poly.vertices[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (Point.left(poly.at(i + 1), poly.at(i), poly.at(j + 1))\n                        && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {\n                    p = getIntersectionPoint(poly.at(i + 1), poly.at(i), poly.at(j), poly.at(j + 1));\n                    if (Point.left(poly.at(i - 1), poly.at(i), p)) {\n                        d = Point.sqdist(poly.vertices[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex == (upperIndex + 1) % this.vertices.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+this.vertices.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    lowerPoly.append(poly, i, upperIndex+1);\n                    lowerPoly.vertices.push(p);\n                    upperPoly.vertices.push(p);\n                    if (lowerIndex != 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        upperPoly.append(poly,lowerIndex,poly.vertices.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    upperPoly.append(poly,0,i+1);\n                } else {\n                    if (i != 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        lowerPoly.append(poly,i,poly.vertices.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    lowerPoly.append(poly,0,upperIndex+1);\n                    lowerPoly.vertices.push(p);\n                    upperPoly.vertices.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    upperPoly.append(poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+this.vertices.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += this.vertices.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (Point.leftOn(poly.at(i - 1), poly.at(i), poly.at(j))\n                            && Point.rightOn(poly.at(i + 1), poly.at(i), poly.at(j))) {\n                        d = Point.sqdist(poly.at(i), poly.at(j));\n                        if (d < closestDist) {\n                            closestDist = d;\n                            closestIndex = j % this.vertices.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    lowerPoly.append(poly,i,closestIndex+1);\n                    if (closestIndex != 0){\n                        upperPoly.append(poly,closestIndex,v.length);\n                    }\n                    upperPoly.append(poly,0,i+1);\n                } else {\n                    if (i != 0){\n                        lowerPoly.append(poly,i,v.length);\n                    }\n                    lowerPoly.append(poly,0,closestIndex+1);\n                    upperPoly.append(poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.vertices.length < upperPoly.vertices.length) {\n                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                upperPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                lowerPoly.quickDecomp(result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(this);\n\n    return result;\n};\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nPolygon.prototype.removeCollinearPoints = function(precision){\n    var num = 0;\n    for(var i=this.vertices.length-1; this.vertices.length>3 && i>=0; --i){\n        if(Point.collinear(this.at(i-1),this.at(i),this.at(i+1),precision)){\n            // Remove the middle point\n            this.vertices.splice(i%this.vertices.length,1);\n            i--; // Jump one point forward. Otherwise we may get a chain removal\n            num++;\n        }\n    }\n    return num;\n};\n\n},{\"./Line\":2,\"./Point\":3,\"./Scalar\":5}],5:[function(require,module,exports){\nmodule.exports = Scalar;\n\n/**\n * Scalar functions\n * @class Scalar\n */\nfunction Scalar(){}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nScalar.eq = function(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) < precision;\n};\n\n},{}],6:[function(require,module,exports){\nmodule.exports = {\n    Polygon : require(\"./Polygon\"),\n    Point : require(\"./Point\"),\n};\n\n},{\"./Point\":3,\"./Polygon\":4}],7:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"p2\",\n  \"version\": \"0.5.0\",\n  \"description\": \"A JavaScript 2D physics engine.\",\n  \"author\": \"Stefan Hedman <schteppe@gmail.com> (http://steffe.se)\",\n  \"keywords\": [\n    \"p2.js\",\n    \"p2\",\n    \"physics\",\n    \"engine\",\n    \"2d\"\n  ],\n  \"main\": \"./src/p2.js\",\n  \"engines\": {\n    \"node\": \"*\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/schteppe/p2.js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/schteppe/p2.js/issues\"\n  },\n  \"licenses\": [\n    {\n      \"type\": \"MIT\"\n    }\n  ],\n  \"devDependencies\": {\n    \"grunt\": \"~0.4.0\",\n    \"grunt-contrib-jshint\": \"~0.9.2\",\n    \"grunt-contrib-nodeunit\": \"~0.1.2\",\n    \"grunt-contrib-uglify\": \"~0.4.0\",\n    \"grunt-contrib-watch\": \"~0.5.0\",\n    \"grunt-browserify\": \"~2.0.1\",\n    \"z-schema\": \"~2.4.6\"\n  },\n  \"dependencies\": {\n    \"poly-decomp\": \"0.1.0\",\n    \"gl-matrix\": \"2.1.0\"\n  }\n}\n\n},{}],8:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\n,   Utils = require('../utils/Utils');\n\nmodule.exports = AABB;\n\n/**\n * Axis aligned bounding box class.\n * @class AABB\n * @constructor\n * @param {Object}  [options]\n * @param {Array}   [options.upperBound]\n * @param {Array}   [options.lowerBound]\n */\nfunction AABB(options){\n\n    /**\n     * The lower bound of the bounding box.\n     * @property lowerBound\n     * @type {Array}\n     */\n    this.lowerBound = vec2.create();\n    if(options && options.lowerBound){\n        vec2.copy(this.lowerBound, options.lowerBound);\n    }\n\n    /**\n     * The upper bound of the bounding box.\n     * @property upperBound\n     * @type {Array}\n     */\n    this.upperBound = vec2.create();\n    if(options && options.upperBound){\n        vec2.copy(this.upperBound, options.upperBound);\n    }\n}\n\nvar tmp = vec2.create();\n\n/**\n * Set the AABB bounds from a set of points.\n * @method setFromPoints\n * @param {Array} points An array of vec2's.\n */\nAABB.prototype.setFromPoints = function(points,position,angle){\n    var l = this.lowerBound,\n        u = this.upperBound;\n    vec2.set(l,  Number.MAX_VALUE,  Number.MAX_VALUE);\n    vec2.set(u, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    for(var i=0; i<points.length; i++){\n        var p = points[i];\n\n        if(typeof(angle) === \"number\"){\n            vec2.rotate(tmp,p,angle);\n            p = tmp;\n        }\n\n        for(var j=0; j<2; j++){\n            if(p[j] > u[j]){\n                u[j] = p[j];\n            }\n            if(p[j] < l[j]){\n                l[j] = p[j];\n            }\n        }\n    }\n\n    // Add offset\n    if(position){\n        vec2.add(this.lowerBound, this.lowerBound, position);\n        vec2.add(this.upperBound, this.upperBound, position);\n    }\n};\n\n/**\n * Copy bounds from an AABB to this AABB\n * @method copy\n * @param  {AABB} aabb\n */\nAABB.prototype.copy = function(aabb){\n    vec2.copy(this.lowerBound, aabb.lowerBound);\n    vec2.copy(this.upperBound, aabb.upperBound);\n};\n\n/**\n * Extend this AABB so that it covers the given AABB too.\n * @method extend\n * @param  {AABB} aabb\n */\nAABB.prototype.extend = function(aabb){\n    // Loop over x and y\n    for(var i=0; i<2; i++){\n        // Extend lower bound\n        if(aabb.lowerBound[i] < this.lowerBound[i]){\n            this.lowerBound[i] = aabb.lowerBound[i];\n        }\n\n        // Upper\n        if(aabb.upperBound[i] > this.upperBound[i]){\n            this.upperBound[i] = aabb.upperBound[i];\n        }\n    }\n};\n\n/**\n * Returns true if the given AABB overlaps this AABB.\n * @method overlaps\n * @param  {AABB} aabb\n * @return {Boolean}\n */\nAABB.prototype.overlaps = function(aabb){\n    var l1 = this.lowerBound,\n        u1 = this.upperBound,\n        l2 = aabb.lowerBound,\n        u2 = aabb.upperBound;\n\n    //      l2        u2\n    //      |---------|\n    // |--------|\n    // l1       u1\n\n    return ((l2[0] <= u1[0] && u1[0] <= u2[0]) || (l1[0] <= u2[0] && u2[0] <= u1[0])) &&\n           ((l2[1] <= u1[1] && u1[1] <= u2[1]) || (l1[1] <= u2[1] && u2[1] <= u1[1]));\n};\n\n},{\"../math/vec2\":30,\"../utils/Utils\":47}],9:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\nvar Body = require('../objects/Body')\n\nmodule.exports = Broadphase;\n\n/**\n * Base class for broadphase implementations.\n * @class Broadphase\n * @constructor\n */\nfunction Broadphase(type){\n\n    this.type = type;\n\n    /**\n     * The resulting overlapping pairs. Will be filled with results during .getCollisionPairs().\n     * @property result\n     * @type {Array}\n     */\n    this.result = [];\n\n    /**\n     * The world to search for collision pairs in. To change it, use .setWorld()\n     * @property world\n     * @type {World}\n     * @readOnly\n     */\n    this.world = null;\n\n    /**\n     * The bounding volume type to use in the broadphase algorithms.\n     * @property {Number} boundingVolumeType\n     */\n    this.boundingVolumeType = Broadphase.AABB;\n}\n\n/**\n * Axis aligned bounding box type.\n * @static\n * @property {Number} AABB\n */\nBroadphase.AABB = 1;\n\n/**\n * Bounding circle type.\n * @static\n * @property {Number} BOUNDING_CIRCLE\n */\nBroadphase.BOUNDING_CIRCLE = 2;\n\n/**\n * Set the world that we are searching for collision pairs in\n * @method setWorld\n * @param  {World} world\n */\nBroadphase.prototype.setWorld = function(world){\n    this.world = world;\n};\n\n/**\n * Get all potential intersecting body pairs.\n * @method getCollisionPairs\n * @param  {World} world The world to search in.\n * @return {Array} An array of the bodies, ordered in pairs. Example: A result of [a,b,c,d] means that the potential pairs are: (a,b), (c,d).\n */\nBroadphase.prototype.getCollisionPairs = function(world){\n    throw new Error(\"getCollisionPairs must be implemented in a subclass!\");\n};\n\nvar dist = vec2.create();\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.boundingRadiusCheck = function(bodyA, bodyB){\n    vec2.sub(dist, bodyA.position, bodyB.position);\n    var d2 = vec2.squaredLength(dist),\n        r = bodyA.boundingRadius + bodyB.boundingRadius;\n    return d2 <= r*r;\n};\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.aabbCheck = function(bodyA, bodyB){\n    if(bodyA.aabbNeedsUpdate){\n        bodyA.updateAABB();\n    }\n    if(bodyB.aabbNeedsUpdate){\n        bodyB.updateAABB();\n    }\n    return bodyA.aabb.overlaps(bodyB.aabb);\n};\n\n/**\n * Check whether the bounding radius of two bodies overlap.\n * @method  boundingRadiusCheck\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.prototype.boundingVolumeCheck = function(bodyA, bodyB){\n    var result;\n\n    switch(this.boundingVolumeType){\n    case Broadphase.BOUNDING_CIRCLE:\n        result =  Broadphase.boundingRadiusCheck(bodyA,bodyB);\n        break;\n    case Broadphase.AABB:\n        result = Broadphase.aabbCheck(bodyA,bodyB);\n        break;\n    default:\n        throw new Error('Bounding volume type not recognized: '+this.boundingVolumeType);\n    }\n    return result;\n};\n\n/**\n * Check whether two bodies are allowed to collide at all.\n * @method  canCollide\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {Boolean}\n */\nBroadphase.canCollide = function(bodyA, bodyB){\n\n    // Cannot collide static bodies\n    if(bodyA.motionState === Body.STATIC && bodyB.motionState === Body.STATIC){\n        return false;\n    }\n\n    // Cannot collide static vs kinematic bodies\n    if( (bodyA.motionState === Body.KINEMATIC && bodyB.motionState === Body.STATIC) ||\n        (bodyA.motionState === Body.STATIC    && bodyB.motionState === Body.KINEMATIC)){\n        return false;\n    }\n\n    // Cannot collide kinematic vs kinematic\n    if(bodyA.motionState === Body.KINEMATIC && bodyB.motionState === Body.KINEMATIC){\n        return false;\n    }\n\n    // Cannot collide both sleeping bodies\n    if(bodyA.sleepState === Body.SLEEPING && bodyB.sleepState === Body.SLEEPING){\n        return false;\n    }\n\n    // Cannot collide if one is static and the other is sleeping\n    if( (bodyA.sleepState === Body.SLEEPING && bodyB.motionState === Body.STATIC) ||\n        (bodyB.sleepState === Body.SLEEPING && bodyA.motionState === Body.STATIC)){\n        return false;\n    }\n\n    return true;\n};\n\nBroadphase.NAIVE = 1;\nBroadphase.SAP = 2;\n\n},{\"../math/vec2\":30,\"../objects/Body\":31}],10:[function(require,module,exports){\nvar Circle = require('../shapes/Circle')\n,   Plane = require('../shapes/Plane')\n,   Particle = require('../shapes/Particle')\n,   Broadphase = require('../collision/Broadphase')\n,   vec2 = require('../math/vec2')\n,   Utils = require('../utils/Utils')\n\nmodule.exports = GridBroadphase;\n\n/**\n * Broadphase that uses axis-aligned bins.\n * @class GridBroadphase\n * @constructor\n * @extends Broadphase\n * @param {object} [options]\n * @param {number} [options.xmin]   Lower x bound of the grid\n * @param {number} [options.xmax]   Upper x bound\n * @param {number} [options.ymin]   Lower y bound\n * @param {number} [options.ymax]   Upper y bound\n * @param {number} [options.nx]     Number of bins along x axis\n * @param {number} [options.ny]     Number of bins along y axis\n * @todo Should have an option for dynamic scene size\n */\nfunction GridBroadphase(options){\n    Broadphase.apply(this);\n\n    options = Utils.defaults(options,{\n        xmin:   -100,\n        xmax:   100,\n        ymin:   -100,\n        ymax:   100,\n        nx:     10,\n        ny:     10\n    });\n\n    this.xmin = options.xmin;\n    this.ymin = options.ymin;\n    this.xmax = options.xmax;\n    this.ymax = options.ymax;\n    this.nx = options.nx;\n    this.ny = options.ny;\n\n    this.binsizeX = (this.xmax-this.xmin) / this.nx;\n    this.binsizeY = (this.ymax-this.ymin) / this.ny;\n}\nGridBroadphase.prototype = new Broadphase();\n\n/**\n * Get collision pairs.\n * @method getCollisionPairs\n * @param  {World} world\n * @return {Array}\n */\nGridBroadphase.prototype.getCollisionPairs = function(world){\n    var result = [],\n        bodies = world.bodies,\n        Ncolliding = bodies.length,\n        binsizeX = this.binsizeX,\n        binsizeY = this.binsizeY,\n        nx = this.nx,\n        ny = this.ny,\n        xmin = this.xmin,\n        ymin = this.ymin,\n        xmax = this.xmax,\n        ymax = this.ymax;\n\n    // Todo: make garbage free\n    var bins=[], Nbins=nx*ny;\n    for(var i=0; i<Nbins; i++){\n        bins.push([]);\n    }\n\n    var xmult = nx / (xmax-xmin);\n    var ymult = ny / (ymax-ymin);\n\n    // Put all bodies into bins\n    for(var i=0; i!==Ncolliding; i++){\n        var bi = bodies[i];\n        var aabb = bi.aabb;\n        var lowerX = Math.max(aabb.lowerBound[0], xmin);\n        var lowerY = Math.max(aabb.lowerBound[1], ymin);\n        var upperX = Math.min(aabb.upperBound[0], xmax);\n        var upperY = Math.min(aabb.upperBound[1], ymax);\n        var xi1 = Math.floor(xmult * (lowerX - xmin));\n        var yi1 = Math.floor(ymult * (lowerY - ymin));\n        var xi2 = Math.floor(xmult * (upperX - xmin));\n        var yi2 = Math.floor(ymult * (upperY - ymin));\n\n        // Put in bin\n        for(var j=xi1; j<=xi2; j++){\n            for(var k=yi1; k<=yi2; k++){\n                var xi = j;\n                var yi = k;\n                var idx = xi*(ny-1) + yi;\n                if(idx >= 0 && idx < Nbins){\n                    bins[ idx ].push(bi);\n                }\n            }\n        }\n    }\n\n    // Check each bin\n    for(var i=0; i!==Nbins; i++){\n        var bin = bins[i];\n\n        for(var j=0, NbodiesInBin=bin.length; j!==NbodiesInBin; j++){\n            var bi = bin[j];\n            for(var k=0; k!==j; k++){\n                var bj = bin[k];\n                if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n                    result.push(bi,bj);\n                }\n            }\n        }\n    }\n    return result;\n};\n\n},{\"../collision/Broadphase\":9,\"../math/vec2\":30,\"../shapes/Circle\":35,\"../shapes/Particle\":39,\"../shapes/Plane\":40,\"../utils/Utils\":47}],11:[function(require,module,exports){\nvar Circle = require('../shapes/Circle'),\n    Plane = require('../shapes/Plane'),\n    Shape = require('../shapes/Shape'),\n    Particle = require('../shapes/Particle'),\n    Broadphase = require('../collision/Broadphase'),\n    vec2 = require('../math/vec2');\n\nmodule.exports = NaiveBroadphase;\n\n/**\n * Naive broadphase implementation. Does N^2 tests.\n *\n * @class NaiveBroadphase\n * @constructor\n * @extends Broadphase\n */\nfunction NaiveBroadphase(){\n    Broadphase.call(this, Broadphase.NAIVE);\n}\nNaiveBroadphase.prototype = new Broadphase();\n\n/**\n * Get the colliding pairs\n * @method getCollisionPairs\n * @param  {World} world\n * @return {Array}\n */\nNaiveBroadphase.prototype.getCollisionPairs = function(world){\n    var bodies = world.bodies,\n        result = this.result;\n\n    result.length = 0;\n\n    for(var i=0, Ncolliding=bodies.length; i!==Ncolliding; i++){\n        var bi = bodies[i];\n\n        for(var j=0; j<i; j++){\n            var bj = bodies[j];\n\n            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n                result.push(bi,bj);\n            }\n        }\n    }\n\n    return result;\n};\n\n},{\"../collision/Broadphase\":9,\"../math/vec2\":30,\"../shapes/Circle\":35,\"../shapes/Particle\":39,\"../shapes/Plane\":40,\"../shapes/Shape\":42}],12:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\n,   sub = vec2.sub\n,   add = vec2.add\n,   dot = vec2.dot\n,   Utils = require('../utils/Utils')\n,   TupleDictionary = require('../utils/TupleDictionary')\n,   Equation = require('../equations/Equation')\n,   ContactEquation = require('../equations/ContactEquation')\n,   FrictionEquation = require('../equations/FrictionEquation')\n,   Circle = require('../shapes/Circle')\n,   Convex = require('../shapes/Convex')\n,   Shape = require('../shapes/Shape')\n,   Body = require('../objects/Body')\n,   Rectangle = require('../shapes/Rectangle');\n\nmodule.exports = Narrowphase;\n\n// Temp things\nvar yAxis = vec2.fromValues(0,1);\n\nvar tmp1 = vec2.fromValues(0,0)\n,   tmp2 = vec2.fromValues(0,0)\n,   tmp3 = vec2.fromValues(0,0)\n,   tmp4 = vec2.fromValues(0,0)\n,   tmp5 = vec2.fromValues(0,0)\n,   tmp6 = vec2.fromValues(0,0)\n,   tmp7 = vec2.fromValues(0,0)\n,   tmp8 = vec2.fromValues(0,0)\n,   tmp9 = vec2.fromValues(0,0)\n,   tmp10 = vec2.fromValues(0,0)\n,   tmp11 = vec2.fromValues(0,0)\n,   tmp12 = vec2.fromValues(0,0)\n,   tmp13 = vec2.fromValues(0,0)\n,   tmp14 = vec2.fromValues(0,0)\n,   tmp15 = vec2.fromValues(0,0)\n,   tmp16 = vec2.fromValues(0,0)\n,   tmp17 = vec2.fromValues(0,0)\n,   tmp18 = vec2.fromValues(0,0)\n,   tmpArray = [];\n\n/**\n * Narrowphase. Creates contacts and friction given shapes and transforms.\n * @class Narrowphase\n * @constructor\n */\nfunction Narrowphase(){\n\n    /**\n     * @property contactEquations\n     * @type {Array}\n     */\n    this.contactEquations = [];\n\n    /**\n     * @property frictionEquations\n     * @type {Array}\n     */\n    this.frictionEquations = [];\n\n    /**\n     * Whether to make friction equations in the upcoming contacts.\n     * @property enableFriction\n     * @type {Boolean}\n     */\n    this.enableFriction = true;\n\n    /**\n     * The friction slip force to use when creating friction equations.\n     * @property slipForce\n     * @type {Number}\n     */\n    this.slipForce = 10.0;\n\n    /**\n     * The friction value to use in the upcoming friction equations.\n     * @property frictionCoefficient\n     * @type {Number}\n     */\n    this.frictionCoefficient = 0.3;\n\n    /**\n     * Will be the .relativeVelocity in each produced FrictionEquation.\n     * @property {Number} surfaceVelocity\n     */\n    this.surfaceVelocity = 0;\n\n    this.reuseObjects = true;\n    this.reusableContactEquations = [];\n    this.reusableFrictionEquations = [];\n\n    /**\n     * The restitution value to use in the next contact equations.\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0;\n\n    /**\n     * The stiffness value to use in the next contact equations.\n     * @property {Number} stiffness\n     */\n    this.stiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The stiffness value to use in the next contact equations.\n     * @property {Number} stiffness\n     */\n    this.relaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * The stiffness value to use in the next friction equations.\n     * @property frictionStiffness\n     * @type {Number}\n     */\n    this.frictionStiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The relaxation value to use in the next friction equations.\n     * @property frictionRelaxation\n     * @type {Number}\n     */\n    this.frictionRelaxation = Equation.DEFAULT_RELAXATION;\n\n\n    // Keep track of the colliding bodies last step\n    this.collidingBodiesLastStep = new TupleDictionary();\n}\n\n/**\n * Check if the bodies were in contact since the last reset().\n * @method collidedLastStep\n * @param  {Body} bi\n * @param  {Body} bj\n * @return {Boolean}\n */\nNarrowphase.prototype.collidedLastStep = function(bi,bj){\n    var id1 = bi.id|0,\n        id2 = bj.id|0;\n    return !!this.collidingBodiesLastStep.get(id1, id2);\n};\n\n// \"for in\" loops aren't optimised in chrome... is there a better way to handle last-step collision memory?\n// Maybe do this: http://jsperf.com/reflection-vs-array-of-keys\nfunction clearObject(obj){\n    var l = obj.keys.length;\n    while(l--){\n        delete obj[obj.keys[l]];\n    }\n    obj.keys.length = 0;\n}\n\n/**\n * Throws away the old equations and gets ready to create new\n * @method reset\n * @param {World} world\n */\nNarrowphase.prototype.reset = function(world){\n    this.collidingBodiesLastStep.reset();\n    for(var i=0; i!==this.contactEquations.length; i++){\n        var eq = this.contactEquations[i],\n            id1 = eq.bodyA.id|0,\n            id2 = eq.bodyB.id|0;\n        this.collidingBodiesLastStep.set(id1, id2, true);\n    }\n\n    if(this.reuseObjects){\n        var ce = this.contactEquations,\n            fe = this.frictionEquations,\n            rfe = this.reusableFrictionEquations,\n            rce = this.reusableContactEquations;\n        Utils.appendArray(rce,ce);\n        Utils.appendArray(rfe,fe);\n    }\n\n    // Reset\n    this.contactEquations.length = this.frictionEquations.length = 0;\n};\n\n/**\n * Creates a ContactEquation, either by reusing an existing object or creating a new one.\n * @method createContactEquation\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {ContactEquation}\n */\nNarrowphase.prototype.createContactEquation = function(bodyA,bodyB,shapeA,shapeB){\n    var c = this.reusableContactEquations.length ? this.reusableContactEquations.pop() : new ContactEquation(bodyA,bodyB);\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.restitution = this.restitution;\n    c.firstImpact = !this.collidedLastStep(bodyA,bodyB);\n    c.stiffness = this.stiffness;\n    c.relaxation = this.relaxation;\n    c.needsUpdate = true;\n    c.enabled = true;\n\n    return c;\n};\n\n/**\n * Creates a FrictionEquation, either by reusing an existing object or creating a new one.\n * @method createFrictionEquation\n * @param  {Body} bodyA\n * @param  {Body} bodyB\n * @return {FrictionEquation}\n */\nNarrowphase.prototype.createFrictionEquation = function(bodyA,bodyB,shapeA,shapeB){\n    var c = this.reusableFrictionEquations.length ? this.reusableFrictionEquations.pop() : new FrictionEquation(bodyA,bodyB);\n    c.bodyA = bodyA;\n    c.bodyB = bodyB;\n    c.shapeA = shapeA;\n    c.shapeB = shapeB;\n    c.setSlipForce(this.slipForce);\n    c.frictionCoefficient = this.frictionCoefficient;\n    c.relativeVelocity = this.surfaceVelocity;\n    c.enabled = true;\n    c.needsUpdate = true;\n    c.stiffness = this.frictionStiffness;\n    c.relaxation = this.frictionRelaxation;\n    return c;\n};\n\n/**\n * Creates a FrictionEquation given the data in the ContactEquation. Uses same offset vectors ri and rj, but the tangent vector will be constructed from the collision normal.\n * @method createFrictionFromContact\n * @param  {ContactEquation} contactEquation\n * @return {FrictionEquation}\n */\nNarrowphase.prototype.createFrictionFromContact = function(c){\n    var eq = this.createFrictionEquation(c.bodyA, c.bodyB, c.shapeA, c.shapeB);\n    vec2.copy(eq.contactPointA, c.contactPointA);\n    vec2.copy(eq.contactPointB, c.contactPointB);\n    vec2.rotate90cw(eq.t, c.normalA);\n    eq.contactEquation = c;\n    return eq;\n};\n\n/**\n * Convex/line narrowphase\n * @method convexLine\n * @param  {Body}       bi\n * @param  {Convex}     si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Line}       sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.CONVEX] =\nNarrowphase.prototype.convexLine = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    // TODO\n    if(justTest)\n        return false;\n    else\n        return 0;\n};\n\n/**\n * Line/rectangle narrowphase\n * @method lineRectangle\n * @param  {Body}       bi\n * @param  {Line}       si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Rectangle}  sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.RECTANGLE] =\nNarrowphase.prototype.lineRectangle = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    // TODO\n    if(justTest)\n        return false;\n    else\n        return 0;\n};\n\nfunction setConvexToCapsuleShapeMiddle(convexShape, capsuleShape){\n    vec2.set(convexShape.vertices[0], -capsuleShape.length * 0.5, -capsuleShape.radius);\n    vec2.set(convexShape.vertices[1],  capsuleShape.length * 0.5, -capsuleShape.radius);\n    vec2.set(convexShape.vertices[2],  capsuleShape.length * 0.5,  capsuleShape.radius);\n    vec2.set(convexShape.vertices[3], -capsuleShape.length * 0.5,  capsuleShape.radius);\n}\n\nvar convexCapsule_tempRect = new Rectangle(1,1),\n    convexCapsule_tempVec = vec2.create();\n\n/**\n * Convex/capsule narrowphase\n * @method convexCapsule\n * @param  {Body}       bi\n * @param  {Convex}     si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Capsule}    sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.CAPSULE | Shape.RECTANGLE] =\nNarrowphase.prototype.convexCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n\n    // Check the circles\n    // Add offsets!\n    var circlePos = convexCapsule_tempVec;\n    vec2.set(circlePos, sj.length/2,0);\n    vec2.rotate(circlePos,circlePos,aj);\n    vec2.add(circlePos,circlePos,xj);\n    var result1 = this.circleConvex(bj,sj,circlePos,aj, bi,si,xi,ai, justTest, sj.radius);\n\n    vec2.set(circlePos,-sj.length/2, 0);\n    vec2.rotate(circlePos,circlePos,aj);\n    vec2.add(circlePos,circlePos,xj);\n    var result2 = this.circleConvex(bj,sj,circlePos,aj, bi,si,xi,ai, justTest, sj.radius);\n\n    if(justTest && (result1 || result2))\n        return true;\n\n    // Check center rect\n    var r = convexCapsule_tempRect;\n    setConvexToCapsuleShapeMiddle(r,sj);\n    var result = this.convexConvex(bi,si,xi,ai, bj,r,xj,aj, justTest);\n\n    return result + result1 + result2;\n};\n\n/**\n * Capsule/line narrowphase\n * @method lineCapsule\n * @param  {Body}       bi\n * @param  {Line}       si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Capsule}    sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.LINE] =\nNarrowphase.prototype.lineCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    // TODO\n    if(justTest)\n        return false;\n    else\n        return 0;\n};\n\nvar capsuleCapsule_tempVec1 = vec2.create();\nvar capsuleCapsule_tempVec2 = vec2.create();\nvar capsuleCapsule_tempRect1 = new Rectangle(1,1);\n\n/**\n * Capsule/capsule narrowphase\n * @method capsuleCapsule\n * @param  {Body}       bi\n * @param  {Capsule}    si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Capsule}    sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.CAPSULE | Shape.CAPSULE] =\nNarrowphase.prototype.capsuleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n\n    // Check the circles\n    // Add offsets!\n    var circlePosi = capsuleCapsule_tempVec1,\n        circlePosj = capsuleCapsule_tempVec2;\n\n    var numContacts = 0;\n\n    // Need 4 circle checks, between all\n    for(var i=0; i<2; i++){\n\n        vec2.set(circlePosi,(i==0?-1:1)*si.length/2,0);\n        vec2.rotate(circlePosi,circlePosi,ai);\n        vec2.add(circlePosi,circlePosi,xi);\n\n        for(var j=0; j<2; j++){\n\n            vec2.set(circlePosj,(j==0?-1:1)*sj.length/2, 0);\n            vec2.rotate(circlePosj,circlePosj,aj);\n            vec2.add(circlePosj,circlePosj,xj);\n\n            var result = this.circleCircle(bi,si,circlePosi,ai, bj,sj,circlePosj,aj, justTest, si.radius, sj.radius);\n\n            if(justTest && result)\n                return true;\n\n            numContacts += result;\n        }\n    }\n\n    // Check circles against the center rectangles\n    var rect = capsuleCapsule_tempRect1;\n    setConvexToCapsuleShapeMiddle(rect,si);\n    var result1 = this.convexCapsule(bi,rect,xi,ai, bj,sj,xj,aj, justTest);\n\n    if(justTest && result1) return true;\n    numContacts += result1;\n\n    setConvexToCapsuleShapeMiddle(rect,sj);\n    var result2 = this.convexCapsule(bj,rect,xj,aj, bi,si,xi,ai, justTest);\n\n    if(justTest && result2) return true;\n    numContacts += result2;\n\n    return numContacts;\n};\n\n/**\n * Line/line narrowphase\n * @method lineLine\n * @param  {Body}       bi\n * @param  {Line}       si\n * @param  {Array}      xi\n * @param  {Number}     ai\n * @param  {Body}       bj\n * @param  {Line}       sj\n * @param  {Array}      xj\n * @param  {Number}     aj\n * @todo Implement me!\n */\nNarrowphase.prototype[Shape.LINE | Shape.LINE] =\nNarrowphase.prototype.lineLine = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    // TODO\n    if(justTest)\n        return false;\n    else\n        return 0;\n};\n\n/**\n * Plane/line Narrowphase\n * @method planeLine\n * @param  {Body}   planeBody\n * @param  {Plane}  planeShape\n * @param  {Array}  planeOffset\n * @param  {Number} planeAngle\n * @param  {Body}   lineBody\n * @param  {Line}   lineShape\n * @param  {Array}  lineOffset\n * @param  {Number} lineAngle\n */\nNarrowphase.prototype[Shape.PLANE | Shape.LINE] =\nNarrowphase.prototype.planeLine = function(planeBody, planeShape, planeOffset, planeAngle,\n                                           lineBody,  lineShape,  lineOffset,  lineAngle, justTest){\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldVertex01 = tmp3,\n        worldVertex11 = tmp4,\n        worldEdge = tmp5,\n        worldEdgeUnit = tmp6,\n        dist = tmp7,\n        worldNormal = tmp8,\n        worldTangent = tmp9,\n        verts = tmpArray\n        numContacts = 0;\n\n    // Get start and end points\n    vec2.set(worldVertex0, -lineShape.length/2, 0);\n    vec2.set(worldVertex1,  lineShape.length/2, 0);\n\n    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n    vec2.rotate(worldVertex01, worldVertex0, lineAngle);\n    vec2.rotate(worldVertex11, worldVertex1, lineAngle);\n\n    add(worldVertex01, worldVertex01, lineOffset);\n    add(worldVertex11, worldVertex11, lineOffset);\n\n    vec2.copy(worldVertex0,worldVertex01);\n    vec2.copy(worldVertex1,worldVertex11);\n\n    // Get vector along the line\n    sub(worldEdge, worldVertex1, worldVertex0);\n    vec2.normalize(worldEdgeUnit, worldEdge);\n\n    // Get tangent to the edge.\n    vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    // Check line ends\n    verts[0] = worldVertex0;\n    verts[1] = worldVertex1;\n    for(var i=0; i<verts.length; i++){\n        var v = verts[i];\n\n        sub(dist, v, planeOffset);\n\n        var d = dot(dist,worldNormal);\n\n        if(d < 0){\n\n            if(justTest)\n                return true;\n\n            var c = this.createContactEquation(planeBody,lineBody,planeShape,lineShape);\n            numContacts++;\n\n            vec2.copy(c.normalA, worldNormal);\n            vec2.normalize(c.normalA,c.normalA);\n\n            // distance vector along plane normal\n            vec2.scale(dist, worldNormal, d);\n\n            // Vector from plane center to contact\n            sub(c.contactPointA, v, dist);\n            sub(c.contactPointA, c.contactPointA, planeBody.position);\n\n            // From line center to contact\n            sub(c.contactPointB, v,    lineOffset);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            // TODO : only need one friction equation if both points touch\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n        }\n    }\n\n    return numContacts;\n};\n\nNarrowphase.prototype[Shape.PARTICLE | Shape.CAPSULE] =\nNarrowphase.prototype.particleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius, 0);\n};\n\n/**\n * Circle/line Narrowphase\n * @method circleLine\n * @param  {Body} bi\n * @param  {Circle} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Line} sj\n * @param  {Array} xj\n * @param  {Number} aj\n * @param {Boolean} justTest If set to true, this function will return the result (intersection or not) without adding equations.\n * @param {Number} lineRadius Radius to add to the line. Can be used to test Capsules.\n * @param {Number} circleRadius If set, this value overrides the circle shape radius.\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.LINE] =\nNarrowphase.prototype.circleLine = function(bi,si,xi,ai, bj,sj,xj,aj, justTest, lineRadius, circleRadius){\n    var lineShape = sj,\n        lineAngle = aj,\n        lineBody = bj,\n        lineOffset = xj,\n        circleOffset = xi,\n        circleBody = bi,\n        circleShape = si,\n\n        lineRadius = lineRadius || 0,\n        circleRadius = typeof(circleRadius)!=\"undefined\" ? circleRadius : circleShape.radius,\n\n        orthoDist = tmp1,\n        lineToCircleOrthoUnit = tmp2,\n        projectedPoint = tmp3,\n        centerDist = tmp4,\n        worldTangent = tmp5,\n        worldEdge = tmp6,\n        worldEdgeUnit = tmp7,\n        worldVertex0 = tmp8,\n        worldVertex1 = tmp9,\n        worldVertex01 = tmp10,\n        worldVertex11 = tmp11,\n        dist = tmp12,\n        lineToCircle = tmp13,\n        lineEndToLineRadius = tmp14,\n\n        verts = tmpArray;\n\n    // Get start and end points\n    vec2.set(worldVertex0, -lineShape.length/2, 0);\n    vec2.set(worldVertex1,  lineShape.length/2, 0);\n\n    // Not sure why we have to use worldVertex*1 here, but it won't work otherwise. Tired.\n    vec2.rotate(worldVertex01, worldVertex0, lineAngle);\n    vec2.rotate(worldVertex11, worldVertex1, lineAngle);\n\n    add(worldVertex01, worldVertex01, lineOffset);\n    add(worldVertex11, worldVertex11, lineOffset);\n\n    vec2.copy(worldVertex0,worldVertex01);\n    vec2.copy(worldVertex1,worldVertex11);\n\n    // Get vector along the line\n    sub(worldEdge, worldVertex1, worldVertex0);\n    vec2.normalize(worldEdgeUnit, worldEdge);\n\n    // Get tangent to the edge.\n    vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n    // Check distance from the plane spanned by the edge vs the circle\n    sub(dist, circleOffset, worldVertex0);\n    var d = dot(dist, worldTangent); // Distance from center of line to circle center\n    sub(centerDist, worldVertex0, lineOffset);\n\n    sub(lineToCircle, circleOffset, lineOffset);\n\n    if(Math.abs(d) < circleRadius+lineRadius){\n\n        // Now project the circle onto the edge\n        vec2.scale(orthoDist, worldTangent, d);\n        sub(projectedPoint, circleOffset, orthoDist);\n\n        // Add the missing line radius\n        vec2.scale(lineToCircleOrthoUnit, worldTangent, dot(worldTangent, lineToCircle));\n        vec2.normalize(lineToCircleOrthoUnit,lineToCircleOrthoUnit);\n        vec2.scale(lineToCircleOrthoUnit, lineToCircleOrthoUnit, lineRadius);\n        add(projectedPoint,projectedPoint,lineToCircleOrthoUnit);\n\n        // Check if the point is within the edge span\n        var pos =  dot(worldEdgeUnit, projectedPoint);\n        var pos0 = dot(worldEdgeUnit, worldVertex0);\n        var pos1 = dot(worldEdgeUnit, worldVertex1);\n\n        if(pos > pos0 && pos < pos1){\n            // We got contact!\n\n            if(justTest) return true;\n\n            var c = this.createContactEquation(circleBody,lineBody,si,sj);\n\n            vec2.scale(c.normalA, orthoDist, -1);\n            vec2.normalize(c.normalA, c.normalA);\n\n            vec2.scale( c.contactPointA, c.normalA,  circleRadius);\n            add(c.contactPointA, c.contactPointA, circleOffset);\n            sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n            sub(c.contactPointB, projectedPoint, lineOffset);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n\n            return 1;\n        }\n    }\n\n    // Add corner\n    // @todo reuse array object\n    verts[0] = worldVertex0;\n    verts[1] = worldVertex1;\n\n    for(var i=0; i<verts.length; i++){\n        var v = verts[i];\n\n        sub(dist, v, circleOffset);\n\n        if(vec2.squaredLength(dist) < (circleRadius+lineRadius)*(circleRadius+lineRadius)){\n\n            if(justTest) return true;\n\n            var c = this.createContactEquation(circleBody,lineBody,si,sj);\n\n            vec2.copy(c.normalA, dist);\n            vec2.normalize(c.normalA,c.normalA);\n\n            // Vector from circle to contact point is the normal times the circle radius\n            vec2.scale(c.contactPointA, c.normalA, circleRadius);\n            add(c.contactPointA, c.contactPointA, circleOffset);\n            sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n            sub(c.contactPointB, v, lineOffset);\n            vec2.scale(lineEndToLineRadius, c.normalA, -lineRadius);\n            add(c.contactPointB, c.contactPointB, lineEndToLineRadius);\n            add(c.contactPointB, c.contactPointB, lineOffset);\n            sub(c.contactPointB, c.contactPointB, lineBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n\n            return 1;\n        }\n    }\n\n    return 0;\n};\n\n/**\n * Circle/capsule Narrowphase\n * @method circleCapsule\n * @param  {Body}   bi\n * @param  {Circle} si\n * @param  {Array}  xi\n * @param  {Number} ai\n * @param  {Body}   bj\n * @param  {Line}   sj\n * @param  {Array}  xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.CAPSULE] =\nNarrowphase.prototype.circleCapsule = function(bi,si,xi,ai, bj,sj,xj,aj, justTest){\n    return this.circleLine(bi,si,xi,ai, bj,sj,xj,aj, justTest, sj.radius);\n};\n\n/**\n * Circle/convex Narrowphase\n * @method circleConvex\n * @param  {Body} bi\n * @param  {Circle} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Convex} sj\n * @param  {Array} xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.CIRCLE | Shape.RECTANGLE] =\nNarrowphase.prototype.circleConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, circleRadius){\n    var convexShape = sj,\n        convexAngle = aj,\n        convexBody = bj,\n        convexOffset = xj,\n        circleOffset = xi,\n        circleBody = bi,\n        circleShape = si,\n        circleRadius = typeof(circleRadius)==\"number\" ? circleRadius : circleShape.radius;\n\n    var worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldEdge = tmp3,\n        worldEdgeUnit = tmp4,\n        worldTangent = tmp5,\n        centerDist = tmp6,\n        convexToCircle = tmp7,\n        orthoDist = tmp8,\n        projectedPoint = tmp9,\n        dist = tmp10,\n        worldVertex = tmp11,\n\n        closestEdge = -1,\n        closestEdgeDistance = null,\n        closestEdgeOrthoDist = tmp12,\n        closestEdgeProjectedPoint = tmp13,\n        candidate = tmp14,\n        candidateDist = tmp15,\n        minCandidate = tmp16,\n\n        found = false,\n        minCandidateDistance = Number.MAX_VALUE;\n\n    var numReported = 0;\n\n    // New algorithm:\n    // 1. Check so center of circle is not inside the polygon. If it is, this wont work...\n    // 2. For each edge\n    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n    // 2. 2. Check if point is inside.\n\n    verts = convexShape.vertices;\n\n    // Check all edges first\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n        sub(worldEdge, worldVertex1, worldVertex0);\n\n        vec2.normalize(worldEdgeUnit, worldEdge);\n\n        // Get tangent to the edge. Points out of the Convex\n        vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n        // Get point on circle, closest to the polygon\n        vec2.scale(candidate,worldTangent,-circleShape.radius);\n        add(candidate,candidate,circleOffset);\n\n        if(pointInConvex(candidate,convexShape,convexOffset,convexAngle)){\n\n            vec2.sub(candidateDist,worldVertex0,candidate);\n            var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));\n\n            /*\n            // Check distance from the plane spanned by the edge vs the circle\n            sub(dist, circleOffset, worldVertex0);\n            var d = dot(dist, worldTangent);\n            sub(centerDist, worldVertex0, convexOffset);\n\n            sub(convexToCircle, circleOffset, convexOffset);\n\n            if(d < circleRadius && dot(centerDist,convexToCircle) > 0){\n\n                // Now project the circle onto the edge\n                vec2.scale(orthoDist, worldTangent, d);\n                sub(projectedPoint, circleOffset, orthoDist);\n\n\n                // Check if the point is within the edge span\n                var pos =  dot(worldEdgeUnit, projectedPoint);\n                var pos0 = dot(worldEdgeUnit, worldVertex0);\n                var pos1 = dot(worldEdgeUnit, worldVertex1);\n\n                if(pos > pos0 && pos < pos1){\n                    // We got contact!\n\n                    if(justTest) return true;\n\n                    if(closestEdgeDistance === null || d*d<closestEdgeDistance*closestEdgeDistance){\n                        closestEdgeDistance = d;\n                        closestEdge = i;\n                        vec2.copy(closestEdgeOrthoDist, orthoDist);\n                        vec2.copy(closestEdgeProjectedPoint, projectedPoint);\n                    }\n                }\n            }\n            */\n\n            if(candidateDistance < minCandidateDistance){\n                vec2.copy(minCandidate,candidate);\n                minCandidateDistance = candidateDistance;\n                vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);\n                vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,candidate);\n                found = true;\n            }\n        }\n    }\n\n    if(found){\n\n        if(justTest)\n            return true;\n\n        var c = this.createContactEquation(circleBody,convexBody,si,sj);\n        vec2.sub(c.normalA, minCandidate, circleOffset)\n        vec2.normalize(c.normalA, c.normalA);\n\n        vec2.scale(c.contactPointA,  c.normalA, circleRadius);\n        add(c.contactPointA, c.contactPointA, circleOffset);\n        sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n        this.contactEquations.push(c);\n\n        if(this.enableFriction)\n            this.frictionEquations.push( this.createFrictionFromContact(c) );\n\n        return 1;\n    }\n\n    /*\n    if(closestEdge != -1){\n        var c = this.createContactEquation(circleBody,convexBody);\n\n        vec2.scale(c.normalA, closestEdgeOrthoDist, -1);\n        vec2.normalize(c.normalA, c.normalA);\n\n        vec2.scale(c.contactPointA,  c.normalA, circleRadius);\n        add(c.contactPointA, c.contactPointA, circleOffset);\n        sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n        this.contactEquations.push(c);\n\n        if(this.enableFriction)\n            this.frictionEquations.push( this.createFrictionFromContact(c) );\n\n        return true;\n    }\n    */\n\n    // Check all vertices\n    if(circleRadius > 0){\n        for(var i=0; i<verts.length; i++){\n            var localVertex = verts[i];\n            vec2.rotate(worldVertex, localVertex, convexAngle);\n            add(worldVertex, worldVertex, convexOffset);\n\n            sub(dist, worldVertex, circleOffset);\n            if(vec2.squaredLength(dist) < circleRadius*circleRadius){\n\n                if(justTest) return true;\n\n                var c = this.createContactEquation(circleBody,convexBody,si,sj);\n\n                vec2.copy(c.normalA, dist);\n                vec2.normalize(c.normalA,c.normalA);\n\n                // Vector from circle to contact point is the normal times the circle radius\n                vec2.scale(c.contactPointA, c.normalA, circleRadius);\n                add(c.contactPointA, c.contactPointA, circleOffset);\n                sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n                sub(c.contactPointB, worldVertex, convexOffset);\n                add(c.contactPointB, c.contactPointB, convexOffset);\n                sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n                this.contactEquations.push(c);\n\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n};\n\n// Check if a point is in a polygon\nvar pic_worldVertex0 = vec2.create(),\n    pic_worldVertex1 = vec2.create(),\n    pic_r0 = vec2.create(),\n    pic_r1 = vec2.create();\nfunction pointInConvex(worldPoint,convexShape,convexOffset,convexAngle){\n    var worldVertex0 = pic_worldVertex0,\n        worldVertex1 = pic_worldVertex1,\n        r0 = pic_r0,\n        r1 = pic_r1,\n        point = worldPoint,\n        verts = convexShape.vertices,\n        lastCross = null;\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        // Transform vertices to world\n        // can we instead transform point to local of the convex???\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n\n        sub(r0, worldVertex0, point);\n        sub(r1, worldVertex1, point);\n        var cross = vec2.crossLength(r0,r1);\n\n        if(lastCross===null) lastCross = cross;\n\n        // If we got a different sign of the distance vector, the point is out of the polygon\n        if(cross*lastCross <= 0){\n            return false;\n        }\n        lastCross = cross;\n    }\n    return true;\n};\n\n/**\n * Particle/convex Narrowphase\n * @method particleConvex\n * @param  {Body} bi\n * @param  {Particle} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Convex} sj\n * @param  {Array} xj\n * @param  {Number} aj\n * @todo use pointInConvex and code more similar to circleConvex\n */\nNarrowphase.prototype[Shape.PARTICLE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.PARTICLE | Shape.RECTANGLE] =\nNarrowphase.prototype.particleConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var convexShape = sj,\n        convexAngle = aj,\n        convexBody = bj,\n        convexOffset = xj,\n        particleOffset = xi,\n        particleBody = bi,\n        particleShape = si,\n        worldVertex0 = tmp1,\n        worldVertex1 = tmp2,\n        worldEdge = tmp3,\n        worldEdgeUnit = tmp4,\n        worldTangent = tmp5,\n        centerDist = tmp6,\n        convexToparticle = tmp7,\n        orthoDist = tmp8,\n        projectedPoint = tmp9,\n        dist = tmp10,\n        worldVertex = tmp11,\n        closestEdge = -1,\n        closestEdgeDistance = null,\n        closestEdgeOrthoDist = tmp12,\n        closestEdgeProjectedPoint = tmp13,\n        r0 = tmp14, // vector from particle to vertex0\n        r1 = tmp15,\n        localPoint = tmp16,\n        candidateDist = tmp17,\n        minEdgeNormal = tmp18,\n        minCandidateDistance = Number.MAX_VALUE;\n\n    var numReported = 0,\n        found = false,\n        verts = convexShape.vertices;\n\n    // Check if the particle is in the polygon at all\n    if(!pointInConvex(particleOffset,convexShape,convexOffset,convexAngle)){\n        return 0;\n    }\n\n    if(justTest) return true;\n\n    // Check edges first\n    var lastCross = null;\n    for(var i=0; i!==verts.length+1; i++){\n        var v0 = verts[i%verts.length],\n            v1 = verts[(i+1)%verts.length];\n\n        // Transform vertices to world\n        vec2.rotate(worldVertex0, v0, convexAngle);\n        vec2.rotate(worldVertex1, v1, convexAngle);\n        add(worldVertex0, worldVertex0, convexOffset);\n        add(worldVertex1, worldVertex1, convexOffset);\n\n        // Get world edge\n        sub(worldEdge, worldVertex1, worldVertex0);\n        vec2.normalize(worldEdgeUnit, worldEdge);\n\n        // Get tangent to the edge. Points out of the Convex\n        vec2.rotate90cw(worldTangent, worldEdgeUnit);\n\n        // Check distance from the infinite line (spanned by the edge) to the particle\n        sub(dist, particleOffset, worldVertex0);\n        var d = dot(dist, worldTangent);\n        sub(centerDist, worldVertex0, convexOffset);\n\n        sub(convexToparticle, particleOffset, convexOffset);\n\n\n        /*\n        if(d < 0 && dot(centerDist,convexToparticle) >= 0){\n\n            // Now project the particle onto the edge\n            vec2.scale(orthoDist, worldTangent, d);\n            sub(projectedPoint, particleOffset, orthoDist);\n\n            // Check if the point is within the edge span\n            var pos =  dot(worldEdgeUnit, projectedPoint);\n            var pos0 = dot(worldEdgeUnit, worldVertex0);\n            var pos1 = dot(worldEdgeUnit, worldVertex1);\n\n            if(pos > pos0 && pos < pos1){\n                // We got contact!\n                if(justTest) return true;\n\n                if(closestEdgeDistance === null || d*d<closestEdgeDistance*closestEdgeDistance){\n                    closestEdgeDistance = d;\n                    closestEdge = i;\n                    vec2.copy(closestEdgeOrthoDist, orthoDist);\n                    vec2.copy(closestEdgeProjectedPoint, projectedPoint);\n                }\n            }\n        }\n        */\n\n        vec2.sub(candidateDist,worldVertex0,particleOffset);\n        var candidateDistance = Math.abs(vec2.dot(candidateDist,worldTangent));\n\n        if(candidateDistance < minCandidateDistance){\n            minCandidateDistance = candidateDistance;\n            vec2.scale(closestEdgeProjectedPoint,worldTangent,candidateDistance);\n            vec2.add(closestEdgeProjectedPoint,closestEdgeProjectedPoint,particleOffset);\n            vec2.copy(minEdgeNormal,worldTangent);\n            found = true;\n        }\n    }\n\n    if(found){\n        var c = this.createContactEquation(particleBody,convexBody,si,sj);\n\n        vec2.scale(c.normalA, minEdgeNormal, -1);\n        vec2.normalize(c.normalA, c.normalA);\n\n        // Particle has no extent to the contact point\n        vec2.set(c.contactPointA,  0, 0);\n        add(c.contactPointA, c.contactPointA, particleOffset);\n        sub(c.contactPointA, c.contactPointA, particleBody.position);\n\n        // From convex center to point\n        sub(c.contactPointB, closestEdgeProjectedPoint, convexOffset);\n        add(c.contactPointB, c.contactPointB, convexOffset);\n        sub(c.contactPointB, c.contactPointB, convexBody.position);\n\n        this.contactEquations.push(c);\n\n        if(this.enableFriction)\n            this.frictionEquations.push( this.createFrictionFromContact(c) );\n\n        return 1;\n    }\n\n\n    return 0;\n};\n\n/**\n * Circle/circle Narrowphase\n * @method circleCircle\n * @param  {Body} bi\n * @param  {Circle} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Circle} sj\n * @param  {Array} xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CIRCLE] =\nNarrowphase.prototype.circleCircle = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, radiusA, radiusB){\n    var bodyA = bi,\n        shapeA = si,\n        offsetA = xi,\n        bodyB = bj,\n        shapeB = sj,\n        offsetB = xj,\n        dist = tmp1,\n        radiusA = radiusA || shapeA.radius,\n        radiusB = radiusB || shapeB.radius;\n\n    sub(dist,xi,xj);\n    var r = radiusA + radiusB;\n    if(vec2.squaredLength(dist) > r*r){\n        return 0;\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    var c = this.createContactEquation(bodyA,bodyB,si,sj);\n    sub(c.normalA, offsetB, offsetA);\n    vec2.normalize(c.normalA,c.normalA);\n\n    vec2.scale( c.contactPointA, c.normalA,  radiusA);\n    vec2.scale( c.contactPointB, c.normalA, -radiusB);\n\n    add(c.contactPointA, c.contactPointA, offsetA);\n    sub(c.contactPointA, c.contactPointA, bodyA.position);\n\n    add(c.contactPointB, c.contactPointB, offsetB);\n    sub(c.contactPointB, c.contactPointB, bodyB.position);\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n    return 1;\n};\n\n/**\n * Plane/Convex Narrowphase\n * @method planeConvex\n * @param  {Body} bi\n * @param  {Plane} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Convex} sj\n * @param  {Array} xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.PLANE | Shape.CONVEX] =\nNarrowphase.prototype[Shape.PLANE | Shape.RECTANGLE] =\nNarrowphase.prototype.planeConvex = function( bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var convexBody = bj,\n        convexOffset = xj,\n        convexShape = sj,\n        convexAngle = aj,\n        planeBody = bi,\n        planeShape = si,\n        planeOffset = xi,\n        planeAngle = ai;\n\n    var worldVertex = tmp1,\n        worldNormal = tmp2,\n        dist = tmp3;\n\n    var numReported = 0;\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    for(var i=0; i<convexShape.vertices.length; i++){\n        var v = convexShape.vertices[i];\n        vec2.rotate(worldVertex, v, convexAngle);\n        add(worldVertex, worldVertex, convexOffset);\n\n        sub(dist, worldVertex, planeOffset);\n\n        if(dot(dist,worldNormal) <= Narrowphase.convexPrecision){\n\n            if(justTest){\n                return true;\n            }\n\n            // Found vertex\n            numReported++;\n\n            var c = this.createContactEquation(planeBody,convexBody,planeShape,convexShape);\n\n            sub(dist, worldVertex, planeOffset);\n\n            vec2.copy(c.normalA, worldNormal);\n\n            var d = dot(dist, c.normalA);\n            vec2.scale(dist, c.normalA, d);\n\n            // rj is from convex center to contact\n            sub(c.contactPointB, worldVertex, convexBody.position);\n\n\n            // ri is from plane center to contact\n            sub( c.contactPointA, worldVertex, dist);\n            sub( c.contactPointA, c.contactPointA, planeBody.position);\n\n            this.contactEquations.push(c);\n            if(this.enableFriction){\n                this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n        }\n    }\n\n    return numReported;\n};\n\n/**\n * @method convexPlane\n * @deprecated Use .planeConvex() instead!\n */\nNarrowphase.prototype.convexPlane = function( bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    console.warn(\"Narrowphase.prototype.convexPlane is deprecated. Use planeConvex instead!\");\n    return this.planeConvex( bj,sj,xj,aj, bi,si,xi,ai, justTest );\n}\n\n/**\n * Narrowphase for particle vs plane\n * @method particlePlane\n * @param  {Body}       bi The particle body\n * @param  {Particle}   si Particle shape\n * @param  {Array}      xi World position for the particle\n * @param  {Number}     ai World angle for the particle\n * @param  {Body}       bj Plane body\n * @param  {Plane}      sj Plane shape\n * @param  {Array}      xj World position for the plane\n * @param  {Number}     aj World angle for the plane\n */\nNarrowphase.prototype[Shape.PARTICLE | Shape.PLANE] =\nNarrowphase.prototype.particlePlane = function( bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var particleBody = bi,\n        particleShape = si,\n        particleOffset = xi,\n        planeBody = bj,\n        planeShape = sj,\n        planeOffset = xj,\n        planeAngle = aj;\n\n    var dist = tmp1,\n        worldNormal = tmp2;\n\n    planeAngle = planeAngle || 0;\n\n    sub(dist, particleOffset, planeOffset);\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    var d = dot(dist, worldNormal);\n\n    if(d > 0) return 0;\n    if(justTest) return true;\n\n    var c = this.createContactEquation(planeBody,particleBody,sj,si);\n\n    vec2.copy(c.normalA, worldNormal);\n    vec2.scale( dist, c.normalA, d );\n    // dist is now the distance vector in the normal direction\n\n    // ri is the particle position projected down onto the plane, from the plane center\n    sub( c.contactPointA, particleOffset, dist);\n    sub( c.contactPointA, c.contactPointA, planeBody.position);\n\n    // rj is from the body center to the particle center\n    sub( c.contactPointB, particleOffset, particleBody.position );\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n    return 1;\n};\n\n/**\n * Circle/Particle Narrowphase\n * @method circleParticle\n * @param  {Body} bi\n * @param  {Circle} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Particle} sj\n * @param  {Array} xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.PARTICLE] =\nNarrowphase.prototype.circleParticle = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var circleBody = bi,\n        circleShape = si,\n        circleOffset = xi,\n        particleBody = bj,\n        particleShape = sj,\n        particleOffset = xj,\n        dist = tmp1;\n\n    sub(dist, particleOffset, circleOffset);\n    if(vec2.squaredLength(dist) > circleShape.radius*circleShape.radius) return 0;\n    if(justTest) return true;\n\n    var c = this.createContactEquation(circleBody,particleBody,si,sj);\n    vec2.copy(c.normalA, dist);\n    vec2.normalize(c.normalA,c.normalA);\n\n    // Vector from circle to contact point is the normal times the circle radius\n    vec2.scale(c.contactPointA, c.normalA, circleShape.radius);\n    add(c.contactPointA, c.contactPointA, circleOffset);\n    sub(c.contactPointA, c.contactPointA, circleBody.position);\n\n    // Vector from particle center to contact point is zero\n    sub(c.contactPointB, particleOffset, particleBody.position);\n\n    this.contactEquations.push(c);\n\n    if(this.enableFriction){\n        this.frictionEquations.push(this.createFrictionFromContact(c));\n    }\n\n    return 1;\n};\n\nvar capsulePlane_tmpCircle = new Circle(1),\n    capsulePlane_tmp1 = vec2.create(),\n    capsulePlane_tmp2 = vec2.create(),\n    capsulePlane_tmp3 = vec2.create();\n\nNarrowphase.prototype[Shape.PLANE | Shape.CAPSULE] =\nNarrowphase.prototype.planeCapsule = function( bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var end1 = capsulePlane_tmp1,\n        end2 = capsulePlane_tmp2,\n        circle = capsulePlane_tmpCircle,\n        dst = capsulePlane_tmp3;\n\n    // Compute world end positions\n    vec2.set(end1, -sj.length/2, 0);\n    vec2.rotate(end1,end1,aj);\n    add(end1,end1,xj);\n\n    vec2.set(end2,  sj.length/2, 0);\n    vec2.rotate(end2,end2,aj);\n    add(end2,end2,xj);\n\n    circle.radius = sj.radius;\n\n    // Do Narrowphase as two circles\n    var numContacts1 = this.circlePlane(bj,circle,end1,0, bi,si,xi,ai, justTest),\n        numContacts2 = this.circlePlane(bj,circle,end2,0, bi,si,xi,ai, justTest);\n\n    if(justTest)\n        return numContacts1 || numContacts2;\n    else\n        return numContacts1 + numContacts2;\n};\n\n/**\n * @method capsulePlane\n * @deprecated Use .planeCapsule() instead!\n */\nNarrowphase.prototype.capsulePlane = function( bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    console.warn(\"Narrowphase.prototype.capsulePlane() is deprecated. Use .planeCapsule() instead!\");\n    return this.planeCapsule( bj,sj,xj,aj, bi,si,xi,ai, justTest );\n}\n\n/**\n * Creates ContactEquations and FrictionEquations for a collision.\n * @method circlePlane\n * @param  {Body}    bi     The first body that should be connected to the equations.\n * @param  {Circle}  si     The circle shape participating in the collision.\n * @param  {Array}   xi     Extra offset to take into account for the Shape, in addition to the one in circleBody.position. Will *not* be rotated by circleBody.angle (maybe it should, for sake of homogenity?). Set to null if none.\n * @param  {Body}    bj     The second body that should be connected to the equations.\n * @param  {Plane}   sj     The Plane shape that is participating\n * @param  {Array}   xj     Extra offset for the plane shape.\n * @param  {Number}  aj     Extra angle to apply to the plane\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.PLANE] =\nNarrowphase.prototype.circlePlane = function(   bi,si,xi,ai, bj,sj,xj,aj, justTest ){\n    var circleBody = bi,\n        circleShape = si,\n        circleOffset = xi, // Offset from body center, rotated!\n        planeBody = bj,\n        shapeB = sj,\n        planeOffset = xj,\n        planeAngle = aj;\n\n    planeAngle = planeAngle || 0;\n\n    // Vector from plane to circle\n    var planeToCircle = tmp1,\n        worldNormal = tmp2,\n        temp = tmp3;\n\n    sub(planeToCircle, circleOffset, planeOffset);\n\n    // World plane normal\n    vec2.rotate(worldNormal, yAxis, planeAngle);\n\n    // Normal direction distance\n    var d = dot(worldNormal, planeToCircle);\n\n    if(d > circleShape.radius){\n        return 0; // No overlap. Abort.\n    }\n\n    if(justTest){\n        return true;\n    }\n\n    // Create contact\n    var contact = this.createContactEquation(planeBody,circleBody,sj,si);\n\n    // ni is the plane world normal\n    vec2.copy(contact.normalA, worldNormal);\n\n    // rj is the vector from circle center to the contact point\n    vec2.scale(contact.contactPointB, contact.normalA, -circleShape.radius);\n    add(contact.contactPointB, contact.contactPointB, circleOffset);\n    sub(contact.contactPointB, contact.contactPointB, circleBody.position);\n\n    // ri is the distance from plane center to contact.\n    vec2.scale(temp, contact.normalA, d);\n    sub(contact.contactPointA, planeToCircle, temp ); // Subtract normal distance vector from the distance vector\n    add(contact.contactPointA, contact.contactPointA, planeOffset);\n    sub(contact.contactPointA, contact.contactPointA, planeBody.position);\n\n    this.contactEquations.push(contact);\n\n    if(this.enableFriction){\n        this.frictionEquations.push( this.createFrictionFromContact(contact) );\n    }\n\n    return 1;\n};\n\nNarrowphase.convexPrecision = 1e-7;\n\n/**\n * Convex/convex Narrowphase.See <a href=\"http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/\">this article</a> for more info.\n * @method convexConvex\n * @param  {Body} bi\n * @param  {Convex} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Convex} sj\n * @param  {Array} xj\n * @param  {Number} aj\n */\nNarrowphase.prototype[Shape.CONVEX] =\nNarrowphase.prototype[Shape.CONVEX | Shape.RECTANGLE] =\nNarrowphase.prototype[Shape.RECTANGLE] =\nNarrowphase.prototype.convexConvex = function(  bi,si,xi,ai, bj,sj,xj,aj, justTest, precision ){\n    var sepAxis = tmp1,\n        worldPoint = tmp2,\n        worldPoint0 = tmp3,\n        worldPoint1 = tmp4,\n        worldEdge = tmp5,\n        projected = tmp6,\n        penetrationVec = tmp7,\n        dist = tmp8,\n        worldNormal = tmp9,\n        numContacts = 0,\n        precision = precision || Narrowphase.convexPrecision;\n\n    var found = Narrowphase.findSeparatingAxis(si,xi,ai,sj,xj,aj,sepAxis);\n    if(!found){\n        return 0;\n    }\n\n    // Make sure the separating axis is directed from shape i to shape j\n    sub(dist,xj,xi);\n    if(dot(sepAxis,dist) > 0){\n        vec2.scale(sepAxis,sepAxis,-1);\n    }\n\n    // Find edges with normals closest to the separating axis\n    var closestEdge1 = Narrowphase.getClosestEdge(si,ai,sepAxis,true), // Flipped axis\n        closestEdge2 = Narrowphase.getClosestEdge(sj,aj,sepAxis);\n\n    if(closestEdge1 === -1 || closestEdge2 === -1){\n        return 0;\n    }\n\n    // Loop over the shapes\n    for(var k=0; k<2; k++){\n\n        var closestEdgeA = closestEdge1,\n            closestEdgeB = closestEdge2,\n            shapeA =  si, shapeB =  sj,\n            offsetA = xi, offsetB = xj,\n            angleA = ai, angleB = aj,\n            bodyA = bi, bodyB = bj;\n\n        if(k === 0){\n            // Swap!\n            var tmp;\n            tmp = closestEdgeA; closestEdgeA = closestEdgeB;    closestEdgeB = tmp;\n            tmp = shapeA;       shapeA = shapeB;                shapeB = tmp;\n            tmp = offsetA;      offsetA = offsetB;              offsetB = tmp;\n            tmp = angleA;       angleA = angleB;                angleB = tmp;\n            tmp = bodyA;        bodyA = bodyB;                  bodyB = tmp;\n        }\n\n        // Loop over 2 points in convex B\n        for(var j=closestEdgeB; j<closestEdgeB+2; j++){\n\n            // Get world point\n            var v = shapeB.vertices[(j+shapeB.vertices.length)%shapeB.vertices.length];\n            vec2.rotate(worldPoint, v, angleB);\n            add(worldPoint, worldPoint, offsetB);\n\n            var insideNumEdges = 0;\n\n            // Loop over the 3 closest edges in convex A\n            for(var i=closestEdgeA-1; i<closestEdgeA+2; i++){\n\n                var v0 = shapeA.vertices[(i  +shapeA.vertices.length)%shapeA.vertices.length],\n                    v1 = shapeA.vertices[(i+1+shapeA.vertices.length)%shapeA.vertices.length];\n\n                // Construct the edge\n                vec2.rotate(worldPoint0, v0, angleA);\n                vec2.rotate(worldPoint1, v1, angleA);\n                add(worldPoint0, worldPoint0, offsetA);\n                add(worldPoint1, worldPoint1, offsetA);\n\n                sub(worldEdge, worldPoint1, worldPoint0);\n\n                vec2.rotate90cw(worldNormal, worldEdge); // Normal points out of convex 1\n                vec2.normalize(worldNormal,worldNormal);\n\n                sub(dist, worldPoint, worldPoint0);\n\n                var d = dot(worldNormal,dist);\n\n                if(d <= precision){\n                    insideNumEdges++;\n                }\n            }\n\n            if(insideNumEdges >= 3){\n\n                if(justTest){\n                    return true;\n                }\n\n                // worldPoint was on the \"inside\" side of each of the 3 checked edges.\n                // Project it to the center edge and use the projection direction as normal\n\n                // Create contact\n                var c = this.createContactEquation(bodyA,bodyB,shapeA,shapeB);\n                numContacts++;\n\n                // Get center edge from body A\n                var v0 = shapeA.vertices[(closestEdgeA)   % shapeA.vertices.length],\n                    v1 = shapeA.vertices[(closestEdgeA+1) % shapeA.vertices.length];\n\n                // Construct the edge\n                vec2.rotate(worldPoint0, v0, angleA);\n                vec2.rotate(worldPoint1, v1, angleA);\n                add(worldPoint0, worldPoint0, offsetA);\n                add(worldPoint1, worldPoint1, offsetA);\n\n                sub(worldEdge, worldPoint1, worldPoint0);\n\n                vec2.rotate90cw(c.normalA, worldEdge); // Normal points out of convex A\n                vec2.normalize(c.normalA,c.normalA);\n\n                sub(dist, worldPoint, worldPoint0); // From edge point to the penetrating point\n                var d = dot(c.normalA,dist);             // Penetration\n                vec2.scale(penetrationVec, c.normalA, d);     // Vector penetration\n\n                sub(c.contactPointA, worldPoint, offsetA);\n                sub(c.contactPointA, c.contactPointA, penetrationVec);\n                add(c.contactPointA, c.contactPointA, offsetA);\n                sub(c.contactPointA, c.contactPointA, bodyA.position);\n\n                sub(c.contactPointB, worldPoint, offsetB);\n                add(c.contactPointB, c.contactPointB, offsetB);\n                sub(c.contactPointB, c.contactPointB, bodyB.position);\n\n                this.contactEquations.push(c);\n\n                // Todo reduce to 1 friction equation if we have 2 contact points\n                if(this.enableFriction)\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n            }\n        }\n    }\n\n    return numContacts;\n};\n\n// .projectConvex is called by other functions, need local tmp vectors\nvar pcoa_tmp1 = vec2.fromValues(0,0);\n\n/**\n * Project a Convex onto a world-oriented axis\n * @method projectConvexOntoAxis\n * @static\n * @param  {Convex} convexShape\n * @param  {Array} convexOffset\n * @param  {Number} convexAngle\n * @param  {Array} worldAxis\n * @param  {Array} result\n */\nNarrowphase.projectConvexOntoAxis = function(convexShape, convexOffset, convexAngle, worldAxis, result){\n    var max=null,\n        min=null,\n        v,\n        value,\n        localAxis = pcoa_tmp1;\n\n    // Convert the axis to local coords of the body\n    vec2.rotate(localAxis, worldAxis, -convexAngle);\n\n    // Get projected position of all vertices\n    for(var i=0; i<convexShape.vertices.length; i++){\n        v = convexShape.vertices[i];\n        value = dot(v,localAxis);\n        if(max === null || value > max) max = value;\n        if(min === null || value < min) min = value;\n    }\n\n    if(min > max){\n        var t = min;\n        min = max;\n        max = t;\n    }\n\n    // Project the position of the body onto the axis - need to add this to the result\n    var offset = dot(convexOffset, worldAxis);\n\n    vec2.set( result, min + offset, max + offset);\n};\n\n// .findSeparatingAxis is called by other functions, need local tmp vectors\nvar fsa_tmp1 = vec2.fromValues(0,0)\n,   fsa_tmp2 = vec2.fromValues(0,0)\n,   fsa_tmp3 = vec2.fromValues(0,0)\n,   fsa_tmp4 = vec2.fromValues(0,0)\n,   fsa_tmp5 = vec2.fromValues(0,0)\n,   fsa_tmp6 = vec2.fromValues(0,0)\n\n/**\n * Find a separating axis between the shapes, that maximizes the separating distance between them.\n * @method findSeparatingAxis\n * @static\n * @param  {Convex}     c1\n * @param  {Array}      offset1\n * @param  {Number}     angle1\n * @param  {Convex}     c2\n * @param  {Array}      offset2\n * @param  {Number}     angle2\n * @param  {Array}      sepAxis     The resulting axis\n * @return {Boolean}                Whether the axis could be found.\n */\nNarrowphase.findSeparatingAxis = function(c1,offset1,angle1,c2,offset2,angle2,sepAxis){\n    var maxDist = null,\n        overlap = false,\n        found = false,\n        edge = fsa_tmp1,\n        worldPoint0 = fsa_tmp2,\n        worldPoint1 = fsa_tmp3,\n        normal = fsa_tmp4,\n        span1 = fsa_tmp5,\n        span2 = fsa_tmp6;\n\n    for(var j=0; j!==2; j++){\n        var c = c1,\n            angle = angle1;\n        if(j===1){\n            c = c2;\n            angle = angle2;\n        }\n\n        for(var i=0; i!==c.vertices.length; i++){\n            // Get the world edge\n            vec2.rotate(worldPoint0, c.vertices[i], angle);\n            vec2.rotate(worldPoint1, c.vertices[(i+1)%c.vertices.length], angle);\n\n            sub(edge, worldPoint1, worldPoint0);\n\n            // Get normal - just rotate 90 degrees since vertices are given in CCW\n            vec2.rotate90cw(normal, edge);\n            vec2.normalize(normal,normal);\n\n            // Project hulls onto that normal\n            Narrowphase.projectConvexOntoAxis(c1,offset1,angle1,normal,span1);\n            Narrowphase.projectConvexOntoAxis(c2,offset2,angle2,normal,span2);\n\n            // Order by span position\n            var a=span1,\n                b=span2,\n                swapped = false;\n            if(span1[0] > span2[0]){\n                b=span1;\n                a=span2;\n                swapped = true;\n            }\n\n            // Get separating distance\n            var dist = b[0] - a[1];\n            overlap = (dist <= Narrowphase.convexPrecision);\n\n            if(maxDist===null || dist > maxDist){\n                vec2.copy(sepAxis, normal);\n                maxDist = dist;\n                found = overlap;\n            }\n        }\n    }\n\n    return found;\n};\n\n// .getClosestEdge is called by other functions, need local tmp vectors\nvar gce_tmp1 = vec2.fromValues(0,0)\n,   gce_tmp2 = vec2.fromValues(0,0)\n,   gce_tmp3 = vec2.fromValues(0,0)\n\n/**\n * Get the edge that has a normal closest to an axis.\n * @method getClosestEdge\n * @static\n * @param  {Convex}     c\n * @param  {Number}     angle\n * @param  {Array}      axis\n * @param  {Boolean}    flip\n * @return {Number}             Index of the edge that is closest. This index and the next spans the resulting edge. Returns -1 if failed.\n */\nNarrowphase.getClosestEdge = function(c,angle,axis,flip){\n    var localAxis = gce_tmp1,\n        edge = gce_tmp2,\n        normal = gce_tmp3;\n\n    // Convert the axis to local coords of the body\n    vec2.rotate(localAxis, axis, -angle);\n    if(flip){\n        vec2.scale(localAxis,localAxis,-1);\n    }\n\n    var closestEdge = -1,\n        N = c.vertices.length;\n    for(var i=0; i!==N; i++){\n        // Get the edge\n        sub(edge, c.vertices[(i+1)%N], c.vertices[i%N]);\n\n        // Get normal - just rotate 90 degrees since vertices are given in CCW\n        vec2.rotate90cw(normal, edge);\n        vec2.normalize(normal,normal);\n\n        var d = dot(normal,localAxis);\n        if(closestEdge == -1 || d > maxDot){\n            closestEdge = i % N;\n            maxDot = d;\n        }\n    }\n\n    return closestEdge;\n};\n\nvar circleHeightfield_candidate = vec2.create(),\n    circleHeightfield_dist = vec2.create(),\n    circleHeightfield_v0 = vec2.create(),\n    circleHeightfield_v1 = vec2.create(),\n    circleHeightfield_minCandidate = vec2.create(),\n    circleHeightfield_worldNormal = vec2.create(),\n    circleHeightfield_minCandidateNormal = vec2.create();\n\n/**\n * @method circleHeightfield\n * @param  {Body}           bi\n * @param  {Circle}         si\n * @param  {Array}          xi\n * @param  {Body}           bj\n * @param  {Heightfield}    sj\n * @param  {Array}          xj\n * @param  {Number}         aj\n */\nNarrowphase.prototype[Shape.CIRCLE | Shape.HEIGHTFIELD] =\nNarrowphase.prototype.circleHeightfield = function( circleBody,circleShape,circlePos,circleAngle,\n                                                    hfBody,hfShape,hfPos,hfAngle, justTest, radius ){\n    var data = hfShape.data,\n        radius = radius || circleShape.radius,\n        w = hfShape.elementWidth,\n        dist = circleHeightfield_dist,\n        candidate = circleHeightfield_candidate,\n        minCandidate = circleHeightfield_minCandidate,\n        minCandidateNormal = circleHeightfield_minCandidateNormal,\n        worldNormal = circleHeightfield_worldNormal,\n        v0 = circleHeightfield_v0,\n        v1 = circleHeightfield_v1;\n\n    // Get the index of the points to test against\n    var idxA = Math.floor( (circlePos[0] - radius - hfPos[0]) / w ),\n        idxB = Math.ceil(  (circlePos[0] + radius - hfPos[0]) / w );\n\n    /*if(idxB < 0 || idxA >= data.length)\n        return justTest ? false : 0;*/\n\n    if(idxA < 0) idxA = 0;\n    if(idxB >= data.length) idxB = data.length-1;\n\n    // Get max and min\n    var max = data[idxA],\n        min = data[idxB];\n    for(var i=idxA; i<idxB; i++){\n        if(data[i] < min) min = data[i];\n        if(data[i] > max) max = data[i];\n    }\n\n    if(circlePos[1]-radius > max)\n        return justTest ? false : 0;\n\n    if(circlePos[1]+radius < min){\n        // Below the minimum point... We can just guess.\n        // TODO\n    }\n\n    // 1. Check so center of circle is not inside the field. If it is, this wont work...\n    // 2. For each edge\n    // 2. 1. Get point on circle that is closest to the edge (scale normal with -radius)\n    // 2. 2. Check if point is inside.\n\n    var found = false;\n\n    // Check all edges first\n    for(var i=idxA; i<idxB; i++){\n\n        // Get points\n        vec2.set(v0,     i*w, data[i]  );\n        vec2.set(v1, (i+1)*w, data[i+1]);\n        vec2.add(v0,v0,hfPos);\n        vec2.add(v1,v1,hfPos);\n\n        // Get normal\n        vec2.sub(worldNormal, v1, v0);\n        vec2.rotate(worldNormal, worldNormal, Math.PI/2);\n        vec2.normalize(worldNormal,worldNormal);\n\n        // Get point on circle, closest to the edge\n        vec2.scale(candidate,worldNormal,-radius);\n        vec2.add(candidate,candidate,circlePos);\n\n        // Distance from v0 to the candidate point\n        vec2.sub(dist,candidate,v0);\n\n        // Check if it is in the element \"stick\"\n        var d = vec2.dot(dist,worldNormal);\n        if(candidate[0] >= v0[0] && candidate[0] < v1[0] && d <= 0){\n\n            if(justTest){\n                return true;\n            }\n\n            found = true;\n\n            // Store the candidate point, projected to the edge\n            vec2.scale(dist,worldNormal,-d);\n            vec2.add(minCandidate,candidate,dist);\n            vec2.copy(minCandidateNormal,worldNormal);\n\n            var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n            // Normal is out of the heightfield\n            vec2.copy(c.normalA, minCandidateNormal);\n\n            // Vector from circle to heightfield\n            vec2.scale(c.contactPointB,  c.normalA, -radius);\n            add(c.contactPointB, c.contactPointB, circlePos);\n            sub(c.contactPointB, c.contactPointB, circleBody.position);\n\n            vec2.copy(c.contactPointA, minCandidate);\n            vec2.sub(c.contactPointA, c.contactPointA, hfBody.position);\n\n            this.contactEquations.push(c);\n\n            if(this.enableFriction){\n                this.frictionEquations.push( this.createFrictionFromContact(c) );\n            }\n        }\n    }\n\n    // Check all vertices\n    found = false;\n    if(radius > 0){\n        for(var i=idxA; i<=idxB; i++){\n\n            // Get point\n            vec2.set(v0, i*w, data[i]);\n            vec2.add(v0,v0,hfPos);\n\n            vec2.sub(dist, circlePos, v0);\n\n            if(vec2.squaredLength(dist) < radius*radius){\n\n                if(justTest) return true;\n\n                found = true;\n\n                var c = this.createContactEquation(hfBody,circleBody,hfShape,circleShape);\n\n                // Construct normal - out of heightfield\n                vec2.copy(c.normalA, dist);\n                vec2.normalize(c.normalA,c.normalA);\n\n                vec2.scale(c.contactPointB, c.normalA, -radius);\n                add(c.contactPointB, c.contactPointB, circlePos);\n                sub(c.contactPointB, c.contactPointB, circleBody.position);\n\n                sub(c.contactPointA, v0, hfPos);\n                add(c.contactPointA, c.contactPointA, hfPos);\n                sub(c.contactPointA, c.contactPointA, hfBody.position);\n\n                this.contactEquations.push(c);\n\n                if(this.enableFriction){\n                    this.frictionEquations.push(this.createFrictionFromContact(c));\n                }\n            }\n        }\n    }\n\n    if(found){\n        return 1;\n    }\n\n    return 0;\n\n};\n\nvar convexHeightfield_v0 = vec2.create(),\n    convexHeightfield_v1 = vec2.create(),\n    convexHeightfield_tilePos = vec2.create(),\n    convexHeightfield_tempConvexShape = new Convex([vec2.create(),vec2.create(),vec2.create(),vec2.create()]);\n/**\n * @method circleHeightfield\n * @param  {Body}           bi\n * @param  {Circle}         si\n * @param  {Array}          xi\n * @param  {Body}           bj\n * @param  {Heightfield}    sj\n * @param  {Array}          xj\n * @param  {Number}         aj\n */\nNarrowphase.prototype[Shape.RECTANGLE | Shape.HEIGHTFIELD] =\nNarrowphase.prototype[Shape.CONVEX | Shape.HEIGHTFIELD] =\nNarrowphase.prototype.convexHeightfield = function( convexBody,convexShape,convexPos,convexAngle,\n                                                    hfBody,hfShape,hfPos,hfAngle, justTest ){\n    var data = hfShape.data,\n        w = hfShape.elementWidth,\n        v0 = convexHeightfield_v0,\n        v1 = convexHeightfield_v1,\n        tilePos = convexHeightfield_tilePos,\n        tileConvex = convexHeightfield_tempConvexShape;\n\n    // Get the index of the points to test against\n    var idxA = Math.floor( (convexBody.aabb.lowerBound[0] - hfPos[0]) / w ),\n        idxB = Math.ceil(  (convexBody.aabb.upperBound[0] - hfPos[0]) / w );\n\n    if(idxA < 0) idxA = 0;\n    if(idxB >= data.length) idxB = data.length-1;\n\n    // Get max and min\n    var max = data[idxA],\n        min = data[idxB];\n    for(var i=idxA; i<idxB; i++){\n        if(data[i] < min) min = data[i];\n        if(data[i] > max) max = data[i];\n    }\n\n    if(convexBody.aabb.lowerBound[1] > max){\n        return justTest ? false : 0;\n    }\n\n    var found = false;\n    var numContacts = 0;\n\n    // Loop over all edges\n    for(var i=idxA; i<idxB; i++){\n\n        // Get points\n        vec2.set(v0,     i*w, data[i]  );\n        vec2.set(v1, (i+1)*w, data[i+1]);\n        vec2.add(v0,v0,hfPos);\n        vec2.add(v1,v1,hfPos);\n\n        // Construct a convex\n        var tileHeight = 100; // todo\n        vec2.set(tilePos, (v1[0] + v0[0])*0.5, (v1[1] + v0[1] - tileHeight)*0.5);\n\n        vec2.sub(tileConvex.vertices[0], v1, tilePos);\n        vec2.sub(tileConvex.vertices[1], v0, tilePos);\n        vec2.copy(tileConvex.vertices[2], tileConvex.vertices[1]);\n        vec2.copy(tileConvex.vertices[3], tileConvex.vertices[0]);\n        tileConvex.vertices[2][1] -= tileHeight;\n        tileConvex.vertices[3][1] -= tileHeight;\n\n        // Do convex collision\n        numContacts += this.convexConvex(   convexBody, convexShape, convexPos, convexAngle,\n                                            hfBody, tileConvex, tilePos, 0, justTest);\n    }\n\n    return numContacts;\n};\n},{\"../equations/ContactEquation\":21,\"../equations/Equation\":22,\"../equations/FrictionEquation\":23,\"../math/vec2\":30,\"../objects/Body\":31,\"../shapes/Circle\":35,\"../shapes/Convex\":36,\"../shapes/Rectangle\":41,\"../shapes/Shape\":42,\"../utils/TupleDictionary\":46,\"../utils/Utils\":47}],13:[function(require,module,exports){\nvar Utils = require('../utils/Utils')\n,   Broadphase = require('../collision/Broadphase');\n\nmodule.exports = SAPBroadphase;\n\n/**\n * Sweep and prune broadphase along one axis.\n *\n * @class SAPBroadphase\n * @constructor\n * @extends Broadphase\n */\nfunction SAPBroadphase(){\n    Broadphase.call(this,Broadphase.SAP);\n\n    /**\n     * List of bodies currently in the broadphase.\n     * @property axisList\n     * @type {Array}\n     */\n    this.axisList = [];\n\n    /**\n     * The world to search in.\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * The axis to sort along.\n     * @property axisIndex\n     * @type {Number}\n     */\n    this.axisIndex = 0;\n\n    var axisList = this.axisList;\n\n    this._addBodyHandler = function(e){\n        axisList.push(e.body);\n    };\n\n    this._removeBodyHandler = function(e){\n        // Remove from list\n        var idx = axisList.indexOf(e.body);\n        if(idx !== -1){\n            axisList.splice(idx,1);\n        }\n    };\n}\nSAPBroadphase.prototype = new Broadphase();\n\n/**\n * Change the world\n * @method setWorld\n * @param  {World} world\n */\nSAPBroadphase.prototype.setWorld = function(world){\n    // Clear the old axis array\n    this.axisList.length = 0;\n\n    // Add all bodies from the new world\n    Utils.appendArray(this.axisList, world.bodies);\n\n    // Remove old handlers, if any\n    world\n        .off(\"addBody\",this._addBodyHandler)\n        .off(\"removeBody\",this._removeBodyHandler);\n\n    // Add handlers to update the list of bodies.\n    world.on(\"addBody\",this._addBodyHandler).on(\"removeBody\",this._removeBodyHandler);\n\n    this.world = world;\n};\n\n/**\n * Sorts bodies along an axis.\n * @method sortAxisList\n * @param {Array} a\n * @param {number} axisIndex\n * @return {Array}\n */\nSAPBroadphase.sortAxisList = function(a, axisIndex){\n    axisIndex = axisIndex|0;\n    for(var i=1,l=a.length; i<l; i++) {\n        var v = a[i];\n        for(var j=i - 1;j>=0;j--) {\n            if(a[j].aabb.lowerBound[axisIndex] <= v.aabb.lowerBound[axisIndex]){\n                break;\n            }\n            a[j+1] = a[j];\n        }\n        a[j+1] = v;\n    }\n    return a;\n};\n\n/**\n * Get the colliding pairs\n * @method getCollisionPairs\n * @param  {World} world\n * @return {Array}\n */\nSAPBroadphase.prototype.getCollisionPairs = function(world){\n    var bodies = this.axisList,\n        result = this.result,\n        axisIndex = this.axisIndex;\n\n    result.length = 0;\n\n    // Update all AABBs if needed\n    var l = bodies.length;\n    while(l--){\n        var b = bodies[l];\n        if(b.aabbNeedsUpdate){\n            b.updateAABB();\n        }\n    }\n\n    // Sort the lists\n    SAPBroadphase.sortAxisList(bodies, axisIndex);\n\n    // Look through the X list\n    for(var i=0, N=bodies.length|0; i!==N; i++){\n        var bi = bodies[i];\n\n        for(var j=i+1; j<N; j++){\n            var bj = bodies[j];\n\n            // Bounds overlap?\n            var overlaps = (bj.aabb.lowerBound[axisIndex] <= bi.aabb.upperBound[axisIndex]);\n            if(!overlaps){\n                break;\n            }\n\n            if(Broadphase.canCollide(bi,bj) && this.boundingVolumeCheck(bi,bj)){\n                result.push(bi,bj);\n            }\n        }\n    }\n\n    return result;\n};\n\n\n},{\"../collision/Broadphase\":9,\"../utils/Utils\":47}],14:[function(require,module,exports){\nmodule.exports = Constraint;\n\nvar Utils = require('../utils/Utils');\n\n/**\n * Base constraint class.\n *\n * @class Constraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} type\n * @param {Object} [options]\n * @param {Object} [options.collideConnected=true]\n */\nfunction Constraint(bodyA, bodyB, type, options){\n    this.type = type;\n\n    options = Utils.defaults(options,{\n        collideConnected : true,\n        wakeUpBodies : true,\n    });\n\n    /**\n     * Equations to be solved in this constraint\n     *\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * First body participating in the constraint.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second body participating in the constraint.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * Set to true if you want the connected bodies to collide.\n     * @property collideConnected\n     * @type {Boolean}\n     * @default true\n     */\n    this.collideConnected = options.collideConnected;\n\n    // Wake up bodies when connected\n    if(options.wakeUpBodies){\n        if(bodyA){\n            bodyA.wakeUp();\n        }\n        if(bodyB){\n            bodyB.wakeUp();\n        }\n    }\n}\n\n/**\n * Updates the internal constraint parameters before solve.\n * @method update\n */\nConstraint.prototype.update = function(){\n    throw new Error(\"method update() not implmemented in this Constraint subclass!\");\n};\n\nConstraint.DISTANCE = 1;\nConstraint.GEAR = 2;\nConstraint.LOCK = 3;\nConstraint.PRISMATIC = 4;\nConstraint.REVOLUTE = 5;\n\n/**\n * Set stiffness for this constraint.\n * @method setStiffness\n * @param {Number} stiffness\n */\nConstraint.prototype.setStiffness = function(stiffness){\n    var eqs = this.equations;\n    for(var i=0; i !== eqs.length; i++){\n        var eq = eqs[i];\n        eq.stiffness = stiffness;\n        eq.needsUpdate = true;\n    }\n};\n\n/**\n * Set relaxation for this constraint.\n * @method setRelaxation\n * @param {Number} relaxation\n */\nConstraint.prototype.setRelaxation = function(relaxation){\n    var eqs = this.equations;\n    for(var i=0; i !== eqs.length; i++){\n        var eq = eqs[i];\n        eq.relaxation = relaxation;\n        eq.needsUpdate = true;\n    }\n};\n\n},{\"../utils/Utils\":47}],15:[function(require,module,exports){\nvar Constraint = require('./Constraint')\n,   Equation = require('../equations/Equation')\n,   vec2 = require('../math/vec2')\n\nmodule.exports = DistanceConstraint;\n\n/**\n * Constraint that tries to keep the distance between two bodies constant.\n *\n * @class DistanceConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {number} distance The distance to keep between the bodies.\n * @param {object} [options]\n * @param {object} [options.maxForce=Number.MAX_VALUE] Maximum force to apply.\n * @extends Constraint\n */\nfunction DistanceConstraint(bodyA,bodyB,distance,options){\n    options = options || {};\n\n    Constraint.call(this,bodyA,bodyB,Constraint.DISTANCE,options);\n\n    /**\n     * The distance to keep.\n     * @property distance\n     * @type {Number}\n     */\n    this.distance = distance;\n\n    /**\n     * Local anchor in body A.\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = vec2.create();\n\n    /**\n     * Local anchor in body B.\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = vec2.create();\n\n    var localAnchorA = this.localAnchorA;\n    var localAnchorB = this.localAnchorB;\n\n    var maxForce;\n    if(typeof(options.maxForce)===\"undefined\" ){\n        maxForce = Number.MAX_VALUE;\n    } else {\n        maxForce = options.maxForce;\n    }\n\n    var normal = new Equation(bodyA,bodyB,-maxForce,maxForce); // Just in the normal direction\n    this.equations = [ normal ];\n\n    // g = (xi - xj).dot(n)\n    // dg/dt = (vi - vj).dot(n) = G*W = [n 0 -n 0] * [vi wi vj wj]'\n\n    // ...and if we were to include offset points (TODO for now):\n    // g =\n    //      (xj + rj - xi - ri).dot(n) - distance\n    //\n    // dg/dt =\n    //      (vj + wj x rj - vi - wi x ri).dot(n) =\n    //      { term 2 is near zero } =\n    //      [-n   -ri x n   n   rj x n] * [vi wi vj wj]' =\n    //      G * W\n    //\n    // => G = [-n -rixn n rjxn]\n\n    var r = vec2.create();\n    var ri = vec2.create(); // worldAnchorA\n    var rj = vec2.create(); // worldAnchorB\n    var that = this;\n    normal.computeGq = function(){\n        var bodyA = this.bodyA,\n            bodyB = this.bodyB,\n            xi = bodyA.position,\n            xj = bodyB.position;\n\n        // Transform local anchors to world\n        vec2.rotate(ri, localAnchorA, bodyA.angle);\n        vec2.rotate(rj, localAnchorB, bodyB.angle);\n\n        vec2.add(r, xi, rj);\n        vec2.sub(r, r, ri);\n        vec2.sub(r, r, xi);\n\n        vec2.sub(r, bodyB.position, bodyA.position);\n        return vec2.length(r) - that.distance;\n    };\n\n    // Make the contact constraint bilateral\n    this.setMaxForce(maxForce);\n}\nDistanceConstraint.prototype = new Constraint();\n\n/**\n * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n * @method update\n */\nvar n = vec2.create();\nvar ri = vec2.create(); // worldAnchorA\nvar rj = vec2.create(); // worldAnchorB\nDistanceConstraint.prototype.update = function(){\n    var normal = this.equations[0],\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        distance = this.distance,\n        xi = bodyA.position,\n        xj = bodyB.position,\n        G = normal.G;\n\n    // Transform local anchors to world\n    vec2.rotate(ri, this.localAnchorA, bodyA.angle);\n    vec2.rotate(rj, this.localAnchorB, bodyB.angle);\n\n    // Caluclate cross products\n    var rixn = vec2.crossLength(ri, n),\n        rjxn = vec2.crossLength(rj, n);\n\n    /*\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n    */\n\n    vec2.sub(n, bodyB.position, bodyA.position);\n    vec2.normalize(n,n);\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[3] =  n[0];\n    G[4] =  n[1];\n};\n\n/**\n * Set the max force to be used\n * @method setMaxForce\n * @param {Number} f\n */\nDistanceConstraint.prototype.setMaxForce = function(f){\n    var normal = this.equations[0];\n    normal.minForce = -f;\n    normal.maxForce =  f;\n};\n\n/**\n * Get the max force\n * @method getMaxForce\n * @return {Number}\n */\nDistanceConstraint.prototype.getMaxForce = function(f){\n    var normal = this.equations[0];\n    return normal.maxForce;\n};\n\n},{\"../equations/Equation\":22,\"../math/vec2\":30,\"./Constraint\":14}],16:[function(require,module,exports){\nvar Constraint = require('./Constraint')\n,   Equation = require('../equations/Equation')\n,   AngleLockEquation = require('../equations/AngleLockEquation')\n,   vec2 = require('../math/vec2')\n\nmodule.exports = GearConstraint;\n\n/**\n * Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n * @class GearConstraint\n * @constructor\n * @author schteppe\n * @param {Body}            bodyA\n * @param {Body}            bodyB\n * @param {Object}          [options]\n * @param {Number}          [options.angle=0] Relative angle between the bodies.\n * @param {Number}          [options.ratio=1] Gear ratio.\n * @param {Number}          [options.maxTorque] Maximum torque to apply.\n * @extends Constraint\n * @todo Ability to specify world points\n */\nfunction GearConstraint(bodyA, bodyB, options){\n    options = options || {};\n\n    Constraint.call(this, bodyA, bodyB, Constraint.GEAR, options);\n\n    this.equations = [\n        new AngleLockEquation(bodyA,bodyB,options),\n    ];\n\n    /**\n     * The relative angle\n     * @property angle\n     * @type {Number}\n     */\n    this.angle = typeof(options.angle) === \"number\" ? options.angle : 0;\n\n    /**\n     * The gear ratio.\n     * @property ratio\n     * @type {Number}\n     */\n    this.ratio = typeof(options.ratio) === \"number\" ? options.ratio : 1;\n\n    // Set max torque\n    if(typeof(options.maxTorque) === \"number\"){\n        this.setMaxTorque(options.maxTorque);\n    }\n}\nGearConstraint.prototype = new Constraint();\n\nGearConstraint.prototype.update = function(){\n    var eq = this.equations[0];\n    if(eq.ratio !== this.ratio){\n        eq.setRatio(this.ratio);\n    }\n    eq.angle = this.angle;\n};\n\n/**\n * Set the max torque for the constraint.\n * @method setMaxTorque\n * @param {Number} torque\n */\nGearConstraint.prototype.setMaxTorque = function(torque){\n    this.equations[0].setMaxTorque(torque);\n};\n\n/**\n * Get the max torque for the constraint.\n * @method getMaxTorque\n * @return {Number}\n */\nGearConstraint.prototype.getMaxTorque = function(torque){\n    return this.equations[0].maxForce;\n};\n},{\"../equations/AngleLockEquation\":20,\"../equations/Equation\":22,\"../math/vec2\":30,\"./Constraint\":14}],17:[function(require,module,exports){\nvar Constraint = require('./Constraint')\n,   vec2 = require('../math/vec2')\n,   Equation = require('../equations/Equation')\n\nmodule.exports = LockConstraint;\n\n/**\n * Locks the relative position between two bodies.\n *\n * @class LockConstraint\n * @constructor\n * @author schteppe\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Array}  [options.localOffsetB] The offset of bodyB in bodyA's frame. Default is the zero vector.\n * @param {number} [options.localAngleB=0]  The angle of bodyB in bodyA's frame.\n * @param {number} [options.maxForce]\n * @extends Constraint\n */\nfunction LockConstraint(bodyA, bodyB, options){\n    options = options || {};\n\n    Constraint.call(this,bodyA,bodyB,Constraint.LOCK,options);\n    var maxForce = ( typeof(options.maxForce)===\"undefined\" ? Number.MAX_VALUE : options.maxForce );\n    var localOffsetB = options.localOffsetB || vec2.fromValues(0,0);\n    localOffsetB = vec2.fromValues(localOffsetB[0],localOffsetB[1]);\n\n    var localAngleB = options.localAngleB || 0;\n\n    // Use 3 equations:\n    // gx =   (xj - xi - l) * xhat = 0\n    // gy =   (xj - xi - l) * yhat = 0\n    // gr =   (xi - xj + r) * that = 0\n    //\n    // ...where:\n    //   l is the localOffsetB vector rotated to world in bodyA frame\n    //   r is the same vector but reversed and rotated from bodyB frame\n    //   xhat, yhat are world axis vectors\n    //   that is the tangent of r\n    //\n    // For the first two constraints, we get\n    // G*W = (vj - vi - ldot  ) * xhat\n    //     = (vj - vi - wi x l) * xhat\n    //\n    // Since (wi x l) * xhat = (l x xhat) * wi, we get\n    // G*W = [ -1   0   (-l x xhat)  1   0   0] * [vi wi vj wj]\n    //\n    // The last constraint gives\n    // GW = (vi - vj + wj x r) * that\n    //    = [  that   0  -that  (r x t) ]\n\n    var x =     new Equation(bodyA,bodyB,-maxForce,maxForce),\n        y =     new Equation(bodyA,bodyB,-maxForce,maxForce),\n        rot =   new Equation(bodyA,bodyB,-maxForce,maxForce);\n\n    var l = vec2.create(),\n        g = vec2.create(),\n        that = this;\n    x.computeGq = function(){\n        vec2.rotate(l, that.localOffsetB, bodyA.angle);\n        vec2.sub(g, bodyB.position, bodyA.position);\n        vec2.sub(g, g, l);\n        return g[0];\n    };\n    y.computeGq = function(){\n        vec2.rotate(l, that.localOffsetB, bodyA.angle);\n        vec2.sub(g, bodyB.position, bodyA.position);\n        vec2.sub(g, g, l);\n        return g[1];\n    };\n    var r = vec2.create(),\n        t = vec2.create();\n    rot.computeGq = function(){\n        vec2.rotate(r, that.localOffsetB, bodyB.angle - that.localAngleB);\n        vec2.scale(r,r,-1);\n        vec2.sub(g,bodyA.position,bodyB.position);\n        vec2.add(g,g,r);\n        vec2.rotate(t,r,-Math.PI/2);\n        vec2.normalize(t,t);\n        return vec2.dot(g,t);\n    };\n\n    /**\n     * The offset of bodyB in bodyA's frame.\n     * @property {Array} localOffsetB\n     */\n    this.localOffsetB = localOffsetB;\n\n    /**\n     * The offset angle of bodyB in bodyA's frame.\n     * @property {Number} localAngleB\n     */\n    this.localAngleB =  localAngleB;\n\n    this.equations.push(x, y, rot);\n    this.setMaxForce(maxForce);\n}\nLockConstraint.prototype = new Constraint();\n\n/**\n * Set the maximum force to be applied.\n * @method setMaxForce\n * @param {Number} force\n */\nLockConstraint.prototype.setMaxForce = function(force){\n    var eqs = this.equations;\n    for(var i=0; i<this.equations.length; i++){\n        eqs[i].maxForce =  force;\n        eqs[i].minForce = -force;\n    }\n};\n\n/**\n * Get the max force.\n * @method getMaxForce\n * @return {Number}\n */\nLockConstraint.prototype.getMaxForce = function(){\n    return this.equations[0].maxForce;\n};\n\nvar l = vec2.create();\nvar r = vec2.create();\nvar t = vec2.create();\nvar xAxis = vec2.fromValues(1,0);\nvar yAxis = vec2.fromValues(0,1);\nLockConstraint.prototype.update = function(){\n    var x =   this.equations[0],\n        y =   this.equations[1],\n        rot = this.equations[2],\n        bodyA = this.bodyA,\n        bodyB = this.bodyB;\n\n    vec2.rotate(l,this.localOffsetB,bodyA.angle);\n    vec2.rotate(r,this.localOffsetB,bodyB.angle - this.localAngleB);\n    vec2.scale(r,r,-1);\n\n    vec2.rotate(t,r,Math.PI/2);\n    vec2.normalize(t,t);\n\n    x.G[0] = -1;\n    x.G[1] =  0;\n    x.G[2] = -vec2.crossLength(l,xAxis);\n    x.G[3] =  1;\n\n    y.G[0] =  0;\n    y.G[1] = -1;\n    y.G[2] = -vec2.crossLength(l,yAxis);\n    y.G[4] =  1;\n\n    rot.G[0] =  -t[0];\n    rot.G[1] =  -t[1];\n    rot.G[3] =  t[0];\n    rot.G[4] =  t[1];\n    rot.G[5] =  vec2.crossLength(r,t);\n};\n\n},{\"../equations/Equation\":22,\"../math/vec2\":30,\"./Constraint\":14}],18:[function(require,module,exports){\nvar Constraint = require('./Constraint')\n,   ContactEquation = require('../equations/ContactEquation')\n,   Equation = require('../equations/Equation')\n,   vec2 = require('../math/vec2')\n,   RotationalLockEquation = require('../equations/RotationalLockEquation')\n\nmodule.exports = PrismaticConstraint;\n\n/**\n * Constraint that only allows bodies to move along a line, relative to each other. See <a href=\"http://www.iforce2d.net/b2dtut/joints-prismatic\">this tutorial</a>.\n *\n * @class PrismaticConstraint\n * @constructor\n * @extends Constraint\n * @author schteppe\n * @param {Body}    bodyA\n * @param {Body}    bodyB\n * @param {Object}  [options]\n * @param {Number}  [options.maxForce]                Max force to be applied by the constraint\n * @param {Array}   [options.localAnchorA]            Body A's anchor point, defined in its own local frame.\n * @param {Array}   [options.localAnchorB]            Body B's anchor point, defined in its own local frame.\n * @param {Array}   [options.localAxisA]              An axis, defined in body A frame, that body B's anchor point may slide along.\n * @param {Boolean} [options.disableRotationalLock]   If set to true, bodyB will be free to rotate around its anchor point.\n * @param {Number}  [options.upperLimit]\n * @param {Number}  [options.lowerLimit]\n */\nfunction PrismaticConstraint(bodyA, bodyB, options){\n    options = options || {};\n    Constraint.call(this,bodyA,bodyB,Constraint.PRISMATIC,options);\n\n    // Get anchors\n    var localAnchorA = vec2.fromValues(0,0),\n        localAxisA = vec2.fromValues(1,0),\n        localAnchorB = vec2.fromValues(0,0);\n    if(options.localAnchorA) vec2.copy(localAnchorA, options.localAnchorA);\n    if(options.localAxisA)   vec2.copy(localAxisA,   options.localAxisA);\n    if(options.localAnchorB) vec2.copy(localAnchorB, options.localAnchorB);\n\n    /**\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = localAnchorA;\n\n    /**\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = localAnchorB;\n\n    /**\n     * @property localAxisA\n     * @type {Array}\n     */\n    this.localAxisA = localAxisA;\n\n    /*\n\n    The constraint violation for the common axis point is\n\n        g = ( xj + rj - xi - ri ) * t   :=  gg*t\n\n    where r are body-local anchor points, and t is a tangent to the constraint axis defined in body i frame.\n\n        gdot =  ( vj + wj x rj - vi - wi x ri ) * t + ( xj + rj - xi - ri ) * ( wi x t )\n\n    Note the use of the chain rule. Now we identify the jacobian\n\n        G*W = [ -t      -ri x t + t x gg     t    rj x t ] * [vi wi vj wj]\n\n    The rotational part is just a rotation lock.\n\n     */\n\n    var maxForce = this.maxForce = typeof(options.maxForce)!=\"undefined\" ? options.maxForce : Number.MAX_VALUE;\n\n    // Translational part\n    var trans = new Equation(bodyA,bodyB,-maxForce,maxForce);\n    var ri = new vec2.create(),\n        rj = new vec2.create(),\n        gg = new vec2.create(),\n        t =  new vec2.create();\n    trans.computeGq = function(){\n        // g = ( xj + rj - xi - ri ) * t\n        return vec2.dot(gg,t);\n    };\n    trans.updateJacobian = function(){\n        var G = this.G,\n            xi = bodyA.position,\n            xj = bodyB.position;\n        vec2.rotate(ri,localAnchorA,bodyA.angle);\n        vec2.rotate(rj,localAnchorB,bodyB.angle);\n        vec2.add(gg,xj,rj);\n        vec2.sub(gg,gg,xi);\n        vec2.sub(gg,gg,ri);\n        vec2.rotate(t,localAxisA,bodyA.angle+Math.PI/2);\n\n        G[0] = -t[0];\n        G[1] = -t[1];\n        G[2] = -vec2.crossLength(ri,t) + vec2.crossLength(t,gg);\n        G[3] = t[0];\n        G[4] = t[1];\n        G[5] = vec2.crossLength(rj,t);\n    };\n    this.equations.push(trans);\n\n    // Rotational part\n    if(!options.disableRotationalLock){\n        var rot = new RotationalLockEquation(bodyA,bodyB,-maxForce,maxForce);\n        this.equations.push(rot);\n    }\n\n    /**\n     * The position of anchor A relative to anchor B, along the constraint axis.\n     * @property position\n     * @type {Number}\n     */\n    this.position = 0;\n\n    this.velocity = 0;\n\n    /**\n     * Set to true to enable lower limit.\n     * @property lowerLimitEnabled\n     * @type {Boolean}\n     */\n    this.lowerLimitEnabled = typeof(options.lowerLimit)!==\"undefined\" ? true : false;\n\n    /**\n     * Set to true to enable upper limit.\n     * @property upperLimitEnabled\n     * @type {Boolean}\n     */\n    this.upperLimitEnabled = typeof(options.upperLimit)!==\"undefined\" ? true : false;\n\n    /**\n     * Lower constraint limit. The constraint position is forced to be larger than this value.\n     * @property lowerLimit\n     * @type {Number}\n     */\n    this.lowerLimit = typeof(options.lowerLimit)!==\"undefined\" ? options.lowerLimit : 0;\n\n    /**\n     * Upper constraint limit. The constraint position is forced to be smaller than this value.\n     * @property upperLimit\n     * @type {Number}\n     */\n    this.upperLimit = typeof(options.upperLimit)!==\"undefined\" ? options.upperLimit : 1;\n\n    // Equations used for limits\n    this.upperLimitEquation = new ContactEquation(bodyA,bodyB);\n    this.lowerLimitEquation = new ContactEquation(bodyA,bodyB);\n\n    // Set max/min forces\n    this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0;\n    this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = maxForce;\n\n    /**\n     * Equation used for the motor.\n     * @property motorEquation\n     * @type {Equation}\n     */\n    this.motorEquation = new Equation(bodyA,bodyB);\n\n    /**\n     * The current motor state. Enable or disable the motor using .enableMotor\n     * @property motorEnabled\n     * @type {Boolean}\n     */\n    this.motorEnabled = false;\n\n    /**\n     * Set the target speed for the motor.\n     * @property motorSpeed\n     * @type {Number}\n     */\n    this.motorSpeed = 0;\n\n    var that = this;\n    var motorEquation = this.motorEquation;\n    var old = motorEquation.computeGW;\n    motorEquation.computeGq = function(){ return 0; };\n    motorEquation.computeGW = function(){\n        var G = this.G,\n            bi = this.bodyA,\n            bj = this.bodyB,\n            vi = bi.velocity,\n            vj = bj.velocity,\n            wi = bi.angularVelocity,\n            wj = bj.angularVelocity;\n        return this.transformedGmult(G,vi,wi,vj,wj) + that.motorSpeed;\n    };\n}\n\nPrismaticConstraint.prototype = new Constraint();\n\nvar worldAxisA = vec2.create(),\n    worldAnchorA = vec2.create(),\n    worldAnchorB = vec2.create(),\n    orientedAnchorA = vec2.create(),\n    orientedAnchorB = vec2.create(),\n    tmp = vec2.create();\n\n/**\n * Update the constraint equations. Should be done if any of the bodies changed position, before solving.\n * @method update\n */\nPrismaticConstraint.prototype.update = function(){\n    var eqs = this.equations,\n        trans = eqs[0],\n        upperLimit = this.upperLimit,\n        lowerLimit = this.lowerLimit,\n        upperLimitEquation = this.upperLimitEquation,\n        lowerLimitEquation = this.lowerLimitEquation,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        localAxisA = this.localAxisA,\n        localAnchorA = this.localAnchorA,\n        localAnchorB = this.localAnchorB;\n\n    trans.updateJacobian();\n\n    // Transform local things to world\n    vec2.rotate(worldAxisA,      localAxisA,      bodyA.angle);\n    vec2.rotate(orientedAnchorA, localAnchorA,    bodyA.angle);\n    vec2.add(worldAnchorA,       orientedAnchorA, bodyA.position);\n    vec2.rotate(orientedAnchorB, localAnchorB,    bodyB.angle);\n    vec2.add(worldAnchorB,       orientedAnchorB, bodyB.position);\n\n    var relPosition = this.position = vec2.dot(worldAnchorB,worldAxisA) - vec2.dot(worldAnchorA,worldAxisA);\n\n    // Motor\n    if(this.motorEnabled){\n        // G = [ a     a x ri   -a   -a x rj ]\n        var G = this.motorEquation.G;\n        G[0] = worldAxisA[0];\n        G[1] = worldAxisA[1];\n        G[2] = vec2.crossLength(worldAxisA,orientedAnchorB);\n        G[3] = -worldAxisA[0];\n        G[4] = -worldAxisA[1];\n        G[5] = -vec2.crossLength(worldAxisA,orientedAnchorA);\n    }\n\n    /*\n        Limits strategy:\n        Add contact equation, with normal along the constraint axis.\n        min/maxForce is set so the constraint is repulsive in the correct direction.\n        Some offset is added to either equation.contactPointA or .contactPointB to get the correct upper/lower limit.\n\n                 ^\n                 |\n      upperLimit x\n                 |    ------\n         anchorB x<---|  B |\n                 |    |    |\n        ------   |    ------\n        |    |   |\n        |  A |-->x anchorA\n        ------   |\n                 x lowerLimit\n                 |\n                axis\n     */\n\n    if(this.upperLimitEnabled && relPosition > upperLimit){\n        // Update contact constraint normal, etc\n        vec2.scale(upperLimitEquation.normalA, worldAxisA, -1);\n        vec2.sub(upperLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n        vec2.sub(upperLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n        vec2.scale(tmp,worldAxisA,upperLimit);\n        vec2.add(upperLimitEquation.contactPointA,upperLimitEquation.contactPointA,tmp);\n        if(eqs.indexOf(upperLimitEquation)==-1)\n            eqs.push(upperLimitEquation);\n    } else {\n        var idx = eqs.indexOf(upperLimitEquation);\n        if(idx != -1) eqs.splice(idx,1);\n    }\n\n    if(this.lowerLimitEnabled && relPosition < lowerLimit){\n        // Update contact constraint normal, etc\n        vec2.scale(lowerLimitEquation.normalA, worldAxisA, 1);\n        vec2.sub(lowerLimitEquation.contactPointA, worldAnchorA, bodyA.position);\n        vec2.sub(lowerLimitEquation.contactPointB, worldAnchorB, bodyB.position);\n        vec2.scale(tmp,worldAxisA,lowerLimit);\n        vec2.sub(lowerLimitEquation.contactPointB,lowerLimitEquation.contactPointB,tmp);\n        if(eqs.indexOf(lowerLimitEquation)==-1)\n            eqs.push(lowerLimitEquation);\n    } else {\n        var idx = eqs.indexOf(lowerLimitEquation);\n        if(idx != -1) eqs.splice(idx,1);\n    }\n};\n\n/**\n * Enable the motor\n * @method enableMotor\n */\nPrismaticConstraint.prototype.enableMotor = function(){\n    if(this.motorEnabled) return;\n    this.equations.push(this.motorEquation);\n    this.motorEnabled = true;\n};\n\n/**\n * Disable the rotational motor\n * @method disableMotor\n */\nPrismaticConstraint.prototype.disableMotor = function(){\n    if(!this.motorEnabled) return;\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations.splice(i,1);\n    this.motorEnabled = false;\n};\n\n},{\"../equations/ContactEquation\":21,\"../equations/Equation\":22,\"../equations/RotationalLockEquation\":24,\"../math/vec2\":30,\"./Constraint\":14}],19:[function(require,module,exports){\nvar Constraint = require('./Constraint')\n,   Equation = require('../equations/Equation')\n,   RotationalVelocityEquation = require('../equations/RotationalVelocityEquation')\n,   RotationalLockEquation = require('../equations/RotationalLockEquation')\n,   vec2 = require('../math/vec2')\n\nmodule.exports = RevoluteConstraint;\n\nvar worldPivotA = vec2.create(),\n    worldPivotB = vec2.create(),\n    xAxis = vec2.fromValues(1,0),\n    yAxis = vec2.fromValues(0,1),\n    g = vec2.create();\n\n/**\n * Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n * @class RevoluteConstraint\n * @constructor\n * @author schteppe\n * @param {Body}    bodyA\n * @param {Array}   pivotA              The point relative to the center of mass of bodyA which bodyA is constrained to.\n * @param {Body}    bodyB               Body that will be constrained in a similar way to the same point as bodyA. We will therefore get sort of a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.\n * @param {Array}   pivotB              See pivotA.\n * @param {Object}  [options]\n * @param {Number}  [options.maxForce]  The maximum force that should be applied to constrain the bodies.\n * @extends Constraint\n * @todo Ability to specify world points\n * @todo put pivot parameters in the options object?\n */\nfunction RevoluteConstraint(bodyA, pivotA, bodyB, pivotB, options){\n    options = options || {};\n    Constraint.call(this,bodyA,bodyB,Constraint.REVOLUTE,options);\n\n    var maxForce = this.maxForce = typeof(options.maxForce) !== \"undefined\" ? options.maxForce : Number.MAX_VALUE;\n\n    /**\n     * @property {Array} pivotA\n     */\n    this.pivotA = vec2.fromValues(pivotA[0],pivotA[1]);\n\n    /**\n     * @property {Array} pivotB\n     */\n    this.pivotB = vec2.fromValues(pivotB[0],pivotB[1]);\n\n    // Equations to be fed to the solver\n    var eqs = this.equations = [\n        new Equation(bodyA,bodyB,-maxForce,maxForce),\n        new Equation(bodyA,bodyB,-maxForce,maxForce),\n    ];\n\n    var x = eqs[0];\n    var y = eqs[1];\n    var that = this;\n\n    x.computeGq = function(){\n        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);\n        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);\n        vec2.add(g, bodyB.position, worldPivotB);\n        vec2.sub(g, g, bodyA.position);\n        vec2.sub(g, g, worldPivotA);\n        return vec2.dot(g,xAxis);\n    };\n\n    y.computeGq = function(){\n        vec2.rotate(worldPivotA, that.pivotA, bodyA.angle);\n        vec2.rotate(worldPivotB, that.pivotB, bodyB.angle);\n        vec2.add(g, bodyB.position, worldPivotB);\n        vec2.sub(g, g, bodyA.position);\n        vec2.sub(g, g, worldPivotA);\n        return vec2.dot(g,yAxis);\n    };\n\n    y.minForce = x.minForce = -maxForce;\n    y.maxForce = x.maxForce =  maxForce;\n\n    this.motorEquation = new RotationalVelocityEquation(bodyA,bodyB);\n\n    /**\n     * Indicates whether the motor is enabled. Use .enableMotor() to enable the constraint motor.\n     * @property {Boolean} motorEnabled\n     * @readOnly\n     */\n    this.motorEnabled = false;\n\n    /**\n     * The constraint position.\n     * @property angle\n     * @type {Number}\n     * @readOnly\n     */\n    this.angle = 0;\n\n    /**\n     * Set to true to enable lower limit\n     * @property lowerLimitEnabled\n     * @type {Boolean}\n     */\n    this.lowerLimitEnabled = false;\n\n    /**\n     * Set to true to enable upper limit\n     * @property upperLimitEnabled\n     * @type {Boolean}\n     */\n    this.upperLimitEnabled = false;\n\n    /**\n     * The lower limit on the constraint angle.\n     * @property lowerLimit\n     * @type {Boolean}\n     */\n    this.lowerLimit = 0;\n\n    /**\n     * The upper limit on the constraint angle.\n     * @property upperLimit\n     * @type {Boolean}\n     */\n    this.upperLimit = 0;\n\n    this.upperLimitEquation = new RotationalLockEquation(bodyA,bodyB);\n    this.lowerLimitEquation = new RotationalLockEquation(bodyA,bodyB);\n    this.upperLimitEquation.minForce = 0;\n    this.lowerLimitEquation.maxForce = 0;\n}\nRevoluteConstraint.prototype = new Constraint();\n\nRevoluteConstraint.prototype.update = function(){\n    var bodyA =  this.bodyA,\n        bodyB =  this.bodyB,\n        pivotA = this.pivotA,\n        pivotB = this.pivotB,\n        eqs =    this.equations,\n        normal = eqs[0],\n        tangent= eqs[1],\n        x = eqs[0],\n        y = eqs[1],\n        upperLimit = this.upperLimit,\n        lowerLimit = this.lowerLimit,\n        upperLimitEquation = this.upperLimitEquation,\n        lowerLimitEquation = this.lowerLimitEquation;\n\n    var relAngle = this.angle = bodyB.angle - bodyA.angle;\n\n    if(this.upperLimitEnabled && relAngle > upperLimit){\n        upperLimitEquation.angle = upperLimit;\n        if(eqs.indexOf(upperLimitEquation)==-1)\n            eqs.push(upperLimitEquation);\n    } else {\n        var idx = eqs.indexOf(upperLimitEquation);\n        if(idx != -1) eqs.splice(idx,1);\n    }\n\n    if(this.lowerLimitEnabled && relAngle < lowerLimit){\n        lowerLimitEquation.angle = lowerLimit;\n        if(eqs.indexOf(lowerLimitEquation)==-1)\n            eqs.push(lowerLimitEquation);\n    } else {\n        var idx = eqs.indexOf(lowerLimitEquation);\n        if(idx != -1) eqs.splice(idx,1);\n    }\n\n    /*\n\n    The constraint violation is\n\n        g = xj + rj - xi - ri\n\n    ...where xi and xj are the body positions and ri and rj world-oriented offset vectors. Differentiate:\n\n        gdot = vj + wj x rj - vi - wi x ri\n\n    We split this into x and y directions. (let x and y be unit vectors along the respective axes)\n\n        gdot * x = ( vj + wj x rj - vi - wi x ri ) * x\n                 = ( vj*x + (wj x rj)*x -vi*x -(wi x ri)*x\n                 = ( vj*x + (rj x x)*wj -vi*x -(ri x x)*wi\n                 = [ -x   -(ri x x)   x   (rj x x)] * [vi wi vj wj]\n                 = G*W\n\n    ...and similar for y. We have then identified the jacobian entries for x and y directions:\n\n        Gx = [ x   (rj x x)   -x   -(ri x x)]\n        Gy = [ y   (rj x y)   -y   -(ri x y)]\n\n     */\n\n    vec2.rotate(worldPivotA, pivotA, bodyA.angle);\n    vec2.rotate(worldPivotB, pivotB, bodyB.angle);\n\n    // todo: these are a bit sparse. We could save some computations on making custom eq.computeGW functions, etc\n\n    x.G[0] = -1;\n    x.G[1] =  0;\n    x.G[2] = -vec2.crossLength(worldPivotA,xAxis);\n    x.G[3] =  1;\n    x.G[4] =  0;\n    x.G[5] =  vec2.crossLength(worldPivotB,xAxis);\n\n    y.G[0] =  0;\n    y.G[1] = -1;\n    y.G[2] = -vec2.crossLength(worldPivotA,yAxis);\n    y.G[3] =  0;\n    y.G[4] =  1;\n    y.G[5] =  vec2.crossLength(worldPivotB,yAxis);\n};\n\n/**\n * Enable the rotational motor\n * @method enableMotor\n */\nRevoluteConstraint.prototype.enableMotor = function(){\n    if(this.motorEnabled) return;\n    this.equations.push(this.motorEquation);\n    this.motorEnabled = true;\n};\n\n/**\n * Disable the rotational motor\n * @method disableMotor\n */\nRevoluteConstraint.prototype.disableMotor = function(){\n    if(!this.motorEnabled) return;\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations.splice(i,1);\n    this.motorEnabled = false;\n};\n\n/**\n * Check if the motor is enabled.\n * @method motorIsEnabled\n * @return {Boolean}\n */\nRevoluteConstraint.prototype.motorIsEnabled = function(){\n    return !!this.motorEnabled;\n};\n\n/**\n * Set the speed of the rotational constraint motor\n * @method setMotorSpeed\n * @param  {Number} speed\n */\nRevoluteConstraint.prototype.setMotorSpeed = function(speed){\n    if(!this.motorEnabled){\n        return;\n    }\n    var i = this.equations.indexOf(this.motorEquation);\n    this.equations[i].relativeVelocity = speed;\n};\n\n/**\n * Get the speed of the rotational constraint motor\n * @method getMotorSpeed\n * @return  {Number} The current speed, or false if the motor is not enabled.\n */\nRevoluteConstraint.prototype.getMotorSpeed = function(){\n    if(!this.motorEnabled) return false;\n    return this.motorEquation.relativeVelocity;\n};\n\n},{\"../equations/Equation\":22,\"../equations/RotationalLockEquation\":24,\"../equations/RotationalVelocityEquation\":25,\"../math/vec2\":30,\"./Constraint\":14}],20:[function(require,module,exports){\nvar Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = AngleLockEquation;\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n *\n * @class AngleLockEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Number} [options.angle] Angle to add to the local vector in body A.\n * @param {Number} [options.ratio] Gear ratio\n */\nfunction AngleLockEquation(bodyA, bodyB, options){\n    options = options || {};\n    Equation.call(this,bodyA,bodyB,-Number.MAX_VALUE,Number.MAX_VALUE);\n    this.angle = options.angle || 0;\n\n    /**\n     * The gear ratio.\n     * @property {Number} ratio\n     * @private\n     * @see setRatio\n     */\n    this.ratio = typeof(options.ratio)===\"number\" ? options.ratio : 1;\n\n    this.setRatio(this.ratio);\n}\nAngleLockEquation.prototype = new Equation();\nAngleLockEquation.prototype.constructor = AngleLockEquation;\n\nAngleLockEquation.prototype.computeGq = function(){\n    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle;\n};\n\n/**\n * Set the gear ratio for this equation\n * @method setRatio\n * @param {Number} ratio\n */\nAngleLockEquation.prototype.setRatio = function(ratio){\n    var G = this.G;\n    G[2] =  ratio;\n    G[5] = -1;\n    this.ratio = ratio;\n};\n\n/**\n * Set the max force for the equation.\n * @method setMaxTorque\n * @param {Number} torque\n */\nAngleLockEquation.prototype.setMaxTorque = function(torque){\n    this.maxForce =  torque;\n    this.minForce = -torque;\n};\n\n},{\"../math/vec2\":30,\"./Equation\":22}],21:[function(require,module,exports){\nvar Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = ContactEquation;\n\n/**\n * Non-penetration constraint equation. Tries to make the ri and rj vectors the same point.\n *\n * @class ContactEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nfunction ContactEquation(bodyA, bodyB){\n    Equation.call(this, bodyA, bodyB, 0, Number.MAX_VALUE);\n\n    /**\n     * Vector from body i center of mass to the contact point.\n     * @property contactPointA\n     * @type {Array}\n     */\n    this.contactPointA = vec2.create();\n    this.penetrationVec = vec2.create();\n\n    /**\n     * World-oriented vector from body A center of mass to the contact point.\n     * @property contactPointB\n     * @type {Array}\n     */\n    this.contactPointB = vec2.create();\n\n    /**\n     * The normal vector, pointing out of body i\n     * @property normalA\n     * @type {Array}\n     */\n    this.normalA = vec2.create();\n\n    /**\n     * The restitution to use (0=no bounciness, 1=max bounciness).\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution = 0;\n\n    /**\n     * This property is set to true if this is the first impact between the bodies (not persistant contact).\n     * @property firstImpact\n     * @type {Boolean}\n     * @readOnly\n     */\n    this.firstImpact = false;\n\n    /**\n     * The shape in body i that triggered this contact.\n     * @property shapeA\n     * @type {Shape}\n     */\n    this.shapeA = null;\n\n    /**\n     * The shape in body j that triggered this contact.\n     * @property shapeB\n     * @type {Shape}\n     */\n    this.shapeB = null;\n}\nContactEquation.prototype = new Equation();\nContactEquation.prototype.constructor = ContactEquation;\nContactEquation.prototype.computeB = function(a,b,h){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        ri = this.contactPointA,\n        rj = this.contactPointB,\n        xi = bi.position,\n        xj = bj.position;\n\n    var penetrationVec = this.penetrationVec,\n        n = this.normalA,\n        G = this.G;\n\n    // Caluclate cross products\n    var rixn = vec2.crossLength(ri,n),\n        rjxn = vec2.crossLength(rj,n);\n\n    // G = [-n -rixn n rjxn]\n    G[0] = -n[0];\n    G[1] = -n[1];\n    G[2] = -rixn;\n    G[3] = n[0];\n    G[4] = n[1];\n    G[5] = rjxn;\n\n    // Calculate q = xj+rj -(xi+ri) i.e. the penetration vector\n    vec2.add(penetrationVec,xj,rj);\n    vec2.sub(penetrationVec,penetrationVec,xi);\n    vec2.sub(penetrationVec,penetrationVec,ri);\n\n    // Compute iteration\n    var GW, Gq;\n    if(this.firstImpact && this.restitution !== 0){\n        Gq = 0;\n        GW = (1/b)*(1+this.restitution) * this.computeGW();\n    } else {\n        Gq = vec2.dot(n,penetrationVec);\n        GW = this.computeGW();\n    }\n\n    var GiMf = this.computeGiMf();\n    var B = - Gq * a - GW * b - h*GiMf;\n\n    return B;\n};\n\n},{\"../math/vec2\":30,\"./Equation\":22}],22:[function(require,module,exports){\nmodule.exports = Equation;\n\nvar vec2 = require('../math/vec2'),\n    Utils = require('../utils/Utils'),\n    Body = require('../objects/Body');\n\n/**\n * Base class for constraint equations.\n * @class Equation\n * @constructor\n * @param {Body} bodyA First body participating in the equation\n * @param {Body} bodyB Second body participating in the equation\n * @param {number} minForce Minimum force to apply. Default: -Number.MAX_VALUE\n * @param {number} maxForce Maximum force to apply. Default: Number.MAX_VALUE\n */\nfunction Equation(bodyA, bodyB, minForce, maxForce){\n\n    /**\n     * Minimum force to apply when solving.\n     * @property minForce\n     * @type {Number}\n     */\n    this.minForce = typeof(minForce)===\"undefined\" ? -Number.MAX_VALUE : minForce;\n\n    /**\n     * Max force to apply when solving.\n     * @property maxForce\n     * @type {Number}\n     */\n    this.maxForce = typeof(maxForce)===\"undefined\" ? Number.MAX_VALUE : maxForce;\n\n    /**\n     * First body participating in the constraint\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second body participating in the constraint\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * The stiffness of this equation. Typically chosen to a large number (~1e7), but can be chosen somewhat freely to get a stable simulation.\n     * @property stiffness\n     * @type {Number}\n     */\n    this.stiffness = Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * The number of time steps needed to stabilize the constraint equation. Typically between 3 and 5 time steps.\n     * @property relaxation\n     * @type {Number}\n     */\n    this.relaxation = Equation.DEFAULT_RELAXATION;\n\n    /**\n     * The Jacobian entry of this equation. 6 numbers, 3 per body (x,y,angle).\n     * @property G\n     * @type {Array}\n     */\n    this.G = new Utils.ARRAY_TYPE(6);\n    for(var i=0; i<6; i++){\n        this.G[i]=0;\n    }\n\n    // Constraint frames for body i and j\n    /*\n    this.xi = vec2.create();\n    this.xj = vec2.create();\n    this.ai = 0;\n    this.aj = 0;\n    */\n    this.offset = 0;\n\n    this.a = 0;\n    this.b = 0;\n    this.epsilon = 0;\n    this.timeStep = 1/60;\n\n    /**\n     * Indicates if stiffness or relaxation was changed.\n     * @property {Boolean} needsUpdate\n     */\n    this.needsUpdate = true;\n\n    /**\n     * The resulting constraint multiplier from the last solve. This is mostly equivalent to the force produced by the constraint.\n     * @property multiplier\n     * @type {Number}\n     */\n    this.multiplier = 0;\n\n    /**\n     * Relative velocity.\n     * @property {Number} relativeVelocity\n     */\n    this.relativeVelocity = 0;\n\n    /**\n     * Whether this equation is enabled or not. If true, it will be added to the solver.\n     * @property {Boolean} enabled\n     */\n    this.enabled = true;\n}\nEquation.prototype.constructor = Equation;\n\n/**\n * The default stiffness when creating a new Equation.\n * @static\n * @property {Number} DEFAULT_STIFFNESS\n * @default 1e6\n */\nEquation.DEFAULT_STIFFNESS = 1e6;\n\n/**\n * The default relaxation when creating a new Equation.\n * @static\n * @property {Number} DEFAULT_RELAXATION\n * @default 4\n */\nEquation.DEFAULT_RELAXATION = 4;\n\n/**\n * Compute SPOOK parameters .a, .b and .epsilon according to the current parameters. See equations 9, 10 and 11 in the <a href=\"http://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf\">SPOOK notes</a>.\n * @method update\n */\nEquation.prototype.update = function(){\n    var k = this.stiffness,\n        d = this.relaxation,\n        h = this.timeStep;\n\n    this.a = 4.0 / (h * (1 + 4 * d));\n    this.b = (4.0 * d) / (1 + 4 * d);\n    this.epsilon = 4.0 / (h * h * k * (1 + 4 * d));\n\n    this.needsUpdate = false;\n};\n\nfunction Gmult(G,vi,wi,vj,wj){\n    return  G[0] * vi[0] +\n            G[1] * vi[1] +\n            G[2] * wi +\n            G[3] * vj[0] +\n            G[4] * vj[1] +\n            G[5] * wj;\n}\n\n/**\n * Computes the RHS of the SPOOK equation\n * @method computeB\n * @return {Number}\n */\nEquation.prototype.computeB = function(a,b,h){\n    var GW = this.computeGW();\n    var Gq = this.computeGq();\n    var GiMf = this.computeGiMf();\n    return - Gq * a - GW * b - GiMf*h;\n};\n\n/**\n * Computes G*q, where q are the generalized body coordinates\n * @method computeGq\n * @return {Number}\n */\nvar qi = vec2.create(),\n    qj = vec2.create();\nEquation.prototype.computeGq = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        xi = bi.position,\n        xj = bj.position,\n        ai = bi.angle,\n        aj = bj.angle;\n\n    return Gmult(G, qi, ai, qj, aj) + this.offset;\n};\n\n/**\n * Computes G*W, where W are the body velocities\n * @method computeGW\n * @return {Number}\n */\nEquation.prototype.computeGW = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        vi = bi.velocity,\n        vj = bj.velocity,\n        wi = bi.angularVelocity,\n        wj = bj.angularVelocity;\n    return Gmult(G,vi,wi,vj,wj) + this.relativeVelocity;\n};\n\n/**\n * Computes G*Wlambda, where W are the body velocities\n * @method computeGWlambda\n * @return {Number}\n */\nEquation.prototype.computeGWlambda = function(){\n    var G = this.G,\n        bi = this.bodyA,\n        bj = this.bodyB,\n        vi = bi.vlambda,\n        vj = bj.vlambda,\n        wi = bi.wlambda,\n        wj = bj.wlambda;\n    return Gmult(G,vi,wi,vj,wj);\n};\n\n/**\n * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.\n * @method computeGiMf\n * @return {Number}\n */\nvar iMfi = vec2.create(),\n    iMfj = vec2.create();\nEquation.prototype.computeGiMf = function(){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        fi = bi.force,\n        ti = bi.angularForce,\n        fj = bj.force,\n        tj = bj.angularForce,\n        invMassi = getBodyInvMass(bi),\n        invMassj = getBodyInvMass(bj),\n        invIi = getBodyInvInertia(bi),\n        invIj = getBodyInvInertia(bj),\n        G = this.G;\n\n    vec2.scale(iMfi, fi,invMassi);\n    vec2.scale(iMfj, fj,invMassj);\n\n    return Gmult(G,iMfi,ti*invIi,iMfj,tj*invIj);\n};\n\nfunction getBodyInvMass(body){\n    if(body.sleepState === Body.SLEEPING){\n        return 0;\n    } else {\n        return body.invMass;\n    }\n}\nfunction getBodyInvInertia(body){\n    if(body.sleepState === Body.SLEEPING){\n        return 0;\n    } else {\n        return body.invInertia;\n    }\n}\n\n/**\n * Computes G*inv(M)*G'\n * @method computeGiMGt\n * @return {Number}\n */\nEquation.prototype.computeGiMGt = function(){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        invMassi = getBodyInvMass(bi),\n        invMassj = getBodyInvMass(bj),\n        invIi = getBodyInvInertia(bi),\n        invIj = getBodyInvInertia(bj),\n        G = this.G;\n\n    return  G[0] * G[0] * invMassi +\n            G[1] * G[1] * invMassi +\n            G[2] * G[2] *    invIi +\n            G[3] * G[3] * invMassj +\n            G[4] * G[4] * invMassj +\n            G[5] * G[5] *    invIj;\n};\n\nvar addToWlambda_temp = vec2.create(),\n    addToWlambda_Gi = vec2.create(),\n    addToWlambda_Gj = vec2.create(),\n    addToWlambda_ri = vec2.create(),\n    addToWlambda_rj = vec2.create(),\n    addToWlambda_Mdiag = vec2.create();\n\n/**\n * Add constraint velocity to the bodies.\n * @method addToWlambda\n * @param {Number} deltalambda\n */\nEquation.prototype.addToWlambda = function(deltalambda){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        temp = addToWlambda_temp,\n        Gi = addToWlambda_Gi,\n        Gj = addToWlambda_Gj,\n        ri = addToWlambda_ri,\n        rj = addToWlambda_rj,\n        invMassi = getBodyInvMass(bi),\n        invMassj = getBodyInvMass(bj),\n        invIi = getBodyInvInertia(bi),\n        invIj = getBodyInvInertia(bj),\n        Mdiag = addToWlambda_Mdiag,\n        G = this.G;\n\n    Gi[0] = G[0];\n    Gi[1] = G[1];\n    Gj[0] = G[3];\n    Gj[1] = G[4];\n\n    // Add to linear velocity\n    // v_lambda += inv(M) * delta_lamba * G\n    vec2.scale(temp, Gi, invMassi*deltalambda);\n    vec2.add( bi.vlambda, bi.vlambda, temp);\n    // This impulse is in the offset frame\n    // Also add contribution to angular\n    //bi.wlambda -= vec2.crossLength(temp,ri);\n    bi.wlambda += invIi * G[2] * deltalambda;\n\n\n    vec2.scale(temp, Gj, invMassj*deltalambda);\n    vec2.add( bj.vlambda, bj.vlambda, temp);\n    //bj.wlambda -= vec2.crossLength(temp,rj);\n    bj.wlambda += invIj * G[5] * deltalambda;\n};\n\n/**\n * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps\n * @method computeInvC\n * @param  {Number} eps\n * @return {Number}\n */\nEquation.prototype.computeInvC = function(eps){\n    return 1.0 / (this.computeGiMGt() + eps);\n};\n\n},{\"../math/vec2\":30,\"../objects/Body\":31,\"../utils/Utils\":47}],23:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\n,   Equation = require('./Equation')\n,   Utils = require('../utils/Utils');\n\nmodule.exports = FrictionEquation;\n\n/**\n * Constrains the slipping in a contact along a tangent\n *\n * @class FrictionEquation\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Number} slipForce\n * @extends Equation\n */\nfunction FrictionEquation(bodyA, bodyB, slipForce){\n    Equation.call(this, bodyA, bodyB, -slipForce, slipForce);\n\n    /**\n     * Relative vector from center of body A to the contact point, world oriented.\n     * @property contactPointA\n     * @type {Array}\n     */\n    this.contactPointA = vec2.create();\n\n    /**\n     * Relative vector from center of body B to the contact point, world oriented.\n     * @property contactPointB\n     * @type {Array}\n     */\n    this.contactPointB = vec2.create();\n\n    /**\n     * Tangent vector that the friction force will act along. World oriented.\n     * @property t\n     * @type {Array}\n     */\n    this.t = vec2.create();\n\n    /**\n     * A ContactEquation connected to this friction. The contact equation can be used to rescale the max force for the friction.\n     * @property contactEquation\n     * @type {ContactEquation}\n     */\n    this.contactEquation = null;\n\n    /**\n     * The shape in body i that triggered this friction.\n     * @property shapeA\n     * @type {Shape}\n     * @todo Needed? The shape can be looked up via contactEquation.shapeA...\n     */\n    this.shapeA = null;\n\n    /**\n     * The shape in body j that triggered this friction.\n     * @property shapeB\n     * @type {Shape}\n     * @todo Needed? The shape can be looked up via contactEquation.shapeB...\n     */\n    this.shapeB = null;\n\n    /**\n     * The friction coefficient to use.\n     * @property frictionCoefficient\n     * @type {Number}\n     */\n    this.frictionCoefficient = 0.3;\n}\nFrictionEquation.prototype = new Equation();\nFrictionEquation.prototype.constructor = FrictionEquation;\n\n/**\n * Set the slipping condition for the constraint. The friction force cannot be\n * larger than this value.\n * @method setSlipForce\n * @param  {Number} slipForce\n */\nFrictionEquation.prototype.setSlipForce = function(slipForce){\n    this.maxForce = slipForce;\n    this.minForce = -slipForce;\n};\n\n/**\n * Get the max force for the constraint.\n * @method getSlipForce\n * @return {Number}\n */\nFrictionEquation.prototype.getSlipForce = function(){\n    return this.maxForce;\n};\n\nFrictionEquation.prototype.computeB = function(a,b,h){\n    var bi = this.bodyA,\n        bj = this.bodyB,\n        ri = this.contactPointA,\n        rj = this.contactPointB,\n        t = this.t,\n        G = this.G;\n\n    // G = [-t -rixt t rjxt]\n    // And remember, this is a pure velocity constraint, g is always zero!\n    G[0] = -t[0];\n    G[1] = -t[1];\n    G[2] = -vec2.crossLength(ri,t);\n    G[3] = t[0];\n    G[4] = t[1];\n    G[5] = vec2.crossLength(rj,t);\n\n    var GW = this.computeGW(),\n        GiMf = this.computeGiMf();\n\n    var B = /* - g * a  */ - GW * b - h*GiMf;\n\n    return B;\n};\n\n},{\"../math/vec2\":30,\"../utils/Utils\":47,\"./Equation\":22}],24:[function(require,module,exports){\nvar Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = RotationalLockEquation;\n\n/**\n * Locks the relative angle between two bodies. The constraint tries to keep the dot product between two vectors, local in each body, to zero. The local angle in body i is a parameter.\n *\n * @class RotationalLockEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {Number} [options.angle] Angle to add to the local vector in body i.\n */\nfunction RotationalLockEquation(bodyA, bodyB, options){\n    options = options || {};\n    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n    this.angle = options.angle || 0;\n\n    var G = this.G;\n    G[2] =  1;\n    G[5] = -1;\n}\nRotationalLockEquation.prototype = new Equation();\nRotationalLockEquation.prototype.constructor = RotationalLockEquation;\n\nvar worldVectorA = vec2.create(),\n    worldVectorB = vec2.create(),\n    xAxis = vec2.fromValues(1,0),\n    yAxis = vec2.fromValues(0,1);\nRotationalLockEquation.prototype.computeGq = function(){\n    vec2.rotate(worldVectorA,xAxis,this.bodyA.angle+this.angle);\n    vec2.rotate(worldVectorB,yAxis,this.bodyB.angle);\n    return vec2.dot(worldVectorA,worldVectorB);\n};\n\n},{\"../math/vec2\":30,\"./Equation\":22}],25:[function(require,module,exports){\nvar Equation = require(\"./Equation\"),\n    vec2 = require('../math/vec2');\n\nmodule.exports = RotationalVelocityEquation;\n\n/**\n * Syncs rotational velocity of two bodies, or sets a relative velocity (motor).\n *\n * @class RotationalVelocityEquation\n * @constructor\n * @extends Equation\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nfunction RotationalVelocityEquation(bodyA, bodyB){\n    Equation.call(this, bodyA, bodyB, -Number.MAX_VALUE, Number.MAX_VALUE);\n    this.relativeVelocity = 1;\n    this.ratio = 1;\n}\nRotationalVelocityEquation.prototype = new Equation();\nRotationalVelocityEquation.prototype.constructor = RotationalVelocityEquation;\nRotationalVelocityEquation.prototype.computeB = function(a,b,h){\n    var G = this.G;\n    G[2] = -1;\n    G[5] = this.ratio;\n\n    var GiMf = this.computeGiMf();\n    var GW = this.computeGW();\n    var B = - GW * b - h*GiMf;\n\n    return B;\n};\n\n},{\"../math/vec2\":30,\"./Equation\":22}],26:[function(require,module,exports){\n/**\n * Base class for objects that dispatches events.\n * @class EventEmitter\n * @constructor\n */\nvar EventEmitter = function () {}\n\nmodule.exports = EventEmitter;\n\nEventEmitter.prototype = {\n    constructor: EventEmitter,\n\n    /**\n     * Add an event listener\n     * @method on\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    on: function ( type, listener, context ) {\n        listener.context = context || this;\n        if ( this._listeners === undefined ) this._listeners = {};\n        var listeners = this._listeners;\n        if ( listeners[ type ] === undefined ) {\n            listeners[ type ] = [];\n        }\n        if ( listeners[ type ].indexOf( listener ) === - 1 ) {\n            listeners[ type ].push( listener );\n        }\n        return this;\n    },\n\n    /**\n     * Check if an event listener is added\n     * @method has\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {Boolean}\n     */\n    has: function ( type, listener ) {\n        if ( this._listeners === undefined ) return false;\n        var listeners = this._listeners;\n        if(listener){\n            if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n                return true;\n            }\n        } else {\n            if ( listeners[ type ] !== undefined ) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    /**\n     * Remove an event listener\n     * @method off\n     * @param  {String} type\n     * @param  {Function} listener\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    off: function ( type, listener ) {\n        if ( this._listeners === undefined ) return this;\n        var listeners = this._listeners;\n        var index = listeners[ type ].indexOf( listener );\n        if ( index !== - 1 ) {\n            listeners[ type ].splice( index, 1 );\n        }\n        return this;\n    },\n\n    /**\n     * Emit an event.\n     * @method emit\n     * @param  {Object} event\n     * @param  {String} event.type\n     * @return {EventEmitter} The self object, for chainability.\n     */\n    emit: function ( event ) {\n        if ( this._listeners === undefined ) return this;\n        var listeners = this._listeners;\n        var listenerArray = listeners[ event.type ];\n        if ( listenerArray !== undefined ) {\n            event.target = this;\n            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {\n                var listener = listenerArray[ i ];\n                listener.call( listener.context, event );\n            }\n        }\n        return this;\n    }\n};\n\n},{}],27:[function(require,module,exports){\nvar Material = require('./Material');\nvar Equation = require('../equations/Equation');\n\nmodule.exports = ContactMaterial;\n\n/**\n * Defines what happens when two materials meet, such as what friction coefficient to use. You can also set other things such as restitution, surface velocity and constraint parameters.\n * @class ContactMaterial\n * @constructor\n * @param {Material} materialA\n * @param {Material} materialB\n * @param {Object}   [options]\n * @param {Number}   [options.friction=0.3]       Friction coefficient.\n * @param {Number}   [options.restitution=0]      Restitution coefficient aka \"bounciness\".\n * @param {Number}   [options.stiffness]          ContactEquation stiffness.\n * @param {Number}   [options.relaxation]         ContactEquation relaxation.\n * @param {Number}   [options.frictionStiffness]  FrictionEquation stiffness.\n * @param {Number}   [options.frictionRelaxation] FrictionEquation relaxation.\n * @param {Number}   [options.surfaceVelocity=0]  Surface velocity.\n * @author schteppe\n */\nfunction ContactMaterial(materialA, materialB, options){\n    options = options || {};\n\n    if(!(materialA instanceof Material) || !(materialB instanceof Material))\n        throw new Error(\"First two arguments must be Material instances.\");\n\n    /**\n     * The contact material identifier\n     * @property id\n     * @type {Number}\n     */\n    this.id = ContactMaterial.idCounter++;\n\n    /**\n     * First material participating in the contact material\n     * @property materialA\n     * @type {Material}\n     */\n    this.materialA = materialA;\n\n    /**\n     * Second material participating in the contact material\n     * @property materialB\n     * @type {Material}\n     */\n    this.materialB = materialB;\n\n    /**\n     * Friction to use in the contact of these two materials\n     * @property friction\n     * @type {Number}\n     */\n    this.friction    =  typeof(options.friction)    !== \"undefined\" ?   Number(options.friction)    : 0.3;\n\n    /**\n     * Restitution to use in the contact of these two materials\n     * @property restitution\n     * @type {Number}\n     */\n    this.restitution =  typeof(options.restitution) !== \"undefined\" ?   Number(options.restitution) : 0.0;\n\n    /**\n     * Stiffness of the resulting ContactEquation that this ContactMaterial generate\n     * @property stiffness\n     * @type {Number}\n     */\n    this.stiffness =            typeof(options.stiffness)           !== \"undefined\" ?   Number(options.stiffness)   : Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * Relaxation of the resulting ContactEquation that this ContactMaterial generate\n     * @property relaxation\n     * @type {Number}\n     */\n    this.relaxation =           typeof(options.relaxation)          !== \"undefined\" ?   Number(options.relaxation)  : Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Stiffness of the resulting FrictionEquation that this ContactMaterial generate\n     * @property frictionStiffness\n     * @type {Number}\n     */\n    this.frictionStiffness =    typeof(options.frictionStiffness)   !== \"undefined\" ?   Number(options.frictionStiffness)   : Equation.DEFAULT_STIFFNESS;\n\n    /**\n     * Relaxation of the resulting FrictionEquation that this ContactMaterial generate\n     * @property frictionRelaxation\n     * @type {Number}\n     */\n    this.frictionRelaxation =   typeof(options.frictionRelaxation)  !== \"undefined\" ?   Number(options.frictionRelaxation)  : Equation.DEFAULT_RELAXATION;\n\n    /**\n     * Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.\n     * @property {Number} surfaceVelocity\n     */\n    this.surfaceVelocity = typeof(options.surfaceVelocity)    !== \"undefined\" ?   Number(options.surfaceVelocity)    : 0;\n}\n\nContactMaterial.idCounter = 0;\n\n},{\"../equations/Equation\":22,\"./Material\":28}],28:[function(require,module,exports){\nmodule.exports = Material;\n\n/**\n * Defines a physics material.\n * @class Material\n * @constructor\n * @param string name\n * @author schteppe\n */\nfunction Material(){\n    /**\n     * The material identifier\n     * @property id\n     * @type {Number}\n     */\n    this.id = Material.idCounter++;\n};\n\nMaterial.idCounter = 0;\n\n},{}],29:[function(require,module,exports){\n\n    /*\n        PolyK library\n        url: http://polyk.ivank.net\n        Released under MIT licence.\n\n        Copyright (c) 2012 Ivan Kuckir\n\n        Permission is hereby granted, free of charge, to any person\n        obtaining a copy of this software and associated documentation\n        files (the \"Software\"), to deal in the Software without\n        restriction, including without limitation the rights to use,\n        copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the\n        Software is furnished to do so, subject to the following\n        conditions:\n\n        The above copyright notice and this permission notice shall be\n        included in all copies or substantial portions of the Software.\n\n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n        OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n        WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n        FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n        OTHER DEALINGS IN THE SOFTWARE.\n    */\n\n    var PolyK = {};\n\n    /*\n        Is Polygon self-intersecting?\n\n        O(n^2)\n    */\n    /*\n    PolyK.IsSimple = function(p)\n    {\n        var n = p.length>>1;\n        if(n<4) return true;\n        var a1 = new PolyK._P(), a2 = new PolyK._P();\n        var b1 = new PolyK._P(), b2 = new PolyK._P();\n        var c = new PolyK._P();\n\n        for(var i=0; i<n; i++)\n        {\n            a1.x = p[2*i  ];\n            a1.y = p[2*i+1];\n            if(i==n-1)  { a2.x = p[0    ];  a2.y = p[1    ]; }\n            else        { a2.x = p[2*i+2];  a2.y = p[2*i+3]; }\n\n            for(var j=0; j<n; j++)\n            {\n                if(Math.abs(i-j) < 2) continue;\n                if(j==n-1 && i==0) continue;\n                if(i==n-1 && j==0) continue;\n\n                b1.x = p[2*j  ];\n                b1.y = p[2*j+1];\n                if(j==n-1)  { b2.x = p[0    ];  b2.y = p[1    ]; }\n                else        { b2.x = p[2*j+2];  b2.y = p[2*j+3]; }\n\n                if(PolyK._GetLineIntersection(a1,a2,b1,b2,c) != null) return false;\n            }\n        }\n        return true;\n    }\n\n    PolyK.IsConvex = function(p)\n    {\n        if(p.length<6) return true;\n        var l = p.length - 4;\n        for(var i=0; i<l; i+=2)\n            if(!PolyK._convex(p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5])) return false;\n        if(!PolyK._convex(p[l  ], p[l+1], p[l+2], p[l+3], p[0], p[1])) return false;\n        if(!PolyK._convex(p[l+2], p[l+3], p[0  ], p[1  ], p[2], p[3])) return false;\n        return true;\n    }\n    */\n    PolyK.GetArea = function(p)\n    {\n        if(p.length <6) return 0;\n        var l = p.length - 2;\n        var sum = 0;\n        for(var i=0; i<l; i+=2)\n            sum += (p[i+2]-p[i]) * (p[i+1]+p[i+3]);\n        sum += (p[0]-p[l]) * (p[l+1]+p[1]);\n        return - sum * 0.5;\n    }\n    /*\n    PolyK.GetAABB = function(p)\n    {\n        var minx = Infinity;\n        var miny = Infinity;\n        var maxx = -minx;\n        var maxy = -miny;\n        for(var i=0; i<p.length; i+=2)\n        {\n            minx = Math.min(minx, p[i  ]);\n            maxx = Math.max(maxx, p[i  ]);\n            miny = Math.min(miny, p[i+1]);\n            maxy = Math.max(maxy, p[i+1]);\n        }\n        return {x:minx, y:miny, width:maxx-minx, height:maxy-miny};\n    }\n    */\n\n    PolyK.Triangulate = function(p)\n    {\n        var n = p.length>>1;\n        if(n<3) return [];\n        var tgs = [];\n        var avl = [];\n        for(var i=0; i<n; i++) avl.push(i);\n\n        var i = 0;\n        var al = n;\n        while(al > 3)\n        {\n            var i0 = avl[(i+0)%al];\n            var i1 = avl[(i+1)%al];\n            var i2 = avl[(i+2)%al];\n\n            var ax = p[2*i0],  ay = p[2*i0+1];\n            var bx = p[2*i1],  by = p[2*i1+1];\n            var cx = p[2*i2],  cy = p[2*i2+1];\n\n            var earFound = false;\n            if(PolyK._convex(ax, ay, bx, by, cx, cy))\n            {\n                earFound = true;\n                for(var j=0; j<al; j++)\n                {\n                    var vi = avl[j];\n                    if(vi==i0 || vi==i1 || vi==i2) continue;\n                    if(PolyK._PointInTriangle(p[2*vi], p[2*vi+1], ax, ay, bx, by, cx, cy)) {earFound = false; break;}\n                }\n            }\n            if(earFound)\n            {\n                tgs.push(i0, i1, i2);\n                avl.splice((i+1)%al, 1);\n                al--;\n                i= 0;\n            }\n            else if(i++ > 3*al) break;      // no convex angles :(\n        }\n        tgs.push(avl[0], avl[1], avl[2]);\n        return tgs;\n    }\n    /*\n    PolyK.ContainsPoint = function(p, px, py)\n    {\n        var n = p.length>>1;\n        var ax, ay, bx = p[2*n-2]-px, by = p[2*n-1]-py;\n        var depth = 0;\n        for(var i=0; i<n; i++)\n        {\n            ax = bx;  ay = by;\n            bx = p[2*i  ] - px;\n            by = p[2*i+1] - py;\n            if(ay< 0 && by< 0) continue;    // both \"up\" or both \"donw\"\n            if(ay>=0 && by>=0) continue;    // both \"up\" or both \"donw\"\n            if(ax< 0 && bx< 0) continue;\n\n            var lx = ax + (bx-ax)*(-ay)/(by-ay);\n            if(lx>0) depth++;\n        }\n        return (depth & 1) == 1;\n    }\n\n    PolyK.Slice = function(p, ax, ay, bx, by)\n    {\n        if(PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by)) return [p.slice(0)];\n\n        var a = new PolyK._P(ax, ay);\n        var b = new PolyK._P(bx, by);\n        var iscs = [];  // intersections\n        var ps = [];    // points\n        for(var i=0; i<p.length; i+=2) ps.push(new PolyK._P(p[i], p[i+1]));\n\n        for(var i=0; i<ps.length; i++)\n        {\n            var isc = new PolyK._P(0,0);\n            isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i+1)%ps.length], isc);\n\n            if(isc)\n            {\n                isc.flag = true;\n                iscs.push(isc);\n                ps.splice(i+1,0,isc);\n                i++;\n            }\n        }\n        if(iscs.length == 0) return [p.slice(0)];\n        var comp = function(u,v) {return PolyK._P.dist(a,u) - PolyK._P.dist(a,v); }\n        iscs.sort(comp);\n\n        var pgs = [];\n        var dir = 0;\n        while(iscs.length > 0)\n        {\n            var n = ps.length;\n            var i0 = iscs[0];\n            var i1 = iscs[1];\n            var ind0 = ps.indexOf(i0);\n            var ind1 = ps.indexOf(i1);\n            var solved = false;\n\n            if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;\n            else\n            {\n                i0 = iscs[1];\n                i1 = iscs[0];\n                ind0 = ps.indexOf(i0);\n                ind1 = ps.indexOf(i1);\n                if(PolyK._firstWithFlag(ps, ind0) == ind1) solved = true;\n            }\n            if(solved)\n            {\n                dir--;\n                var pgn = PolyK._getPoints(ps, ind0, ind1);\n                pgs.push(pgn);\n                ps = PolyK._getPoints(ps, ind1, ind0);\n                i0.flag = i1.flag = false;\n                iscs.splice(0,2);\n                if(iscs.length == 0) pgs.push(ps);\n            }\n            else { dir++; iscs.reverse(); }\n            if(dir>1) break;\n        }\n        var result = [];\n        for(var i=0; i<pgs.length; i++)\n        {\n            var pg = pgs[i];\n            var npg = [];\n            for(var j=0; j<pg.length; j++) npg.push(pg[j].x, pg[j].y);\n            result.push(npg);\n        }\n        return result;\n    }\n\n    PolyK.Raycast = function(p, x, y, dx, dy, isc)\n    {\n        var l = p.length - 2;\n        var tp = PolyK._tp;\n        var a1 = tp[0], a2 = tp[1],\n        b1 = tp[2], b2 = tp[3], c = tp[4];\n        a1.x = x; a1.y = y;\n        a2.x = x+dx; a2.y = y+dy;\n\n        if(isc==null) isc = {dist:0, edge:0, norm:{x:0, y:0}, refl:{x:0, y:0}};\n        isc.dist = Infinity;\n\n        for(var i=0; i<l; i+=2)\n        {\n            b1.x = p[i  ];  b1.y = p[i+1];\n            b2.x = p[i+2];  b2.y = p[i+3];\n            var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n            if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, i/2, isc);\n        }\n        b1.x = b2.x;  b1.y = b2.y;\n        b2.x = p[0];  b2.y = p[1];\n        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n        if(nisc) PolyK._updateISC(dx, dy, a1, b1, b2, c, p.length/2, isc);\n\n        return (isc.dist != Infinity) ? isc : null;\n    }\n\n    PolyK.ClosestEdge = function(p, x, y, isc)\n    {\n        var l = p.length - 2;\n        var tp = PolyK._tp;\n        var a1 = tp[0],\n        b1 = tp[2], b2 = tp[3], c = tp[4];\n        a1.x = x; a1.y = y;\n\n        if(isc==null) isc = {dist:0, edge:0, point:{x:0, y:0}, norm:{x:0, y:0}};\n        isc.dist = Infinity;\n\n        for(var i=0; i<l; i+=2)\n        {\n            b1.x = p[i  ];  b1.y = p[i+1];\n            b2.x = p[i+2];  b2.y = p[i+3];\n            PolyK._pointLineDist(a1, b1, b2, i>>1, isc);\n        }\n        b1.x = b2.x;  b1.y = b2.y;\n        b2.x = p[0];  b2.y = p[1];\n        PolyK._pointLineDist(a1, b1, b2, l>>1, isc);\n\n        var idst = 1/isc.dist;\n        isc.norm.x = (x-isc.point.x)*idst;\n        isc.norm.y = (y-isc.point.y)*idst;\n        return isc;\n    }\n\n    PolyK._pointLineDist = function(p, a, b, edge, isc)\n    {\n        var x = p.x, y = p.y, x1 = a.x, y1 = a.y, x2 = b.x, y2 = b.y;\n\n        var A = x - x1;\n        var B = y - y1;\n        var C = x2 - x1;\n        var D = y2 - y1;\n\n        var dot = A * C + B * D;\n        var len_sq = C * C + D * D;\n        var param = dot / len_sq;\n\n        var xx, yy;\n\n        if (param < 0 || (x1 == x2 && y1 == y2)) {\n            xx = x1;\n            yy = y1;\n        }\n        else if (param > 1) {\n            xx = x2;\n            yy = y2;\n        }\n        else {\n            xx = x1 + param * C;\n            yy = y1 + param * D;\n        }\n\n        var dx = x - xx;\n        var dy = y - yy;\n        var dst = Math.sqrt(dx * dx + dy * dy);\n        if(dst<isc.dist)\n        {\n            isc.dist = dst;\n            isc.edge = edge;\n            isc.point.x = xx;\n            isc.point.y = yy;\n        }\n    }\n\n    PolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)\n    {\n        var nrl = PolyK._P.dist(a1, c);\n        if(nrl<isc.dist)\n        {\n            var ibl = 1/PolyK._P.dist(b1, b2);\n            var nx = -(b2.y-b1.y)*ibl;\n            var ny =  (b2.x-b1.x)*ibl;\n            var ddot = 2*(dx*nx+dy*ny);\n            isc.dist = nrl;\n            isc.norm.x = nx;\n            isc.norm.y = ny;\n            isc.refl.x = -ddot*nx+dx;\n            isc.refl.y = -ddot*ny+dy;\n            isc.edge = edge;\n        }\n    }\n\n    PolyK._getPoints = function(ps, ind0, ind1)\n    {\n        var n = ps.length;\n        var nps = [];\n        if(ind1<ind0) ind1 += n;\n        for(var i=ind0; i<= ind1; i++) nps.push(ps[i%n]);\n        return nps;\n    }\n\n    PolyK._firstWithFlag = function(ps, ind)\n    {\n        var n = ps.length;\n        while(true)\n        {\n            ind = (ind+1)%n;\n            if(ps[ind].flag) return ind;\n        }\n    }\n    */\n    PolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n    {\n        var v0x = cx-ax;\n        var v0y = cy-ay;\n        var v1x = bx-ax;\n        var v1y = by-ay;\n        var v2x = px-ax;\n        var v2y = py-ay;\n\n        var dot00 = v0x*v0x+v0y*v0y;\n        var dot01 = v0x*v1x+v0y*v1y;\n        var dot02 = v0x*v2x+v0y*v2y;\n        var dot11 = v1x*v1x+v1y*v1y;\n        var dot12 = v1x*v2x+v1y*v2y;\n\n        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n        // Check if point is in triangle\n        return (u >= 0) && (v >= 0) && (u + v < 1);\n    }\n    /*\n    PolyK._RayLineIntersection = function(a1, a2, b1, b2, c)\n    {\n        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n        var day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n        var Den = dax*dby - day*dbx;\n        if (Den == 0) return null;  // parallel\n\n        var A = (a1.x * a2.y - a1.y * a2.x);\n        var B = (b1.x * b2.y - b1.y * b2.x);\n\n        var I = c;\n        var iDen = 1/Den;\n        I.x = ( A*dbx - dax*B ) * iDen;\n        I.y = ( A*dby - day*B ) * iDen;\n\n        if(!PolyK._InRect(I, b1, b2)) return null;\n        if((day>0 && I.y>a1.y) || (day<0 && I.y<a1.y)) return null;\n        if((dax>0 && I.x>a1.x) || (dax<0 && I.x<a1.x)) return null;\n        return I;\n    }\n\n    PolyK._GetLineIntersection = function(a1, a2, b1, b2, c)\n    {\n        var dax = (a1.x-a2.x), dbx = (b1.x-b2.x);\n        var day = (a1.y-a2.y), dby = (b1.y-b2.y);\n\n        var Den = dax*dby - day*dbx;\n        if (Den == 0) return null;  // parallel\n\n        var A = (a1.x * a2.y - a1.y * a2.x);\n        var B = (b1.x * b2.y - b1.y * b2.x);\n\n        var I = c;\n        I.x = ( A*dbx - dax*B ) / Den;\n        I.y = ( A*dby - day*B ) / Den;\n\n        if(PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2)) return I;\n        return null;\n    }\n\n    PolyK._InRect = function(a, b, c)\n    {\n        if  (b.x == c.x) return (a.y>=Math.min(b.y, c.y) && a.y<=Math.max(b.y, c.y));\n        if  (b.y == c.y) return (a.x>=Math.min(b.x, c.x) && a.x<=Math.max(b.x, c.x));\n\n        if(a.x >= Math.min(b.x, c.x) && a.x <= Math.max(b.x, c.x)\n        && a.y >= Math.min(b.y, c.y) && a.y <= Math.max(b.y, c.y))\n        return true;\n        return false;\n    }\n    */\n    PolyK._convex = function(ax, ay, bx, by, cx, cy)\n    {\n        return (ay-by)*(cx-bx) + (bx-ax)*(cy-by) >= 0;\n    }\n    /*\n    PolyK._P = function(x,y)\n    {\n        this.x = x;\n        this.y = y;\n        this.flag = false;\n    }\n    PolyK._P.prototype.toString = function()\n    {\n        return \"Point [\"+this.x+\", \"+this.y+\"]\";\n    }\n    PolyK._P.dist = function(a,b)\n    {\n        var dx = b.x-a.x;\n        var dy = b.y-a.y;\n        return Math.sqrt(dx*dx + dy*dy);\n    }\n\n    PolyK._tp = [];\n    for(var i=0; i<10; i++) PolyK._tp.push(new PolyK._P(0,0));\n        */\n\nmodule.exports = PolyK;\n\n},{}],30:[function(require,module,exports){\n/**\n * The vec2 object from glMatrix, with some extensions and some removed methods. See http://glmatrix.net for full doc.\n * @class vec2\n */\n\nvar vec2 = require('../../build/vec2').vec2;\n\n/**\n * Make a cross product and only return the z component\n * @method crossLength\n * @static\n * @param  {Float32Array} a\n * @param  {Float32Array} b\n * @return {Number}\n */\nvec2.crossLength = function(a,b){\n    return a[0] * b[1] - a[1] * b[0];\n};\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @method crossVZ\n * @static\n * @param  {Float32Array} out\n * @param  {Float32Array} vec\n * @param  {Number} zcomp\n * @return {Number}\n */\nvec2.crossVZ = function(out, vec, zcomp){\n    vec2.rotate(out,vec,-Math.PI/2);// Rotate according to the right hand rule\n    vec2.scale(out,out,zcomp);      // Scale with z\n    return out;\n};\n\n/**\n * Cross product between a vector and the Z component of a vector\n * @method crossZV\n * @static\n * @param  {Float32Array} out\n * @param  {Number} zcomp\n * @param  {Float32Array} vec\n * @return {Number}\n */\nvec2.crossZV = function(out, zcomp, vec){\n    vec2.rotate(out,vec,Math.PI/2); // Rotate according to the right hand rule\n    vec2.scale(out,out,zcomp);      // Scale with z\n    return out;\n};\n\n/**\n * Rotate a vector by an angle\n * @method rotate\n * @static\n * @param  {Float32Array} out\n * @param  {Float32Array} a\n * @param  {Number} angle\n */\nvec2.rotate = function(out,a,angle){\n    var c = Math.cos(angle),\n        s = Math.sin(angle),\n        x = a[0],\n        y = a[1];\n    out[0] = c*x -s*y;\n    out[1] = s*x +c*y;\n};\n\n/**\n * Rotate a vector 90 degrees clockwise\n * @method rotate90cw\n * @static\n * @param  {Float32Array} out\n * @param  {Float32Array} a\n * @param  {Number} angle\n */\nvec2.rotate90cw = function(out, a) {\n    out[0] = a[1];\n    out[1] = -a[0];\n};\n\n/**\n * Transform a point position to local frame.\n * @method toLocalFrame\n * @param  {Array} out\n * @param  {Array} worldPoint\n * @param  {Array} framePosition\n * @param  {Number} frameAngle\n */\nvec2.toLocalFrame = function(out, worldPoint, framePosition, frameAngle){\n    vec2.copy(out, worldPoint);\n    vec2.sub(out, out, framePosition);\n    vec2.rotate(out, out, -frameAngle);\n};\n\n/**\n * Transform a point position to global frame.\n * @method toGlobalFrame\n * @param  {Array} out\n * @param  {Array} localPoint\n * @param  {Array} framePosition\n * @param  {Number} frameAngle\n */\nvec2.toGlobalFrame = function(out, localPoint, framePosition, frameAngle){\n    vec2.copy(out, localPoint);\n    vec2.rotate(out, out, frameAngle);\n    vec2.add(out, out, framePosition);\n};\n\n/**\n * Compute centroid of a triangle spanned by vectors a,b,c. See http://easycalculation.com/analytical/learn-centroid.php\n * @method centroid\n * @static\n * @param  {Float32Array} out\n * @param  {Float32Array} a\n * @param  {Float32Array} b\n * @param  {Float32Array} c\n * @return  {Float32Array} The out object\n */\nvec2.centroid = function(out, a, b, c){\n    vec2.add(out, a, b);\n    vec2.add(out, out, c);\n    vec2.scale(out, out, 1/3);\n    return out;\n};\n\n// Export everything\nmodule.exports = vec2;\n\n},{\"../../build/vec2\":1}],31:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\n,   decomp = require('poly-decomp')\n,   Convex = require('../shapes/Convex')\n,   AABB = require('../collision/AABB')\n,   EventEmitter = require('../events/EventEmitter')\n\nmodule.exports = Body;\n\n/**\n * A rigid body. Has got a center of mass, position, velocity and a number of\n * shapes that are used for collisions.\n *\n * @class Body\n * @constructor\n * @extends EventEmitter\n * @param {Object}              [options]\n * @param {Number}              [options.mass=0]    A number >= 0. If zero, the .motionState will be set to Body.STATIC.\n * @param {Array}               [options.position]\n * @param {Array}               [options.velocity]\n * @param {Number}              [options.angle=0]\n * @param {Number}              [options.angularVelocity=0]\n * @param {Array}               [options.force]\n * @param {Number}              [options.angularForce=0]\n * @param {Number}              [options.fixedRotation=false]\n */\nfunction Body(options){\n    options = options || {};\n\n    EventEmitter.call(this);\n\n    /**\n     * The body identifyer\n     * @property id\n     * @type {Number}\n     */\n    this.id = ++Body._idCounter;\n\n    /**\n     * The world that this body is added to. This property is set to NULL if the body is not added to any world.\n     * @property world\n     * @type {World}\n     */\n    this.world = null;\n\n    /**\n     * The shapes of the body. The local transform of the shape in .shapes[i] is\n     * defined by .shapeOffsets[i] and .shapeAngles[i].\n     *\n     * @property shapes\n     * @type {Array}\n     */\n    this.shapes = [];\n\n    /**\n     * The local shape offsets, relative to the body center of mass. This is an\n     * array of Array.\n     * @property shapeOffsets\n     * @type {Array}\n     */\n    this.shapeOffsets = [];\n\n    /**\n     * The body-local shape angle transforms. This is an array of numbers (angles).\n     * @property shapeAngles\n     * @type {Array}\n     */\n    this.shapeAngles = [];\n\n    /**\n     * The mass of the body.\n     * @property mass\n     * @type {number}\n     */\n    this.mass = options.mass || 0;\n\n    /**\n     * The inverse mass of the body.\n     * @property invMass\n     * @type {number}\n     */\n    this.invMass = 0;\n\n    /**\n     * The inertia of the body around the Z axis.\n     * @property inertia\n     * @type {number}\n     */\n    this.inertia = 0;\n\n    /**\n     * The inverse inertia of the body.\n     * @property invInertia\n     * @type {number}\n     */\n    this.invInertia = 0;\n\n    /**\n     * Set to true if you want to fix the rotation of the body.\n     * @property fixedRotation\n     * @type {Boolean}\n     */\n    this.fixedRotation = !!options.fixedRotation || false;\n\n    /**\n     * The position of the body\n     * @property position\n     * @type {Array}\n     */\n    this.position = vec2.fromValues(0,0);\n    if(options.position){\n        vec2.copy(this.position, options.position);\n    }\n\n    /**\n     * The interpolated position of the body.\n     * @property interpolatedPosition\n     * @type {Array}\n     */\n    this.interpolatedPosition = vec2.fromValues(0,0);\n\n    /**\n     * The interpolated angle of the body.\n     * @property interpolatedAngle\n     * @type {Number}\n     */\n    this.interpolatedAngle = 0;\n\n    /**\n     * The previous position of the body.\n     * @property previousPosition\n     * @type {Array}\n     */\n    this.previousPosition = vec2.fromValues(0,0);\n\n    /**\n     * The previous angle of the body.\n     * @property previousAngle\n     * @type {Number}\n     */\n    this.previousAngle = 0;\n\n    /**\n     * The velocity of the body\n     * @property velocity\n     * @type {Array}\n     */\n    this.velocity = vec2.fromValues(0,0);\n    if(options.velocity){\n        vec2.copy(this.velocity, options.velocity);\n    }\n\n    /**\n     * Constraint velocity that was added to the body during the last step.\n     * @property vlambda\n     * @type {Array}\n     */\n    this.vlambda = vec2.fromValues(0,0);\n\n    /**\n     * Angular constraint velocity that was added to the body during last step.\n     * @property wlambda\n     * @type {Array}\n     */\n    this.wlambda = 0;\n\n    /**\n     * The angle of the body, in radians.\n     * @property angle\n     * @type {number}\n     * @example\n     *     // The angle property is not normalized to the interval 0 to 2*pi, it can be any value.\n     *     // If you need a value between 0 and 2*pi, use the following function to normalize it.\n     *     function normalizeAngle(angle){\n     *         angle = angle % (2*Math.PI);\n     *         if(angle < 0){\n     *             angle += (2*Math.PI);\n     *         }\n     *         return angle;\n     *     }\n     */\n    this.angle = options.angle || 0;\n\n    /**\n     * The angular velocity of the body, in radians per second.\n     * @property angularVelocity\n     * @type {number}\n     */\n    this.angularVelocity = options.angularVelocity || 0;\n\n    /**\n     * The force acting on the body. Since the body force (and {{#crossLink \"Body/angularForce:property\"}}{{/crossLink}}) will be zeroed after each step, so you need to set the force before each step.\n     * @property force\n     * @type {Array}\n     *\n     * @example\n     *     // This produces a forcefield of 1 Newton in the positive x direction.\n     *     for(var i=0; i<numSteps; i++){\n     *         body.force[0] = 1;\n     *         world.step(1/60);\n     *     }\n     *\n     * @example\n     *     // This will apply a rotational force on the body\n     *     for(var i=0; i<numSteps; i++){\n     *         body.angularForce = -3;\n     *         world.step(1/60);\n     *     }\n     */\n    this.force = vec2.create();\n    if(options.force) vec2.copy(this.force, options.force);\n\n    /**\n     * The angular force acting on the body. See {{#crossLink \"Body/force:property\"}}{{/crossLink}}.\n     * @property angularForce\n     * @type {number}\n     */\n    this.angularForce = options.angularForce || 0;\n\n    /**\n     * The linear damping acting on the body in the velocity direction. Should be a value between 0 and 1.\n     * @property damping\n     * @type {Number}\n     * @default 0.1\n     */\n    this.damping = typeof(options.damping)==\"number\" ? options.damping : 0.1;\n\n    /**\n     * The angular force acting on the body. Should be a value between 0 and 1.\n     * @property angularDamping\n     * @type {Number}\n     * @default 0.1\n     */\n    this.angularDamping = typeof(options.angularDamping)==\"number\" ? options.angularDamping : 0.1;\n\n    /**\n     * The type of motion this body has. Should be one of: {{#crossLink \"Body/STATIC:property\"}}Body.STATIC{{/crossLink}}, {{#crossLink \"Body/DYNAMIC:property\"}}Body.DYNAMIC{{/crossLink}} and {{#crossLink \"Body/KINEMATIC:property\"}}Body.KINEMATIC{{/crossLink}}.\n     *\n     * * Static bodies do not move, and they do not respond to forces or collision.\n     * * Dynamic bodies body can move and respond to collisions and forces.\n     * * Kinematic bodies only moves according to its .velocity, and does not respond to collisions or force.\n     *\n     * @property motionState\n     * @type {number}\n     *\n     * @example\n     *     // This body will move and interact with other bodies\n     *     var dynamicBody = new Body({\n     *         mass : 1  // If mass is nonzero, the body becomes dynamic automatically\n     *     });\n     *     dynamicBody.motionState == Body.DYNAMIC // true\n     *\n     * @example\n     *     // This body will not move at all\n     *     var staticBody = new Body({\n     *         mass : 0 // Will make the body static\n     *     });\n     *     staticBody.motionState == Body.STATIC // true\n     *\n     * @example\n     *     // This body will only move if you change its velocity\n     *     var kinematicBody = new Body();\n     *     kinematicBody.motionState = Body.KINEMATIC;\n     */\n    this.motionState = this.mass === 0 ? Body.STATIC : Body.DYNAMIC;\n\n    /**\n     * Bounding circle radius.\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    /**\n     * Bounding box of this body.\n     * @property aabb\n     * @type {AABB}\n     */\n    this.aabb = new AABB();\n\n    /**\n     * Indicates if the AABB needs update. Update it with {{#crossLink \"Body/updateAABB:method\"}}.updateAABB(){{/crossLink}}.\n     * @property aabbNeedsUpdate\n     * @type {Boolean}\n     * @see updateAABB\n     *\n     * @example\n     *     // Force update the AABB\n     *     body.aabbNeedsUpdate = true;\n     *     body.updateAABB();\n     *     console.log(body.aabbNeedsUpdate); // false\n     */\n    this.aabbNeedsUpdate = true;\n\n    /**\n     * If true, the body will automatically fall to sleep. Note that you need to enable sleeping in the {{#crossLink \"World\"}}{{/crossLink}} before anything will happen.\n     * @property allowSleep\n     * @type {Boolean}\n     * @default true\n     */\n    this.allowSleep = true;\n\n    this.wantsToSleep = false;\n\n    /**\n     * One of {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}}, {{#crossLink \"Body/SLEEPY:property\"}}Body.SLEEPY{{/crossLink}} and {{#crossLink \"Body/SLEEPING:property\"}}Body.SLEEPING{{/crossLink}}.\n     *\n     * The body is initially Body.AWAKE. If its velocity norm is below .sleepSpeedLimit, the sleepState will become Body.SLEEPY. If the body continues to be Body.SLEEPY for .sleepTimeLimit seconds, it will fall asleep (Body.SLEEPY).\n     *\n     * @property sleepState\n     * @type {Number}\n     * @default Body.AWAKE\n     */\n    this.sleepState = Body.AWAKE;\n\n    /**\n     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.\n     * @property sleepSpeedLimit\n     * @type {Number}\n     * @default 0.2\n     */\n    this.sleepSpeedLimit = 0.2;\n\n    /**\n     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.\n     * @property sleepTimeLimit\n     * @type {Number}\n     * @default 1\n     */\n    this.sleepTimeLimit = 1;\n\n    /**\n     * Gravity scaling factor. If you want the body to ignore gravity, set this to zero. If you want to reverse gravity, set it to -1.\n     * @property {Number} gravityScale\n     * @default 1\n     */\n    this.gravityScale = 1;\n\n    /**\n     * The last time when the body went to SLEEPY state.\n     * @property {Number} timeLastSleepy\n     * @private\n     */\n    this.timeLastSleepy = 0;\n\n    this.concavePath = null;\n\n    this.lastDampingScale = 1;\n    this.lastAngularDampingScale = 1;\n    this.lastDampingTimeStep = -1;\n\n    this._wakeUpAfterNarrowphase = false;\n\n    this.updateMassProperties();\n}\nBody.prototype = new EventEmitter();\n\nBody._idCounter = 0;\n\n/**\n * Set the total density of the body\n * @method setDensity\n */\nBody.prototype.setDensity = function(density) {\n    var totalArea = this.getArea();\n    this.mass = totalArea * density;\n    this.updateMassProperties();\n};\n\n/**\n * Get the total area of all shapes in the body\n * @method getArea\n * @return {Number}\n */\nBody.prototype.getArea = function() {\n    var totalArea = 0;\n    for(var i=0; i<this.shapes.length; i++){\n        totalArea += this.shapes[i].area;\n    }\n    return totalArea;\n};\n\nvar shapeAABB = new AABB(),\n    tmp = vec2.create();\n\n/**\n * Updates the AABB of the Body\n * @method updateAABB\n */\nBody.prototype.updateAABB = function() {\n    var shapes = this.shapes,\n        shapeOffsets = this.shapeOffsets,\n        shapeAngles = this.shapeAngles,\n        N = shapes.length;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i],\n            offset = tmp,\n            angle = shapeAngles[i] + this.angle;\n\n        // Get shape world offset\n        vec2.rotate(offset,shapeOffsets[i],this.angle);\n        vec2.add(offset,offset,this.position);\n\n        // Get shape AABB\n        shape.computeAABB(shapeAABB,offset,angle);\n\n        if(i===0)\n            this.aabb.copy(shapeAABB);\n        else\n            this.aabb.extend(shapeAABB);\n    }\n\n    this.aabbNeedsUpdate = false;\n};\n\n/**\n * Update the bounding radius of the body. Should be done if any of the shapes\n * are changed.\n * @method updateBoundingRadius\n */\nBody.prototype.updateBoundingRadius = function(){\n    var shapes = this.shapes,\n        shapeOffsets = this.shapeOffsets,\n        N = shapes.length,\n        radius = 0;\n\n    for(var i=0; i!==N; i++){\n        var shape = shapes[i],\n            offset = vec2.length(shapeOffsets[i]),\n            r = shape.boundingRadius;\n        if(offset + r > radius){\n            radius = offset + r;\n        }\n    }\n\n    this.boundingRadius = radius;\n};\n\n/**\n * Add a shape to the body. You can pass a local transform when adding a shape,\n * so that the shape gets an offset and angle relative to the body center of mass.\n * Will automatically update the mass properties and bounding radius.\n *\n * @method addShape\n * @param  {Shape}              shape\n * @param  {Array} [offset] Local body offset of the shape.\n * @param  {Number}             [angle]  Local body angle.\n *\n * @example\n *     var body = new Body(),\n *         shape = new Circle();\n *\n *     // Add the shape to the body, positioned in the center\n *     body.addShape(shape);\n *\n *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local x-axis.\n *     body.addShape(shape,[1,0]);\n *\n *     // Add another shape to the body, positioned 1 unit length from the body center of mass along the local y-axis, and rotated 90 degrees CCW.\n *     body.addShape(shape,[0,1],Math.PI/2);\n */\nBody.prototype.addShape = function(shape,offset,angle){\n    angle = angle || 0.0;\n\n    // Copy the offset vector\n    if(offset){\n        offset = vec2.fromValues(offset[0],offset[1]);\n    } else {\n        offset = vec2.fromValues(0,0);\n    }\n\n    this.shapes      .push(shape);\n    this.shapeOffsets.push(offset);\n    this.shapeAngles .push(angle);\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n\n    this.aabbNeedsUpdate = true;\n};\n\n/**\n * Remove a shape\n * @method removeShape\n * @param  {Shape}  shape\n * @return {Boolean}       True if the shape was found and removed, else false.\n */\nBody.prototype.removeShape = function(shape){\n    var idx = this.shapes.indexOf(shape);\n\n    if(idx !== -1){\n        this.shapes.splice(idx,1);\n        this.shapeOffsets.splice(idx,1);\n        this.shapeAngles.splice(idx,1);\n        this.aabbNeedsUpdate = true;\n        return true;\n    } else {\n        return false;\n    }\n};\n\n/**\n * Updates .inertia, .invMass, .invInertia for this Body. Should be called when\n * changing the structure or mass of the Body.\n *\n * @method updateMassProperties\n *\n * @example\n *     body.mass += 1;\n *     body.updateMassProperties();\n */\nBody.prototype.updateMassProperties = function(){\n    if(this.motionState === Body.STATIC || this.motionState === Body.KINEMATIC){\n\n        this.mass = Number.MAX_VALUE;\n        this.invMass = 0;\n        this.inertia = Number.MAX_VALUE;\n        this.invInertia = 0;\n\n    } else {\n\n        var shapes = this.shapes,\n            N = shapes.length,\n            m = this.mass / N,\n            I = 0;\n\n        if(!this.fixedRotation){\n            for(var i=0; i<N; i++){\n                var shape = shapes[i],\n                    r2 = vec2.squaredLength(this.shapeOffsets[i]),\n                    Icm = shape.computeMomentOfInertia(m);\n                I += Icm + m*r2;\n            }\n            this.inertia = I;\n            this.invInertia = I>0 ? 1/I : 0;\n\n        } else {\n            this.inertia = Number.MAX_VALUE;\n            this.invInertia = 0;\n        }\n\n        // Inverse mass properties are easy\n        this.invMass = 1/this.mass;// > 0 ? 1/this.mass : 0;\n    }\n};\n\nvar Body_applyForce_r = vec2.create();\n\n/**\n * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.\n * @method applyForce\n * @param {Array} force The force to add.\n * @param {Array} worldPoint A world point to apply the force on.\n */\nBody.prototype.applyForce = function(force,worldPoint){\n    // Compute point position relative to the body center\n    var r = Body_applyForce_r;\n    vec2.sub(r,worldPoint,this.position);\n\n    // Add linear force\n    vec2.add(this.force,this.force,force);\n\n    // Compute produced rotational force\n    var rotForce = vec2.crossLength(r,force);\n\n    // Add rotational force\n    this.angularForce += rotForce;\n};\n\n/**\n * Transform a world point to local body frame.\n * @method toLocalFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} worldPoint   The input world vector\n */\nBody.prototype.toLocalFrame = function(out, worldPoint){\n    vec2.toLocalFrame(out, worldPoint, this.position, this.angle);\n};\n\n/**\n * Transform a local point to world frame.\n * @method toWorldFrame\n * @param  {Array} out          The vector to store the result in\n * @param  {Array} localPoint   The input local vector\n */\nBody.prototype.toWorldFrame = function(out, localPoint){\n    vec2.toGlobalFrame(out, localPoint, this.position, this.angle);\n};\n\n/**\n * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points.\n * @method fromPolygon\n * @param {Array} path An array of 2d vectors, e.g. [[0,0],[0,1],...] that resembles a concave or convex polygon. The shape must be simple and without holes.\n * @param {Object} [options]\n * @param {Boolean} [options.optimalDecomp=false]   Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n * @param {Boolean} [options.skipSimpleCheck=false] Set to true if you already know that the path is not intersecting itself.\n * @param {Boolean|Number} [options.removeCollinearPoints=false] Set to a number (angle threshold value) to remove collinear points, or false to keep all points.\n * @return {Boolean} True on success, else false.\n */\nBody.prototype.fromPolygon = function(path,options){\n    options = options || {};\n\n    // Remove all shapes\n    for(var i=this.shapes.length; i>=0; --i)\n        this.removeShape(this.shapes[i]);\n\n    var p = new decomp.Polygon();\n    p.vertices = path;\n\n    // Make it counter-clockwise\n    p.makeCCW();\n\n    if(typeof(options.removeCollinearPoints)==\"number\"){\n        p.removeCollinearPoints(options.removeCollinearPoints);\n    }\n\n    // Check if any line segment intersects the path itself\n    if(typeof(options.skipSimpleCheck) == \"undefined\"){\n        if(!p.isSimple()) return false;\n    }\n\n    // Save this path for later\n    this.concavePath = p.vertices.slice(0);\n    for(var i=0; i<this.concavePath.length; i++){\n        var v = [0,0];\n        vec2.copy(v,this.concavePath[i]);\n        this.concavePath[i] = v;\n    }\n\n    // Slow or fast decomp?\n    var convexes;\n    if(options.optimalDecomp)   convexes = p.decomp();\n    else                        convexes = p.quickDecomp();\n\n    var cm = vec2.create();\n\n    // Add convexes\n    for(var i=0; i!==convexes.length; i++){\n        // Create convex\n        var c = new Convex(convexes[i].vertices);\n\n        // Move all vertices so its center of mass is in the local center of the convex\n        for(var j=0; j!==c.vertices.length; j++){\n            var v = c.vertices[j];\n            vec2.sub(v,v,c.centerOfMass);\n        }\n\n        vec2.scale(cm,c.centerOfMass,1);\n        c.updateTriangles();\n        c.updateCenterOfMass();\n        c.updateBoundingRadius();\n\n        // Add the shape\n        this.addShape(c,cm);\n    }\n\n    this.adjustCenterOfMass();\n\n    this.aabbNeedsUpdate = true;\n\n    return true;\n};\n\nvar adjustCenterOfMass_tmp1 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp2 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp3 = vec2.fromValues(0,0),\n    adjustCenterOfMass_tmp4 = vec2.fromValues(0,0);\n\n/**\n * Moves the shape offsets so their center of mass becomes the body center of mass.\n * @method adjustCenterOfMass\n */\nBody.prototype.adjustCenterOfMass = function(){\n    var offset_times_area = adjustCenterOfMass_tmp2,\n        sum =               adjustCenterOfMass_tmp3,\n        cm =                adjustCenterOfMass_tmp4,\n        totalArea =         0;\n    vec2.set(sum,0,0);\n\n    for(var i=0; i!==this.shapes.length; i++){\n        var s = this.shapes[i],\n            offset = this.shapeOffsets[i];\n        vec2.scale(offset_times_area,offset,s.area);\n        vec2.add(sum,sum,offset_times_area);\n        totalArea += s.area;\n    }\n\n    vec2.scale(cm,sum,1/totalArea);\n\n    // Now move all shapes\n    for(var i=0; i!==this.shapes.length; i++){\n        var s = this.shapes[i],\n            offset = this.shapeOffsets[i];\n\n        // Offset may be undefined. Fix that.\n        if(!offset){\n            offset = this.shapeOffsets[i] = vec2.create();\n        }\n\n        vec2.sub(offset,offset,cm);\n    }\n\n    // Move the body position too\n    vec2.add(this.position,this.position,cm);\n\n    // And concave path\n    for(var i=0; this.concavePath && i<this.concavePath.length; i++){\n        vec2.sub(this.concavePath[i], this.concavePath[i], cm);\n    }\n\n    this.updateMassProperties();\n    this.updateBoundingRadius();\n};\n\n/**\n * Sets the force on the body to zero.\n * @method setZeroForce\n */\nBody.prototype.setZeroForce = function(){\n    vec2.set(this.force,0.0,0.0);\n    this.angularForce = 0.0;\n};\n\nBody.prototype.resetConstraintVelocity = function(){\n    var b = this,\n        vlambda = b.vlambda;\n    vec2.set(vlambda,0,0);\n    b.wlambda = 0;\n};\n\nBody.prototype.addConstraintVelocity = function(){\n    var b = this,\n        v = b.velocity;\n    vec2.add( v, v, b.vlambda);\n    b.angularVelocity += b.wlambda;\n};\n\n/**\n * Apply damping, see <a href=\"http://code.google.com/p/bullet/issues/detail?id=74\">this</a> for details.\n * @method applyDamping\n * @param  {number} dt Current time step\n */\nBody.prototype.applyDamping = function(dt){\n    if(this.motionState === Body.DYNAMIC){ // Only for dynamic bodies\n\n        // Since Math.pow generates garbage we check if we can reuse the scaling coefficient from last step\n        if(dt !== this.lastDampingTimeStep){\n            this.lastDampingScale =         Math.pow(1.0 - this.damping,dt);\n            this.lastAngularDampingScale =  Math.pow(1.0 - this.angularDamping,dt);\n            this.lastDampingTimeStep = dt;\n        }\n\n        var v = this.velocity;\n        vec2.scale(v,v,this.lastDampingScale);\n        this.angularVelocity *= this.lastAngularDampingScale;\n    }\n};\n\n/**\n * Wake the body up. Normally you should not need this, as the body is automatically awoken at events such as collisions.\n * Sets the sleepState to {{#crossLink \"Body/AWAKE:property\"}}Body.AWAKE{{/crossLink}} and emits the wakeUp event if the body wasn't awake before.\n * @method wakeUp\n */\nBody.prototype.wakeUp = function(){\n    var s = this.sleepState;\n    this.sleepState = Body.AWAKE;\n    this.idleTime = 0;\n    if(s !== Body.AWAKE){\n        this.emit(Body.wakeUpEvent);\n    }\n};\n\n/**\n * Force body sleep\n * @method sleep\n */\nBody.prototype.sleep = function(){\n    this.sleepState = Body.SLEEPING;\n    this.angularVelocity = 0;\n    this.angularForce = 0;\n    vec2.set(this.velocity,0,0);\n    vec2.set(this.force,0,0);\n    this.emit(Body.sleepEvent);\n};\n\n//var velo2 = vec2.create();\n\n/**\n * @method sleepTick\n * @param float time The world time in seconds\n * @brief Called every timestep to update internal sleep timer and change sleep state if needed.\n */\nBody.prototype.sleepTick = function(time, dontSleep, dt){\n    if(!this.allowSleep || this.motionState === Body.SLEEPING){\n        return;\n    }\n\n    this.wantsToSleep = false;\n\n    var sleepState = this.sleepState,\n        speedSquared = vec2.squaredLength(this.velocity) + Math.pow(this.angularVelocity,2),\n        speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);\n\n    // Add to idle time\n    if(speedSquared >= speedLimitSquared){\n        this.idleTime = 0;\n        this.sleepState = Body.AWAKE;\n    } else {\n        this.idleTime += dt;\n        this.sleepState = Body.SLEEPY;\n    }\n    if(this.idleTime > this.sleepTimeLimit){\n        if(!dontSleep){\n            this.sleep();\n        } else {\n            this.wantsToSleep = true;\n        }\n    }\n\n    /*\n    if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){\n        this.sleepState = Body.SLEEPY; // Sleepy\n        this.timeLastSleepy = time;\n        this.emit(Body.sleepyEvent);\n    } else if(sleepState===Body.SLEEPY && speedSquared >= speedLimitSquared){\n        this.wakeUp(); // Wake up\n    } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){\n        this.wantsToSleep = true;\n        if(!dontSleep){\n            this.sleep();\n        }\n    }\n    */\n};\n\nBody.prototype.getVelocityFromPosition = function(store, timeStep){\n    store = store || vec2.create();\n    vec2.sub(store, this.position, this.previousPosition);\n    vec2.scale(store, store, 1/timeStep);\n    return store;\n};\nBody.prototype.getAngularVelocityFromPosition = function(timeStep){\n    return (this.angle - this.previousAngle) / timeStep;\n};\n\n/**\n * @event sleepy\n */\nBody.sleepyEvent = {\n    type: \"sleepy\"\n};\n\n/**\n * @event sleep\n */\nBody.sleepEvent = {\n    type: \"sleep\"\n};\n\n/**\n * @event wakeup\n */\nBody.wakeUpEvent = {\n    type: \"wakeup\"\n};\n\n/**\n * Dynamic body.\n * @property DYNAMIC\n * @type {Number}\n * @static\n */\nBody.DYNAMIC = 1;\n\n/**\n * Static body.\n * @property STATIC\n * @type {Number}\n * @static\n */\nBody.STATIC = 2;\n\n/**\n * Kinematic body.\n * @property KINEMATIC\n * @type {Number}\n * @static\n */\nBody.KINEMATIC = 4;\n\n/**\n * @property AWAKE\n * @type {Number}\n * @static\n */\nBody.AWAKE = 0;\n\n/**\n * @property SLEEPY\n * @type {Number}\n * @static\n */\nBody.SLEEPY = 1;\n\n/**\n * @property SLEEPING\n * @type {Number}\n * @static\n */\nBody.SLEEPING = 2;\n\n\n},{\"../collision/AABB\":8,\"../events/EventEmitter\":26,\"../math/vec2\":30,\"../shapes/Convex\":36,\"poly-decomp\":6}],32:[function(require,module,exports){\nvar vec2 = require('../math/vec2');\nvar Utils = require('../utils/Utils');\n\nmodule.exports = Spring;\n\n/**\n * A spring, connecting two bodies. The Spring explicitly adds force and angularForce to the bodies and does therefore not put load on the solver.\n *\n * @class Spring\n * @constructor\n * @param {Body} bodyA\n * @param {Body} bodyB\n * @param {Object} [options]\n * @param {number} [options.restLength=1]   A number > 0. Default: 1\n * @param {number} [options.stiffness=100]  Spring constant (see Hookes Law). A number >= 0.\n * @param {number} [options.damping=1]      A number >= 0. Default: 1\n * @param {Array}  [options.localAnchorA]   Where to hook the spring to body A, in local body coordinates. Defaults to the body center.\n * @param {Array}  [options.localAnchorB]\n * @param {Array}  [options.worldAnchorA]   Where to hook the spring to body A, in world coordinates. Overrides the option \"localAnchorA\" if given.\n * @param {Array}  [options.worldAnchorB]\n */\nfunction Spring(bodyA,bodyB,options){\n    options = Utils.defaults(options,{\n        restLength: 1,\n        stiffness: 100,\n        damping: 1,\n        localAnchorA: [0,0],\n        localAnchorB: [0,0],\n    });\n\n    /**\n     * Rest length of the spring.\n     * @property restLength\n     * @type {number}\n     */\n    this.restLength = options.restLength;\n\n    /**\n     * Stiffness of the spring.\n     * @property stiffness\n     * @type {number}\n     */\n    this.stiffness = options.stiffness;\n\n    /**\n     * Damping of the spring.\n     * @property damping\n     * @type {number}\n     */\n    this.damping = options.damping;\n\n    /**\n     * First connected body.\n     * @property bodyA\n     * @type {Body}\n     */\n    this.bodyA = bodyA;\n\n    /**\n     * Second connected body.\n     * @property bodyB\n     * @type {Body}\n     */\n    this.bodyB = bodyB;\n\n    /**\n     * Anchor for bodyA in local bodyA coordinates.\n     * @property localAnchorA\n     * @type {Array}\n     */\n    this.localAnchorA = vec2.create();\n    vec2.copy(this.localAnchorA, options.localAnchorA);\n\n    /**\n     * Anchor for bodyB in local bodyB coordinates.\n     * @property localAnchorB\n     * @type {Array}\n     */\n    this.localAnchorB = vec2.create();\n    vec2.copy(this.localAnchorB, options.localAnchorB);\n\n    if(options.worldAnchorA){\n        this.setWorldAnchorA(options.worldAnchorA);\n    }\n    if(options.worldAnchorB){\n        this.setWorldAnchorB(options.worldAnchorB);\n    }\n}\n\n/**\n * Set the anchor point on body A, using world coordinates.\n * @method setWorldAnchorA\n * @param {Array} worldAnchorA\n */\nSpring.prototype.setWorldAnchorA = function(worldAnchorA){\n    this.bodyA.toLocalFrame(this.localAnchorA, worldAnchorA);\n};\n\n/**\n * Set the anchor point on body B, using world coordinates.\n * @method setWorldAnchorB\n * @param {Array} worldAnchorB\n */\nSpring.prototype.setWorldAnchorB = function(worldAnchorB){\n    this.bodyB.toLocalFrame(this.localAnchorB, worldAnchorB);\n};\n\n/**\n * Get the anchor point on body A, in world coordinates.\n * @method getWorldAnchorA\n * @param {Array} result The vector to store the result in.\n */\nSpring.prototype.getWorldAnchorA = function(result){\n    this.bodyA.toWorldFrame(result, this.localAnchorA);\n};\n\n/**\n * Get the anchor point on body B, in world coordinates.\n * @method getWorldAnchorB\n * @param {Array} result The vector to store the result in.\n */\nSpring.prototype.getWorldAnchorB = function(result){\n    this.bodyB.toWorldFrame(result, this.localAnchorB);\n};\n\nvar applyForce_r =              vec2.create(),\n    applyForce_r_unit =         vec2.create(),\n    applyForce_u =              vec2.create(),\n    applyForce_f =              vec2.create(),\n    applyForce_worldAnchorA =   vec2.create(),\n    applyForce_worldAnchorB =   vec2.create(),\n    applyForce_ri =             vec2.create(),\n    applyForce_rj =             vec2.create(),\n    applyForce_tmp =            vec2.create();\n\n/**\n * Apply the spring force to the connected bodies.\n * @method applyForce\n */\nSpring.prototype.applyForce = function(){\n    var k = this.stiffness,\n        d = this.damping,\n        l = this.restLength,\n        bodyA = this.bodyA,\n        bodyB = this.bodyB,\n        r = applyForce_r,\n        r_unit = applyForce_r_unit,\n        u = applyForce_u,\n        f = applyForce_f,\n        tmp = applyForce_tmp;\n\n    var worldAnchorA = applyForce_worldAnchorA,\n        worldAnchorB = applyForce_worldAnchorB,\n        ri = applyForce_ri,\n        rj = applyForce_rj;\n\n    // Get world anchors\n    this.getWorldAnchorA(worldAnchorA);\n    this.getWorldAnchorB(worldAnchorB);\n\n    // Get offset points\n    vec2.sub(ri, worldAnchorA, bodyA.position);\n    vec2.sub(rj, worldAnchorB, bodyB.position);\n\n    // Compute distance vector between world anchor points\n    vec2.sub(r, worldAnchorB, worldAnchorA);\n    var rlen = vec2.len(r);\n    vec2.normalize(r_unit,r);\n\n    //console.log(rlen)\n    //console.log(\"A\",vec2.str(worldAnchorA),\"B\",vec2.str(worldAnchorB))\n\n    // Compute relative velocity of the anchor points, u\n    vec2.sub(u, bodyB.velocity, bodyA.velocity);\n    vec2.crossZV(tmp, bodyB.angularVelocity, rj);\n    vec2.add(u, u, tmp);\n    vec2.crossZV(tmp, bodyA.angularVelocity, ri);\n    vec2.sub(u, u, tmp);\n\n    // F = - k * ( x - L ) - D * ( u )\n    vec2.scale(f, r_unit, -k*(rlen-l) - d*vec2.dot(u,r_unit));\n\n    // Add forces to bodies\n    vec2.sub( bodyA.force, bodyA.force, f);\n    vec2.add( bodyB.force, bodyB.force, f);\n\n    // Angular force\n    var ri_x_f = vec2.crossLength(ri, f);\n    var rj_x_f = vec2.crossLength(rj, f);\n    bodyA.angularForce -= ri_x_f;\n    bodyB.angularForce += rj_x_f;\n};\n\n},{\"../math/vec2\":30,\"../utils/Utils\":47}],33:[function(require,module,exports){\n// Export p2 classes\nmodule.exports = {\n    AABB :                          require('./collision/AABB'),\n    AngleLockEquation :             require('./equations/AngleLockEquation'),\n    Body :                          require('./objects/Body'),\n    Broadphase :                    require('./collision/Broadphase'),\n    Capsule :                       require('./shapes/Capsule'),\n    Circle :                        require('./shapes/Circle'),\n    Constraint :                    require('./constraints/Constraint'),\n    ContactEquation :               require('./equations/ContactEquation'),\n    ContactMaterial :               require('./material/ContactMaterial'),\n    Convex :                        require('./shapes/Convex'),\n    DistanceConstraint :            require('./constraints/DistanceConstraint'),\n    Equation :                      require('./equations/Equation'),\n    EventEmitter :                  require('./events/EventEmitter'),\n    FrictionEquation :              require('./equations/FrictionEquation'),\n    GearConstraint :                require('./constraints/GearConstraint'),\n    GridBroadphase :                require('./collision/GridBroadphase'),\n    GSSolver :                      require('./solver/GSSolver'),\n    Heightfield :                   require('./shapes/Heightfield'),\n    Line :                          require('./shapes/Line'),\n    LockConstraint :                require('./constraints/LockConstraint'),\n    Material :                      require('./material/Material'),\n    Narrowphase :                   require('./collision/Narrowphase'),\n    NaiveBroadphase :               require('./collision/NaiveBroadphase'),\n    Particle :                      require('./shapes/Particle'),\n    Plane :                         require('./shapes/Plane'),\n    RevoluteConstraint :            require('./constraints/RevoluteConstraint'),\n    PrismaticConstraint :           require('./constraints/PrismaticConstraint'),\n    Rectangle :                     require('./shapes/Rectangle'),\n    RotationalVelocityEquation :    require('./equations/RotationalVelocityEquation'),\n    SAPBroadphase :                 require('./collision/SAPBroadphase'),\n    Shape :                         require('./shapes/Shape'),\n    Solver :                        require('./solver/Solver'),\n    Spring :                        require('./objects/Spring'),\n    Utils :                         require('./utils/Utils'),\n    World :                         require('./world/World'),\n    vec2 :                          require('./math/vec2'),\n    version :                       require('../package.json').version,\n};\n\n},{\"../package.json\":7,\"./collision/AABB\":8,\"./collision/Broadphase\":9,\"./collision/GridBroadphase\":10,\"./collision/NaiveBroadphase\":11,\"./collision/Narrowphase\":12,\"./collision/SAPBroadphase\":13,\"./constraints/Constraint\":14,\"./constraints/DistanceConstraint\":15,\"./constraints/GearConstraint\":16,\"./constraints/LockConstraint\":17,\"./constraints/PrismaticConstraint\":18,\"./constraints/RevoluteConstraint\":19,\"./equations/AngleLockEquation\":20,\"./equations/ContactEquation\":21,\"./equations/Equation\":22,\"./equations/FrictionEquation\":23,\"./equations/RotationalVelocityEquation\":25,\"./events/EventEmitter\":26,\"./material/ContactMaterial\":27,\"./material/Material\":28,\"./math/vec2\":30,\"./objects/Body\":31,\"./objects/Spring\":32,\"./shapes/Capsule\":34,\"./shapes/Circle\":35,\"./shapes/Convex\":36,\"./shapes/Heightfield\":37,\"./shapes/Line\":38,\"./shapes/Particle\":39,\"./shapes/Plane\":40,\"./shapes/Rectangle\":41,\"./shapes/Shape\":42,\"./solver/GSSolver\":43,\"./solver/Solver\":44,\"./utils/Utils\":47,\"./world/World\":51}],34:[function(require,module,exports){\nvar Shape = require('./Shape')\n,   vec2 = require('../math/vec2');\n\nmodule.exports = Capsule;\n\n/**\n * Capsule shape class.\n * @class Capsule\n * @constructor\n * @extends Shape\n * @param {Number} [length] The distance between the end points\n * @param {Number} [radius] Radius of the capsule\n */\nfunction Capsule(length, radius){\n\n    /**\n     * The distance between the end points.\n     * @property {Number} length\n     */\n    this.length = length || 1;\n\n    /**\n     * The radius of the capsule.\n     * @property {Number} radius\n     */\n    this.radius = radius || 1;\n\n    Shape.call(this,Shape.CAPSULE);\n}\nCapsule.prototype = new Shape();\n\n/**\n * Compute the mass moment of inertia of the Capsule.\n * @method conputeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n * @todo\n */\nCapsule.prototype.computeMomentOfInertia = function(mass){\n    // Approximate with rectangle\n    var r = this.radius,\n        w = this.length + r, // 2*r is too much, 0 is too little\n        h = r*2;\n    return mass * (h*h + w*w) / 12;\n};\n\n/**\n * @method updateBoundingRadius\n */\nCapsule.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.radius + this.length/2;\n};\n\n/**\n * @method updateArea\n */\nCapsule.prototype.updateArea = function(){\n    this.area = Math.PI * this.radius * this.radius + this.radius * 2 * this.length;\n};\n\nvar r = vec2.create();\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nCapsule.prototype.computeAABB = function(out, position, angle){\n    var radius = this.radius;\n\n    // Compute center position of one of the the circles, world oriented, but with local offset\n    vec2.set(r,this.length,0);\n    vec2.rotate(r,r,angle);\n\n    // Get bounds\n    vec2.set(out.upperBound,  Math.max(r[0]+radius, -r[0]+radius),\n                              Math.max(r[1]+radius, -r[1]+radius));\n    vec2.set(out.lowerBound,  Math.min(r[0]-radius, -r[0]-radius),\n                              Math.min(r[1]-radius, -r[1]-radius));\n\n    // Add offset\n    vec2.add(out.lowerBound, out.lowerBound, position);\n    vec2.add(out.upperBound, out.upperBound, position);\n};\n\n},{\"../math/vec2\":30,\"./Shape\":42}],35:[function(require,module,exports){\nvar Shape = require('./Shape')\n,    vec2 = require('../math/vec2')\n\nmodule.exports = Circle;\n\n/**\n * Circle shape class.\n * @class Circle\n * @extends Shape\n * @constructor\n * @param {number} [radius=1] The radius of this circle\n */\nfunction Circle(radius){\n\n    /**\n     * The radius of the circle.\n     * @property radius\n     * @type {number}\n     */\n    this.radius = radius || 1;\n\n    Shape.call(this,Shape.CIRCLE);\n};\nCircle.prototype = new Shape();\n\n/**\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nCircle.prototype.computeMomentOfInertia = function(mass){\n    var r = this.radius;\n    return mass * r * r / 2;\n};\n\n/**\n * @method updateBoundingRadius\n * @return {Number}\n */\nCircle.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.radius;\n};\n\n/**\n * @method updateArea\n * @return {Number}\n */\nCircle.prototype.updateArea = function(){\n    this.area = Math.PI * this.radius * this.radius;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nCircle.prototype.computeAABB = function(out, position, angle){\n    var r = this.radius;\n    vec2.set(out.upperBound,  r,  r);\n    vec2.set(out.lowerBound, -r, -r);\n    if(position){\n        vec2.add(out.lowerBound, out.lowerBound, position);\n        vec2.add(out.upperBound, out.upperBound, position);\n    }\n};\n\n},{\"../math/vec2\":30,\"./Shape\":42}],36:[function(require,module,exports){\nvar Shape = require('./Shape')\n,   vec2 = require('../math/vec2')\n,   polyk = require('../math/polyk')\n,   decomp = require('poly-decomp')\n\nmodule.exports = Convex;\n\n/**\n * Convex shape class.\n * @class Convex\n * @constructor\n * @extends Shape\n * @param {Array} vertices An array of Float32Array vertices that span this shape. Vertices are given in counter-clockwise (CCW) direction.\n */\nfunction Convex(vertices){\n\n    /**\n     * Vertices defined in the local frame.\n     * @property vertices\n     * @type {Array}\n     */\n    this.vertices = [];\n\n    // Copy the verts\n    for(var i=0; i<vertices.length; i++){\n        var v = vec2.create();\n        vec2.copy(v,vertices[i]);\n        this.vertices.push(v);\n    }\n\n    /**\n     * The center of mass of the Convex\n     * @property centerOfMass\n     * @type {Float32Array}\n     */\n    this.centerOfMass = vec2.fromValues(0,0);\n\n    /**\n     * Triangulated version of this convex. The structure is Array of 3-Arrays, and each subarray contains 3 integers, referencing the vertices.\n     * @property triangles\n     * @type {Array}\n     */\n    this.triangles = [];\n\n    if(this.vertices.length){\n        this.updateTriangles();\n        this.updateCenterOfMass();\n    }\n\n    /**\n     * The bounding radius of the convex\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n\n    Shape.call(this,Shape.CONVEX);\n\n    this.updateBoundingRadius();\n    this.updateArea();\n    if(this.area < 0)\n        throw new Error(\"Convex vertices must be given in conter-clockwise winding.\");\n};\nConvex.prototype = new Shape();\n\n/**\n * Update the .triangles property\n * @method updateTriangles\n */\nConvex.prototype.updateTriangles = function(){\n\n    this.triangles.length = 0;\n\n    // Rewrite on polyk notation, array of numbers\n    var polykVerts = [];\n    for(var i=0; i<this.vertices.length; i++){\n        var v = this.vertices[i];\n        polykVerts.push(v[0],v[1]);\n    }\n\n    // Triangulate\n    var triangles = polyk.Triangulate(polykVerts);\n\n    // Loop over all triangles, add their inertia contributions to I\n    for(var i=0; i<triangles.length; i+=3){\n        var id1 = triangles[i],\n            id2 = triangles[i+1],\n            id3 = triangles[i+2];\n\n        // Add to triangles\n        this.triangles.push([id1,id2,id3]);\n    }\n};\n\nvar updateCenterOfMass_centroid = vec2.create(),\n    updateCenterOfMass_centroid_times_mass = vec2.create(),\n    updateCenterOfMass_a = vec2.create(),\n    updateCenterOfMass_b = vec2.create(),\n    updateCenterOfMass_c = vec2.create(),\n    updateCenterOfMass_ac = vec2.create(),\n    updateCenterOfMass_ca = vec2.create(),\n    updateCenterOfMass_cb = vec2.create(),\n    updateCenterOfMass_n = vec2.create();\n\n/**\n * Update the .centerOfMass property.\n * @method updateCenterOfMass\n */\nConvex.prototype.updateCenterOfMass = function(){\n    var triangles = this.triangles,\n        verts = this.vertices,\n        cm = this.centerOfMass,\n        centroid = updateCenterOfMass_centroid,\n        n = updateCenterOfMass_n,\n        a = updateCenterOfMass_a,\n        b = updateCenterOfMass_b,\n        c = updateCenterOfMass_c,\n        ac = updateCenterOfMass_ac,\n        ca = updateCenterOfMass_ca,\n        cb = updateCenterOfMass_cb,\n        centroid_times_mass = updateCenterOfMass_centroid_times_mass;\n\n    vec2.set(cm,0,0);\n    var totalArea = 0;\n\n    for(var i=0; i!==triangles.length; i++){\n        var t = triangles[i],\n            a = verts[t[0]],\n            b = verts[t[1]],\n            c = verts[t[2]];\n\n        vec2.centroid(centroid,a,b,c);\n\n        // Get mass for the triangle (density=1 in this case)\n        // http://math.stackexchange.com/questions/80198/area-of-triangle-via-vectors\n        var m = Convex.triangleArea(a,b,c)\n        totalArea += m;\n\n        // Add to center of mass\n        vec2.scale(centroid_times_mass, centroid, m);\n        vec2.add(cm, cm, centroid_times_mass);\n    }\n\n    vec2.scale(cm,cm,1/totalArea);\n};\n\n/**\n * Compute the mass moment of inertia of the Convex.\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n * @see http://www.gamedev.net/topic/342822-moment-of-inertia-of-a-polygon-2d/\n */\nConvex.prototype.computeMomentOfInertia = function(mass){\n    var denom = 0.0,\n        numer = 0.0,\n        N = this.vertices.length;\n    for(var j = N-1, i = 0; i < N; j = i, i ++){\n        var p0 = this.vertices[j];\n        var p1 = this.vertices[i];\n        var a = Math.abs(vec2.crossLength(p0,p1));\n        var b = vec2.dot(p1,p1) + vec2.dot(p1,p0) + vec2.dot(p0,p0);\n        denom += a * b;\n        numer += a;\n    }\n    return (mass / 6.0) * (denom / numer);\n};\n\n/**\n * Updates the .boundingRadius property\n * @method updateBoundingRadius\n */\nConvex.prototype.updateBoundingRadius = function(){\n    var verts = this.vertices,\n        r2 = 0;\n\n    for(var i=0; i!==verts.length; i++){\n        var l2 = vec2.squaredLength(verts[i]);\n        if(l2 > r2) r2 = l2;\n    }\n\n    this.boundingRadius = Math.sqrt(r2);\n};\n\n/**\n * Get the area of the triangle spanned by the three points a, b, c. The area is positive if the points are given in counter-clockwise order, otherwise negative.\n * @static\n * @method triangleArea\n * @param {Array} a\n * @param {Array} b\n * @param {Array} c\n * @return {Number}\n */\nConvex.triangleArea = function(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1]))) * 0.5;\n}\n\n/**\n * Update the .area\n * @method updateArea\n */\nConvex.prototype.updateArea = function(){\n    this.updateTriangles();\n    this.area = 0;\n\n    var triangles = this.triangles,\n        verts = this.vertices;\n    for(var i=0; i!==triangles.length; i++){\n        var t = triangles[i],\n            a = verts[t[0]],\n            b = verts[t[1]],\n            c = verts[t[2]];\n\n        // Get mass for the triangle (density=1 in this case)\n        var m = Convex.triangleArea(a,b,c);\n        this.area += m;\n    }\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nConvex.prototype.computeAABB = function(out, position, angle){\n   out.setFromPoints(this.vertices,position,angle);\n};\n\n},{\"../math/polyk\":29,\"../math/vec2\":30,\"./Shape\":42,\"poly-decomp\":6}],37:[function(require,module,exports){\nvar Shape = require('./Shape')\n,    vec2 = require('../math/vec2')\n,    Utils = require('../utils/Utils');\n\nmodule.exports = Heightfield;\n\n/**\n * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a distance \"elementWidth\".\n * @class Heightfield\n * @extends Shape\n * @constructor\n * @param {Array} data\n * @param {Number} maxValue\n * @param {Number} elementWidth\n * @todo Should take maxValue as an option and also be able to compute it itself if not given.\n * @todo Should be possible to use along all axes, not just y\n */\nfunction Heightfield(data, options){\n    options = Utils.defaults(options, {\n        maxValue : null,\n        minValue : null,\n        elementWidth : 0.1\n    });\n\n    if(options.minValue === null || options.maxValue === null){\n        options.maxValue = data[0];\n        options.minValue = data[0];\n        for(var i=0; i !== data.length; i++){\n            var v = data[i];\n            if(v > options.maxValue){\n                options.maxValue = v;\n            }\n            if(v < options.minValue){\n                options.minValue = v;\n            }\n        }\n    }\n\n    /**\n     * An array of numbers, or height values, that are spread out along the x axis.\n     * @property {array} data\n     */\n    this.data = data;\n\n    /**\n     * Max value of the data\n     * @property {number} maxValue\n     */\n    this.maxValue = options.maxValue;\n\n    /**\n     * Max value of the data\n     * @property {number} minValue\n     */\n    this.minValue = options.minValue;\n\n    /**\n     * The width of each element\n     * @property {number} elementWidth\n     */\n    this.elementWidth = options.elementWidth;\n\n    Shape.call(this,Shape.HEIGHTFIELD);\n}\nHeightfield.prototype = new Shape();\n\n/**\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nHeightfield.prototype.computeMomentOfInertia = function(mass){\n    return Number.MAX_VALUE;\n};\n\nHeightfield.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = Number.MAX_VALUE;\n};\n\nHeightfield.prototype.updateArea = function(){\n    var data = this.data,\n        area = 0;\n    for(var i=0; i<data.length-1; i++){\n        area += (data[i]+data[i+1]) / 2 * this.elementWidth;\n    }\n    this.area = area;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nHeightfield.prototype.computeAABB = function(out, position, angle){\n    // Use the max data rectangle\n    out.upperBound[0] = this.elementWidth * this.data.length + position[0];\n    out.upperBound[1] = this.maxValue + position[1];\n    out.lowerBound[0] = position[0];\n    out.lowerBound[1] = -Number.MAX_VALUE; // Infinity\n};\n\n},{\"../math/vec2\":30,\"../utils/Utils\":47,\"./Shape\":42}],38:[function(require,module,exports){\nvar Shape = require('./Shape')\n,   vec2 = require('../math/vec2')\n\nmodule.exports = Line;\n\n/**\n * Line shape class. The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].\n * @class Line\n * @param {Number} length The total length of the line\n * @extends Shape\n * @constructor\n */\nfunction Line(length){\n\n    /**\n     * Length of this line\n     * @property length\n     * @type {Number}\n     */\n    this.length = length || 1;\n\n    Shape.call(this,Shape.LINE);\n}\nLine.prototype = new Shape();\nLine.prototype.computeMomentOfInertia = function(mass){\n    return mass * Math.pow(this.length,2) / 12;\n};\n\nLine.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = this.length/2;\n};\n\nvar points = [vec2.create(),vec2.create()];\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nLine.prototype.computeAABB = function(out, position, angle){\n    var l = this.length;\n    vec2.set(points[0], -l/2,  0);\n    vec2.set(points[1],  l/2,  0);\n    out.setFromPoints(points,position,angle);\n};\n\n\n},{\"../math/vec2\":30,\"./Shape\":42}],39:[function(require,module,exports){\nvar Shape = require('./Shape')\n,   vec2 = require('../math/vec2')\n\nmodule.exports = Particle;\n\n/**\n * Particle shape class.\n * @class Particle\n * @constructor\n * @extends Shape\n */\nfunction Particle(){\n    Shape.call(this,Shape.PARTICLE);\n};\nParticle.prototype = new Shape();\nParticle.prototype.computeMomentOfInertia = function(mass){\n    return 0; // Can't rotate a particle\n};\n\nParticle.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = 0;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nParticle.prototype.computeAABB = function(out, position, angle){\n    var l = this.length;\n    vec2.copy(out.lowerBound, position);\n    vec2.copy(out.upperBound, position);\n};\n\n},{\"../math/vec2\":30,\"./Shape\":42}],40:[function(require,module,exports){\nvar Shape =  require('./Shape')\n,    vec2 =  require('../math/vec2')\n,    Utils = require('../utils/Utils')\n\nmodule.exports = Plane;\n\n/**\n * Plane shape class. The plane is facing in the Y direction.\n * @class Plane\n * @extends Shape\n * @constructor\n */\nfunction Plane(){\n    Shape.call(this,Shape.PLANE);\n};\nPlane.prototype = new Shape();\n\n/**\n * Compute moment of inertia\n * @method computeMomentOfInertia\n */\nPlane.prototype.computeMomentOfInertia = function(mass){\n    return 0; // Plane is infinite. The inertia should therefore be infinty but by convention we set 0 here\n};\n\n/**\n * Update the bounding radius\n * @method updateBoundingRadius\n */\nPlane.prototype.updateBoundingRadius = function(){\n    this.boundingRadius = Number.MAX_VALUE;\n};\n\n/**\n * @method computeAABB\n * @param  {AABB}   out\n * @param  {Array}  position\n * @param  {Number} angle\n */\nPlane.prototype.computeAABB = function(out, position, angle){\n    var a = 0,\n        set = vec2.set;\n    if(typeof(angle) == \"number\")\n        a = angle % (2*Math.PI);\n\n    if(a == 0){\n        // y goes from -inf to 0\n        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        set(out.upperBound,  Number.MAX_VALUE,  0);\n    } else if(a == Math.PI / 2){\n        // x goes from 0 to inf\n        set(out.lowerBound,                 0, -Number.MAX_VALUE);\n        set(out.upperBound,  Number.MAX_VALUE,  Number.MAX_VALUE);\n    } else if(a == Math.PI){\n        // y goes from 0 to inf\n        set(out.lowerBound, -Number.MAX_VALUE, 0);\n        set(out.upperBound,  Number.MAX_VALUE, Number.MAX_VALUE);\n    } else if(a == 3*Math.PI/2){\n        // x goes from -inf to 0\n        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        set(out.upperBound,                 0,  Number.MAX_VALUE);\n    } else {\n        // Set max bounds\n        set(out.lowerBound, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        set(out.upperBound,  Number.MAX_VALUE,  Number.MAX_VALUE);\n    }\n\n    vec2.add(out.lowerBound, out.lowerBound, position);\n    vec2.add(out.upperBound, out.upperBound, position);\n};\n\nPlane.prototype.updateArea = function(){\n    this.area = Number.MAX_VALUE;\n};\n\n\n},{\"../math/vec2\":30,\"../utils/Utils\":47,\"./Shape\":42}],41:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\n,   Shape = require('./Shape')\n,   Convex = require('./Convex');\n\nmodule.exports = Rectangle;\n\n/**\n * Rectangle shape class.\n * @class Rectangle\n * @constructor\n * @param {Number} width Width\n * @param {Number} height Height\n * @extends Convex\n */\nfunction Rectangle(width, height){\n    width = width || 1;\n    height = height || 1;\n\n    var verts = [   vec2.fromValues(-width/2, -height/2),\n                    vec2.fromValues( width/2, -height/2),\n                    vec2.fromValues( width/2,  height/2),\n                    vec2.fromValues(-width/2,  height/2)];\n\n    /**\n     * Total width of the rectangle\n     * @property width\n     * @type {Number}\n     */\n    this.width = width;\n\n    /**\n     * Total height of the rectangle\n     * @property height\n     * @type {Number}\n     */\n    this.height = height;\n\n    Convex.call(this,verts);\n\n    this.type = Shape.RECTANGLE;\n}\nRectangle.prototype = new Convex([]);\n\n/**\n * Compute moment of inertia\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number}\n */\nRectangle.prototype.computeMomentOfInertia = function(mass){\n    var w = this.width,\n        h = this.height;\n    return mass * (h*h + w*w) / 12;\n};\n\n/**\n * Update the bounding radius\n * @method updateBoundingRadius\n */\nRectangle.prototype.updateBoundingRadius = function(){\n    var w = this.width,\n        h = this.height;\n    this.boundingRadius = Math.sqrt(w*w + h*h) / 2;\n};\n\nvar corner1 = vec2.create(),\n    corner2 = vec2.create(),\n    corner3 = vec2.create(),\n    corner4 = vec2.create();\n\n/**\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nRectangle.prototype.computeAABB = function(out, position, angle){\n   out.setFromPoints(this.vertices,position,angle);\n};\n\nRectangle.prototype.updateArea = function(){\n    this.area = this.width * this.height;\n};\n\n\n},{\"../math/vec2\":30,\"./Convex\":36,\"./Shape\":42}],42:[function(require,module,exports){\nmodule.exports = Shape;\n\n/**\n * Base class for shapes.\n * @class Shape\n * @constructor\n * @param {Number} type\n */\nfunction Shape(type){\n\n    /**\n     * The type of the shape. One of:\n     *\n     * * {{#crossLink \"Shape/CIRCLE:property\"}}Shape.CIRCLE{{/crossLink}}\n     * * {{#crossLink \"Shape/PARTICLE:property\"}}Shape.PARTICLE{{/crossLink}}\n     * * {{#crossLink \"Shape/PLANE:property\"}}Shape.PLANE{{/crossLink}}\n     * * {{#crossLink \"Shape/CONVEX:property\"}}Shape.CONVEX{{/crossLink}}\n     * * {{#crossLink \"Shape/LINE:property\"}}Shape.LINE{{/crossLink}}\n     * * {{#crossLink \"Shape/RECTANGLE:property\"}}Shape.RECTANGLE{{/crossLink}}\n     * * {{#crossLink \"Shape/CAPSULE:property\"}}Shape.CAPSULE{{/crossLink}}\n     * * {{#crossLink \"Shape/HEIGHTFIELD:property\"}}Shape.HEIGHTFIELD{{/crossLink}}\n     *\n     * @property {number} type\n     */\n    this.type = type;\n\n    /**\n     * Shape object identifier.\n     * @type {Number}\n     * @property id\n     */\n    this.id = Shape.idCounter++;\n\n    /**\n     * Bounding circle radius of this shape\n     * @property boundingRadius\n     * @type {Number}\n     */\n    this.boundingRadius = 0;\n\n    /**\n     * Collision group that this shape belongs to (bit mask). See <a href=\"http://www.aurelienribon.com/blog/2011/07/box2d-tutorial-collision-filtering/\">this tutorial</a>.\n     * @property collisionGroup\n     * @type {Number}\n     * @example\n     *     // Setup bits for each available group\n     *     var PLAYER = Math.pow(2,0),\n     *         ENEMY =  Math.pow(2,1),\n     *         GROUND = Math.pow(2,2)\n     *\n     *     // Put shapes into their groups\n     *     player1Shape.collisionGroup = PLAYER;\n     *     player2Shape.collisionGroup = PLAYER;\n     *     enemyShape  .collisionGroup = ENEMY;\n     *     groundShape .collisionGroup = GROUND;\n     *\n     *     // Assign groups that each shape collide with.\n     *     // Note that the players can collide with ground and enemies, but not with other players.\n     *     player1Shape.collisionMask = ENEMY | GROUND;\n     *     player2Shape.collisionMask = ENEMY | GROUND;\n     *     enemyShape  .collisionMask = PLAYER | GROUND;\n     *     groundShape .collisionMask = PLAYER | ENEMY;\n     *\n     * @example\n     *     // How collision check is done\n     *     if(shapeA.collisionGroup & shapeB.collisionMask)!=0 && (shapeB.collisionGroup & shapeA.collisionMask)!=0){\n     *         // The shapes will collide\n     *     }\n     */\n    this.collisionGroup = 1;\n\n    /**\n     * Collision mask of this shape. See .collisionGroup.\n     * @property collisionMask\n     * @type {Number}\n     */\n    this.collisionMask =  1;\n    if(type) this.updateBoundingRadius();\n\n    /**\n     * Material to use in collisions for this Shape. If this is set to null, the world will use default material properties instead.\n     * @property material\n     * @type {Material}\n     */\n    this.material = null;\n\n    /**\n     * Area of this shape.\n     * @property area\n     * @type {Number}\n     */\n    this.area = 0;\n\n    /**\n     * Set to true if you want this shape to be a sensor. A sensor does not generate contacts, but it still reports contact events. This is good if you want to know if a shape is overlapping another shape, without them generating contacts.\n     * @property {Boolean} sensor\n     */\n    this.sensor = false;\n\n    this.updateArea();\n};\n\nShape.idCounter = 0;\n\n/**\n * @static\n * @property {Number} CIRCLE\n */\nShape.CIRCLE =      1;\n\n/**\n * @static\n * @property {Number} PARTICLE\n */\nShape.PARTICLE =    2;\n\n/**\n * @static\n * @property {Number} PLANE\n */\nShape.PLANE =       4;\n\n/**\n * @static\n * @property {Number} CONVEX\n */\nShape.CONVEX =      8;\n\n/**\n * @static\n * @property {Number} LINE\n */\nShape.LINE =        16;\n\n/**\n * @static\n * @property {Number} RECTANGLE\n */\nShape.RECTANGLE =   32;\n\n/**\n * @static\n * @property {Number} CAPSULE\n */\nShape.CAPSULE =     64;\n\n/**\n * @static\n * @property {Number} HEIGHTFIELD\n */\nShape.HEIGHTFIELD = 128;\n\n/**\n * Should return the moment of inertia around the Z axis of the body given the total mass. See <a href=\"http://en.wikipedia.org/wiki/List_of_moments_of_inertia\">Wikipedia's list of moments of inertia</a>.\n * @method computeMomentOfInertia\n * @param  {Number} mass\n * @return {Number} If the inertia is infinity or if the object simply isn't possible to rotate, return 0.\n */\nShape.prototype.computeMomentOfInertia = function(mass){\n    throw new Error(\"Shape.computeMomentOfInertia is not implemented in this Shape...\");\n};\n\n/**\n * Returns the bounding circle radius of this shape.\n * @method updateBoundingRadius\n * @return {Number}\n */\nShape.prototype.updateBoundingRadius = function(){\n    throw new Error(\"Shape.updateBoundingRadius is not implemented in this Shape...\");\n};\n\n/**\n * Update the .area property of the shape.\n * @method updateArea\n */\nShape.prototype.updateArea = function(){\n    // To be implemented in all subclasses\n};\n\n/**\n * Compute the world axis-aligned bounding box (AABB) of this shape.\n * @method computeAABB\n * @param  {AABB}   out      The resulting AABB.\n * @param  {Array}  position\n * @param  {Number} angle\n */\nShape.prototype.computeAABB = function(out, position, angle){\n    // To be implemented in each subclass\n};\n\n},{}],43:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\n,   Solver = require('./Solver')\n,   Utils = require('../utils/Utils')\n,   FrictionEquation = require('../equations/FrictionEquation');\n\nmodule.exports = GSSolver;\n\n/**\n * Iterative Gauss-Seidel constraint equation solver.\n *\n * @class GSSolver\n * @constructor\n * @extends Solver\n * @param {Object} [options]\n * @param {Number} [options.iterations=10]\n * @param {Number} [options.tolerance=0]\n */\nfunction GSSolver(options){\n    Solver.call(this,options,Solver.GS);\n    options = options || {};\n\n    /**\n     * The number of iterations to do when solving. More gives better results, but is more expensive.\n     * @property iterations\n     * @type {Number}\n     */\n    this.iterations = options.iterations || 10;\n\n    /**\n     * The error tolerance, per constraint. If the total error is below this limit, the solver will stop iterating. Set to zero for as good solution as possible, but to something larger than zero to make computations faster.\n     * @property tolerance\n     * @type {Number}\n     */\n    this.tolerance = options.tolerance || 1e-10;\n\n    this.arrayStep = 30;\n    this.lambda = new Utils.ARRAY_TYPE(this.arrayStep);\n    this.Bs =     new Utils.ARRAY_TYPE(this.arrayStep);\n    this.invCs =  new Utils.ARRAY_TYPE(this.arrayStep);\n\n    /**\n     * Set to true to set all right hand side terms to zero when solving. Can be handy for a few applications.\n     * @property useZeroRHS\n     * @type {Boolean}\n     */\n    this.useZeroRHS = false;\n\n    /**\n     * Number of solver iterations that are done to approximate normal forces. When these iterations are done, friction force will be computed from the contact normal forces. These friction forces will override any other friction forces set from the World for example.\n     * The solver will use less iterations if the solution is below the .tolerance.\n     * @property frictionIterations\n     * @type {Number}\n     */\n    this.frictionIterations = 0;\n\n    /**\n     * The number of iterations that were made during the last solve. If .tolerance is zero, this value will always be equal to .iterations, but if .tolerance is larger than zero, and the solver can quit early, then this number will be somewhere between 1 and .iterations.\n     * @property {Number} usedIterations\n     */\n    this.usedIterations = 0;\n}\nGSSolver.prototype = new Solver();\n\nfunction setArrayZero(array){\n    var l = array.length;\n    while(l--){\n        array[l] = +0.0;\n    }\n}\n\n/**\n * Solve the system of equations\n * @method solve\n * @param  {Number}  h       Time step\n * @param  {World}   world    World to solve\n */\nGSSolver.prototype.solve = function(h, world){\n\n    this.sortEquations();\n\n    var iter = 0,\n        maxIter = this.iterations,\n        maxFrictionIter = this.frictionIterations,\n        equations = this.equations,\n        Neq = equations.length,\n        tolSquared = Math.pow(this.tolerance*Neq, 2),\n        bodies = world.bodies,\n        Nbodies = world.bodies.length,\n        add = vec2.add,\n        set = vec2.set,\n        useZeroRHS = this.useZeroRHS,\n        lambda = this.lambda;\n\n    this.usedIterations = 0;\n\n    // Things that does not change during iteration can be computed once\n    if(lambda.length < Neq){\n        lambda = this.lambda =  new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n        this.Bs =               new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n        this.invCs =            new Utils.ARRAY_TYPE(Neq + this.arrayStep);\n    }\n    setArrayZero(lambda);\n    var invCs = this.invCs,\n        Bs = this.Bs,\n        lambda = this.lambda;\n\n    for(var i=0; i!==equations.length; i++){\n        var c = equations[i];\n        if(c.timeStep !== h || c.needsUpdate){\n            c.timeStep = h;\n            c.update();\n        }\n        Bs[i] =     c.computeB(c.a,c.b,h);\n        invCs[i] =  c.computeInvC(c.epsilon);\n    }\n\n    var q, B, c, deltalambdaTot,i,j;\n\n    if(Neq !== 0){\n\n        // Reset vlambda\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].resetConstraintVelocity();\n        }\n\n        if(maxFrictionIter){\n            // Iterate over contact equations to get normal forces\n            for(iter=0; iter!==maxFrictionIter; iter++){\n\n                // Accumulate the total error for each iteration.\n                deltalambdaTot = 0.0;\n\n                for(j=0; j!==Neq; j++){\n                    c = equations[j];\n\n                    if(c instanceof FrictionEquation){\n                        //continue;\n                    }\n\n                    var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);\n                    deltalambdaTot += Math.abs(deltalambda);\n                }\n\n                this.usedIterations++;\n\n                // If the total error is small enough - stop iterate\n                if(deltalambdaTot*deltalambdaTot <= tolSquared){\n                    break;\n                }\n            }\n\n            GSSolver.updateMultipliers(equations, lambda, 1/h);\n\n            // Set computed friction force\n            for(j=0; j!==Neq; j++){\n                var eq = equations[j];\n                if(eq instanceof FrictionEquation){\n                    var f = eq.contactEquation.multiplier * eq.frictionCoefficient;\n                    eq.maxForce =  f;\n                    eq.minForce = -f;\n                }\n            }\n        }\n\n        // Iterate over all equations\n        for(iter=0; iter!==maxIter; iter++){\n\n            // Accumulate the total error for each iteration.\n            deltalambdaTot = 0.0;\n\n            for(j=0; j!==Neq; j++){\n                c = equations[j];\n\n                var deltalambda = GSSolver.iterateEquation(j,c,c.epsilon,Bs,invCs,lambda,useZeroRHS,h,iter);\n                deltalambdaTot += Math.abs(deltalambda);\n            }\n\n            this.usedIterations++;\n\n            // If the total error is small enough - stop iterate\n            if(deltalambdaTot*deltalambdaTot <= tolSquared){\n                break;\n            }\n        }\n\n        // Add result to velocity\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].addConstraintVelocity();\n        }\n\n        GSSolver.updateMultipliers(equations, lambda, 1/h);\n    }\n};\n\n// Sets the .multiplier property of each equation\nGSSolver.updateMultipliers = function(equations, lambda, invDt){\n    // Set the .multiplier property of each equation\n    var l = equations.length;\n    while(l--){\n        equations[l].multiplier = lambda[l] * invDt;\n    }\n};\n\nGSSolver.iterateEquation = function(j,eq,eps,Bs,invCs,lambda,useZeroRHS,dt,iter){\n    // Compute iteration\n    var B = Bs[j],\n        invC = invCs[j],\n        lambdaj = lambda[j],\n        GWlambda = eq.computeGWlambda();\n\n    var maxForce = eq.maxForce,\n        minForce = eq.minForce;\n\n    if(useZeroRHS){\n        B = 0;\n    }\n\n    var deltalambda = invC * ( B - GWlambda - eps * lambdaj );\n\n    // Clamp if we are not within the min/max interval\n    var lambdaj_plus_deltalambda = lambdaj + deltalambda;\n    if(lambdaj_plus_deltalambda < minForce*dt){\n        deltalambda = minForce*dt - lambdaj;\n    } else if(lambdaj_plus_deltalambda > maxForce*dt){\n        deltalambda = maxForce*dt - lambdaj;\n    }\n    lambda[j] += deltalambda;\n    eq.addToWlambda(deltalambda);\n\n    return deltalambda;\n};\n\n},{\"../equations/FrictionEquation\":23,\"../math/vec2\":30,\"../utils/Utils\":47,\"./Solver\":44}],44:[function(require,module,exports){\nvar Utils = require('../utils/Utils')\n,   EventEmitter = require('../events/EventEmitter')\n\nmodule.exports = Solver;\n\n/**\n * Base class for constraint solvers.\n * @class Solver\n * @constructor\n * @extends EventEmitter\n */\nfunction Solver(options,type){\n    options = options || {};\n\n    EventEmitter.call(this);\n\n    this.type = type;\n\n    /**\n     * Current equations in the solver.\n     *\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * Function that is used to sort all equations before each solve.\n     * @property equationSortFunction\n     * @type {function|boolean}\n     */\n    this.equationSortFunction = options.equationSortFunction || false;\n}\nSolver.prototype = new EventEmitter();\n\n/**\n * Method to be implemented in each subclass\n * @method solve\n * @param  {Number} dt\n * @param  {World} world\n */\nSolver.prototype.solve = function(dt,world){\n    throw new Error(\"Solver.solve should be implemented by subclasses!\");\n};\n\nvar mockWorld = {bodies:[]};\n\n/**\n * Solves all constraints in an island.\n * @method solveIsland\n * @param  {Number} dt\n * @param  {Island} island\n */\nSolver.prototype.solveIsland = function(dt,island){\n\n    this.removeAllEquations();\n\n    if(island.equations.length){\n        // Add equations to solver\n        this.addEquations(island.equations);\n        mockWorld.bodies.length = 0;\n        island.getBodies(mockWorld.bodies);\n\n        // Solve\n        if(mockWorld.bodies.length){\n            this.solve(dt,mockWorld);\n        }\n    }\n};\n\n/**\n * Sort all equations using the .equationSortFunction. Should be called by subclasses before solving.\n * @method sortEquations\n */\nSolver.prototype.sortEquations = function(){\n    if(this.equationSortFunction){\n        this.equations.sort(this.equationSortFunction);\n    }\n};\n\n/**\n * Add an equation to be solved.\n *\n * @method addEquation\n * @param {Equation} eq\n */\nSolver.prototype.addEquation = function(eq){\n    if(eq.enabled){\n        this.equations.push(eq);\n    }\n};\n\n/**\n * Add equations. Same as .addEquation, but this time the argument is an array of Equations\n *\n * @method addEquations\n * @param {Array} eqs\n */\nSolver.prototype.addEquations = function(eqs){\n    //Utils.appendArray(this.equations,eqs);\n    for(var i=0, N=eqs.length; i!==N; i++){\n        var eq = eqs[i];\n        if(eq.enabled){\n            this.equations.push(eq);\n        }\n    }\n};\n\n/**\n * Remove an equation.\n *\n * @method removeEquation\n * @param {Equation} eq\n */\nSolver.prototype.removeEquation = function(eq){\n    var i = this.equations.indexOf(eq);\n    if(i !== -1){\n        this.equations.splice(i,1);\n    }\n};\n\n/**\n * Remove all currently added equations.\n *\n * @method removeAllEquations\n */\nSolver.prototype.removeAllEquations = function(){\n    this.equations.length=0;\n};\n\nSolver.GS = 1;\nSolver.ISLAND = 2;\n\n},{\"../events/EventEmitter\":26,\"../utils/Utils\":47}],45:[function(require,module,exports){\nvar TupleDictionary = require('./TupleDictionary');\nvar Utils = require('./Utils');\n\nmodule.exports = OverlapKeeper;\n\n/**\n * Keeps track of overlaps in the current state and the last step state.\n * @class OverlapKeeper\n * @constructor\n */\nfunction OverlapKeeper() {\n    this.overlappingLastState = new TupleDictionary();\n    this.overlappingCurrentState = new TupleDictionary();\n    this.recordPool = [];\n    this.tmpDict = new TupleDictionary();\n    this.tmpArray1 = [];\n}\n\n/**\n * @method tick\n */\nOverlapKeeper.prototype.tick = function() {\n    var last = this.overlappingLastState;\n    var current = this.overlappingCurrentState;\n\n    // Save old objects into pool\n    var l = current.keys.length;\n    while(l--){\n        var key = current.keys[l];\n        this.recordPool.push(current.getByKey(key));\n    }\n\n    // Clear last object\n    last.reset();\n\n    // Transfer from new object to old\n    last.copy(current);\n\n    // Clear current object\n    current.reset();\n};\n\n/**\n * @method setOverlapping\n */\nOverlapKeeper.prototype.setOverlapping = function(bodyA, shapeA, bodyB, shapeB) {\n    var last = this.overlappingLastState;\n    var current = this.overlappingCurrentState;\n\n    // Store current contact state\n    if(!current.get(shapeA.id, shapeB.id)){\n\n        var data;\n        if(this.recordPool.length){\n            data = this.recordPool.pop();\n        } else {\n            data = new OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB);\n        }\n\n        current.set(shapeA.id, shapeB.id, data);\n    }\n};\n\nOverlapKeeper.prototype.getNewOverlaps = function(result){\n    return this.getDiff(this.overlappingLastState, this.overlappingCurrentState, result);\n};\n\nOverlapKeeper.prototype.getEndOverlaps = function(result){\n    return this.getDiff(this.overlappingCurrentState, this.overlappingLastState, result);\n};\n\nOverlapKeeper.prototype.getDiff = function(dictA, dictB, result){\n    var result = result || [];\n    var last = dictA;\n    var current = dictB;\n\n    result.length = 0;\n\n    var l = current.keys.length;\n    while(l--){\n        var key = current.keys[l];\n        var data = current.data[key];\n\n        if(!data){\n            throw new Error('Key '+key+' had no data!');\n        }\n\n        var lastData = last.data[key];\n        if(!lastData){\n            // Not overlapping in last state, but in current.\n            result.push(data);\n        }\n    }\n\n    return result;\n};\n\nOverlapKeeper.prototype.isNewOverlap = function(shapeA, shapeB){\n    var idA = shapeA.id|0,\n        idB = shapeB.id|0;\n    return !!!this.overlappingLastState.get(idA, idB) && !!this.overlappingCurrentState.get(idA, idB);\n};\n\nOverlapKeeper.prototype.getNewBodyOverlaps = function(result){\n    this.tmpArray1.length = 0;\n    var overlaps = this.getNewOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n};\n\nOverlapKeeper.prototype.getEndBodyOverlaps = function(result){\n    this.tmpArray1.length = 0;\n    var overlaps = this.getEndOverlaps(this.tmpArray1);\n    return this.getBodyDiff(overlaps, result);\n};\n\nOverlapKeeper.prototype.getBodyDiff = function(overlaps, result){\n    result = result || [];\n    var accumulator = this.tmpDict;\n\n    var l = overlaps.length;\n\n    while(l--){\n        var data = overlaps[l];\n\n        // Since we use body id's for the accumulator, these will be a subset of the original one\n        accumulator.set(data.bodyA.id|0, data.bodyB.id|0, data);\n    }\n\n    l = accumulator.keys.length;\n    while(l--){\n        var data = accumulator.keys[l];\n        result.push(data.bodyA, data.bodyB);\n    }\n\n    accumulator.reset();\n\n    return result;\n};\n\n/**\n * Overlap data container for the OverlapKeeper\n * @param {Body} bodyA\n * @param {Shape} shapeA\n * @param {Body} bodyB\n * @param {Shape} shapeB [description]\n */\nfunction OverlapKeeperRecord(bodyA, shapeA, bodyB, shapeB){\n    /**\n     * @property {Shape} shapeA\n     */\n    this.shapeA = shapeA;\n    /**\n     * @property {Shape} shapeB\n     */\n    this.shapeB = shapeB;\n    /**\n     * @property {Body} bodyA\n     */\n    this.bodyA = bodyA;\n    /**\n     * @property {Body} bodyB\n     */\n    this.bodyB = bodyB;\n}\n\nOverlapKeeperRecord.prototype.set = function(bodyA, shapeA, bodyB, shapeB){\n    OverlapKeeperRecord.call(this, bodyA, shapeA, bodyB, shapeB);\n};\n\n},{\"./TupleDictionary\":46,\"./Utils\":47}],46:[function(require,module,exports){\nvar Utils = require('./Utils');\n\nmodule.exports = TupleDictionary;\n\n/**\n * @class TupleDictionary\n * @constructor\n */\nfunction TupleDictionary() {\n\n    /**\n     * The data storage\n     * @property data\n     * @type {Array}\n     */\n    this.data = [];\n\n    /**\n     * Keys that are currently used.\n     * @type {Array}\n     */\n    this.keys = [];\n}\n\n/**\n * Generate a key given two integers\n * @param  {number} i\n * @param  {number} j\n * @return {string}\n */\nTupleDictionary.prototype.getKey = function(id1, id2) {\n    id1 = id1|0;\n    id2 = id2|0;\n\n    if ( (id1|0) === (id2|0) ){\n        return -1;\n    }\n\n    // valid for values < 2^16\n    return ((id1|0) > (id2|0) ?\n        (id1 << 16) | (id2 & 0xFFFF) :\n        (id2 << 16) | (id1 & 0xFFFF))|0\n        ;\n};\n\n/**\n * @method getByKey\n * @param  {Number} key\n * @return {Object}\n */\nTupleDictionary.prototype.getByKey = function(key) {\n    key = key|0;\n    return this.data[key];\n};\n\n/**\n * @method get\n * @param  {Number} i\n * @param  {Number} j\n * @return {Number}\n */\nTupleDictionary.prototype.get = function(i, j) {\n    i = i|0;\n    j = j|0;\n    var key = this.getKey(i, j)|0;\n    return this.data[key];\n};\n\n/**\n * @method set\n * @param  {Number} i\n * @param  {Number} j\n * @param {Number} value\n */\nTupleDictionary.prototype.set = function(i, j, value) {\n    if(!value){\n        throw new Error(\"No data!\");\n    }\n\n    i = i|0;\n    j = j|0;\n    var key = this.getKey(i, j)|0;\n\n    // Check if key already exists\n    if(!this.get(i, j)){\n        this.keys.push(key);\n    }\n\n    this.data[key] = value;\n\n    return key;\n};\n\n/**\n * @method reset\n */\nTupleDictionary.prototype.reset = function() {\n    var data = this.data,\n        keys = this.keys;\n\n    var l = keys.length|0;\n    while(l--){\n        var key = keys[l]|0;\n        data[key] = undefined;\n    }\n\n    keys.length = 0;\n};\n\n/**\n * @method copy\n */\nTupleDictionary.prototype.copy = function(dict) {\n    this.reset();\n    Utils.appendArray(this.keys, dict.keys);\n    var l = dict.keys.length|0;\n    while(l--){\n        var key = dict.keys[l]|0;\n        this.data[key] = dict.data[key];\n    }\n};\n\n},{\"./Utils\":47}],47:[function(require,module,exports){\nmodule.exports = Utils;\n\n/**\n * Misc utility functions\n * @class Utils\n * @constructor\n */\nfunction Utils(){};\n\n/**\n * Append the values in array b to the array a. See <a href=\"http://stackoverflow.com/questions/1374126/how-to-append-an-array-to-an-existing-javascript-array/1374131#1374131\">this</a> for an explanation.\n * @method appendArray\n * @static\n * @param  {Array} a\n * @param  {Array} b\n */\nUtils.appendArray = function(a,b){\n    if (b.length < 150000) {\n        a.push.apply(a, b);\n    } else {\n        for (var i = 0, len = b.length; i !== len; ++i) {\n            a.push(b[i]);\n        }\n    }\n};\n\n/**\n * Garbage free Array.splice(). Does not allocate a new array.\n * @method splice\n * @static\n * @param  {Array} array\n * @param  {Number} index\n * @param  {Number} howmany\n */\nUtils.splice = function(array,index,howmany){\n    howmany = howmany || 1;\n    for (var i=index, len=array.length-howmany; i < len; i++){\n        array[i] = array[i + howmany];\n    }\n    array.length = len;\n};\n\n/**\n * The array type to use for internal numeric computations.\n * @type {Array}\n * @static\n * @property ARRAY_TYPE\n */\nUtils.ARRAY_TYPE = window.Float32Array || Array;\n\n/**\n * Extend an object with the properties of another\n * @static\n * @method extend\n * @param  {object} a\n * @param  {object} b\n */\nUtils.extend = function(a,b){\n    for(var key in b){\n        a[key] = b[key];\n    }\n};\n\n/**\n * Extend an object with the properties of another\n * @static\n * @method extend\n * @param  {object} a\n * @param  {object} b\n */\nUtils.defaults = function(options, defaults){\n    options = options || {};\n    for(var key in defaults){\n        if(!(key in options)){\n            options[key] = defaults[key];\n        }\n    }\n    return options;\n};\n\n},{}],48:[function(require,module,exports){\nvar Body = require('../objects/Body');\n\nmodule.exports = Island;\n\n/**\n * An island of bodies connected with equations.\n * @class Island\n * @constructor\n */\nfunction Island(){\n\n    /**\n     * Current equations in this island.\n     * @property equations\n     * @type {Array}\n     */\n    this.equations = [];\n\n    /**\n     * Current bodies in this island.\n     * @property bodies\n     * @type {Array}\n     */\n    this.bodies = [];\n}\n\n/**\n * Clean this island from bodies and equations.\n * @method reset\n */\nIsland.prototype.reset = function(){\n    this.equations.length = this.bodies.length = 0;\n};\n\nvar bodyIds = [];\n\n/**\n * Get all unique bodies in this island.\n * @method getBodies\n * @return {Array} An array of Body\n */\nIsland.prototype.getBodies = function(result){\n    var bodies = result || [],\n        eqs = this.equations;\n    bodyIds.length = 0;\n    for(var i=0; i!==eqs.length; i++){\n        var eq = eqs[i];\n        if(bodyIds.indexOf(eq.bodyA.id)===-1){\n            bodies.push(eq.bodyA);\n            bodyIds.push(eq.bodyA.id);\n        }\n        if(bodyIds.indexOf(eq.bodyB.id)===-1){\n            bodies.push(eq.bodyB);\n            bodyIds.push(eq.bodyB.id);\n        }\n    }\n    return bodies;\n};\n\n/**\n * Check if the entire island wants to sleep.\n * @method wantsToSleep\n * @return {Boolean}\n */\nIsland.prototype.wantsToSleep = function(){\n    for(var i=0; i<this.bodies.length; i++){\n        var b = this.bodies[i];\n        if(b.motionState === Body.DYNAMIC && !b.wantsToSleep){\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * Make all bodies in the island sleep.\n * @method sleep\n */\nIsland.prototype.sleep = function(){\n    for(var i=0; i<this.bodies.length; i++){\n        var b = this.bodies[i];\n        b.sleep();\n    }\n    return true;\n};\n\n},{\"../objects/Body\":31}],49:[function(require,module,exports){\nvar vec2 = require('../math/vec2')\n,   Island = require('./Island')\n,   IslandNode = require('./IslandNode')\n,   Body = require('../objects/Body')\n\nmodule.exports = IslandManager;\n\n/**\n * Splits the system of bodies and equations into independent islands\n *\n * @class IslandManager\n * @constructor\n * @param {Object} [options]\n * @extends Solver\n */\nfunction IslandManager(options){\n\n    // Pooling of node objects saves some GC load\n    this._nodePool = [];\n    this._islandPool = [];\n\n    /**\n     * The equations to split. Manually fill this array before running .split().\n     * @property {Array} equations\n     */\n    this.equations = [];\n\n    /**\n     * The resulting {{#crossLink \"Island\"}}{{/crossLink}}s.\n     * @property {Array} islands\n     */\n    this.islands = [];\n\n    /**\n     * The resulting graph nodes.\n     * @property {Array} nodes\n     */\n    this.nodes = [];\n\n    /**\n     * The node queue, used when traversing the graph of nodes.\n     * @private\n     * @property {Array} queue\n     */\n    this.queue = [];\n}\n\n/**\n * Get an unvisited node from a list of nodes.\n * @static\n * @method getUnvisitedNode\n * @param  {Array} nodes\n * @return {IslandNode|boolean} The node if found, else false.\n */\nIslandManager.getUnvisitedNode = function(nodes){\n    var Nnodes = nodes.length;\n    for(var i=0; i!==Nnodes; i++){\n        var node = nodes[i];\n        if(!node.visited && node.body.motionState === Body.DYNAMIC){\n            return node;\n        }\n    }\n    return false;\n};\n\n/**\n * Visit a node.\n * @method visit\n * @param  {IslandNode} node\n * @param  {Array} bds\n * @param  {Array} eqs\n */\nIslandManager.prototype.visit = function (node,bds,eqs){\n    bds.push(node.body);\n    var Neqs = node.equations.length;\n    for(var i=0; i!==Neqs; i++){\n        var eq = node.equations[i];\n        if(eqs.indexOf(eq) === -1){ // Already added?\n            eqs.push(eq);\n        }\n    }\n};\n\n/**\n * Runs the search algorithm, starting at a root node. The resulting bodies and equations will be stored in the provided arrays.\n * @method bfs\n * @param  {IslandNode} root The node to start from\n * @param  {Array} bds  An array to append resulting Bodies to.\n * @param  {Array} eqs  An array to append resulting Equations to.\n */\nIslandManager.prototype.bfs = function(root,bds,eqs){\n\n    // Reset the visit queue\n    var queue = this.queue;\n    queue.length = 0;\n\n    // Add root node to queue\n    queue.push(root);\n    root.visited = true;\n    this.visit(root,bds,eqs);\n\n    // Process all queued nodes\n    while(queue.length) {\n\n        // Get next node in the queue\n        var node = queue.pop();\n\n        // Visit unvisited neighboring nodes\n        var child;\n        while((child = IslandManager.getUnvisitedNode(node.neighbors))) {\n            child.visited = true;\n            this.visit(child,bds,eqs);\n\n            // Only visit the children of this node if it's dynamic\n            if(child.body.motionState === Body.DYNAMIC){\n                queue.push(child);\n            }\n        }\n    }\n};\n\n/**\n * Split the world into independent islands. The result is stored in .islands.\n * @method split\n * @param  {World} world\n * @return {Array} The generated islands\n */\nIslandManager.prototype.split = function(world){\n    var bodies = world.bodies,\n        nodes = this.nodes,\n        equations = this.equations;\n\n    // Move old nodes to the node pool\n    while(nodes.length){\n        this._nodePool.push(nodes.pop());\n    }\n\n    // Create needed nodes, reuse if possible\n    for(var i=0; i!==bodies.length; i++){\n        if(this._nodePool.length){\n            var node = this._nodePool.pop();\n            node.reset();\n            node.body = bodies[i];\n            nodes.push(node);\n        } else {\n            nodes.push(new IslandNode(bodies[i]));\n        }\n    }\n\n    // Add connectivity data. Each equation connects 2 bodies.\n    for(var k=0; k!==equations.length; k++){\n        var eq=equations[k],\n            i=bodies.indexOf(eq.bodyA),\n            j=bodies.indexOf(eq.bodyB),\n            ni=nodes[i],\n            nj=nodes[j];\n        ni.neighbors.push(nj);\n        nj.neighbors.push(ni);\n        ni.equations.push(eq);\n        nj.equations.push(eq);\n    }\n\n    // Move old islands to the island pool\n    var islands = this.islands;\n    while(islands.length){\n        var island = islands.pop();\n        island.reset();\n        this._islandPool.push(island);\n    }\n\n    // Get islands\n    var child;\n    while((child = IslandManager.getUnvisitedNode(nodes))){\n\n        // Create new island\n        var island = this._islandPool.length ? this._islandPool.pop() : new Island();\n\n        // Get all equations and bodies in this island\n        this.bfs(child, island.bodies, island.equations);\n\n        islands.push(island);\n    }\n\n    return islands;\n};\n\n},{\"../math/vec2\":30,\"../objects/Body\":31,\"./Island\":48,\"./IslandNode\":50}],50:[function(require,module,exports){\nmodule.exports = IslandNode;\n\n/**\n * Holds a body and keeps track of some additional properties needed for graph traversal.\n * @class IslandNode\n * @constructor\n * @param {Body} body\n */\nfunction IslandNode(body){\n\n\t/**\n\t * The body that is contained in this node.\n\t * @property {Body}\n\t */\n    this.body = body;\n\n    /**\n     * Neighboring IslandNodes\n     * @property {Array} neighbors\n     */\n    this.neighbors = [];\n\n    /**\n     * Equations connected to this node.\n     * @property {Array} equations\n     */\n    this.equations = [];\n\n    /**\n     * If this node was visiting during the graph traversal.\n     * @property visited\n     * @type {Boolean}\n     */\n    this.visited = false;\n}\n\n/**\n * Clean this node from bodies and equations.\n * @method reset\n */\nIslandNode.prototype.reset = function(){\n    this.equations.length = 0;\n    this.neighbors.length = 0;\n    this.visited = false;\n    this.body = null;\n};\n\n},{}],51:[function(require,module,exports){\nvar  GSSolver = require('../solver/GSSolver')\n,    Solver = require('../solver/Solver')\n,    NaiveBroadphase = require('../collision/NaiveBroadphase')\n,    vec2 = require('../math/vec2')\n,    Circle = require('../shapes/Circle')\n,    Rectangle = require('../shapes/Rectangle')\n,    Convex = require('../shapes/Convex')\n,    Line = require('../shapes/Line')\n,    Plane = require('../shapes/Plane')\n,    Capsule = require('../shapes/Capsule')\n,    Particle = require('../shapes/Particle')\n,    EventEmitter = require('../events/EventEmitter')\n,    Body = require('../objects/Body')\n,    Shape = require('../shapes/Shape')\n,    Spring = require('../objects/Spring')\n,    Material = require('../material/Material')\n,    ContactMaterial = require('../material/ContactMaterial')\n,    DistanceConstraint = require('../constraints/DistanceConstraint')\n,    Constraint = require('../constraints/Constraint')\n,    LockConstraint = require('../constraints/LockConstraint')\n,    RevoluteConstraint = require('../constraints/RevoluteConstraint')\n,    PrismaticConstraint = require('../constraints/PrismaticConstraint')\n,    GearConstraint = require('../constraints/GearConstraint')\n,    pkg = require('../../package.json')\n,    Broadphase = require('../collision/Broadphase')\n,    SAPBroadphase = require('../collision/SAPBroadphase')\n,    Narrowphase = require('../collision/Narrowphase')\n,    Utils = require('../utils/Utils')\n,    OverlapKeeper = require('../utils/OverlapKeeper')\n,    IslandManager = require('./IslandManager')\n\nmodule.exports = World;\n\nif(typeof performance === 'undefined'){\n    performance = {};\n}\nif(!performance.now){\n    var nowOffset = Date.now();\n    if (performance.timing && performance.timing.navigationStart){\n        nowOffset = performance.timing.navigationStart;\n    }\n    performance.now = function(){\n        return Date.now() - nowOffset;\n    };\n}\n\n/**\n * The dynamics world, where all bodies and constraints lives.\n *\n * @class World\n * @constructor\n * @param {Object}          [options]\n * @param {Solver}          [options.solver]            Defaults to GSSolver.\n * @param {Array}           [options.gravity]           Defaults to [0,-9.78]\n * @param {Broadphase}      [options.broadphase]        Defaults to NaiveBroadphase\n * @param {Boolean}         [options.islandSplit=false]\n * @param {Boolean}         [options.doProfiling=false]\n * @extends EventEmitter\n */\nfunction World(options){\n    EventEmitter.apply(this);\n\n    options = options || {};\n\n    /**\n     * All springs in the world. To add a spring to the world, use {{#crossLink \"World/addSpring:method\"}}{{/crossLink}}.\n     *\n     * @property springs\n     * @type {Array}\n     */\n    this.springs = [];\n\n    /**\n     * All bodies in the world. To add a body to the world, use {{#crossLink \"World/addBody:method\"}}{{/crossLink}}.\n     * @property {Array} bodies\n     */\n    this.bodies = [];\n\n    /**\n     * Disabled body collision pairs. See {{#crossLink \"World/disableBodyCollision:method\"}}.\n     * @private\n     * @property {Array} disabledBodyCollisionPairs\n     */\n    this.disabledBodyCollisionPairs = [];\n\n    /**\n     * The solver used to satisfy constraints and contacts. Default is {{#crossLink \"GSSolver\"}}{{/crossLink}}.\n     * @property {Solver} solver\n     */\n    this.solver = options.solver || new GSSolver();\n\n    /**\n     * The narrowphase to use to generate contacts.\n     *\n     * @property narrowphase\n     * @type {Narrowphase}\n     */\n    this.narrowphase = new Narrowphase(this);\n\n    /**\n     * The island manager of this world.\n     * @property {IslandManager} islandManager\n     */\n    this.islandManager = new IslandManager();\n\n    /**\n     * Gravity in the world. This is applied on all bodies in the beginning of each step().\n     *\n     * @property gravity\n     * @type {Array}\n     */\n    this.gravity = vec2.fromValues(0, -9.78);\n    if(options.gravity){\n        vec2.copy(this.gravity, options.gravity);\n    }\n\n    /**\n     * Gravity to use when approximating the friction max force (mu*mass*gravity).\n     * @property {Number} frictionGravity\n     */\n    this.frictionGravity = vec2.length(this.gravity) || 10;\n\n    /**\n     * Set to true if you want .frictionGravity to be automatically set to the length of .gravity.\n     * @property {Boolean} useWorldGravityAsFrictionGravity\n     */\n    this.useWorldGravityAsFrictionGravity = true;\n\n    /**\n     * If the length of .gravity is zero, and .useWorldGravityAsFrictionGravity=true, then switch to using .frictionGravity for friction instead. This fallback is useful for gravityless games.\n     * @property {Boolean} useFrictionGravityOnZeroGravity\n     */\n    this.useFrictionGravityOnZeroGravity = true;\n\n    /**\n     * Whether to do timing measurements during the step() or not.\n     *\n     * @property doPofiling\n     * @type {Boolean}\n     */\n    this.doProfiling = options.doProfiling || false;\n\n    /**\n     * How many millisecconds the last step() took. This is updated each step if .doProfiling is set to true.\n     *\n     * @property lastStepTime\n     * @type {Number}\n     */\n    this.lastStepTime = 0.0;\n\n    /**\n     * The broadphase algorithm to use.\n     *\n     * @property broadphase\n     * @type {Broadphase}\n     */\n    this.broadphase = options.broadphase || new NaiveBroadphase();\n    this.broadphase.setWorld(this);\n\n    /**\n     * User-added constraints.\n     *\n     * @property constraints\n     * @type {Array}\n     */\n    this.constraints = [];\n\n    /**\n     * Dummy default material in the world, used in .defaultContactMaterial\n     * @property {Material} defaultMaterial\n     */\n    this.defaultMaterial = new Material();\n\n    /**\n     * The default contact material to use, if no contact material was set for the colliding materials.\n     * @property {ContactMaterial} defaultContactMaterial\n     */\n    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial);\n\n    /**\n     * For keeping track of what time step size we used last step\n     * @property lastTimeStep\n     * @type {Number}\n     */\n    this.lastTimeStep = 1/60;\n\n    /**\n     * Enable to automatically apply spring forces each step.\n     * @property applySpringForces\n     * @type {Boolean}\n     */\n    this.applySpringForces = true;\n\n    /**\n     * Enable to automatically apply body damping each step.\n     * @property applyDamping\n     * @type {Boolean}\n     */\n    this.applyDamping = true;\n\n    /**\n     * Enable to automatically apply gravity each step.\n     * @property applyGravity\n     * @type {Boolean}\n     */\n    this.applyGravity = true;\n\n    /**\n     * Enable/disable constraint solving in each step.\n     * @property solveConstraints\n     * @type {Boolean}\n     */\n    this.solveConstraints = true;\n\n    /**\n     * The ContactMaterials added to the World.\n     * @property contactMaterials\n     * @type {Array}\n     */\n    this.contactMaterials = [];\n\n    /**\n     * World time.\n     * @property time\n     * @type {Number}\n     */\n    this.time = 0.0;\n\n    /**\n     * Is true during the step().\n     * @property {Boolean} stepping\n     */\n    this.stepping = false;\n\n    /**\n     * Bodies that are scheduled to be removed at the end of the step.\n     * @property {Array} bodiesToBeRemoved\n     * @private\n     */\n    this.bodiesToBeRemoved = [];\n\n    this.fixedStepTime = 0.0;\n\n    /**\n     * Whether to enable island splitting. Island splitting can be an advantage for many things, including solver performance. See {{#crossLink \"IslandManager\"}}{{/crossLink}}.\n     * @property {Boolean} islandSplit\n     */\n    this.islandSplit = typeof(options.islandSplit)!==\"undefined\" ? !!options.islandSplit : false;\n\n    /**\n     * Set to true if you want to the world to emit the \"impact\" event. Turning this off could improve performance.\n     * @property emitImpactEvent\n     * @type {Boolean}\n     */\n    this.emitImpactEvent = true;\n\n    // Id counters\n    this._constraintIdCounter = 0;\n    this._bodyIdCounter = 0;\n\n    /**\n     * Fired after the step().\n     * @event postStep\n     */\n    this.postStepEvent = {\n        type : \"postStep\",\n    };\n\n    /**\n     * Fired when a body is added to the world.\n     * @event addBody\n     * @param {Body} body\n     */\n    this.addBodyEvent = {\n        type : \"addBody\",\n        body : null\n    };\n\n    /**\n     * Fired when a body is removed from the world.\n     * @event removeBody\n     * @param {Body} body\n     */\n    this.removeBodyEvent = {\n        type : \"removeBody\",\n        body : null\n    };\n\n    /**\n     * Fired when a spring is added to the world.\n     * @event addSpring\n     * @param {Spring} spring\n     */\n    this.addSpringEvent = {\n        type : \"addSpring\",\n        spring : null,\n    };\n\n    /**\n     * Fired when a first contact is created between two bodies. This event is fired after the step has been done.\n     * @event impact\n     * @param {Body} bodyA\n     * @param {Body} bodyB\n     */\n    this.impactEvent = {\n        type: \"impact\",\n        bodyA : null,\n        bodyB : null,\n        shapeA : null,\n        shapeB : null,\n        contactEquation : null,\n    };\n\n    /**\n     * Fired after the Broadphase has collected collision pairs in the world.\n     * Inside the event handler, you can modify the pairs array as you like, to\n     * prevent collisions between objects that you don't want.\n     * @event postBroadphase\n     * @param {Array} pairs An array of collision pairs. If this array is [body1,body2,body3,body4], then the body pairs 1,2 and 3,4 would advance to narrowphase.\n     */\n    this.postBroadphaseEvent = {\n        type:\"postBroadphase\",\n        pairs:null,\n    };\n\n    /**\n     * Enable / disable automatic body sleeping. Sleeping can improve performance. You might need to {{#crossLink \"Body/wakeUp:method\"}}wake up{{/crossLink}} the bodies if they fall asleep when they shouldn't. If you want to enable sleeping in the world, but want to disable it for a particular body, see {{#crossLink \"Body/allowSleep:property\"}}Body.allowSleep{{/crossLink}}.\n     * @property allowSleep\n     * @type {Boolean}\n     */\n    this.enableBodySleeping = false;\n\n    /**\n     * Enable or disable island sleeping. Note that you must enable {{#crossLink \"World/islandSplit:property\"}}.islandSplit{{/crossLink}} for this to work.\n     * @property {Boolean} enableIslandSleeping\n     */\n    this.enableIslandSleeping = false;\n\n    /**\n     * Fired when two shapes starts start to overlap. Fired in the narrowphase, during step.\n     * @event beginContact\n     * @param {Shape} shapeA\n     * @param {Shape} shapeB\n     * @param {Body}  bodyA\n     * @param {Body}  bodyB\n     * @param {Array} contactEquations\n     */\n    this.beginContactEvent = {\n        type:\"beginContact\",\n        shapeA : null,\n        shapeB : null,\n        bodyA : null,\n        bodyB : null,\n        contactEquations : [],\n    };\n\n    /**\n     * Fired when two shapes stop overlapping, after the narrowphase (during step).\n     * @event endContact\n     * @param {Shape} shapeA\n     * @param {Shape} shapeB\n     * @param {Body}  bodyA\n     * @param {Body}  bodyB\n     * @param {Array} contactEquations\n     */\n    this.endContactEvent = {\n        type:\"endContact\",\n        shapeA : null,\n        shapeB : null,\n        bodyA : null,\n        bodyB : null,\n    };\n\n    /**\n     * Fired just before equations are added to the solver to be solved. Can be used to control what equations goes into the solver.\n     * @event preSolve\n     * @param {Array} contactEquations  An array of contacts to be solved.\n     * @param {Array} frictionEquations An array of friction equations to be solved.\n     */\n    this.preSolveEvent = {\n        type:\"preSolve\",\n        contactEquations:null,\n        frictionEquations:null,\n    };\n\n    // For keeping track of overlapping shapes\n    this.overlappingShapesLastState = { keys:[] };\n    this.overlappingShapesCurrentState = { keys:[] };\n\n    this.overlapKeeper = new OverlapKeeper();\n}\nWorld.prototype = new Object(EventEmitter.prototype);\n\n/**\n * Add a constraint to the simulation.\n *\n * @method addConstraint\n * @param {Constraint} c\n */\nWorld.prototype.addConstraint = function(c){\n    this.constraints.push(c);\n};\n\n/**\n * Add a ContactMaterial to the simulation.\n * @method addContactMaterial\n * @param {ContactMaterial} contactMaterial\n */\nWorld.prototype.addContactMaterial = function(contactMaterial){\n    this.contactMaterials.push(contactMaterial);\n};\n\n/**\n * Removes a contact material\n *\n * @method removeContactMaterial\n * @param {ContactMaterial} cm\n */\nWorld.prototype.removeContactMaterial = function(cm){\n    var idx = this.contactMaterials.indexOf(cm);\n    if(idx!==-1){\n        Utils.splice(this.contactMaterials,idx,1);\n    }\n};\n\n/**\n * Get a contact material given two materials\n * @method getContactMaterial\n * @param {Material} materialA\n * @param {Material} materialB\n * @return {ContactMaterial} The matching ContactMaterial, or false on fail.\n * @todo Use faster hash map to lookup from material id's\n */\nWorld.prototype.getContactMaterial = function(materialA,materialB){\n    var cmats = this.contactMaterials;\n    for(var i=0, N=cmats.length; i!==N; i++){\n        var cm = cmats[i];\n        if( (cm.materialA === materialA) && (cm.materialB === materialB) ||\n            (cm.materialA === materialB) && (cm.materialB === materialA) ){\n            return cm;\n        }\n    }\n    return false;\n};\n\n/**\n * Removes a constraint\n *\n * @method removeConstraint\n * @param {Constraint} c\n */\nWorld.prototype.removeConstraint = function(c){\n    var idx = this.constraints.indexOf(c);\n    if(idx!==-1){\n        Utils.splice(this.constraints,idx,1);\n    }\n};\n\nvar step_r = vec2.create(),\n    step_runit = vec2.create(),\n    step_u = vec2.create(),\n    step_f = vec2.create(),\n    step_fhMinv = vec2.create(),\n    step_velodt = vec2.create(),\n    step_mg = vec2.create(),\n    xiw = vec2.fromValues(0,0),\n    xjw = vec2.fromValues(0,0),\n    zero = vec2.fromValues(0,0),\n    interpvelo = vec2.fromValues(0,0);\n\n/**\n * Step the physics world forward in time.\n *\n * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.\n *\n * @method step\n * @param {Number} dt                       The fixed time step size to use.\n * @param {Number} [timeSinceLastCalled=0]  The time elapsed since the function was last called.\n * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.\n *\n * @example\n *     // fixed timestepping without interpolation\n *     var world = new World();\n *     world.step(0.01);\n *\n * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World\n */\nWorld.prototype.step = function(dt,timeSinceLastCalled,maxSubSteps){\n    maxSubSteps = maxSubSteps || 10;\n    timeSinceLastCalled = timeSinceLastCalled || 0;\n\n    if(timeSinceLastCalled === 0){ // Fixed, simple stepping\n\n        this.internalStep(dt);\n\n        // Increment time\n        this.time += dt;\n\n    } else {\n\n        // Compute the number of fixed steps we should have taken since the last step\n        var internalSteps = Math.floor( (this.time+timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps,maxSubSteps);\n\n        // Do some fixed steps to catch up\n        for(var i=0; i!==internalSteps; i++){\n            this.internalStep(dt);\n        }\n\n        // Increment internal clock\n        this.time += timeSinceLastCalled;\n\n        // Compute \"Left over\" time step\n        var h = this.time % dt;\n        var h_div_dt = h/dt;\n\n        for(var j=0; j!==this.bodies.length; j++){\n            var b = this.bodies[j];\n            if(b.motionState !== Body.STATIC && b.sleepState !== Body.SLEEPING){\n                // Interpolate\n                vec2.sub(interpvelo, b.position, b.previousPosition);\n                vec2.scale(interpvelo, interpvelo, h_div_dt);\n                vec2.add(b.interpolatedPosition, b.position, interpvelo);\n\n                b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;\n            } else {\n                // For static bodies, just copy. Who else will do it?\n                vec2.copy(b.interpolatedPosition, b.position);\n                b.interpolatedAngle = b.angle;\n            }\n        }\n    }\n};\n\nvar endOverlaps = [];\n\n/**\n * Make a fixed step.\n * @method internalStep\n * @param  {number} dt\n * @private\n */\nWorld.prototype.internalStep = function(dt){\n    this.stepping = true;\n\n    var that = this,\n        doProfiling = this.doProfiling,\n        Nsprings = this.springs.length,\n        springs = this.springs,\n        bodies = this.bodies,\n        g = this.gravity,\n        solver = this.solver,\n        Nbodies = this.bodies.length,\n        broadphase = this.broadphase,\n        np = this.narrowphase,\n        constraints = this.constraints,\n        t0, t1,\n        fhMinv = step_fhMinv,\n        velodt = step_velodt,\n        mg = step_mg,\n        scale = vec2.scale,\n        add = vec2.add,\n        rotate = vec2.rotate,\n        islandManager = this.islandManager;\n\n    this.lastTimeStep = dt;\n\n    if(doProfiling){\n        t0 = performance.now();\n    }\n\n    // Update approximate friction gravity.\n    if(this.useWorldGravityAsFrictionGravity){\n        var gravityLen = vec2.length(this.gravity);\n        if(gravityLen === 0 && this.useFrictionGravityOnZeroGravity){\n            // Leave friction gravity as it is.\n        } else {\n            // Nonzero gravity. Use it.\n            this.frictionGravity = gravityLen;\n        }\n    }\n\n    // Add gravity to bodies\n    if(this.applyGravity){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i],\n                fi = b.force;\n            if(b.motionState !== Body.DYNAMIC || b.sleepState === Body.SLEEPING){\n                continue;\n            }\n            vec2.scale(mg,g,b.mass*b.gravityScale); // F=m*g\n            add(fi,fi,mg);\n        }\n    }\n\n    // Add spring forces\n    if(this.applySpringForces){\n        for(var i=0; i!==Nsprings; i++){\n            var s = springs[i];\n            s.applyForce();\n        }\n    }\n\n    if(this.applyDamping){\n        for(var i=0; i!==Nbodies; i++){\n            var b = bodies[i];\n            if(b.motionState === Body.DYNAMIC){\n                b.applyDamping(dt);\n            }\n        }\n    }\n\n    // Broadphase\n    var result = broadphase.getCollisionPairs(this);\n\n    // Remove ignored collision pairs\n    var ignoredPairs = this.disabledBodyCollisionPairs;\n    for(var i=ignoredPairs.length-2; i>=0; i-=2){\n        for(var j=result.length-2; j>=0; j-=2){\n            if( (ignoredPairs[i]   === result[j] && ignoredPairs[i+1] === result[j+1]) ||\n                (ignoredPairs[i+1] === result[j] && ignoredPairs[i]   === result[j+1])){\n                result.splice(j,2);\n            }\n        }\n    }\n\n    // Remove constrained pairs with collideConnected == false\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        var c = constraints[i];\n        if(!c.collideConnected){\n            for(var j=result.length-2; j>=0; j-=2){\n                if( (c.bodyA === result[j] && c.bodyB === result[j+1]) ||\n                    (c.bodyB === result[j] && c.bodyA === result[j+1])){\n                    result.splice(j,2);\n                }\n            }\n        }\n    }\n\n    // postBroadphase event\n    this.postBroadphaseEvent.pairs = result;\n    this.emit(this.postBroadphaseEvent);\n\n    // Narrowphase\n    np.reset(this);\n    for(var i=0, Nresults=result.length; i!==Nresults; i+=2){\n        var bi = result[i],\n            bj = result[i+1];\n\n        // Loop over all shapes of body i\n        for(var k=0, Nshapesi=bi.shapes.length; k!==Nshapesi; k++){\n            var si = bi.shapes[k],\n                xi = bi.shapeOffsets[k],\n                ai = bi.shapeAngles[k];\n\n            // All shapes of body j\n            for(var l=0, Nshapesj=bj.shapes.length; l!==Nshapesj; l++){\n                var sj = bj.shapes[l],\n                    xj = bj.shapeOffsets[l],\n                    aj = bj.shapeAngles[l];\n\n                var cm = this.defaultContactMaterial;\n                if(si.material && sj.material){\n                    var tmp = this.getContactMaterial(si.material,sj.material);\n                    if(tmp){\n                        cm = tmp;\n                    }\n                }\n\n                this.runNarrowphase(np,bi,si,xi,ai,bj,sj,xj,aj,cm,this.frictionGravity);\n            }\n        }\n    }\n\n    // Wake up bodies\n    for(var i=0; i!==Nbodies; i++){\n        var body = bodies[i];\n        if(body._wakeUpAfterNarrowphase){\n            body.wakeUp();\n            body._wakeUpAfterNarrowphase = false;\n        }\n    }\n\n    // Emit end overlap events\n    if(this.has('endContact')){\n        this.overlapKeeper.getEndOverlaps(endOverlaps);\n        var e = this.endContactEvent;\n        var l = endOverlaps.length;\n        while(l--){\n            var data = endOverlaps[l];\n            e.shapeA = data.shapeA;\n            e.shapeB = data.shapeB;\n            e.bodyA = data.bodyA;\n            e.bodyB = data.bodyA;\n            this.emit(e);\n        }\n    }\n    this.overlapKeeper.tick();\n\n    var preSolveEvent = this.preSolveEvent;\n    preSolveEvent.contactEquations = np.contactEquations;\n    preSolveEvent.frictionEquations = np.frictionEquations;\n    this.emit(preSolveEvent);\n\n    // update constraint equations\n    var Nconstraints = constraints.length;\n    for(i=0; i!==Nconstraints; i++){\n        constraints[i].update();\n    }\n\n    if(np.contactEquations.length || np.frictionEquations.length || constraints.length){\n        if(this.islandSplit){\n            // Split into islands\n            islandManager.equations.length = 0;\n            Utils.appendArray(islandManager.equations, np.contactEquations);\n            Utils.appendArray(islandManager.equations, np.frictionEquations);\n            for(i=0; i!==Nconstraints; i++){\n                Utils.appendArray(islandManager.equations, constraints[i].equations);\n            }\n            islandManager.split(this);\n\n            for(var i=0; i!==islandManager.islands.length; i++){\n                var island = islandManager.islands[i];\n                if(island.equations.length){\n                    solver.solveIsland(dt,island);\n                }\n            }\n\n        } else {\n\n            // Add contact equations to solver\n            solver.addEquations(np.contactEquations);\n            solver.addEquations(np.frictionEquations);\n\n            // Add user-defined constraint equations\n            for(i=0; i!==Nconstraints; i++){\n                solver.addEquations(constraints[i].equations);\n            }\n\n            if(this.solveConstraints){\n                solver.solve(dt,this);\n            }\n\n            solver.removeAllEquations();\n        }\n    }\n\n    // Step forward\n    for(var i=0; i!==Nbodies; i++){\n        var body = bodies[i];\n\n        if(body.sleepState !== Body.SLEEPING && body.motionState !== Body.STATIC){\n            World.integrateBody(body,dt);\n        }\n    }\n\n    // Reset force\n    for(var i=0; i!==Nbodies; i++){\n        bodies[i].setZeroForce();\n    }\n\n    if(doProfiling){\n        t1 = performance.now();\n        that.lastStepTime = t1-t0;\n    }\n\n    // Emit impact event\n    if(this.emitImpactEvent && this.has('impact')){\n        var ev = this.impactEvent;\n        for(var i=0; i!==np.contactEquations.length; i++){\n            var eq = np.contactEquations[i];\n            if(eq.firstImpact){\n                ev.bodyA = eq.bodyA;\n                ev.bodyB = eq.bodyB;\n                ev.shapeA = eq.shapeA;\n                ev.shapeB = eq.shapeB;\n                ev.contactEquation = eq;\n                this.emit(ev);\n            }\n        }\n    }\n\n    // Sleeping update\n    if(this.enableBodySleeping){\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].sleepTick(this.time, false, dt);\n        }\n    } else if(this.enableIslandSleeping && this.islandSplit){\n\n        // Tell all bodies to sleep tick but dont sleep yet\n        for(i=0; i!==Nbodies; i++){\n            bodies[i].sleepTick(this.time, true, dt);\n        }\n\n        // Sleep islands\n        for(var i=0; i<this.islandManager.islands.length; i++){\n            var island = this.islandManager.islands[i];\n            if(island.wantsToSleep()){\n                island.sleep();\n            }\n        }\n    }\n\n    this.stepping = false;\n\n    // Remove bodies that are scheduled for removal\n    if(this.bodiesToBeRemoved.length){\n        for(var i=0; i!==this.bodiesToBeRemoved.length; i++){\n            this.removeBody(this.bodiesToBeRemoved[i]);\n        }\n        this.bodiesToBeRemoved.length = 0;\n    }\n\n    this.emit(this.postStepEvent);\n};\n\nvar ib_fhMinv = vec2.create();\nvar ib_velodt = vec2.create();\n\n/**\n * Move a body forward in time.\n * @static\n * @method integrateBody\n * @param  {Body} body\n * @param  {Number} dt\n * @todo Move to Body.prototype?\n */\nWorld.integrateBody = function(body,dt){\n    var minv = body.invMass,\n        f = body.force,\n        pos = body.position,\n        velo = body.velocity;\n\n    // Save old position\n    vec2.copy(body.previousPosition, body.position);\n    body.previousAngle = body.angle;\n\n    // Angular step\n    if(!body.fixedRotation){\n        body.angularVelocity += body.angularForce * body.invInertia * dt;\n        body.angle += body.angularVelocity * dt;\n    }\n\n    // Linear step\n    vec2.scale(ib_fhMinv,f,dt*minv);\n    vec2.add(velo,ib_fhMinv,velo);\n    vec2.scale(ib_velodt,velo,dt);\n    vec2.add(pos,pos,ib_velodt);\n\n    body.aabbNeedsUpdate = true;\n};\n\n/**\n * Runs narrowphase for the shape pair i and j.\n * @method runNarrowphase\n * @param  {Narrowphase} np\n * @param  {Body} bi\n * @param  {Shape} si\n * @param  {Array} xi\n * @param  {Number} ai\n * @param  {Body} bj\n * @param  {Shape} sj\n * @param  {Array} xj\n * @param  {Number} aj\n * @param  {Number} mu\n */\nWorld.prototype.runNarrowphase = function(np,bi,si,xi,ai,bj,sj,xj,aj,cm,glen){\n\n    // Check collision groups and masks\n    if(!((si.collisionGroup & sj.collisionMask) !== 0 && (sj.collisionGroup & si.collisionMask) !== 0)){\n        return;\n    }\n\n    // Get world position and angle of each shape\n    vec2.rotate(xiw, xi, bi.angle);\n    vec2.rotate(xjw, xj, bj.angle);\n    vec2.add(xiw, xiw, bi.position);\n    vec2.add(xjw, xjw, bj.position);\n    var aiw = ai + bi.angle;\n    var ajw = aj + bj.angle;\n\n    np.enableFriction = cm.friction > 0;\n    np.frictionCoefficient = cm.friction;\n    var reducedMass;\n    if(bi.motionState === Body.STATIC || bi.motionState === Body.KINEMATIC){\n        reducedMass = bj.mass;\n    } else if(bj.motionState === Body.STATIC || bj.motionState === Body.KINEMATIC){\n        reducedMass = bi.mass;\n    } else {\n        reducedMass = (bi.mass*bj.mass)/(bi.mass+bj.mass);\n    }\n    np.slipForce = cm.friction*glen*reducedMass;\n    np.restitution = cm.restitution;\n    np.surfaceVelocity = cm.surfaceVelocity;\n    np.frictionStiffness = cm.frictionStiffness;\n    np.frictionRelaxation = cm.frictionRelaxation;\n    np.stiffness = cm.stiffness;\n    np.relaxation = cm.relaxation;\n\n    var resolver = np[si.type | sj.type],\n        numContacts = 0;\n    if (resolver) {\n        var sensor = si.sensor || sj.sensor;\n        var numFrictionBefore = np.frictionEquations.length;\n        if (si.type < sj.type) {\n            numContacts = resolver.call(np, bi,si,xiw,aiw, bj,sj,xjw,ajw, sensor);\n        } else {\n            numContacts = resolver.call(np, bj,sj,xjw,ajw, bi,si,xiw,aiw, sensor);\n        }\n        var numFrictionEquations = np.frictionEquations.length - numFrictionBefore;\n\n        if(numContacts){\n\n            if( bi.allowSleep &&\n                bi.motionState === Body.DYNAMIC &&\n                bi.sleepState  === Body.SLEEPING &&\n                bj.sleepState  === Body.AWAKE &&\n                bj.motionState !== Body.STATIC\n            ){\n                var speedSquaredB = vec2.squaredLength(bj.velocity) + Math.pow(bj.angularVelocity,2);\n                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);\n                if(speedSquaredB >= speedLimitSquaredB*2){\n                    bi._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            if( bj.allowSleep &&\n                bj.motionState === Body.DYNAMIC &&\n                bj.sleepState  === Body.SLEEPING &&\n                bi.sleepState  === Body.AWAKE &&\n                bi.motionState !== Body.STATIC\n            ){\n                var speedSquaredA = vec2.squaredLength(bi.velocity) + Math.pow(bi.angularVelocity,2);\n                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);\n                if(speedSquaredA >= speedLimitSquaredA*2){\n                    bj._wakeUpAfterNarrowphase = true;\n                }\n            }\n\n            this.overlapKeeper.setOverlapping(bi, si, bj, sj);\n            if(this.has('beginContact') && this.overlapKeeper.isNewOverlap(si, sj)){\n\n                // Report new shape overlap\n                var e = this.beginContactEvent;\n                e.shapeA = si;\n                e.shapeB = sj;\n                e.bodyA = bi;\n                e.bodyB = bj;\n\n                // Reset contact equations\n                e.contactEquations.length = 0;\n\n                if(typeof(numContacts)===\"number\"){\n                    for(var i=np.contactEquations.length-numContacts; i<np.contactEquations.length; i++){\n                        e.contactEquations.push(np.contactEquations[i]);\n                    }\n                }\n\n                this.emit(e);\n            }\n\n            // divide the max friction force by the number of contacts\n            if(typeof(numContacts)===\"number\" && numFrictionEquations > 1){ // Why divide by 1?\n                for(var i=np.frictionEquations.length-numFrictionEquations; i<np.frictionEquations.length; i++){\n                    var f = np.frictionEquations[i];\n                    f.setSlipForce(f.getSlipForce() / numFrictionEquations);\n                }\n            }\n        }\n    }\n\n};\n\n/**\n * Add a spring to the simulation\n *\n * @method addSpring\n * @param {Spring} s\n */\nWorld.prototype.addSpring = function(s){\n    this.springs.push(s);\n    this.addSpringEvent.spring = s;\n    this.emit(this.addSpringEvent);\n};\n\n/**\n * Remove a spring\n *\n * @method removeSpring\n * @param {Spring} s\n */\nWorld.prototype.removeSpring = function(s){\n    var idx = this.springs.indexOf(s);\n    if(idx===-1){\n        Utils.splice(this.springs,idx,1);\n    }\n};\n\n/**\n * Add a body to the simulation\n *\n * @method addBody\n * @param {Body} body\n *\n * @example\n *     var world = new World(),\n *         body = new Body();\n *     world.addBody(body);\n * @todo What if this is done during step?\n */\nWorld.prototype.addBody = function(body){\n    if(this.bodies.indexOf(body) === -1){\n        this.bodies.push(body);\n        body.world = this;\n        this.addBodyEvent.body = body;\n        this.emit(this.addBodyEvent);\n    }\n};\n\n/**\n * Remove a body from the simulation. If this method is called during step(), the body removal is scheduled to after the step.\n *\n * @method removeBody\n * @param {Body} body\n */\nWorld.prototype.removeBody = function(body){\n    if(this.stepping){\n        this.bodiesToBeRemoved.push(body);\n    } else {\n        body.world = null;\n        var idx = this.bodies.indexOf(body);\n        if(idx!==-1){\n            Utils.splice(this.bodies,idx,1);\n            this.removeBodyEvent.body = body;\n            body.resetConstraintVelocity();\n            this.emit(this.removeBodyEvent);\n        }\n    }\n};\n\n/**\n * Get a body by its id.\n * @method getBodyById\n * @return {Body|Boolean} The body, or false if it was not found.\n */\nWorld.prototype.getBodyById = function(id){\n    var bodies = this.bodies;\n    for(var i=0; i<bodies.length; i++){\n        var b = bodies[i];\n        if(b.id === id){\n            return b;\n        }\n    }\n    return false;\n};\n\n/**\n * Disable collision between two bodies\n * @method disableCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nWorld.prototype.disableBodyCollision = function(bodyA,bodyB){\n    this.disabledBodyCollisionPairs.push(bodyA,bodyB);\n};\n\n/**\n * Enable collisions between the given two bodies\n * @method enableCollision\n * @param {Body} bodyA\n * @param {Body} bodyB\n */\nWorld.prototype.enableBodyCollision = function(bodyA,bodyB){\n    var pairs = this.disabledBodyCollisionPairs;\n    for(var i=0; i<pairs.length; i+=2){\n        if((pairs[i] === bodyA && pairs[i+1] === bodyB) || (pairs[i+1] === bodyA && pairs[i] === bodyB)){\n            pairs.splice(i,2);\n            return;\n        }\n    }\n};\n\n\nfunction v2a(v){\n    if(!v) return v;\n    return [v[0],v[1]];\n}\n\nfunction extend(a,b){\n    for(var key in b)\n        a[key] = b[key];\n}\n\nfunction contactMaterialToJSON(cm){\n    return {\n        id : cm.id,\n        materialA :             cm.materialA.id,\n        materialB :             cm.materialB.id,\n        friction :              cm.friction,\n        restitution :           cm.restitution,\n        stiffness :             cm.stiffness,\n        relaxation :            cm.relaxation,\n        frictionStiffness :     cm.frictionStiffness,\n        frictionRelaxation :    cm.frictionRelaxation,\n    };\n}\n\n/**\n * Convert the world to a JSON-serializable Object.\n *\n * @method toJSON\n * @return {Object}\n * @deprecated Should use Serializer instead.\n */\nWorld.prototype.toJSON = function(){\n    var world = this;\n\n    var json = {\n        p2 :                        pkg.version,\n        bodies :                    [],\n        springs :                   [],\n        solver :                    {},\n        gravity :                   v2a(world.gravity),\n        broadphase :                {},\n        distanceConstraints :       [],\n        revoluteConstraints :       [],\n        prismaticConstraints :      [],\n        lockConstraints :           [],\n        gearConstraints :           [],\n        contactMaterials :          [],\n        materials :                 [],\n        defaultContactMaterial :    contactMaterialToJSON(world.defaultContactMaterial),\n        islandSplit :               world.islandSplit,\n        enableIslandSleeping :      world.enableIslandSleeping,\n        enableBodySleeping :        world.enableBodySleeping,\n    };\n\n    // Solver\n    var js = json.solver,\n        s = world.solver;\n    if(s.type === Solver.GS){\n        js.type = \"GSSolver\";\n        js.iterations = s.iterations;\n    }\n\n    // Broadphase\n    var jb = json.broadphase,\n        wb = world.broadphase;\n    if(wb.type === Broadphase.NAIVE){\n        jb.type = \"NaiveBroadphase\";\n    } else if(wb.type === Broadphase.SAP) {\n        jb.type = \"SAPBroadphase\";\n        //jb.axisIndex = wb.axisIndex;\n    } else {\n        console.error(\"Broadphase not supported: \"+wb.type);\n    }\n\n    // Serialize springs\n    for(var i=0; i!==world.springs.length; i++){\n        var s = world.springs[i];\n        json.springs.push({\n            bodyA :         world.bodies.indexOf(s.bodyA),\n            bodyB :         world.bodies.indexOf(s.bodyB),\n            stiffness :     s.stiffness,\n            damping :       s.damping,\n            restLength :    s.restLength,\n            localAnchorA :  v2a(s.localAnchorA),\n            localAnchorB :  v2a(s.localAnchorB),\n        });\n    }\n\n    // Serialize constraints\n    for(var i=0; i<world.constraints.length; i++){\n        var c = world.constraints[i];\n        var jc = {\n            bodyA : world.bodies.indexOf(c.bodyA),\n            bodyB : world.bodies.indexOf(c.bodyB),\n            collideConnected : c.collideConnected\n        };\n\n        switch(c.type){\n\n        case Constraint.DISTANCE:\n            extend(jc,{\n                distance : c.distance,\n                maxForce : c.getMaxForce(),\n            });\n            json.distanceConstraints.push(jc);\n            break;\n\n        case Constraint.REVOLUTE:\n            extend(jc,{\n                pivotA :            v2a(c.pivotA),\n                pivotB :            v2a(c.pivotB),\n                maxForce :          c.maxForce,\n                motorSpeed :        c.getMotorSpeed() || 0,\n                motorEnabled :       !!c.getMotorSpeed(),\n                lowerLimit :        c.lowerLimit,\n                lowerLimitEnabled : c.lowerLimitEnabled,\n                upperLimit :        c.upperLimit,\n                upperLimitEnabled : c.upperLimitEnabled,\n            });\n            json.revoluteConstraints.push(jc);\n            break;\n\n        case Constraint.PRISMATIC:\n            extend(jc,{\n                localAxisA :    v2a(c.localAxisA),\n                localAnchorA :  v2a(c.localAnchorA),\n                localAnchorB :  v2a(c.localAnchorB),\n                maxForce :      c.maxForce,\n                upperLimitEnabled : c.upperLimitEnabled,\n                lowerLimitEnabled : c.lowerLimitEnabled,\n                upperLimit : c.upperLimit,\n                lowerLimit : c.lowerLimit,\n                motorEnabled : c.motorEnabled,\n                motorSpeed : c.motorSpeed,\n            });\n            json.prismaticConstraints.push(jc);\n            break;\n\n        case Constraint.LOCK:\n            extend(jc,{\n                localOffsetB :  v2a(c.localOffsetB),\n                localAngleB :   c.localAngleB,\n                maxForce :      c.getMaxForce(),\n            });\n            json.lockConstraints.push(jc);\n            break;\n\n        case Constraint.GEAR:\n            extend(jc,{\n                angle :     c.angle,\n                ratio :     c.ratio,\n                maxForce :  c.maxForce || 1e6, // correct?\n            });\n            json.gearConstraints.push(jc);\n            break;\n\n        default:\n            console.error(\"Constraint not supported yet: \",c.type);\n            break;\n        }\n    }\n\n    // Serialize bodies\n    for(var i=0; i!==world.bodies.length; i++){\n        var b = world.bodies[i],\n            ss = b.shapes,\n            jsonBody = {\n                id : b.id,\n                mass : b.mass,\n                angle : b.angle,\n                position : v2a(b.position),\n                velocity : v2a(b.velocity),\n                angularVelocity : b.angularVelocity,\n                force : v2a(b.force),\n                motionState : b.motionState,\n                fixedRotation : b.fixedRotation,\n                circleShapes :    [],\n                planeShapes :     [],\n                particleShapes :  [],\n                lineShapes :      [],\n                rectangleShapes : [],\n                convexShapes :    [],\n                capsuleShapes :   [],\n            };\n\n        if(b.concavePath){\n            jsonBody.concavePath = b.concavePath;\n        }\n\n        for(var j=0; j<ss.length; j++){\n            var s = ss[j],\n                jsonShape = {};\n\n            jsonShape.offset = v2a(b.shapeOffsets[j]);\n            jsonShape.angle = b.shapeAngles[j];\n            jsonShape.collisionGroup = s.collisionGroup;\n            jsonShape.collisionMask = s.collisionMask;\n            jsonShape.material = s.material ? s.material.id : null;\n\n            // Check type\n            switch(s.type){\n\n            case Shape.CIRCLE:\n                extend(jsonShape,{ radius : s.radius, });\n                jsonBody.circleShapes.push(jsonShape);\n                break;\n\n            case Shape.PLANE:\n                jsonBody.planeShapes.push(jsonShape);\n                break;\n\n            case Shape.PARTICLE:\n                jsonBody.particleShapes.push(jsonShape);\n                break;\n\n            case Shape.LINE:\n                jsonShape.length = s.length;\n                jsonBody.lineShapes.push(jsonShape);\n                break;\n\n            case Shape.RECTANGLE:\n                extend(jsonShape,{   width : s.width,\n                                     height : s.height });\n                jsonBody.rectangleShapes.push(jsonShape);\n                break;\n\n            case Shape.CONVEX:\n                var verts = [];\n                for(var k=0; k<s.vertices.length; k++){\n                    verts.push(v2a(s.vertices[k]));\n                }\n                extend(jsonShape,{ vertices : verts });\n                jsonBody.convexShapes.push(jsonShape);\n                break;\n\n            case Shape.CAPSULE:\n                extend(jsonShape,{ length : s.length, radius : s.radius });\n                jsonBody.capsuleShapes.push(jsonShape);\n                break;\n\n            default:\n                console.error(\"Shape type not supported yet!\");\n                break;\n            }\n        }\n\n        json.bodies.push(jsonBody);\n    }\n\n    // Serialize contactmaterials\n    for(var i=0; i<world.contactMaterials.length; i++){\n        var cm = world.contactMaterials[i];\n        json.contactMaterials.push(contactMaterialToJSON(cm));\n    }\n\n    // Serialize materials\n    var mats = {};\n    // Get unique materials first\n    for(var i=0; i<world.contactMaterials.length; i++){\n        var cm = world.contactMaterials[i];\n        mats[cm.materialA.id+''] = cm.materialA;\n        mats[cm.materialB.id+''] = cm.materialB;\n    }\n    for(var matId in mats){\n        var m = mats[parseInt(matId)];\n        json.materials.push({\n            id : m.id,\n        });\n    }\n\n    return json;\n};\n\n/**\n * Load a scene from a serialized state in JSON format.\n *\n * @method fromJSON\n * @param  {Object} json\n * @return {Boolean} True on success, else false.\n */\nWorld.prototype.fromJSON = function(json){\n    this.clear();\n\n    if(!json.p2){\n        return false;\n    }\n\n    var w = this;\n\n    // Set gravity\n    vec2.copy(w.gravity, json.gravity);\n\n    w.islandSplit =           json.islandSplit;\n    w.enableIslandSleeping =  json.enableIslandSleeping;\n    w.enableBodySleeping =    json.enableBodySleeping;\n\n    // Set solver\n    switch(json.solver.type){\n    case \"GSSolver\":\n        var js = json.solver,\n            s = new GSSolver();\n        w.solver = s;\n        s.iterations = js.iterations;\n        break;\n    default:\n        throw new Error(\"Solver type not recognized: \"+json.solver.type);\n    }\n\n    // Broadphase\n    switch(json.broadphase.type){\n    case \"NaiveBroadphase\":\n        w.broadphase = new NaiveBroadphase();\n        break;\n\n    case \"SAPBroadphase\":\n        w.broadphase = new SAPBroadphase();\n        break;\n    }\n    w.broadphase.setWorld(w);\n\n\n    var bodies = w.bodies;\n\n    // Load materials\n    var id2material = {};\n    for(var i=0; i!==json.materials.length; i++){\n        var jm = json.materials[i];\n        var m = new Material();\n        id2material[jm.id+\"\"] = m;\n        m.id = jm.id;\n    }\n\n    // Load default material\n    w.defaultMaterial.id = json.defaultContactMaterial.materialA;\n\n    // Load bodies\n    for(var i=0; i!==json.bodies.length; i++){\n        var jb = json.bodies[i];\n\n        // Create body\n        var b = new Body({\n            mass :              jb.mass,\n            position :          jb.position,\n            angle :             jb.angle,\n            velocity :          jb.velocity,\n            angularVelocity :   jb.angularVelocity,\n            force :             jb.force,\n            fixedRotation :     jb.fixedRotation,\n        });\n        b.id = jb.id;\n        b.motionState = jb.motionState;\n\n        // Circle\n        for(var j=0; j<jb.circleShapes.length; j++){\n            var s = jb.circleShapes[j];\n            addShape(b, new Circle(s.radius), s);\n        }\n\n        // Plane\n        for(var j=0; j<jb.planeShapes.length; j++){\n            var s = jb.planeShapes[j];\n            addShape(b, new Plane(), s);\n        }\n\n        // Particle\n        for(var j=0; j<jb.particleShapes.length; j++){\n            var s = jb.particleShapes[j];\n            addShape(b, new Particle(), s);\n        }\n\n        // Line\n        for(var j=0; j<jb.lineShapes.length; j++){\n            var s = jb.lineShapes[j];\n            addShape(b, new Line(s.length), s);\n        }\n\n        // Rectangle\n        for(var j=0; j<jb.rectangleShapes.length; j++){\n            var s = jb.rectangleShapes[j];\n            addShape(b, new Rectangle(s.width,s.height), s);\n        }\n\n        // Convex\n        for(var j=0; j<jb.convexShapes.length; j++){\n            var s = jb.convexShapes[j];\n            addShape(b, new Convex(s.vertices), s);\n        }\n\n        // Capsule\n        for(var j=0; j<jb.capsuleShapes.length; j++){\n            var s = jb.capsuleShapes[j];\n            addShape(b, new Capsule(s.length, s.radius), s);\n        }\n\n        function addShape(body, shape, shapeJSON){\n            shape.collisionMask = shapeJSON.collisionMask;\n            shape.collisionGroup = shapeJSON.collisionGroup;\n            if(shapeJSON.material){\n                shape.material = id2material[shapeJSON.material+\"\"];\n            }\n            body.addShape(shape, shapeJSON.offset, shapeJSON.angle);\n        }\n\n        if(jb.concavePath){\n            b.concavePath = jb.concavePath;\n        }\n\n        w.addBody(b);\n    }\n\n    // Load springs\n    for(var i=0; i<json.springs.length; i++){\n        var js = json.springs[i];\n        var bodyA = bodies[js.bodyA],\n            bodyB = bodies[js.bodyB];\n        if(!bodyA){\n            this.error = \"instance.springs[\"+i+\"] references instance.body[\"+js.bodyA+\"], which does not exist.\";\n            return false;\n        }\n        if(!bodyB){\n            this.error = \"instance.springs[\"+i+\"] references instance.body[\"+js.bodyB+\"], which does not exist.\";\n            return false;\n        }\n        var s = new Spring(bodyA, bodyB, {\n            stiffness : js.stiffness,\n            damping : js.damping,\n            restLength : js.restLength,\n            localAnchorA : js.localAnchorA,\n            localAnchorB : js.localAnchorB,\n        });\n        w.addSpring(s);\n    }\n\n    // Load contact materials\n    for(var i=0; i<json.contactMaterials.length; i++){\n        var jm = json.contactMaterials[i],\n            matA = id2material[jm.materialA+\"\"],\n            matB = id2material[jm.materialB+\"\"];\n\n        if(!matA){\n            this.error = \"Reference to material id \"+jm.materialA+\": material not found\";\n            return false;\n        }\n        if(!matB){\n            this.error = \"Reference to material id \"+jm.materialB+\": material not found\";\n            return false;\n        }\n\n        var cm = new ContactMaterial(matA, matB, {\n            friction :              jm.friction,\n            restitution :           jm.restitution,\n            stiffness :             jm.stiffness,\n            relaxation :            jm.relaxation,\n            frictionStiffness :     jm.frictionStiffness,\n            frictionRelaxation :    jm.frictionRelaxation,\n        });\n        cm.id = jm.id;\n        w.addContactMaterial(cm);\n    }\n\n    // Load default contact material\n    var jm = json.defaultContactMaterial,\n        matA = w.defaultMaterial,\n        matB = w.defaultMaterial;\n    var cm = new ContactMaterial(matA, matB, {\n        friction :              jm.friction,\n        restitution :           jm.restitution,\n        stiffness :             jm.stiffness,\n        relaxation :            jm.relaxation,\n        frictionStiffness :     jm.frictionStiffness,\n        frictionRelaxation :    jm.frictionRelaxation,\n    });\n    cm.id = jm.id;\n    w.defaultContactMaterial = cm;\n\n    // DistanceConstraint\n    for(var i=0; i<json.distanceConstraints.length; i++){\n        var c = json.distanceConstraints[i];\n        w.addConstraint(new DistanceConstraint( bodies[c.bodyA], bodies[c.bodyB], c.distance, {\n            maxForce:c.maxForce,\n            collideConnected:c.collideConnected\n        }));\n    }\n\n    // RevoluteConstraint\n    for(var i=0; i<json.revoluteConstraints.length; i++){\n        var c = json.revoluteConstraints[i];\n        var revolute = new RevoluteConstraint(bodies[c.bodyA], c.pivotA, bodies[c.bodyB], c.pivotB, {\n            maxForce: c.maxForce,\n            collideConnected: c.collideConnected\n        });\n        if(c.motorEnabled){\n            revolute.enableMotor();\n        }\n        revolute.setMotorSpeed(c.motorSpeed);\n        revolute.lowerLimit = c.lowerLimit;\n        revolute.upperLimit = c.upperLimit;\n        revolute.lowerLimitEnabled = c.lowerLimitEnabled;\n        revolute.upperLimitEnabled = c.upperLimitEnabled;\n        w.addConstraint(revolute);\n    }\n\n    // PrismaticConstraint\n    for(var i=0; i<json.prismaticConstraints.length; i++){\n        var c = json.prismaticConstraints[i],\n            p = new PrismaticConstraint(bodies[c.bodyA], bodies[c.bodyB], {\n                maxForce : c.maxForce,\n                localAxisA : c.localAxisA,\n                localAnchorA : c.localAnchorA,\n                localAnchorB : c.localAnchorB,\n                collideConnected: c.collideConnected\n            });\n        p.motorSpeed = c.motorSpeed;\n        w.addConstraint(p);\n    }\n\n    // LockConstraint\n    for(var i=0; i<json.lockConstraints.length; i++){\n        var c = json.lockConstraints[i];\n        w.addConstraint(new LockConstraint(bodies[c.bodyA], bodies[c.bodyB], {\n            maxForce :     c.maxForce,\n            localOffsetB : c.localOffsetB,\n            localAngleB :  c.localAngleB,\n            collideConnected: c.collideConnected\n        }));\n    }\n\n    // GearConstraint\n    for(var i=0; i<json.gearConstraints.length; i++){\n        var c = json.gearConstraints[i];\n        w.addConstraint(new GearConstraint(bodies[c.bodyA], bodies[c.bodyB], {\n            maxForce :      c.maxForce,\n            angle :         c.angle,\n            ratio :         c.ratio,\n            collideConnected: c.collideConnected\n        }));\n    }\n\n    return true;\n};\n\n/**\n * Resets the World, removes all bodies, constraints and springs.\n *\n * @method clear\n */\nWorld.prototype.clear = function(){\n\n    this.time = 0;\n    this.fixedStepTime = 0;\n\n    // Remove all solver equations\n    if(this.solver && this.solver.equations.length){\n        this.solver.removeAllEquations();\n    }\n\n    // Remove all constraints\n    var cs = this.constraints;\n    for(var i=cs.length-1; i>=0; i--){\n        this.removeConstraint(cs[i]);\n    }\n\n    // Remove all bodies\n    var bodies = this.bodies;\n    for(var i=bodies.length-1; i>=0; i--){\n        this.removeBody(bodies[i]);\n    }\n\n    // Remove all springs\n    var springs = this.springs;\n    for(var i=springs.length-1; i>=0; i--){\n        this.removeSpring(springs[i]);\n    }\n\n    // Remove all contact materials\n    var cms = this.contactMaterials;\n    for(var i=cms.length-1; i>=0; i--){\n        this.removeContactMaterial(cms[i]);\n    }\n\n    World.apply(this);\n};\n\n/**\n * Get a copy of this World instance\n * @method clone\n * @return {World}\n */\nWorld.prototype.clone = function(){\n    var world = new World();\n    world.fromJSON(this.toJSON());\n    return world;\n};\n\nvar hitTest_tmp1 = vec2.create(),\n    hitTest_zero = vec2.fromValues(0,0),\n    hitTest_tmp2 = vec2.fromValues(0,0);\n\n/**\n * Test if a world point overlaps bodies\n * @method hitTest\n * @param  {Array}  worldPoint  Point to use for intersection tests\n * @param  {Array}  bodies      A list of objects to check for intersection\n * @param  {Number} precision   Used for matching against particles and lines. Adds some margin to these infinitesimal objects.\n * @return {Array}              Array of bodies that overlap the point\n */\nWorld.prototype.hitTest = function(worldPoint,bodies,precision){\n    precision = precision || 0;\n\n    // Create a dummy particle body with a particle shape to test against the bodies\n    var pb = new Body({ position:worldPoint }),\n        ps = new Particle(),\n        px = worldPoint,\n        pa = 0,\n        x = hitTest_tmp1,\n        zero = hitTest_zero,\n        tmp = hitTest_tmp2;\n    pb.addShape(ps);\n\n    var n = this.narrowphase,\n        result = [];\n\n    // Check bodies\n    for(var i=0, N=bodies.length; i!==N; i++){\n        var b = bodies[i];\n        for(var j=0, NS=b.shapes.length; j!==NS; j++){\n            var s = b.shapes[j],\n                offset = b.shapeOffsets[j] || zero,\n                angle = b.shapeAngles[j] || 0.0;\n\n            // Get shape world position + angle\n            vec2.rotate(x, offset, b.angle);\n            vec2.add(x, x, b.position);\n            var a = angle + b.angle;\n\n            if( (s instanceof Circle    && n.circleParticle  (b,s,x,a,     pb,ps,px,pa, true)) ||\n                (s instanceof Convex    && n.particleConvex  (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Plane     && n.particlePlane   (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Capsule   && n.particleCapsule (pb,ps,px,pa, b,s,x,a,     true)) ||\n                (s instanceof Particle  && vec2.squaredLength(vec2.sub(tmp,x,worldPoint)) < precision*precision)\n                ){\n                result.push(b);\n            }\n        }\n    }\n\n    return result;\n};\n\n/**\n * Sets the Equation parameters for all constraints and contact materials.\n * @method setGlobalEquationParameters\n * @param {object} [parameters]\n * @param {Number} [parameters.relaxation]\n * @param {Number} [parameters.stiffness]\n */\nWorld.prototype.setGlobalEquationParameters = function(parameters){\n    parameters = parameters || {};\n\n    // Set for all constraints\n    for(var i=0; i !== this.constraints.length; i++){\n        var c = this.constraints[i];\n        for(var j=0; j !== c.equations.length; j++){\n            var eq = c.equations[j];\n            if(typeof(parameters.stiffness) !== \"undefined\"){\n                eq.stiffness = parameters.stiffness;\n            }\n            if(typeof(parameters.relaxation) !== \"undefined\"){\n                eq.relaxation = parameters.relaxation;\n            }\n            eq.needsUpdate = true;\n        }\n    }\n\n    // Set for all contact materials\n    for(var i=0; i !== this.contactMaterials.length; i++){\n        var c = this.contactMaterials[i];\n        if(typeof(parameters.stiffness) !== \"undefined\"){\n            c.stiffness = parameters.stiffness;\n            c.frictionStiffness = parameters.stiffness;\n        }\n        if(typeof(parameters.relaxation) !== \"undefined\"){\n            c.relaxation = parameters.relaxation;\n            c.frictionRelaxation = parameters.relaxation;\n        }\n    }\n\n    // Set for default contact material\n    var c = this.defaultContactMaterial;\n    if(typeof(parameters.stiffness) !== \"undefined\"){\n        c.stiffness = parameters.stiffness;\n        c.frictionStiffness = parameters.stiffness;\n    }\n    if(typeof(parameters.relaxation) !== \"undefined\"){\n        c.relaxation = parameters.relaxation;\n        c.frictionRelaxation = parameters.relaxation;\n    }\n};\n\n/**\n * Set the stiffness for all equations and contact materials.\n * @method setGlobalStiffness\n * @param {Number} stiffness\n */\nWorld.prototype.setGlobalStiffness = function(stiffness){\n    this.setGlobalEquationParameters({\n        stiffness: stiffness\n    });\n};\n\n/**\n * Set the relaxation for all equations and contact materials.\n * @method setGlobalRelaxation\n * @param {Number} relaxation\n */\nWorld.prototype.setGlobalRelaxation = function(relaxation){\n    this.setGlobalEquationParameters({\n        relaxation: relaxation\n    });\n};\n\n},{\"../../package.json\":7,\"../collision/Broadphase\":9,\"../collision/NaiveBroadphase\":11,\"../collision/Narrowphase\":12,\"../collision/SAPBroadphase\":13,\"../constraints/Constraint\":14,\"../constraints/DistanceConstraint\":15,\"../constraints/GearConstraint\":16,\"../constraints/LockConstraint\":17,\"../constraints/PrismaticConstraint\":18,\"../constraints/RevoluteConstraint\":19,\"../events/EventEmitter\":26,\"../material/ContactMaterial\":27,\"../material/Material\":28,\"../math/vec2\":30,\"../objects/Body\":31,\"../objects/Spring\":32,\"../shapes/Capsule\":34,\"../shapes/Circle\":35,\"../shapes/Convex\":36,\"../shapes/Line\":38,\"../shapes/Particle\":39,\"../shapes/Plane\":40,\"../shapes/Rectangle\":41,\"../shapes/Shape\":42,\"../solver/GSSolver\":43,\"../solver/Solver\":44,\"../utils/OverlapKeeper\":45,\"../utils/Utils\":47,\"./IslandManager\":49}]},{},[33])\n(33)\n});\n;;\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n//  Add an extra properties to p2 that we need\np2.Body.prototype.parent = null;\np2.Spring.prototype.parent = null;\n\n/**\n* @class Phaser.Physics.P2\n* @classdesc Physics World Constructor\n* @constructor\n* @param {Phaser.Game} game - Reference to the current game instance.\n* @param {object} [config] - Physics configuration object passed in from the game constructor.\n*/\nPhaser.Physics.P2 = function (game, config) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    if (typeof config === 'undefined' || !config.hasOwnProperty('gravity') || !config.hasOwnProperty('broadphase'))\n    {\n        config = { gravity: [0, 0], broadphase: new p2.SAPBroadphase() };\n    }\n\n    /**\n    * @property {p2.World} world - The p2 World in which the simulation is run.\n    * @protected\n    */\n    this.world = new p2.World(config);\n\n    /**\n    * @property {number} frameRate - The frame rate the world will be stepped at. Defaults to 1 / 60, but you can change here. Also see useElapsedTime property.\n    * @default\n    */\n    this.frameRate = 1 / 60;\n\n    /**\n    * @property {boolean} useElapsedTime - If true the frameRate value will be ignored and instead p2 will step with the value of Game.Time.physicsElapsed, which is a delta time value.\n    * @default\n    */\n    this.useElapsedTime = false;\n\n    /**\n    * @property {boolean} paused - The paused state of the P2 World.\n    * @default\n    */\n    this.paused = false;\n\n    /**\n    * @property {array<Phaser.Physics.P2.Material>} materials - A local array of all created Materials.\n    * @protected\n    */\n    this.materials = [];\n\n    /**\n    * @property {Phaser.Physics.P2.InversePointProxy} gravity - The gravity applied to all bodies each step.\n    */\n    this.gravity = new Phaser.Physics.P2.InversePointProxy(this, this.world.gravity);\n\n    /**\n    * @property {object} walls - An object containing the 4 wall bodies that bound the physics world.\n    */\n    this.walls = { left: null, right: null, top: null, bottom: null };\n\n    /**\n    * @property {Phaser.Signal} onBodyAdded - Dispatched when a new Body is added to the World.\n    */\n    this.onBodyAdded = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onBodyRemoved - Dispatched when a Body is removed from the World.\n    */\n    this.onBodyRemoved = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onSpringAdded - Dispatched when a new Spring is added to the World.\n    */\n    this.onSpringAdded = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onSpringRemoved - Dispatched when a Spring is removed from the World.\n    */\n    this.onSpringRemoved = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onConstraintAdded - Dispatched when a new Constraint is added to the World.\n    */\n    this.onConstraintAdded = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onConstraintRemoved - Dispatched when a Constraint is removed from the World.\n    */\n    this.onConstraintRemoved = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onContactMaterialAdded - Dispatched when a new ContactMaterial is added to the World.\n    */\n    this.onContactMaterialAdded = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onContactMaterialRemoved - Dispatched when a ContactMaterial is removed from the World.\n    */\n    this.onContactMaterialRemoved = new Phaser.Signal();\n\n    /**\n    * @property {function} postBroadphaseCallback - A postBroadphase callback.\n    */\n    this.postBroadphaseCallback = null;\n\n    /**\n    * @property {object} callbackContext - The context under which the callbacks are fired.\n    */\n    this.callbackContext = null;\n\n    /**\n    * @property {Phaser.Signal} onBeginContact - Dispatched when a first contact is created between two bodies. This event is fired before the step has been done.\n    */\n    this.onBeginContact = new Phaser.Signal();\n\n    /**\n    * @property {Phaser.Signal} onEndContact - Dispatched when final contact occurs between two bodies. This event is fired before the step has been done.\n    */\n    this.onEndContact = new Phaser.Signal();\n\n    //  Pixel to meter function overrides\n    if (config.hasOwnProperty('mpx') && config.hasOwnProperty('pxm') && config.hasOwnProperty('mpxi') && config.hasOwnProperty('pxmi'))\n    {\n        this.mpx = config.mpx;\n        this.mpxi = config.mpxi;\n        this.pxm = config.pxm;\n        this.pxmi = config.pxmi;\n    }\n\n    //  Hook into the World events\n    this.world.on(\"beginContact\", this.beginContactHandler, this);\n    this.world.on(\"endContact\", this.endContactHandler, this);\n\n    /**\n    * @property {array} collisionGroups - An array containing the collision groups that have been defined in the World.\n    */\n    this.collisionGroups = [];\n\n    /**\n    * @property {Phaser.Physics.P2.CollisionGroup} nothingCollisionGroup - A default collision group.\n    */\n    this.nothingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(1);\n\n    /**\n    * @property {Phaser.Physics.P2.CollisionGroup} boundsCollisionGroup - A default collision group.\n    */\n    this.boundsCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2);\n\n    /**\n    * @property {Phaser.Physics.P2.CollisionGroup} everythingCollisionGroup - A default collision group.\n    */\n    this.everythingCollisionGroup = new Phaser.Physics.P2.CollisionGroup(2147483648);\n\n    /**\n    * @property {array} boundsCollidesWith - An array of the bodies the world bounds collides with.\n    */\n    this.boundsCollidesWith = [];\n\n    /**\n    * @property {array} _toRemove - Internal var used to hold references to bodies to remove from the world on the next step.\n    * @private\n    */\n    this._toRemove = [];\n\n    /**\n    * @property {number} _collisionGroupID - Internal var.\n    * @private\n    */\n    this._collisionGroupID = 2;\n\n    //  By default we want everything colliding with everything\n    this.setBoundsToWorld(true, true, true, true, false);\n\n};\n\nPhaser.Physics.P2.prototype = {\n\n    /**\n    * This will add a P2 Physics body into the removal list for the next step.\n    *\n    * @method Phaser.Physics.P2#removeBodyNextStep\n    * @param {Phaser.Physics.P2.Body} body - The body to remove at the start of the next step.\n    */\n    removeBodyNextStep: function (body) {\n\n        this._toRemove.push(body);\n\n    },\n\n    /**\n    * Called at the start of the core update loop. Purges flagged bodies from the world.\n    *\n    * @method Phaser.Physics.P2#preUpdate\n    */\n    preUpdate: function () {\n\n        var i = this._toRemove.length;\n\n        while (i--)\n        {\n            this.removeBody(this._toRemove[i]);\n        }\n\n        this._toRemove.length = 0;\n\n    },\n\n    /**\n    * This will create a P2 Physics body on the given game object or array of game objects.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the object is destroyed.\n    *\n    * @method Phaser.Physics.P2#enable\n    * @param {object|array|Phaser.Group} object - The game object to create the physics body on. Can also be an array or Group of objects, a body will be created on every child that has a `body` property.\n    * @param {boolean} [debug=false] - Create a debug object to go with this body?\n    * @param {boolean} [children=true] - Should a body be created on all children of this object? If true it will recurse down the display list as far as it can go.\n    */\n    enable: function (object, debug, children) {\n\n        if (typeof debug === 'undefined') { debug = false; }\n        if (typeof children === 'undefined') { children = true; }\n\n        var i = 1;\n\n        if (Array.isArray(object))\n        {\n            i = object.length;\n\n            while (i--)\n            {\n                if (object[i] instanceof Phaser.Group)\n                {\n                    //  If it's a Group then we do it on the children regardless\n                    this.enable(object[i].children, debug, children);\n                }\n                else\n                {\n                    this.enableBody(object[i], debug);\n\n                    if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0)\n                    {\n                        this.enable(object[i], debug, true);\n                    }\n                }\n            }\n        }\n        else\n        {\n            if (object instanceof Phaser.Group)\n            {\n                //  If it's a Group then we do it on the children regardless\n                this.enable(object.children, debug, children);\n            }\n            else\n            {\n                this.enableBody(object, debug);\n\n                if (children && object.hasOwnProperty('children') && object.children.length > 0)\n                {\n                    this.enable(object.children, debug, true);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Creates a P2 Physics body on the given game object.\n    * A game object can only have 1 physics body active at any one time, and it can't be changed until the body is nulled.\n    *\n    * @method Phaser.Physics.P2#enableBody\n    * @param {object} object - The game object to create the physics body on. A body will only be created if this object has a null `body` property.\n    * @param {boolean} debug - Create a debug object to go with this body?\n    */\n    enableBody: function (object, debug) {\n\n        if (object.hasOwnProperty('body') && object.body === null)\n        {\n            object.body = new Phaser.Physics.P2.Body(this.game, object, object.x, object.y, 1);\n            object.body.debug = debug;\n            object.anchor.set(0.5);\n        }\n\n    },\n\n    /**\n    * Impact event handling is disabled by default. Enable it before any impact events will be dispatched.\n    * In a busy world hundreds of impact events can be generated every step, so only enable this if you cannot do what you need via beginContact or collision masks.\n    *\n    * @method Phaser.Physics.P2#setImpactEvents\n    * @param {boolean} state - Set to true to enable impact events, or false to disable.\n    */\n    setImpactEvents: function (state) {\n\n        if (state)\n        {\n            this.world.on(\"impact\", this.impactHandler, this);\n        }\n        else\n        {\n            this.world.off(\"impact\", this.impactHandler, this);\n        }\n\n    },\n\n    /**\n    * Sets a callback to be fired after the Broadphase has collected collision pairs in the world.\n    * Just because a pair exists it doesn't mean they *will* collide, just that they potentially could do.\n    * If your calback returns `false` the pair will be removed from the narrowphase. This will stop them testing for collision this step.\n    * Returning `true` from the callback will ensure they are checked in the narrowphase.\n    *\n    * @method Phaser.Physics.P2#setPostBroadphaseCallback\n    * @param {function} callback - The callback that will receive the postBroadphase event data. It must return a boolean. Set to null to disable an existing callback.\n    * @param {object} context - The context under which the callback will be fired.\n    */\n    setPostBroadphaseCallback: function (callback, context) {\n\n        this.postBroadphaseCallback = callback;\n        this.callbackContext = context;\n\n        if (callback !== null)\n        {\n            this.world.on(\"postBroadphase\", this.postBroadphaseHandler, this);\n        }\n        else\n        {\n            this.world.off(\"postBroadphase\", this.postBroadphaseHandler, this);\n        }\n\n    },\n\n    /**\n    * Internal handler for the postBroadphase event.\n    *\n    * @method Phaser.Physics.P2#postBroadphaseHandler\n    * @private\n    * @param {object} event - The event data.\n    */\n    postBroadphaseHandler: function (event) {\n\n        if (this.postBroadphaseCallback)\n        {\n            var i = event.pairs.length;\n\n            while (i -= 2)\n            {\n                if (event.pairs[i].parent && event.pairs[i+1].parent && !this.postBroadphaseCallback.call(this.callbackContext, event.pairs[i].parent, event.pairs[i+1].parent))\n                {\n                    event.pairs.splice(i, 2);\n                }\n            }\n        }\n\n    },\n\n    /**\n    * Handles a p2 impact event.\n    *\n    * @method Phaser.Physics.P2#impactHandler\n    * @private\n    * @param {object} event - The event data.\n    */\n    impactHandler: function (event) {\n\n        if (event.bodyA.parent && event.bodyB.parent)\n        {\n            //  Body vs. Body callbacks\n            var a = event.bodyA.parent;\n            var b = event.bodyB.parent;\n\n            if (a._bodyCallbacks[event.bodyB.id])\n            {\n                a._bodyCallbacks[event.bodyB.id].call(a._bodyCallbackContext[event.bodyB.id], a, b, event.shapeA, event.shapeB);\n            }\n\n            if (b._bodyCallbacks[event.bodyA.id])\n            {\n                b._bodyCallbacks[event.bodyA.id].call(b._bodyCallbackContext[event.bodyA.id], b, a, event.shapeB, event.shapeA);\n            }\n\n            //  Body vs. Group callbacks\n            if (a._groupCallbacks[event.shapeB.collisionGroup])\n            {\n                a._groupCallbacks[event.shapeB.collisionGroup].call(a._groupCallbackContext[event.shapeB.collisionGroup], a, b, event.shapeA, event.shapeB);\n            }\n\n            if (b._groupCallbacks[event.shapeA.collisionGroup])\n            {\n                b._groupCallbacks[event.shapeA.collisionGroup].call(b._groupCallbackContext[event.shapeA.collisionGroup], b, a, event.shapeB, event.shapeA);\n            }\n        }\n\n    },\n\n    /**\n    * Handles a p2 begin contact event.\n    *\n    * @method Phaser.Physics.P2#beginContactHandler\n    * @param {object} event - The event data.\n    */\n    beginContactHandler: function (event) {\n\n        this.onBeginContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB, event.contactEquations);\n\n        if (event.bodyA.parent)\n        {\n            event.bodyA.parent.onBeginContact.dispatch(event.bodyB.parent, event.shapeA, event.shapeB, event.contactEquations);\n        }\n\n        if (event.bodyB.parent)\n        {\n            event.bodyB.parent.onBeginContact.dispatch(event.bodyA.parent, event.shapeB, event.shapeA, event.contactEquations);\n        }\n\n    },\n\n    /**\n    * Handles a p2 end contact event.\n    *\n    * @method Phaser.Physics.P2#endContactHandler\n    * @param {object} event - The event data.\n    */\n    endContactHandler: function (event) {\n\n        this.onEndContact.dispatch(event.bodyA, event.bodyB, event.shapeA, event.shapeB);\n\n        if (event.bodyA.parent)\n        {\n            event.bodyA.parent.onEndContact.dispatch(event.bodyB.parent, event.shapeA, event.shapeB);\n        }\n\n        if (event.bodyB.parent)\n        {\n            event.bodyB.parent.onEndContact.dispatch(event.bodyA.parent, event.shapeB, event.shapeA);\n        }\n\n    },\n\n    /**\n    * Sets the bounds of the Physics world to match the Game.World dimensions.\n    * You can optionally set which 'walls' to create: left, right, top or bottom.\n    *\n    * @method Phaser.Physics#setBoundsToWorld\n    * @param {boolean} [left=true] - If true will create the left bounds wall.\n    * @param {boolean} [right=true] - If true will create the right bounds wall.\n    * @param {boolean} [top=true] - If true will create the top bounds wall.\n    * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\n    * @param {boolean} [setCollisionGroup=true] - If true the Bounds will be set to use its own Collision Group.\n    */\n    setBoundsToWorld: function (left, right, top, bottom, setCollisionGroup) {\n\n        this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, left, right, top, bottom, setCollisionGroup);\n\n    },\n\n    /**\n    * Sets the given material against the 4 bounds of this World.\n    *\n    * @method Phaser.Physics#setWorldMaterial\n    * @param {Phaser.Physics.P2.Material} material - The material to set.\n    * @param {boolean} [left=true] - If true will set the material on the left bounds wall.\n    * @param {boolean} [right=true] - If true will set the material on the right bounds wall.\n    * @param {boolean} [top=true] - If true will set the material on the top bounds wall.\n    * @param {boolean} [bottom=true] - If true will set the material on the bottom bounds wall.\n    */\n    setWorldMaterial: function (material, left, right, top, bottom) {\n\n        if (typeof left === 'undefined') { left = true; }\n        if (typeof right === 'undefined') { right = true; }\n        if (typeof top === 'undefined') { top = true; }\n        if (typeof bottom === 'undefined') { bottom = true; }\n\n        if (left && this.walls.left)\n        {\n            this.walls.left.shapes[0].material = material;\n        }\n\n        if (right && this.walls.right)\n        {\n            this.walls.right.shapes[0].material = material;\n        }\n\n        if (top && this.walls.top)\n        {\n            this.walls.top.shapes[0].material = material;\n        }\n\n        if (bottom && this.walls.bottom)\n        {\n            this.walls.bottom.shapes[0].material = material;\n        }\n\n    },\n\n    /**\n    * By default the World will be set to collide everything with everything. The bounds of the world is a Body with 4 shapes, one for each face.\n    * If you start to use your own collision groups then your objects will no longer collide with the bounds.\n    * To fix this you need to adjust the bounds to use its own collision group first BEFORE changing your Sprites collision group.\n    *\n    * @method Phaser.Physics.P2#updateBoundsCollisionGroup\n    * @param {boolean} [setCollisionGroup=true] - If true the Bounds will be set to use its own Collision Group.\n    */\n    updateBoundsCollisionGroup: function (setCollisionGroup) {\n\n        var mask = this.everythingCollisionGroup.mask;\n\n        if (typeof setCollisionGroup === 'undefined') { mask = this.boundsCollisionGroup.mask; }\n\n        if (this.walls.left)\n        {\n            this.walls.left.shapes[0].collisionGroup = mask;\n        }\n\n        if (this.walls.right)\n        {\n            this.walls.right.shapes[0].collisionGroup = mask;\n        }\n\n        if (this.walls.top)\n        {\n            this.walls.top.shapes[0].collisionGroup = mask;\n        }\n\n        if (this.walls.bottom)\n        {\n            this.walls.bottom.shapes[0].collisionGroup = mask;\n        }\n\n    },\n\n    /**\n    * Sets the bounds of the Physics world to match the given world pixel dimensions.\n    * You can optionally set which 'walls' to create: left, right, top or bottom.\n    *\n    * @method Phaser.Physics.P2#setBounds\n    * @param {number} x - The x coordinate of the top-left corner of the bounds.\n    * @param {number} y - The y coordinate of the top-left corner of the bounds.\n    * @param {number} width - The width of the bounds.\n    * @param {number} height - The height of the bounds.\n    * @param {boolean} [left=true] - If true will create the left bounds wall.\n    * @param {boolean} [right=true] - If true will create the right bounds wall.\n    * @param {boolean} [top=true] - If true will create the top bounds wall.\n    * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\n    * @param {boolean} [setCollisionGroup=true] - If true the Bounds will be set to use its own Collision Group.\n    */\n    setBounds: function (x, y, width, height, left, right, top, bottom, setCollisionGroup) {\n\n        if (typeof left === 'undefined') { left = true; }\n        if (typeof right === 'undefined') { right = true; }\n        if (typeof top === 'undefined') { top = true; }\n        if (typeof bottom === 'undefined') { bottom = true; }\n        if (typeof setCollisionGroup === 'undefined') { setCollisionGroup = true; }\n\n        if (this.walls.left)\n        {\n            this.world.removeBody(this.walls.left);\n        }\n\n        if (this.walls.right)\n        {\n            this.world.removeBody(this.walls.right);\n        }\n\n        if (this.walls.top)\n        {\n            this.world.removeBody(this.walls.top);\n        }\n\n        if (this.walls.bottom)\n        {\n            this.world.removeBody(this.walls.bottom);\n        }\n\n        if (left)\n        {\n            this.walls.left = new p2.Body({ mass: 0, position: [ this.pxmi(x), this.pxmi(y) ], angle: 1.5707963267948966 });\n            this.walls.left.addShape(new p2.Plane());\n\n            if (setCollisionGroup)\n            {\n                this.walls.left.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;\n            }\n\n            this.world.addBody(this.walls.left);\n        }\n\n        if (right)\n        {\n            this.walls.right = new p2.Body({ mass: 0, position: [ this.pxmi(x + width), this.pxmi(y) ], angle: -1.5707963267948966 });\n            this.walls.right.addShape(new p2.Plane());\n\n            if (setCollisionGroup)\n            {\n                this.walls.right.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;\n            }\n\n            this.world.addBody(this.walls.right);\n        }\n\n        if (top)\n        {\n            this.walls.top = new p2.Body({ mass: 0, position: [ this.pxmi(x), this.pxmi(y) ], angle: -3.141592653589793 });\n            this.walls.top.addShape(new p2.Plane());\n\n            if (setCollisionGroup)\n            {\n                this.walls.top.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;\n            }\n\n            this.world.addBody(this.walls.top);\n        }\n\n        if (bottom)\n        {\n            this.walls.bottom = new p2.Body({ mass: 0, position: [ this.pxmi(x), this.pxmi(height) ] });\n            this.walls.bottom.addShape(new p2.Plane());\n\n            if (setCollisionGroup)\n            {\n                this.walls.bottom.shapes[0].collisionGroup = this.boundsCollisionGroup.mask;\n            }\n\n            this.world.addBody(this.walls.bottom);\n        }\n\n    },\n\n    /**\n    * Pauses the P2 World independent of the game pause state.\n    *\n    * @method Phaser.Physics.P2#pause\n    */\n    pause: function() {\n\n        this.paused = true;\n\n    },\n    \n    /**\n    * Resumes a paused P2 World.\n    *\n    * @method Phaser.Physics.P2#resume\n    */\n    resume: function() {\n\n        this.paused = false;\n\n    },\n\n    /**\n    * Internal P2 update loop.\n    *\n    * @method Phaser.Physics.P2#update\n    */\n    update: function () {\n\n        // Do nothing when the pysics engine was paused before\n        if (this.paused)\n        {\n            return;\n        }\n\n        if (this.useElapsedTime)\n        {\n            this.world.step(this.game.time.physicsElapsed);\n        }\n        else\n        {\n            this.world.step(this.frameRate);\n        }\n\n    },\n\n    /**\n    * Clears all bodies from the simulation, resets callbacks and resets the collision bitmask.\n    *\n    * @method Phaser.Physics.P2#clear\n    */\n    clear: function () {\n\n        this.world.clear();\n\n        this.world.off(\"beginContact\", this.beginContactHandler, this);\n        this.world.off(\"endContact\", this.endContactHandler, this);\n\n        this.postBroadphaseCallback = null;\n        this.callbackContext = null;\n        this.impactCallback = null;\n\n        this.collisionGroups = [];\n        this._toRemove = [];\n        this._collisionGroupID = 2;\n        this.boundsCollidesWith = [];\n\n    },\n\n    /**\n    * Clears all bodies from the simulation and unlinks World from Game. Should only be called on game shutdown. Call `clear` on a State change.\n    *\n    * @method Phaser.Physics.P2#destroy\n    */\n    destroy: function () {\n\n        this.clear();\n\n        this.game = null;\n\n    },\n\n    /**\n    * Add a body to the world.\n    *\n    * @method Phaser.Physics.P2#addBody\n    * @param {Phaser.Physics.P2.Body} body - The Body to add to the World.\n    * @return {boolean} True if the Body was added successfully, otherwise false.\n    */\n    addBody: function (body) {\n\n        if (body.data.world)\n        {\n            return false;\n        }\n        else\n        {\n            this.world.addBody(body.data);\n\n            this.onBodyAdded.dispatch(body);\n\n            return true;\n        }\n\n    },\n\n    /**\n    * Removes a body from the world. This will silently fail if the body wasn't part of the world to begin with.\n    *\n    * @method Phaser.Physics.P2#removeBody\n    * @param {Phaser.Physics.P2.Body} body - The Body to remove from the World.\n    * @return {Phaser.Physics.P2.Body} The Body that was removed.\n    */\n    removeBody: function (body) {\n\n        if (body.data.world == this.world)\n        {\n            this.world.removeBody(body.data);\n\n            this.onBodyRemoved.dispatch(body);\n        }\n\n        return body;\n\n    },\n\n    /**\n    * Adds a Spring to the world.\n    *\n    * @method Phaser.Physics.P2#addSpring\n    * @param {Phaser.Physics.P2.Spring} spring - The Spring to add to the World.\n    * @return {Phaser.Physics.P2.Spring} The Spring that was added.\n    */\n    addSpring: function (spring) {\n\n        this.world.addSpring(spring);\n\n        this.onSpringAdded.dispatch(spring);\n\n        return spring;\n\n    },\n\n    /**\n    * Removes a Spring from the world.\n    *\n    * @method Phaser.Physics.P2#removeSpring\n    * @param {Phaser.Physics.P2.Spring} spring - The Spring to remove from the World.\n    * @return {Phaser.Physics.P2.Spring} The Spring that was removed.\n    */\n    removeSpring: function (spring) {\n\n        this.world.removeSpring(spring);\n\n        this.onSpringRemoved.dispatch(spring);\n\n        return spring;\n\n    },\n\n    /**\n    * Creates a constraint that tries to keep the distance between two bodies constant.\n    *\n    * @method Phaser.Physics.P2#createDistanceConstraint\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.\n    * @param {number} distance - The distance to keep between the bodies.\n    * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.\n    * @return {Phaser.Physics.P2.DistanceConstraint} The constraint\n    */\n    createDistanceConstraint: function (bodyA, bodyB, distance, maxForce) {\n\n        bodyA = this.getBody(bodyA);\n        bodyB = this.getBody(bodyB);\n\n        if (!bodyA || !bodyB)\n        {\n            console.warn('Cannot create Constraint, invalid body objects given');\n        }\n        else\n        {\n            return this.addConstraint(new Phaser.Physics.P2.DistanceConstraint(this, bodyA, bodyB, distance, maxForce));\n        }\n\n    },\n\n    /**\n    * Creates a constraint that tries to keep the distance between two bodies constant.\n    *\n    * @method Phaser.Physics.P2#createGearConstraint\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.\n    * @param {number} [angle=0] - The relative angle\n    * @param {number} [ratio=1] - The gear ratio.\n    * @return {Phaser.Physics.P2.GearConstraint} The constraint\n    */\n    createGearConstraint: function (bodyA, bodyB, angle, ratio) {\n\n        bodyA = this.getBody(bodyA);\n        bodyB = this.getBody(bodyB);\n\n        if (!bodyA || !bodyB)\n        {\n            console.warn('Cannot create Constraint, invalid body objects given');\n        }\n        else\n        {\n            return this.addConstraint(new Phaser.Physics.P2.GearConstraint(this, bodyA, bodyB, angle, ratio));\n        }\n\n    },\n\n    /**\n    * Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n    * The pivot points are given in world (pixel) coordinates.\n    *\n    * @method Phaser.Physics.P2#createRevoluteConstraint\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.\n    * @param {Array} pivotA - The point relative to the center of mass of bodyA which bodyA is constrained to. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.\n    * @param {Array} pivotB - The point relative to the center of mass of bodyB which bodyB is constrained to. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n    * @param {number} [maxForce=0] - The maximum force that should be applied to constrain the bodies.\n    * @return {Phaser.Physics.P2.RevoluteConstraint} The constraint\n    */\n    createRevoluteConstraint: function (bodyA, pivotA, bodyB, pivotB, maxForce) {\n\n        bodyA = this.getBody(bodyA);\n        bodyB = this.getBody(bodyB);\n\n        if (!bodyA || !bodyB)\n        {\n            console.warn('Cannot create Constraint, invalid body objects given');\n        }\n        else\n        {\n            return this.addConstraint(new Phaser.Physics.P2.RevoluteConstraint(this, bodyA, pivotA, bodyB, pivotB, maxForce));\n        }\n\n    },\n\n    /**\n    * Locks the relative position between two bodies.\n    *\n    * @method Phaser.Physics.P2#createLockConstraint\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.\n    * @param {Array} [offset] - The offset of bodyB in bodyA's frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n    * @param {number} [angle=0] - The angle of bodyB in bodyA's frame.\n    * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.\n    * @return {Phaser.Physics.P2.LockConstraint} The constraint\n    */\n    createLockConstraint: function (bodyA, bodyB, offset, angle, maxForce) {\n\n        bodyA = this.getBody(bodyA);\n        bodyB = this.getBody(bodyB);\n\n        if (!bodyA || !bodyB)\n        {\n            console.warn('Cannot create Constraint, invalid body objects given');\n        }\n        else\n        {\n            return this.addConstraint(new Phaser.Physics.P2.LockConstraint(this, bodyA, bodyB, offset, angle, maxForce));\n        }\n\n    },\n\n    /**\n    * Constraint that only allows bodies to move along a line, relative to each other.\n    * See http://www.iforce2d.net/b2dtut/joints-prismatic\n    *\n    * @method Phaser.Physics.P2#createPrismaticConstraint\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.\n    * @param {boolean} [lockRotation=true] - If set to false, bodyB will be free to rotate around its anchor point.\n    * @param {Array} [anchorA] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n    * @param {Array} [anchorB] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n    * @param {Array} [axis] - An axis, defined in body A frame, that body B's anchor point may slide along. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n    * @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.\n    * @return {Phaser.Physics.P2.PrismaticConstraint} The constraint\n    */\n    createPrismaticConstraint: function (bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {\n\n        bodyA = this.getBody(bodyA);\n        bodyB = this.getBody(bodyB);\n\n        if (!bodyA || !bodyB)\n        {\n            console.warn('Cannot create Constraint, invalid body objects given');\n        }\n        else\n        {\n            return this.addConstraint(new Phaser.Physics.P2.PrismaticConstraint(this, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce));\n        }\n\n    },\n\n    /**\n    * Adds a Constraint to the world.\n    *\n    * @method Phaser.Physics.P2#addConstraint\n    * @param {Phaser.Physics.P2.Constraint} constraint - The Constraint to add to the World.\n    * @return {Phaser.Physics.P2.Constraint} The Constraint that was added.\n    */\n    addConstraint: function (constraint) {\n\n        this.world.addConstraint(constraint);\n\n        this.onConstraintAdded.dispatch(constraint);\n\n        return constraint;\n\n    },\n\n    /**\n    * Removes a Constraint from the world.\n    *\n    * @method Phaser.Physics.P2#removeConstraint\n    * @param {Phaser.Physics.P2.Constraint} constraint - The Constraint to be removed from the World.\n    * @return {Phaser.Physics.P2.Constraint} The Constraint that was removed.\n    */\n    removeConstraint: function (constraint) {\n\n        this.world.removeConstraint(constraint);\n\n        this.onConstraintRemoved.dispatch(constraint);\n\n        return constraint;\n\n    },\n\n    /**\n    * Adds a Contact Material to the world.\n    *\n    * @method Phaser.Physics.P2#addContactMaterial\n    * @param {Phaser.Physics.P2.ContactMaterial} material - The Contact Material to be added to the World.\n    * @return {Phaser.Physics.P2.ContactMaterial} The Contact Material that was added.\n    */\n    addContactMaterial: function (material) {\n\n        this.world.addContactMaterial(material);\n\n        this.onContactMaterialAdded.dispatch(material);\n\n        return material;\n\n    },\n\n    /**\n    * Removes a Contact Material from the world.\n    *\n    * @method Phaser.Physics.P2#removeContactMaterial\n    * @param {Phaser.Physics.P2.ContactMaterial} material - The Contact Material to be removed from the World.\n    * @return {Phaser.Physics.P2.ContactMaterial} The Contact Material that was removed.\n    */\n    removeContactMaterial: function (material) {\n\n        this.world.removeContactMaterial(material);\n\n        this.onContactMaterialRemoved.dispatch(material);\n\n        return material;\n\n    },\n\n    /**\n    * Gets a Contact Material based on the two given Materials.\n    *\n    * @method Phaser.Physics.P2#getContactMaterial\n    * @param {Phaser.Physics.P2.Material} materialA - The first Material to search for.\n    * @param {Phaser.Physics.P2.Material} materialB - The second Material to search for.\n    * @return {Phaser.Physics.P2.ContactMaterial|boolean} The Contact Material or false if none was found matching the Materials given.\n    */\n    getContactMaterial: function (materialA, materialB) {\n\n        return this.world.getContactMaterial(materialA, materialB);\n\n    },\n\n    /**\n    * Sets the given Material against all Shapes owned by all the Bodies in the given array.\n    *\n    * @method Phaser.Physics.P2#setMaterial\n    * @param {Phaser.Physics.P2.Material} material - The Material to be applied to the given Bodies.\n    * @param {array<Phaser.Physics.P2.Body>} bodies - An Array of Body objects that the given Material will be set on.\n    */\n    setMaterial: function (material, bodies) {\n\n        var i = bodies.length;\n\n        while (i--)\n        {\n            bodies[i].setMaterial(material);\n        }\n\n    },\n\n    /**\n    * Creates a Material. Materials are applied to Shapes owned by a Body and can be set with Body.setMaterial().\n    * Materials are a way to control what happens when Shapes collide. Combine unique Materials together to create Contact Materials.\n    * Contact Materials have properties such as friction and restitution that allow for fine-grained collision control between different Materials.\n    *\n    * @method Phaser.Physics.P2#createMaterial\n    * @param {string} [name] - Optional name of the Material. Each Material has a unique ID but string names are handy for debugging.\n    * @param {Phaser.Physics.P2.Body} [body] - Optional Body. If given it will assign the newly created Material to the Body shapes.\n    * @return {Phaser.Physics.P2.Material} The Material that was created. This is also stored in Phaser.Physics.P2.materials.\n    */\n    createMaterial: function (name, body) {\n\n        name = name || '';\n\n        var material = new Phaser.Physics.P2.Material(name);\n\n        this.materials.push(material);\n\n        if (typeof body !== 'undefined')\n        {\n            body.setMaterial(material);\n        }\n\n        return material;\n\n    },\n\n    /**\n    * Creates a Contact Material from the two given Materials. You can then edit the properties of the Contact Material directly.\n    *\n    * @method Phaser.Physics.P2#createContactMaterial\n    * @param {Phaser.Physics.P2.Material} [materialA] - The first Material to create the ContactMaterial from. If undefined it will create a new Material object first.\n    * @param {Phaser.Physics.P2.Material} [materialB] - The second Material to create the ContactMaterial from. If undefined it will create a new Material object first.\n    * @param {object} [options] - Material options object.\n    * @return {Phaser.Physics.P2.ContactMaterial} The Contact Material that was created.\n    */\n    createContactMaterial: function (materialA, materialB, options) {\n\n        if (typeof materialA === 'undefined') { materialA = this.createMaterial(); }\n        if (typeof materialB === 'undefined') { materialB = this.createMaterial(); }\n\n        var contact = new Phaser.Physics.P2.ContactMaterial(materialA, materialB, options);\n\n        return this.addContactMaterial(contact);\n\n    },\n\n    /**\n    * Populates and returns an array with references to of all current Bodies in the world.\n    *\n    * @method Phaser.Physics.P2#getBodies\n    * @return {array<Phaser.Physics.P2.Body>} An array containing all current Bodies in the world.\n    */\n    getBodies: function () {\n\n        var output = [];\n        var i = this.world.bodies.length;\n\n        while (i--)\n        {\n            output.push(this.world.bodies[i].parent);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Checks the given object to see if it has a p2.Body and if so returns it.\n    *\n    * @method Phaser.Physics.P2#getBody\n    * @param {object} object - The object to check for a p2.Body on.\n    * @return {p2.Body} The p2.Body, or null if not found.\n    */\n    getBody: function (object) {\n\n        if (object instanceof p2.Body)\n        {\n            //  Native p2 body\n            return object;\n        }\n        else if (object instanceof Phaser.Physics.P2.Body)\n        {\n            //  Phaser P2 Body\n            return object.data;\n        }\n        else if (object['body'] && object['body'].type === Phaser.Physics.P2JS)\n        {\n            //  Sprite, TileSprite, etc\n            return object.body.data;\n        }\n\n        return null;\n\n    },\n\n    /**\n    * Populates and returns an array of all current Springs in the world.\n    *\n    * @method Phaser.Physics.P2#getSprings\n    * @return {array<Phaser.Physics.P2.Spring>} An array containing all current Springs in the world.\n    */\n    getSprings: function () {\n\n        var output = [];\n        var i = this.world.springs.length;\n\n        while (i--)\n        {\n            output.push(this.world.springs[i].parent);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Populates and returns an array of all current Constraints in the world.\n    *\n    * @method Phaser.Physics.P2#getConstraints\n    * @return {array<Phaser.Physics.P2.Constraint>} An array containing all current Constraints in the world.\n    */\n    getConstraints: function () {\n\n        var output = [];\n        var i = this.world.constraints.length;\n\n        while (i--)\n        {\n            output.push(this.world.constraints[i].parent);\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Test if a world point overlaps bodies. You will get an array of actual P2 bodies back. You can find out which Sprite a Body belongs to\n    * (if any) by checking the Body.parent.sprite property. Body.parent is a Phaser.Physics.P2.Body property.\n    *\n    * @method Phaser.Physics.P2#hitTest\n    * @param {Phaser.Point} worldPoint - Point to use for intersection tests. The points values must be in world (pixel) coordinates.\n    * @param {Array<Phaser.Physics.P2.Body|Phaser.Sprite|p2.Body>} [bodies] - A list of objects to check for intersection. If not given it will check Phaser.Physics.P2.world.bodies (i.e. all world bodies)\n    * @param {number} [precision=5] - Used for matching against particles and lines. Adds some margin to these infinitesimal objects.\n    * @param {boolean} [filterStatic=false] - If true all Static objects will be removed from the results array.\n    * @return {Array} Array of bodies that overlap the point.\n    */\n    hitTest: function (worldPoint, bodies, precision, filterStatic) {\n\n        if (typeof bodies === 'undefined') { bodies = this.world.bodies; }\n        if (typeof precision === 'undefined') { precision = 5; }\n        if (typeof filterStatic === 'undefined') { filterStatic = false; }\n\n        var physicsPosition = [ this.pxmi(worldPoint.x), this.pxmi(worldPoint.y) ];\n\n        var query = [];\n        var i = bodies.length;\n\n        while (i--)\n        {\n            if (bodies[i] instanceof Phaser.Physics.P2.Body && !(filterStatic && bodies[i].data.motionState === p2.Body.STATIC))\n            {\n                query.push(bodies[i].data);\n            }\n            else if (bodies[i] instanceof p2.Body && bodies[i].parent && !(filterStatic && bodies[i].motionState === p2.Body.STATIC))\n            {\n                query.push(bodies[i]);\n            }\n            else if (bodies[i] instanceof Phaser.Sprite && bodies[i].hasOwnProperty('body') && !(filterStatic && bodies[i].body.data.motionState === p2.Body.STATIC))\n            {\n                query.push(bodies[i].body.data);\n            }\n        }\n\n        return this.world.hitTest(physicsPosition, query, precision);\n\n    },\n\n    /**\n    * Converts the current world into a JSON object.\n    *\n    * @method Phaser.Physics.P2#toJSON\n    * @return {object} A JSON representation of the world.\n    */\n    toJSON: function () {\n\n        return this.world.toJSON();\n\n    },\n\n    /**\n    * Creates a new Collision Group and optionally applies it to the given object.\n    * Collision Groups are handled using bitmasks, therefore you have a fixed limit you can create before you need to re-use older groups.\n    *\n    * @method Phaser.Physics.P2#createCollisionGroup\n    * @param {Phaser.Group|Phaser.Sprite} [object] - An optional Sprite or Group to apply the Collision Group to. If a Group is given it will be applied to all top-level children.\n    * @protected\n    */\n    createCollisionGroup: function (object) {\n\n        var bitmask = Math.pow(2, this._collisionGroupID);\n\n        if (this.walls.left)\n        {\n            this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | bitmask;\n        }\n\n        if (this.walls.right)\n        {\n            this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | bitmask;\n        }\n\n        if (this.walls.top)\n        {\n            this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | bitmask;\n        }\n\n        if (this.walls.bottom)\n        {\n            this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | bitmask;\n        }\n\n        this._collisionGroupID++;\n\n        var group = new Phaser.Physics.P2.CollisionGroup(bitmask);\n\n        this.collisionGroups.push(group);\n\n        if (object)\n        {\n            this.setCollisionGroup(object, group);\n        }\n\n        return group;\n\n    },\n\n    /**\n    * Sets the given CollisionGroup to be the collision group for all shapes in this Body, unless a shape is specified.\n    * Note that this resets the collisionMask and any previously set groups. See Body.collides() for appending them.\n    *\n    * @method Phaser.Physics.P2y#setCollisionGroup\n    * @param {Phaser.Group|Phaser.Sprite} object - A Sprite or Group to apply the Collision Group to. If a Group is given it will be applied to all top-level children.\n    * @param {Phaser.Physics.CollisionGroup} group - The Collision Group that this Bodies shapes will use.\n    */\n    setCollisionGroup: function (object, group) {\n\n        if (object instanceof Phaser.Group)\n        {\n            for (var i = 0; i < object.total; i++)\n            {\n                if (object.children[i]['body'] && object.children[i]['body'].type === Phaser.Physics.P2JS)\n                {\n                    object.children[i].body.setCollisionGroup(group);\n                }\n            }\n        }\n        else\n        {\n            object.body.setCollisionGroup(group);\n        }\n\n    },\n\n    /**\n    * Creates a spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.\n    *\n    * @method Phaser.Physics.P2#createSpring\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyA - First connected body.\n    * @param {Phaser.Sprite|Phaser.Physics.P2.Body|p2.Body} bodyB - Second connected body.\n    * @param {number} [restLength=1] - Rest length of the spring. A number > 0.\n    * @param {number} [stiffness=100] - Stiffness of the spring. A number >= 0.\n    * @param {number} [damping=1] - Damping of the spring. A number >= 0.\n    * @param {number} [restLength=1] - Rest length of the spring. A number > 0.\n    * @param {number} [stiffness=100] - Stiffness of the spring. A number >= 0.\n    * @param {number} [damping=1] - Damping of the spring. A number >= 0.\n    * @param {Array} [worldA] - Where to hook the spring to body A in world coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].\n    * @param {Array} [worldB] - Where to hook the spring to body B in world coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].\n    * @param {Array} [localA] - Where to hook the spring to body A in local body coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].\n    * @param {Array} [localB] - Where to hook the spring to body B in local body coordinates. This value is an array by 2 elements, x and y, i.e: [32, 32].\n    * @return {Phaser.Physics.P2.Spring} The spring\n    */\n    createSpring: function (bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {\n\n        bodyA = this.getBody(bodyA);\n        bodyB = this.getBody(bodyB);\n\n        if (!bodyA || !bodyB)\n        {\n            console.warn('Cannot create Spring, invalid body objects given');\n        }\n        else\n        {\n            return this.addSpring(new Phaser.Physics.P2.Spring(this, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB));\n        }\n\n    },\n\n    /**\n    * Creates a new Body and adds it to the World.\n    *\n    * @method Phaser.Physics.P2#createBody\n    * @param {number} x - The x coordinate of Body.\n    * @param {number} y - The y coordinate of Body.\n    * @param {number} mass - The mass of the Body. A mass of 0 means a 'static' Body is created.\n    * @param {boolean} [addToWorld=false] - Automatically add this Body to the world? (usually false as it won't have any shapes on construction).\n    * @param {object} options - An object containing the build options:\n    * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n    * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.\n    * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.\n    * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.\n    *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],\n    *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.\n    * @return {Phaser.Physics.P2.Body} The body\n    */\n    createBody: function (x, y, mass, addToWorld, options, data) {\n\n        if (typeof addToWorld === 'undefined') { addToWorld = false; }\n\n        var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);\n\n        if (data)\n        {\n            var result = body.addPolygon(options, data);\n\n            if (!result)\n            {\n                return false;\n            }\n        }\n\n        if (addToWorld)\n        {\n            this.world.addBody(body.data);\n        }\n\n        return body;\n\n    },\n\n    /**\n    * Creates a new Particle and adds it to the World.\n    *\n    * @method Phaser.Physics.P2#createParticle\n    * @param {number} x - The x coordinate of Body.\n    * @param {number} y - The y coordinate of Body.\n    * @param {number} mass - The mass of the Body. A mass of 0 means a 'static' Body is created.\n    * @param {boolean} [addToWorld=false] - Automatically add this Body to the world? (usually false as it won't have any shapes on construction).\n    * @param {object} options - An object containing the build options:\n    * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n    * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.\n    * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.\n    * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.\n    *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],\n    *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.\n    */\n    createParticle: function (x, y, mass, addToWorld, options, data) {\n\n        if (typeof addToWorld === 'undefined') { addToWorld = false; }\n\n        var body = new Phaser.Physics.P2.Body(this.game, null, x, y, mass);\n\n        if (data)\n        {\n            var result = body.addPolygon(options, data);\n\n            if (!result)\n            {\n                return false;\n            }\n        }\n\n        if (addToWorld)\n        {\n            this.world.addBody(body.data);\n        }\n\n        return body;\n\n    },\n\n    /**\n    * Converts all of the polylines objects inside a Tiled ObjectGroup into physics bodies that are added to the world.\n    * Note that the polylines must be created in such a way that they can withstand polygon decomposition.\n    *\n    * @method Phaser.Physics.P2#convertCollisionObjects\n    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.\n    * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world.\n    * @return {array} An array of the Phaser.Physics.Body objects that have been created.\n    */\n    convertCollisionObjects: function (map, layer, addToWorld) {\n\n        if (typeof addToWorld === 'undefined') { addToWorld = true; }\n\n        var output = [];\n\n        for (var i = 0, len = map.collision[layer].length; i < len; i++)\n        {\n            // name: json.layers[i].objects[v].name,\n            // x: json.layers[i].objects[v].x,\n            // y: json.layers[i].objects[v].y,\n            // width: json.layers[i].objects[v].width,\n            // height: json.layers[i].objects[v].height,\n            // visible: json.layers[i].objects[v].visible,\n            // properties: json.layers[i].objects[v].properties,\n            // polyline: json.layers[i].objects[v].polyline\n\n            var object = map.collision[layer][i];\n\n            var body = this.createBody(object.x, object.y, 0, addToWorld, {}, object.polyline);\n\n            if (body)\n            {\n                output.push(body);\n            }\n\n        }\n\n        return output;\n\n    },\n\n    /**\n    * Clears all physics bodies from the given TilemapLayer that were created with `World.convertTilemap`.\n    *\n    * @method Phaser.Physics.P2#clearTilemapLayerBodies\n    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.\n    */\n    clearTilemapLayerBodies: function (map, layer) {\n\n        layer = map.getLayer(layer);\n\n        var i = map.layers[layer].bodies.length;\n\n        while (i--)\n        {\n            map.layers[layer].bodies[i].destroy();\n        }\n\n        map.layers[layer].bodies.length = [];\n\n    },\n\n    /**\n    * Goes through all tiles in the given Tilemap and TilemapLayer and converts those set to collide into physics bodies.\n    * Only call this *after* you have specified all of the tiles you wish to collide with calls like Tilemap.setCollisionBetween, etc.\n    * Every time you call this method it will destroy any previously created bodies and remove them from the world.\n    * Therefore understand it's a very expensive operation and not to be done in a core game update loop.\n    *\n    * @method Phaser.Physics.P2#convertTilemap\n    * @param {Phaser.Tilemap} map - The Tilemap to get the map data from.\n    * @param {number|string|Phaser.TilemapLayer} [layer] - The layer to operate on. If not given will default to map.currentLayer.\n    * @param {boolean} [addToWorld=true] - If true it will automatically add each body to the world, otherwise it's up to you to do so.\n    * @param {boolean} [optimize=true] - If true adjacent colliding tiles will be combined into a single body to save processing. However it means you cannot perform specific Tile to Body collision responses.\n    * @return {array} An array of the Phaser.Physics.P2.Body objects that were created.\n    */\n    convertTilemap: function (map, layer, addToWorld, optimize) {\n\n        layer = map.getLayer(layer);\n\n        if (typeof addToWorld === 'undefined') { addToWorld = true; }\n        if (typeof optimize === 'undefined') { optimize = true; }\n\n        //  If the bodies array is already populated we need to nuke it\n        this.clearTilemapLayerBodies(map, layer);\n\n        var width = 0;\n        var sx = 0;\n        var sy = 0;\n\n        for (var y = 0, h = map.layers[layer].height; y < h; y++)\n        {\n            width = 0;\n\n            for (var x = 0, w = map.layers[layer].width; x < w; x++)\n            {\n                var tile = map.layers[layer].data[y][x];\n\n                if (tile && tile.collides)\n                {\n                    if (optimize)\n                    {\n                        var right = map.getTileRight(layer, x, y);\n\n                        if (width === 0)\n                        {\n                            sx = tile.x * tile.width;\n                            sy = tile.y * tile.height;\n                            width = tile.width;\n                        }\n\n                        if (right && right.collides)\n                        {\n                            width += tile.width;\n                        }\n                        else\n                        {\n                            var body = this.createBody(sx, sy, 0, false);\n\n                            body.addRectangle(width, tile.height, width / 2, tile.height / 2, 0);\n\n                            if (addToWorld)\n                            {\n                                this.addBody(body);\n                            }\n\n                            map.layers[layer].bodies.push(body);\n\n                            width = 0;\n                        }\n                    }\n                    else\n                    {\n                        var body = this.createBody(tile.x * tile.width, tile.y * tile.height, 0, false);\n\n                        body.addRectangle(tile.width, tile.height, tile.width / 2, tile.height / 2, 0);\n\n                        if (addToWorld)\n                        {\n                            this.addBody(body);\n                        }\n\n                        map.layers[layer].bodies.push(body);\n                    }\n                }\n            }\n        }\n\n        return map.layers[layer].bodies;\n\n    },\n\n    /**\n    * Convert p2 physics value (meters) to pixel scale.\n    * By default Phaser uses a scale of 20px per meter.\n    * If you need to modify this you can over-ride these functions via the Physics Configuration object.\n    *\n    * @method Phaser.Physics.P2#mpx\n    * @param {number} v - The value to convert.\n    * @return {number} The scaled value.\n    */\n    mpx: function (v) {\n\n        return v *= 20;\n\n    },\n\n    /**\n    * Convert pixel value to p2 physics scale (meters).\n    * By default Phaser uses a scale of 20px per meter.\n    * If you need to modify this you can over-ride these functions via the Physics Configuration object.\n    *\n    * @method Phaser.Physics.P2#pxm\n    * @param {number} v - The value to convert.\n    * @return {number} The scaled value.\n    */\n    pxm: function (v) {\n\n        return v * 0.05;\n\n    },\n\n    /**\n    * Convert p2 physics value (meters) to pixel scale and inverses it.\n    * By default Phaser uses a scale of 20px per meter.\n    * If you need to modify this you can over-ride these functions via the Physics Configuration object.\n    *\n    * @method Phaser.Physics.P2#mpxi\n    * @param {number} v - The value to convert.\n    * @return {number} The scaled value.\n    */\n    mpxi: function (v) {\n\n        return v *= -20;\n\n    },\n\n    /**\n    * Convert pixel value to p2 physics scale (meters) and inverses it.\n    * By default Phaser uses a scale of 20px per meter.\n    * If you need to modify this you can over-ride these functions via the Physics Configuration object.\n    *\n    * @method Phaser.Physics.P2#pxmi\n    * @param {number} v - The value to convert.\n    * @return {number} The scaled value.\n    */\n    pxmi: function (v) {\n\n        return v * -0.05;\n\n    }\n\n};\n\n/**\n* @name Phaser.Physics.P2#friction\n* @property {number} friction - Friction between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"friction\", {\n\n    get: function () {\n\n        return this.world.defaultContactMaterial.friction;\n\n    },\n\n    set: function (value) {\n\n        this.world.defaultContactMaterial.friction = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#defaultFriction\n* @property {number} defaultFriction - DEPRECATED: Use World.friction instead.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"defaultFriction\", {\n\n    get: function () {\n\n        return this.world.defaultContactMaterial.friction;\n\n    },\n\n    set: function (value) {\n\n        this.world.defaultContactMaterial.friction = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#restitution\n* @property {number} restitution - Default coefficient of restitution between colliding bodies. This value is used if no matching ContactMaterial is found for a Material pair.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"restitution\", {\n\n    get: function () {\n\n        return this.world.defaultContactMaterial.restitution;\n\n    },\n\n    set: function (value) {\n\n        this.world.defaultContactMaterial.restitution = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#defaultRestitution\n* @property {number} defaultRestitution - DEPRECATED: Use World.restitution instead.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"defaultRestitution\", {\n\n    get: function () {\n\n        return this.world.defaultContactMaterial.restitution;\n\n    },\n\n    set: function (value) {\n\n        this.world.defaultContactMaterial.restitution = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#contactMaterial\n* @property {p2.ContactMaterial} contactMaterial - The default Contact Material being used by the World.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"contactMaterial\", {\n\n    get: function () {\n\n        return this.world.defaultContactMaterial;\n\n    },\n\n    set: function (value) {\n\n        this.world.defaultContactMaterial = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#applySpringForces\n* @property {boolean} applySpringForces - Enable to automatically apply spring forces each step.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"applySpringForces\", {\n\n    get: function () {\n\n        return this.world.applySpringForces;\n\n    },\n\n    set: function (value) {\n\n        this.world.applySpringForces = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#applyDamping\n* @property {boolean} applyDamping - Enable to automatically apply body damping each step.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"applyDamping\", {\n\n    get: function () {\n\n        return this.world.applyDamping;\n\n    },\n\n    set: function (value) {\n\n        this.world.applyDamping = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#applyGravity\n* @property {boolean} applyGravity - Enable to automatically apply gravity each step.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"applyGravity\", {\n\n    get: function () {\n\n        return this.world.applyGravity;\n\n    },\n\n    set: function (value) {\n\n        this.world.applyGravity = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#solveConstraints\n* @property {boolean} solveConstraints - Enable/disable constraint solving in each step.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"solveConstraints\", {\n\n    get: function () {\n\n        return this.world.solveConstraints;\n\n    },\n\n    set: function (value) {\n\n        this.world.solveConstraints = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#time\n* @property {boolean} time - The World time.\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"time\", {\n\n    get: function () {\n\n        return this.world.time;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#emitImpactEvent\n* @property {boolean} emitImpactEvent - Set to true if you want to the world to emit the \"impact\" event. Turning this off could improve performance.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"emitImpactEvent\", {\n\n    get: function () {\n\n        return this.world.emitImpactEvent;\n\n    },\n\n    set: function (value) {\n\n        this.world.emitImpactEvent = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#enableBodySleeping\n* @property {boolean} enableBodySleeping - Enable / disable automatic body sleeping.\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"enableBodySleeping\", {\n\n    get: function () {\n\n        return this.world.enableBodySleeping;\n\n    },\n\n    set: function (value) {\n\n        this.world.enableBodySleeping = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2#total\n* @property {number} total - The total number of bodies in the world.\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.P2.prototype, \"total\", {\n\n    get: function () {\n\n        return this.world.bodies.length;\n\n    }\n\n});\n\n/* jshint noarg: false */\n\n/**\n* @author       Georgios Kaleadis https://github.com/georgiee\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Allow to access a list of created fixture (coming from Body#addPhaserPolygon)\n* which itself parse the input from PhysicsEditor with the custom phaser exporter.\n* You can access fixtures of a Body by a group index or even by providing a fixture Key.\n\n* You can set the fixture key and also the group index for a fixture in PhysicsEditor.\n* This gives you the power to create a complex body built of many fixtures and modify them\n* during runtime (to remove parts, set masks, categories & sensor properties)\n*\n* @class Phaser.Physics.P2.FixtureList\n* @classdesc Collection for generated P2 fixtures \n* @constructor\n* @param {Array} list - A list of fixtures (from Phaser.Physics.P2.Body#addPhaserPolygon)\n*/\nPhaser.Physics.P2.FixtureList = function (list) {\n\n    if (!Array.isArray(list))\n    {\n        list = [list];\n    }\n\n    this.rawList = list;\n    this.init();\n    this.parse(this.rawList);\n\n};\n\nPhaser.Physics.P2.FixtureList.prototype = {\n  \n    /**\n    * @method Phaser.Physics.P2.FixtureList#init\n    */\n    init: function () {\n\n        /**\n        * @property {object} namedFixtures - Collect all fixtures with a key\n        * @private\n        */\n        this.namedFixtures = {};\n\n        /**\n        * @property {Array} groupedFixtures - Collect all given fixtures per group index. Notice: Every fixture with a key also belongs to a group\n        * @private\n        */\n        this.groupedFixtures = [];\n\n        /**\n        * @property {Array} allFixtures - This is a list of everything in this collection\n        * @private\n        */\n        this.allFixtures = [];\n\n    },\n\n    /**\n    * @method Phaser.Physics.P2.FixtureList#setCategory\n    * @param {number} bit - The bit to set as the collision group.\n    * @param {string} fixtureKey - Only apply to the fixture with the given key.\n    */\n    setCategory: function (bit, fixtureKey) {\n\n        var setter = function(fixture) {\n            fixture.collisionGroup = bit;\n        };\n\n        this.getFixtures(fixtureKey).forEach(setter);\n\n    },\n  \n    /**\n    * @method Phaser.Physics.P2.FixtureList#setMask\n    * @param {number} bit - The bit to set as the collision mask\n    * @param {string} fixtureKey - Only apply to the fixture with the given key\n    */\n    setMask: function (bit, fixtureKey) {\n\n        var setter = function(fixture) {\n            fixture.collisionMask = bit;\n        };\n\n        this.getFixtures(fixtureKey).forEach(setter);\n\n    },\n  \n    /**\n    * @method Phaser.Physics.P2.FixtureList#setSensor\n    * @param {boolean} value - sensor true or false\n    * @param {string} fixtureKey - Only apply to the fixture with the given key\n    */\n    setSensor: function (value, fixtureKey) {\n\n        var setter = function(fixture) {\n            fixture.sensor = value;\n        };\n\n        this.getFixtures(fixtureKey).forEach(setter);\n\n    },\n\n    /**\n    * @method Phaser.Physics.P2.FixtureList#setMaterial\n    * @param {Object} material - The contact material for a fixture\n    * @param {string} fixtureKey - Only apply to the fixture with the given key\n    */\n    setMaterial: function (material, fixtureKey) {\n\n        var setter = function(fixture) {\n            fixture.material = material;\n        };\n\n        this.getFixtures(fixtureKey).forEach(setter);\n\n    },\n\n    /**\n    * Accessor to get either a list of specified fixtures by key or the whole fixture list\n    * \n    * @method Phaser.Physics.P2.FixtureList#getFixtures\n    * @param {array} keys - A list of fixture keys\n    */\n    getFixtures: function (keys) {\n\n        var fixtures = [];\n\n        if (keys)\n        {\n            if (!(keys instanceof Array))\n            {\n                keys = [keys];\n            }\n\n            var self = this;\n            keys.forEach(function(key) {\n                if (self.namedFixtures[key])\n                {\n                    fixtures.push(self.namedFixtures[key]);\n                }\n            });\n\n            return this.flatten(fixtures);\n\n        }\n        else\n        {\n            return this.allFixtures;\n        }\n\n    },\n\n    /**\n    * Accessor to get either a single fixture by its key.\n    * \n    * @method Phaser.Physics.P2.FixtureList#getFixtureByKey\n    * @param {string} key - The key of the fixture.\n    */\n    getFixtureByKey: function (key) {\n\n        return this.namedFixtures[key];\n\n    },\n\n    /**\n    * Accessor to get a group of fixtures by its group index.\n    * \n    * @method Phaser.Physics.P2.FixtureList#getGroup\n    * @param {number} groupID - The group index.\n    */\n    getGroup: function (groupID) {\n\n        return this.groupedFixtures[groupID];\n\n    },\n  \n    /**\n    * Parser for the output of Phaser.Physics.P2.Body#addPhaserPolygon\n    * \n    * @method Phaser.Physics.P2.FixtureList#parse\n    */\n    parse: function () {\n\n        var key, value, _ref, _results;\n        _ref = this.rawList;\n        _results = [];\n\n        for (key in _ref)\n        {\n            value = _ref[key];\n\n            if (!isNaN(key - 0))\n            {\n                this.groupedFixtures[key] = this.groupedFixtures[key] || [];\n                this.groupedFixtures[key] = this.groupedFixtures[key].concat(value);\n            }\n            else\n            {\n                this.namedFixtures[key] = this.flatten(value);\n            }\n\n            _results.push(this.allFixtures = this.flatten(this.groupedFixtures));\n        }\n\n    },\n\n    /**\n    * A helper to flatten arrays. This is very useful as the fixtures are nested from time to time due to the way P2 creates and splits polygons.\n    * \n    * @method Phaser.Physics.P2.FixtureList#flatten\n    * @param {array} array - The array to flatten. Notice: This will happen recursive not shallow.\n    */\n    flatten: function (array) {\n\n        var result, self;\n        result = [];\n        self = arguments.callee;\n        \n        array.forEach(function(item) {\n            return Array.prototype.push.apply(result, (Array.isArray(item) ? self(item) : [item]));\n        });\n\n        return result;\n\n    }\n\n};\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A PointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays.\n*\n* @class Phaser.Physics.P2.PointProxy\n* @classdesc PointProxy\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {any} destination - The object to bind to.\n*/\nPhaser.Physics.P2.PointProxy = function (world, destination) {\n\n    this.world = world;\n\tthis.destination = destination;\n\n};\n\nPhaser.Physics.P2.PointProxy.prototype.constructor = Phaser.Physics.P2.PointProxy;\n\n/**\n* @name Phaser.Physics.P2.PointProxy#x\n* @property {number} x - The x property of this PointProxy.\n*/\nObject.defineProperty(Phaser.Physics.P2.PointProxy.prototype, \"x\", {\n\n    get: function () {\n\n        return this.destination[0];\n\n    },\n\n    set: function (value) {\n\n        this.destination[0] = this.world.pxm(value);\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.PointProxy#y\n* @property {number} y - The y property of this PointProxy.\n*/\nObject.defineProperty(Phaser.Physics.P2.PointProxy.prototype, \"y\", {\n\n    get: function () {\n\n        return this.destination[1];\n\n    },\n\n    set: function (value) {\n\n        this.destination[1] = this.world.pxm(value);\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A InversePointProxy is an internal class that allows for direct getter/setter style property access to Arrays and TypedArrays but inverses the values on set.\n*\n* @class Phaser.Physics.P2.InversePointProxy\n* @classdesc InversePointProxy\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {any} destination - The object to bind to.\n*/\nPhaser.Physics.P2.InversePointProxy = function (world, destination) {\n\n    this.world = world;\n\tthis.destination = destination;\n\n};\n\nPhaser.Physics.P2.InversePointProxy.prototype.constructor = Phaser.Physics.P2.InversePointProxy;\n\n/**\n* @name Phaser.Physics.P2.InversePointProxy#x\n* @property {number} x - The x property of this InversePointProxy.\n*/\nObject.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, \"x\", {\n\n    get: function () {\n\n        return this.destination[0];\n\n    },\n\n    set: function (value) {\n\n        this.destination[0] = this.world.pxm(-value);\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.InversePointProxy#y\n* @property {number} y - The y property of this InversePointProxy.\n*/\nObject.defineProperty(Phaser.Physics.P2.InversePointProxy.prototype, \"y\", {\n\n    get: function () {\n\n        return this.destination[1];\n\n    },\n\n    set: function (value) {\n\n        this.destination[1] = this.world.pxm(-value);\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The Physics Body is typically linked to a single Sprite and defines properties that determine how the physics body is simulated.\n* These properties affect how the body reacts to forces, what forces it generates on itself (to simulate friction), and how it reacts to collisions in the scene.\n* In most cases, the properties are used to simulate physical effects. Each body also has its own property values that determine exactly how it reacts to forces and collisions in the scene.\n* By default a single Rectangle shape is added to the Body that matches the dimensions of the parent Sprite. See addShape, removeShape, clearShapes to add extra shapes around the Body.\n* Note: When bound to a Sprite to avoid single-pixel jitters on mobile devices we strongly recommend using Sprite sizes that are even on both axis, i.e. 128x128 not 127x127.\n*\n* @class Phaser.Physics.P2.Body\n* @classdesc Physics Body Constructor\n* @constructor\n* @param {Phaser.Game} game - Game reference to the currently running game.\n* @param {Phaser.Sprite} [sprite] - The Sprite object this physics body belongs to.\n* @param {number} [x=0] - The x coordinate of this Body.\n* @param {number} [y=0] - The y coordinate of this Body.\n* @param {number} [mass=1] - The default mass of this Body (0 = static).\n*/\nPhaser.Physics.P2.Body = function (game, sprite, x, y, mass) {\n\n    sprite = sprite || null;\n    x = x || 0;\n    y = y || 0;\n    if (typeof mass === 'undefined') { mass = 1; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = game;\n\n    /**\n    * @property {Phaser.Physics.P2} world - Local reference to the P2 World.\n    */\n    this.world = game.physics.p2;\n\n    /**\n    * @property {Phaser.Sprite} sprite - Reference to the parent Sprite.\n    */\n    this.sprite = sprite;\n\n    /**\n    * @property {number} type - The type of physics system this body belongs to.\n    */\n    this.type = Phaser.Physics.P2JS;\n\n    /**\n    * @property {Phaser.Point} offset - The offset of the Physics Body from the Sprite x/y position.\n    */\n    this.offset = new Phaser.Point();\n\n    /**\n    * @property {p2.Body} data - The p2 Body data.\n    * @protected\n    */\n    this.data = new p2.Body({ position: [ this.world.pxmi(x), this.world.pxmi(y) ], mass: mass });\n\n    this.data.parent = this;\n\n    /**\n    * @property {Phaser.InversePointProxy} velocity - The velocity of the body. Set velocity.x to a negative value to move to the left, position to the right. velocity.y negative values move up, positive move down.\n    */\n    this.velocity = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.velocity);\n\n    /**\n    * @property {Phaser.InversePointProxy} force - The force applied to the body.\n    */\n    this.force = new Phaser.Physics.P2.InversePointProxy(this.world, this.data.force);\n\n    /**\n    * @property {Phaser.Point} gravity - A locally applied gravity force to the Body. Applied directly before the world step. NOTE: Not currently implemented.\n    */\n    this.gravity = new Phaser.Point();\n\n    /**\n    * Dispatched when a first contact is created between shapes in two bodies. This event is fired during the step, so collision has already taken place.\n    * The event will be sent 4 parameters: The body it is in contact with, the shape from this body that caused the contact, the shape from the contact body and the contact equation data array.\n    * @property {Phaser.Signal} onBeginContact\n    */\n    this.onBeginContact = new Phaser.Signal();\n\n    /**\n    * Dispatched when contact ends between shapes in two bodies. This event is fired during the step, so collision has already taken place.\n    * The event will be sent 3 parameters: The body it is in contact with, the shape from this body that caused the contact and the shape from the contact body.\n    * @property {Phaser.Signal} onEndContact\n    */\n    this.onEndContact = new Phaser.Signal();\n\n    /**\n    * @property {array} collidesWith - Array of CollisionGroups that this Bodies shapes collide with.\n    */\n    this.collidesWith = [];\n\n    /**\n    * @property {boolean} removeNextStep - To avoid deleting this body during a physics step, and causing all kinds of problems, set removeNextStep to true to have it removed in the next preUpdate.\n    */\n    this.removeNextStep = false;\n\n    /**\n    * @property {Phaser.Physics.P2.BodyDebug} debugBody - Reference to the debug body.\n    */\n    this.debugBody = null;\n\n    /**\n    * @property {boolean} _collideWorldBounds - Internal var that determines if this Body collides with the world bounds or not.\n    * @private\n    */\n    this._collideWorldBounds = true;\n\n    /**\n    * @property {object} _bodyCallbacks - Array of Body callbacks.\n    * @private\n    */\n    this._bodyCallbacks = {};\n\n    /**\n    * @property {object} _bodyCallbackContext - Array of Body callback contexts.\n    * @private\n    */\n    this._bodyCallbackContext = {};\n\n    /**\n    * @property {object} _groupCallbacks - Array of Group callbacks.\n    * @private\n    */\n    this._groupCallbacks = {};\n\n    /**\n    * @property {object} _bodyCallbackContext - Array of Grouo callback contexts.\n    * @private\n    */\n    this._groupCallbackContext = {};\n\n    //  Set-up the default shape\n    if (sprite)\n    {\n        this.setRectangleFromSprite(sprite);\n\n        if (sprite.exists)\n        {\n            this.game.physics.p2.addBody(this);\n        }\n    }\n\n};\n\nPhaser.Physics.P2.Body.prototype = {\n\n    /**\n    * Sets a callback to be fired any time a shape in this Body impacts with a shape in the given Body. The impact test is performed against body.id values.\n    * The callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\n    * It also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.\n    *\n    * @method Phaser.Physics.P2.Body#createBodyCallback\n    * @param {Phaser.Sprite|Phaser.TileSprite|Phaser.Physics.P2.Body|p2.Body} object - The object to send impact events for.\n    * @param {function} callback - The callback to fire on impact. Set to null to clear a previously set callback.\n    * @param {object} callbackContext - The context under which the callback will fire.\n    */\n    createBodyCallback: function (object, callback, callbackContext) {\n\n        var id = -1;\n\n        if (object['id'])\n        {\n            id = object.id;\n        }\n        else if (object['body'])\n        {\n            id = object.body.id;\n        }\n\n        if (id > -1)\n        {\n            if (callback === null)\n            {\n                delete (this._bodyCallbacks[id]);\n                delete (this._bodyCallbackContext[id]);\n            }\n            else\n            {\n                this._bodyCallbacks[id] = callback;\n                this._bodyCallbackContext[id] = callbackContext;\n            }\n        }\n\n    },\n\n    /**\n    * Sets a callback to be fired any time this Body impacts with the given Group. The impact test is performed against shape.collisionGroup values.\n    * The callback will be sent 4 parameters: This body, the body that impacted, the Shape in this body and the shape in the impacting body.\n    * This callback will only fire if this Body has been assigned a collision group.\n    * Note that the impact event happens after collision resolution, so it cannot be used to prevent a collision from happening.\n    * It also happens mid-step. So do not destroy a Body during this callback, instead set safeDestroy to true so it will be killed on the next preUpdate.\n    *\n    * @method Phaser.Physics.P2.Body#createGroupCallback\n    * @param {Phaser.Physics.CollisionGroup} group - The Group to send impact events for.\n    * @param {function} callback - The callback to fire on impact. Set to null to clear a previously set callback.\n    * @param {object} callbackContext - The context under which the callback will fire.\n    */\n    createGroupCallback: function (group, callback, callbackContext) {\n\n        if (callback === null)\n        {\n            delete (this._groupCallbacks[group.mask]);\n            delete (this._groupCallbacksContext[group.mask]);\n        }\n        else\n        {\n            this._groupCallbacks[group.mask] = callback;\n            this._groupCallbackContext[group.mask] = callbackContext;\n        }\n\n    },\n\n    /**\n    * Gets the collision bitmask from the groups this body collides with.\n    *\n    * @method Phaser.Physics.P2.Body#getCollisionMask\n    * @return {number} The bitmask.\n    */\n    getCollisionMask: function () {\n\n        var mask = 0;\n\n        if (this._collideWorldBounds)\n        {\n            mask = this.game.physics.p2.boundsCollisionGroup.mask;\n        }\n\n        for (var i = 0; i < this.collidesWith.length; i++)\n        {\n            mask = mask | this.collidesWith[i].mask;\n        }\n\n        return mask;\n\n    },\n\n    /**\n    * Updates the collisionMask.\n    *\n    * @method Phaser.Physics.P2.Body#updateCollisionMask\n    * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision group will be added to all Shapes in this Body.\n    */\n    updateCollisionMask: function (shape) {\n\n        var mask = this.getCollisionMask();\n\n        if (typeof shape === 'undefined')\n        {\n            for (var i = this.data.shapes.length - 1; i >= 0; i--)\n            {\n                this.data.shapes[i].collisionMask = mask;\n            }\n        }\n        else\n        {\n            shape.collisionMask = mask;\n        }\n\n    },\n\n    /**\n    * Sets the given CollisionGroup to be the collision group for all shapes in this Body, unless a shape is specified.\n    * This also resets the collisionMask.\n    *\n    * @method Phaser.Physics.P2.Body#setCollisionGroup\n    * @param {Phaser.Physics.CollisionGroup} group - The Collision Group that this Bodies shapes will use.\n    * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision group will be added to all Shapes in this Body.\n    */\n    setCollisionGroup: function (group, shape) {\n\n        var mask = this.getCollisionMask();\n\n        if (typeof shape === 'undefined')\n        {\n            for (var i = this.data.shapes.length - 1; i >= 0; i--)\n            {\n                this.data.shapes[i].collisionGroup = group.mask;\n                this.data.shapes[i].collisionMask = mask;\n            }\n        }\n        else\n        {\n            shape.collisionGroup = group.mask;\n            shape.collisionMask = mask;\n        }\n\n    },\n\n    /**\n    * Clears the collision data from the shapes in this Body. Optionally clears Group and/or Mask.\n    *\n    * @method Phaser.Physics.P2.Body#clearCollision\n    * @param {boolean} [clearGroup=true] - Clear the collisionGroup value from the shape/s?\n    * @param {boolean} [clearMask=true] - Clear the collisionMask value from the shape/s?\n    * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision data will be cleared from all Shapes in this Body.\n    */\n    clearCollision: function (clearGroup, clearMask, shape) {\n\n        if (typeof shape === 'undefined')\n        {\n            for (var i = this.data.shapes.length - 1; i >= 0; i--)\n            {\n                if (clearGroup)\n                {\n                    this.data.shapes[i].collisionGroup = null;\n                }\n\n                if (clearMask)\n                {\n                    this.data.shapes[i].collisionMask = null;\n                }\n            }\n        }\n        else\n        {\n            if (clearGroup)\n            {\n                shape.collisionGroup = null;\n            }\n\n            if (clearMask)\n            {\n                shape.collisionMask = null;\n            }\n        }\n\n        if (clearGroup)\n        {\n            this.collidesWith.length = 0;\n        }\n\n    },\n\n    /**\n    * Adds the given CollisionGroup, or array of CollisionGroups, to the list of groups that this body will collide with and updates the collision masks.\n    *\n    * @method Phaser.Physics.P2.Body#collides\n    * @param {Phaser.Physics.CollisionGroup|array} group - The Collision Group or Array of Collision Groups that this Bodies shapes will collide with.\n    * @param {function} [callback] - Optional callback that will be triggered when this Body impacts with the given Group.\n    * @param {object} [callbackContext] - The context under which the callback will be called.\n    * @param {p2.Shape} [shape] - An optional Shape. If not provided the collision mask will be added to all Shapes in this Body.\n    */\n    collides: function (group, callback, callbackContext, shape) {\n\n        if (Array.isArray(group))\n        {\n            for (var i = 0; i < group.length; i++)\n            {\n                if (this.collidesWith.indexOf(group[i]) === -1)\n                {\n                    this.collidesWith.push(group[i]);\n\n                    if (callback)\n                    {\n                        this.createGroupCallback(group[i], callback, callbackContext);\n                    }\n                }\n            }\n        }\n        else\n        {\n            if (this.collidesWith.indexOf(group) === -1)\n            {\n                this.collidesWith.push(group);\n\n                if (callback)\n                {\n                    this.createGroupCallback(group, callback, callbackContext);\n                }\n            }\n        }\n\n        var mask = this.getCollisionMask();\n\n        if (typeof shape === 'undefined')\n        {\n            for (var i = this.data.shapes.length - 1; i >= 0; i--)\n            {\n                this.data.shapes[i].collisionMask = mask;\n            }\n        }\n        else\n        {\n            shape.collisionMask = mask;\n        }\n\n    },\n\n    /**\n    * Moves the shape offsets so their center of mass becomes the body center of mass.\n    *\n    * @method Phaser.Physics.P2.Body#adjustCenterOfMass\n    */\n    adjustCenterOfMass: function () {\n\n        this.data.adjustCenterOfMass();\n\n    },\n\n    /**\n    * Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details.\n    *\n    * @method Phaser.Physics.P2.Body#applyDamping\n    * @param {number} dt - Current time step.\n    */\n    applyDamping: function (dt) {\n\n        this.data.applyDamping(dt);\n\n    },\n\n    /**\n    * Apply force to a world point. This could for example be a point on the RigidBody surface. Applying force this way will add to Body.force and Body.angularForce.\n    *\n    * @method Phaser.Physics.P2.Body#applyForce\n    * @param {number} force - The force to add.\n    * @param {number} worldX - The world x point to apply the force on.\n    * @param {number} worldY - The world y point to apply the force on.\n    */\n    applyForce: function (force, worldX, worldY) {\n\n        this.data.applyForce(force, [this.world.pxmi(worldX), this.world.pxmi(worldY)]);\n\n    },\n\n    /**\n    * Sets the force on the body to zero.\n    *\n    * @method Phaser.Physics.P2.Body#setZeroForce\n    */\n    setZeroForce: function () {\n\n        this.data.setZeroForce();\n\n    },\n\n    /**\n    * If this Body is dynamic then this will zero its angular velocity.\n    *\n    * @method Phaser.Physics.P2.Body#setZeroRotation\n    */\n    setZeroRotation: function () {\n\n        this.data.angularVelocity = 0;\n\n    },\n\n    /**\n    * If this Body is dynamic then this will zero its velocity on both axis.\n    *\n    * @method Phaser.Physics.P2.Body#setZeroVelocity\n    */\n    setZeroVelocity: function () {\n\n        this.data.velocity[0] = 0;\n        this.data.velocity[1] = 0;\n\n    },\n\n    /**\n    * Sets the Body damping and angularDamping to zero.\n    *\n    * @method Phaser.Physics.P2.Body#setZeroDamping\n    */\n    setZeroDamping: function () {\n\n        this.data.damping = 0;\n        this.data.angularDamping = 0;\n\n    },\n\n    /**\n    * Transform a world point to local body frame.\n    *\n    * @method Phaser.Physics.P2.Body#toLocalFrame\n    * @param {Float32Array|Array} out - The vector to store the result in.\n    * @param {Float32Array|Array} worldPoint - The input world vector.\n    */\n    toLocalFrame: function (out, worldPoint) {\n\n        return this.data.toLocalFrame(out, worldPoint);\n\n    },\n\n    /**\n    * Transform a local point to world frame.\n    *\n    * @method Phaser.Physics.P2.Body#toWorldFrame\n    * @param {Array} out - The vector to store the result in.\n    * @param {Array} localPoint - The input local vector.\n    */\n    toWorldFrame: function (out, localPoint) {\n\n        return this.data.toWorldFrame(out, localPoint);\n\n    },\n\n    /**\n    * This will rotate the Body by the given speed to the left (counter-clockwise).\n    *\n    * @method Phaser.Physics.P2.Body#rotateLeft\n    * @param {number} speed - The speed at which it should rotate.\n    */\n    rotateLeft: function (speed) {\n\n        this.data.angularVelocity = this.world.pxm(-speed);\n\n    },\n\n    /**\n    * This will rotate the Body by the given speed to the left (clockwise).\n    *\n    * @method Phaser.Physics.P2.Body#rotateRight\n    * @param {number} speed - The speed at which it should rotate.\n    */\n    rotateRight: function (speed) {\n\n        this.data.angularVelocity = this.world.pxm(speed);\n\n    },\n\n    /**\n    * Moves the Body forwards based on its current angle and the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#moveForward\n    * @param {number} speed - The speed at which it should move forwards.\n    */\n    moveForward: function (speed) {\n\n        var magnitude = this.world.pxmi(-speed);\n        var angle = this.data.angle + Math.PI / 2;\n\n        this.data.velocity[0] = magnitude * Math.cos(angle);\n        this.data.velocity[1] = magnitude * Math.sin(angle);\n\n    },\n\n    /**\n    * Moves the Body backwards based on its current angle and the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#moveBackward\n    * @param {number} speed - The speed at which it should move backwards.\n    */\n    moveBackward: function (speed) {\n\n        var magnitude = this.world.pxmi(-speed);\n        var angle = this.data.angle + Math.PI / 2;\n\n        this.data.velocity[0] = -(magnitude * Math.cos(angle));\n        this.data.velocity[1] = -(magnitude * Math.sin(angle));\n\n    },\n\n    /**\n    * Applies a force to the Body that causes it to 'thrust' forwards, based on its current angle and the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#thrust\n    * @param {number} speed - The speed at which it should thrust.\n    */\n    thrust: function (speed) {\n\n        var magnitude = this.world.pxmi(-speed);\n        var angle = this.data.angle + Math.PI / 2;\n\n        this.data.force[0] += magnitude * Math.cos(angle);\n        this.data.force[1] += magnitude * Math.sin(angle);\n\n    },\n\n    /**\n    * Applies a force to the Body that causes it to 'thrust' backwards (in reverse), based on its current angle and the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#rever\n    * @param {number} speed - The speed at which it should reverse.\n    */\n    reverse: function (speed) {\n\n        var magnitude = this.world.pxmi(-speed);\n        var angle = this.data.angle + Math.PI / 2;\n\n        this.data.force[0] -= magnitude * Math.cos(angle);\n        this.data.force[1] -= magnitude * Math.sin(angle);\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it to the left by setting its x velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#moveLeft\n    * @param {number} speed - The speed at which it should move to the left, in pixels per second.\n    */\n    moveLeft: function (speed) {\n\n        this.data.velocity[0] = this.world.pxmi(-speed);\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it to the right by setting its x velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#moveRight\n    * @param {number} speed - The speed at which it should move to the right, in pixels per second.\n    */\n    moveRight: function (speed) {\n\n        this.data.velocity[0] = this.world.pxmi(speed);\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it up by setting its y velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#moveUp\n    * @param {number} speed - The speed at which it should move up, in pixels per second.\n    */\n    moveUp: function (speed) {\n\n        this.data.velocity[1] = this.world.pxmi(-speed);\n\n    },\n\n    /**\n    * If this Body is dynamic then this will move it down by setting its y velocity to the given speed.\n    * The speed is represented in pixels per second. So a value of 100 would move 100 pixels in 1 second (1000ms).\n    *\n    * @method Phaser.Physics.P2.Body#moveDown\n    * @param {number} speed - The speed at which it should move down, in pixels per second.\n    */\n    moveDown: function (speed) {\n\n        this.data.velocity[1] = this.world.pxmi(speed);\n\n    },\n\n    /**\n    * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.\n    *\n    * @method Phaser.Physics.P2.Body#preUpdate\n    * @protected\n    */\n    preUpdate: function () {\n\n        if (this.removeNextStep)\n        {\n            this.removeFromWorld();\n            this.removeNextStep = false;\n        }\n\n    },\n\n    /**\n    * Internal method. This is called directly before the sprites are sent to the renderer and after the update function has finished.\n    *\n    * @method Phaser.Physics.P2.Body#postUpdate\n    * @protected\n    */\n    postUpdate: function () {\n\n        this.sprite.x = this.world.mpxi(this.data.position[0]);\n        this.sprite.y = this.world.mpxi(this.data.position[1]);\n\n        if (!this.fixedRotation)\n        {\n            this.sprite.rotation = this.data.angle;\n        }\n\n    },\n\n    /**\n    * Resets the Body force, velocity (linear and angular) and rotation. Optionally resets damping and mass.\n    *\n    * @method Phaser.Physics.P2.Body#reset\n    * @param {number} x - The new x position of the Body.\n    * @param {number} y - The new x position of the Body.\n    * @param {boolean} [resetDamping=false] - Resets the linear and angular damping.\n    * @param {boolean} [resetMass=false] - Sets the Body mass back to 1.\n    */\n    reset: function (x, y, resetDamping, resetMass) {\n\n        if (typeof resetDamping === 'undefined') { resetDamping = false; }\n        if (typeof resetMass === 'undefined') { resetMass = false; }\n\n        this.setZeroForce();\n        this.setZeroVelocity();\n        this.setZeroRotation();\n\n        if (resetDamping)\n        {\n            this.setZeroDamping();\n        }\n\n        if (resetMass)\n        {\n            this.mass = 1;\n        }\n\n        this.x = x;\n        this.y = y;\n\n    },\n\n    /**\n    * Adds this physics body to the world.\n    *\n    * @method Phaser.Physics.P2.Body#addToWorld\n    */\n    addToWorld: function () {\n\n        if (this.data.world !== this.game.physics.p2.world)\n        {\n            this.game.physics.p2.addBody(this);\n        }\n\n    },\n\n    /**\n    * Removes this physics body from the world.\n    *\n    * @method Phaser.Physics.P2.Body#removeFromWorld\n    */\n    removeFromWorld: function () {\n\n        if (this.data.world === this.game.physics.p2.world)\n        {\n            this.game.physics.p2.removeBodyNextStep(this);\n        }\n\n    },\n\n    /**\n    * Destroys this Body and all references it holds to other objects.\n    *\n    * @method Phaser.Physics.P2.Body#destroy\n    */\n    destroy: function () {\n\n        this.removeFromWorld();\n\n        this.clearShapes();\n\n        this._bodyCallbacks = {};\n        this._bodyCallbackContext = {};\n        this._groupCallbacks = {};\n        this._groupCallbackContext = {};\n\n        if (this.debugBody)\n        {\n            this.debugBody.destroy();\n        }\n\n        this.debugBody = null;\n\n        this.sprite = null;\n\n    },\n\n    /**\n    * Removes all Shapes from this Body.\n    *\n    * @method Phaser.Physics.P2.Body#clearShapes\n    */\n    clearShapes: function () {\n\n        var i = this.data.shapes.length;\n\n        while (i--)\n        {\n            this.data.removeShape(this.data.shapes[i]);\n        }\n\n        this.shapeChanged();\n\n    },\n\n    /**\n    * Add a shape to the body. You can pass a local transform when adding a shape, so that the shape gets an offset and an angle relative to the body center of mass.\n    * Will automatically update the mass properties and bounding radius.\n    *\n    * @method Phaser.Physics.P2.Body#addShape\n    * @param {p2.Shape} shape - The shape to add to the body.\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Shape} The shape that was added to the body.\n    */\n    addShape: function (shape, offsetX, offsetY, rotation) {\n\n        if (typeof offsetX === 'undefined') { offsetX = 0; }\n        if (typeof offsetY === 'undefined') { offsetY = 0; }\n        if (typeof rotation === 'undefined') { rotation = 0; }\n\n        this.data.addShape(shape, [this.world.pxmi(offsetX), this.world.pxmi(offsetY)], rotation);\n        this.shapeChanged();\n\n        return shape;\n\n    },\n\n    /**\n    * Adds a Circle shape to this Body. You can control the offset from the center of the body and the rotation.\n    *\n    * @method Phaser.Physics.P2.Body#addCircle\n    * @param {number} radius - The radius of this circle (in pixels)\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Circle} The Circle shape that was added to the Body.\n    */\n    addCircle: function (radius, offsetX, offsetY, rotation) {\n\n        var shape = new p2.Circle(this.world.pxm(radius));\n\n        return this.addShape(shape, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Adds a Rectangle shape to this Body. You can control the offset from the center of the body and the rotation.\n    *\n    * @method Phaser.Physics.P2.Body#addRectangle\n    * @param {number} width - The width of the rectangle in pixels.\n    * @param {number} height - The height of the rectangle in pixels.\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Rectangle} The Rectangle shape that was added to the Body.\n    */\n    addRectangle: function (width, height, offsetX, offsetY, rotation) {\n\n        var shape = new p2.Rectangle(this.world.pxm(width), this.world.pxm(height));\n\n        return this.addShape(shape, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Adds a Plane shape to this Body. The plane is facing in the Y direction. You can control the offset from the center of the body and the rotation.\n    *\n    * @method Phaser.Physics.P2.Body#addPlane\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Plane} The Plane shape that was added to the Body.\n    */\n    addPlane: function (offsetX, offsetY, rotation) {\n\n        var shape = new p2.Plane();\n\n        return this.addShape(shape, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Adds a Particle shape to this Body. You can control the offset from the center of the body and the rotation.\n    *\n    * @method Phaser.Physics.P2.Body#addParticle\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Particle} The Particle shape that was added to the Body.\n    */\n    addParticle: function (offsetX, offsetY, rotation) {\n\n        var shape = new p2.Particle();\n\n        return this.addShape(shape, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Adds a Line shape to this Body.\n    * The line shape is along the x direction, and stretches from [-length/2, 0] to [length/2,0].\n    * You can control the offset from the center of the body and the rotation.\n    *\n    * @method Phaser.Physics.P2.Body#addLine\n    * @param {number} length - The length of this line (in pixels)\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Line} The Line shape that was added to the Body.\n    */\n    addLine: function (length, offsetX, offsetY, rotation) {\n\n        var shape = new p2.Line(this.world.pxm(length));\n\n        return this.addShape(shape, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Adds a Capsule shape to this Body.\n    * You can control the offset from the center of the body and the rotation.\n    *\n    * @method Phaser.Physics.P2.Body#addCapsule\n    * @param {number} length - The distance between the end points in pixels.\n    * @param {number} radius - Radius of the capsule in radians.\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Capsule} The Capsule shape that was added to the Body.\n    */\n    addCapsule: function (length, radius, offsetX, offsetY, rotation) {\n\n        var shape = new p2.Capsule(this.world.pxm(length), radius);\n\n        return this.addShape(shape, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Reads a polygon shape path, and assembles convex shapes from that and puts them at proper offset points. The shape must be simple and without holes.\n    * This function expects the x.y values to be given in pixels. If you want to provide them at p2 world scales then call Body.data.fromPolygon directly.\n    *\n    * @method Phaser.Physics.P2.Body#addPolygon\n    * @param {object} options - An object containing the build options:\n    * @param {boolean} [options.optimalDecomp=false] - Set to true if you need optimal decomposition. Warning: very slow for polygons with more than 10 vertices.\n    * @param {boolean} [options.skipSimpleCheck=false] - Set to true if you already know that the path is not intersecting itself.\n    * @param {boolean|number} [options.removeCollinearPoints=false] - Set to a number (angle threshold value) to remove collinear points, or false to keep all points.\n    * @param {(number[]|...number)} points - An array of 2d vectors that form the convex or concave polygon.\n    *                                       Either [[0,0], [0,1],...] or a flat array of numbers that will be interpreted as [x,y, x,y, ...],\n    *                                       or the arguments passed can be flat x,y values e.g. `setPolygon(options, x,y, x,y, x,y, ...)` where `x` and `y` are numbers.\n    * @return {boolean} True on success, else false.\n    */\n    addPolygon: function (options, points) {\n\n        options = options || {};\n\n        points = Array.prototype.slice.call(arguments, 1);\n\n        var path = [];\n\n        //  Did they pass in a single array of points?\n        if (points.length === 1 && Array.isArray(points[0]))\n        {\n            path = points[0].slice(0);\n        }\n        else if (Array.isArray(points[0]))\n        {\n            path = points[0].slice(0);\n        }\n        else if (typeof points[0] === 'number')\n        {\n            //  We've a list of numbers\n            for (var i = 0, len = points.length; i < len; i += 2)\n            {\n                path.push([points[i], points[i + 1]]);\n            }\n        }\n\n        //  top and tail\n        var idx = path.length - 1;\n\n        if (path[idx][0] === path[0][0] && path[idx][1] === path[0][1])\n        {\n            path.pop();\n        }\n\n        //  Now process them into p2 values\n        for (var p = 0; p < path.length; p++)\n        {\n            path[p][0] = this.world.pxmi(path[p][0]);\n            path[p][1] = this.world.pxmi(path[p][1]);\n        }\n\n        var result = this.data.fromPolygon(path, options);\n\n        this.shapeChanged();\n\n        return result;\n\n    },\n\n    /**\n    * Remove a shape from the body. Will automatically update the mass properties and bounding radius.\n    *\n    * @method Phaser.Physics.P2.Body#removeShape\n    * @param {p2.Circle|p2.Rectangle|p2.Plane|p2.Line|p2.Particle} shape - The shape to remove from the body.\n    * @return {boolean} True if the shape was found and removed, else false.\n    */\n    removeShape: function (shape) {\n\n        return this.data.removeShape(shape);\n\n    },\n\n    /**\n    * Clears any previously set shapes. Then creates a new Circle shape and adds it to this Body.\n    *\n    * @method Phaser.Physics.P2.Body#setCircle\n    * @param {number} radius - The radius of this circle (in pixels)\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    */\n    setCircle: function (radius, offsetX, offsetY, rotation) {\n\n        this.clearShapes();\n\n        return this.addCircle(radius, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Clears any previously set shapes. The creates a new Rectangle shape at the given size and offset, and adds it to this Body.\n    * If you wish to create a Rectangle to match the size of a Sprite or Image see Body.setRectangleFromSprite.\n    *\n    * @method Phaser.Physics.P2.Body#setRectangle\n    * @param {number} [width=16] - The width of the rectangle in pixels.\n    * @param {number} [height=16] - The height of the rectangle in pixels.\n    * @param {number} [offsetX=0] - Local horizontal offset of the shape relative to the body center of mass.\n    * @param {number} [offsetY=0] - Local vertical offset of the shape relative to the body center of mass.\n    * @param {number} [rotation=0] - Local rotation of the shape relative to the body center of mass, specified in radians.\n    * @return {p2.Rectangle} The Rectangle shape that was added to the Body.\n    */\n    setRectangle: function (width, height, offsetX, offsetY, rotation) {\n\n        if (typeof width === 'undefined') { width = 16; }\n        if (typeof height === 'undefined') { height = 16; }\n\n        this.clearShapes();\n\n        return this.addRectangle(width, height, offsetX, offsetY, rotation);\n\n    },\n\n    /**\n    * Clears any previously set shapes.\n    * Then creates a Rectangle shape sized to match the dimensions and orientation of the Sprite given.\n    * If no Sprite is given it defaults to using the parent of this Body.\n    *\n    * @method Phaser.Physics.P2.Body#setRectangleFromSprite\n    * @param {Phaser.Sprite|Phaser.Image} [sprite] - The Sprite on which the Rectangle will get its dimensions.\n    * @return {p2.Rectangle} The Rectangle shape that was added to the Body.\n    */\n    setRectangleFromSprite: function (sprite) {\n\n        if (typeof sprite === 'undefined') { sprite = this.sprite; }\n\n        this.clearShapes();\n\n        return this.addRectangle(sprite.width, sprite.height, 0, 0, sprite.rotation);\n\n    },\n\n    /**\n    * Adds the given Material to all Shapes that belong to this Body.\n    * If you only wish to apply it to a specific Shape in this Body then provide that as the 2nd parameter.\n    *\n    * @method Phaser.Physics.P2.Body#setMaterial\n    * @param {Phaser.Physics.P2.Material} material - The Material that will be applied.\n    * @param {p2.Shape} [shape] - An optional Shape. If not provided the Material will be added to all Shapes in this Body.\n    */\n    setMaterial: function (material, shape) {\n\n        if (typeof shape === 'undefined')\n        {\n            for (var i = this.data.shapes.length - 1; i >= 0; i--)\n            {\n                this.data.shapes[i].material = material;\n            }\n        }\n        else\n        {\n            shape.material = material;\n        }\n\n    },\n\n    /**\n    * Updates the debug draw if any body shapes change.\n    *\n    * @method Phaser.Physics.P2.Body#shapeChanged\n    */\n    shapeChanged: function() {\n\n        if (this.debugBody)\n        {\n            this.debugBody.draw();\n        }\n\n    },\n\n    /**\n    * Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.\n    * The shape data format is based on the custom phaser export in.\n    *\n    * @method Phaser.Physics.P2.Body#addPhaserPolygon\n    * @param {string} key - The key of the Physics Data file as stored in Game.Cache.\n    * @param {string} object - The key of the object within the Physics data file that you wish to load the shape data from.\n    */\n    addPhaserPolygon: function (key, object) {\n\n        var data = this.game.cache.getPhysicsData(key, object);\n        var createdFixtures = [];\n\n        //  Cycle through the fixtures\n        for (var i = 0; i < data.length; i++)\n        {\n            var fixtureData = data[i];\n            var shapesOfFixture = this.addFixture(fixtureData);\n            \n            //  Always add to a group\n            createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group] || [];\n            createdFixtures[fixtureData.filter.group] = createdFixtures[fixtureData.filter.group].concat(shapesOfFixture);\n\n            //  if (unique) fixture key is provided\n            if (fixtureData.fixtureKey)\n            {\n                createdFixtures[fixtureData.fixtureKey] = shapesOfFixture;\n            }\n        }\n\n        this.data.aabbNeedsUpdate = true;\n        this.shapeChanged();\n\n        return createdFixtures;\n\n    },\n\n    /**\n    * Add a polygon fixture. This is used during #loadPolygon.\n    *\n    * @method Phaser.Physics.P2.Body#addFixture\n    * @param {string} fixtureData - The data for the fixture. It contains: isSensor, filter (collision) and the actual polygon shapes.\n    * @return {array} An array containing the generated shapes for the given polygon.\n    */\n    addFixture: function (fixtureData) {\n\n        var generatedShapes = [];\n\n        if (fixtureData.circle)\n        {\n            var shape = new p2.Circle(this.world.pxm(fixtureData.circle.radius));\n            shape.collisionGroup = fixtureData.filter.categoryBits;\n            shape.collisionMask = fixtureData.filter.maskBits;\n            shape.sensor = fixtureData.isSensor;\n\n            var offset = p2.vec2.create();\n            offset[0] = this.world.pxmi(fixtureData.circle.position[0] - this.sprite.width/2);\n            offset[1] = this.world.pxmi(fixtureData.circle.position[1] - this.sprite.height/2);\n\n            this.data.addShape(shape, offset);\n            generatedShapes.push(shape);\n        }\n        else\n        {\n            var polygons = fixtureData.polygons;\n            var cm = p2.vec2.create();\n\n            for (var i = 0; i < polygons.length; i++)\n            {\n                var shapes = polygons[i];\n                var vertices = [];\n\n                for (var s = 0; s < shapes.length; s += 2)\n                {\n                    vertices.push([ this.world.pxmi(shapes[s]), this.world.pxmi(shapes[s + 1]) ]);\n                }\n\n                var shape = new p2.Convex(vertices);\n\n                //  Move all vertices so its center of mass is in the local center of the convex\n                for (var j = 0; j !== shape.vertices.length; j++)\n                {\n                    var v = shape.vertices[j];\n                    p2.vec2.sub(v, v, shape.centerOfMass);\n                }\n\n                p2.vec2.scale(cm, shape.centerOfMass, 1);\n\n                cm[0] -= this.world.pxmi(this.sprite.width / 2);\n                cm[1] -= this.world.pxmi(this.sprite.height / 2);\n\n                shape.updateTriangles();\n                shape.updateCenterOfMass();\n                shape.updateBoundingRadius();\n\n                shape.collisionGroup = fixtureData.filter.categoryBits;\n                shape.collisionMask = fixtureData.filter.maskBits;\n                shape.sensor = fixtureData.isSensor;\n\n                this.data.addShape(shape, cm);\n\n                generatedShapes.push(shape);\n            }\n        }\n\n        return generatedShapes;\n\n    },\n\n    /**\n    * Reads the shape data from a physics data file stored in the Game.Cache and adds it as a polygon to this Body.\n    *\n    * @method Phaser.Physics.P2.Body#loadPolygon\n    * @param {string} key - The key of the Physics Data file as stored in Game.Cache.\n    * @param {string} object - The key of the object within the Physics data file that you wish to load the shape data from.\n    * @return {boolean} True on success, else false.\n    */\n    loadPolygon: function (key, object) {\n\n        var data = this.game.cache.getPhysicsData(key, object);\n\n        //  We've multiple Convex shapes, they should be CCW automatically\n        var cm = p2.vec2.create();\n\n        for (var i = 0; i < data.length; i++)\n        {\n            var vertices = [];\n\n            for (var s = 0; s < data[i].shape.length; s += 2)\n            {\n                vertices.push([ this.world.pxmi(data[i].shape[s]), this.world.pxmi(data[i].shape[s + 1]) ]);\n            }\n\n            var c = new p2.Convex(vertices);\n\n            // Move all vertices so its center of mass is in the local center of the convex\n            for (var j = 0; j !== c.vertices.length; j++)\n            {\n                var v = c.vertices[j];\n                p2.vec2.sub(v, v, c.centerOfMass);\n            }\n\n            p2.vec2.scale(cm, c.centerOfMass, 1);\n\n            cm[0] -= this.world.pxmi(this.sprite.width / 2);\n            cm[1] -= this.world.pxmi(this.sprite.height / 2);\n\n            c.updateTriangles();\n            c.updateCenterOfMass();\n            c.updateBoundingRadius();\n\n            this.data.addShape(c, cm);\n        }\n\n        this.data.aabbNeedsUpdate = true;\n        this.shapeChanged();\n\n        return true;\n\n    },\n\n    /**\n    * DEPRECATED: This method will soon be removed from the API. Please avoid using.\n    * Reads the physics data from a physics data file stored in the Game.Cache.\n    * It will add the shape data to this Body, as well as set the density (mass).\n    *\n    * @method Phaser.Physics.P2.Body#loadData\n    * @param {string} key - The key of the Physics Data file as stored in Game.Cache.\n    * @param {string} object - The key of the object within the Physics data file that you wish to load the shape data from.\n    * @return {boolean} True on success, else false.\n    */\n    loadData: function (key, object) {\n\n        var data = this.game.cache.getPhysicsData(key, object);\n\n        if (data && data.shape)\n        {\n            this.mass = data.density;\n            return this.loadPolygon(key, object);\n        }\n\n    }\n\n};\n\nPhaser.Physics.P2.Body.prototype.constructor = Phaser.Physics.P2.Body;\n\n/**\n * Dynamic body.\n * @property DYNAMIC\n * @type {Number}\n * @static\n */\nPhaser.Physics.P2.Body.DYNAMIC = 1;\n\n/**\n * Static body.\n * @property STATIC\n * @type {Number}\n * @static\n */\nPhaser.Physics.P2.Body.STATIC = 2;\n\n/**\n * Kinematic body.\n * @property KINEMATIC\n * @type {Number}\n * @static\n */\nPhaser.Physics.P2.Body.KINEMATIC = 4;\n\n/**\n* @name Phaser.Physics.P2.Body#static\n* @property {boolean} static - Returns true if the Body is static. Setting Body.static to 'false' will make it dynamic.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"static\", {\n\n    get: function () {\n\n        return (this.data.motionState === Phaser.Physics.P2.Body.STATIC);\n\n    },\n\n    set: function (value) {\n\n        if (value && this.data.motionState !== Phaser.Physics.P2.Body.STATIC)\n        {\n            this.data.motionState = Phaser.Physics.P2.Body.STATIC;\n            this.mass = 0;\n        }\n        else if (!value && this.data.motionState === Phaser.Physics.P2.Body.STATIC)\n        {\n            this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC;\n\n            if (this.mass === 0)\n            {\n                this.mass = 1;\n            }\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#dynamic\n* @property {boolean} dynamic - Returns true if the Body is dynamic. Setting Body.dynamic to 'false' will make it static.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"dynamic\", {\n\n    get: function () {\n\n        return (this.data.motionState === Phaser.Physics.P2.Body.DYNAMIC);\n\n    },\n\n    set: function (value) {\n\n        if (value && this.data.motionState !== Phaser.Physics.P2.Body.DYNAMIC)\n        {\n            this.data.motionState = Phaser.Physics.P2.Body.DYNAMIC;\n\n            if (this.mass === 0)\n            {\n                this.mass = 1;\n            }\n        }\n        else if (!value && this.data.motionState === Phaser.Physics.P2.Body.DYNAMIC)\n        {\n            this.data.motionState = Phaser.Physics.P2.Body.STATIC;\n            this.mass = 0;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#kinematic\n* @property {boolean} kinematic - Returns true if the Body is kinematic. Setting Body.kinematic to 'false' will make it static.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"kinematic\", {\n\n    get: function () {\n\n        return (this.data.motionState === Phaser.Physics.P2.Body.KINEMATIC);\n\n    },\n\n    set: function (value) {\n\n        if (value && this.data.motionState !== Phaser.Physics.P2.Body.KINEMATIC)\n        {\n            this.data.motionState = Phaser.Physics.P2.Body.KINEMATIC;\n            this.mass = 4;\n        }\n        else if (!value && this.data.motionState === Phaser.Physics.P2.Body.KINEMATIC)\n        {\n            this.data.motionState = Phaser.Physics.P2.Body.STATIC;\n            this.mass = 0;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#allowSleep\n* @property {boolean} allowSleep -\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"allowSleep\", {\n\n    get: function () {\n\n        return this.data.allowSleep;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this.data.allowSleep)\n        {\n            this.data.allowSleep = value;\n        }\n\n    }\n\n});\n\n/**\n* The angle of the Body in degrees from its original orientation. Values from 0 to 180 represent clockwise rotation; values from 0 to -180 represent counterclockwise rotation.\n* Values outside this range are added to or subtracted from 360 to obtain a value within the range. For example, the statement Body.angle = 450 is the same as Body.angle = 90.\n* If you wish to work in radians instead of degrees use the property Body.rotation instead. Working in radians is faster as it doesn't have to convert values.\n*\n* @name Phaser.Physics.P2.Body#angle\n* @property {number} angle - The angle of this Body in degrees.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"angle\", {\n\n    get: function() {\n\n        return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.angle));\n\n    },\n\n    set: function(value) {\n\n        this.data.angle = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value));\n\n    }\n\n});\n\n/**\n* Damping is specified as a value between 0 and 1, which is the proportion of velocity lost per second.\n* @name Phaser.Physics.P2.Body#angularDamping\n* @property {number} angularDamping - The angular damping acting acting on the body.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"angularDamping\", {\n\n    get: function () {\n\n        return this.data.angularDamping;\n\n    },\n\n    set: function (value) {\n\n        this.data.angularDamping = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#angularForce\n* @property {number} angularForce - The angular force acting on the body.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"angularForce\", {\n\n    get: function () {\n\n        return this.data.angularForce;\n\n    },\n\n    set: function (value) {\n\n        this.data.angularForce = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#angularVelocity\n* @property {number} angularVelocity - The angular velocity of the body.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"angularVelocity\", {\n\n    get: function () {\n\n        return this.data.angularVelocity;\n\n    },\n\n    set: function (value) {\n\n        this.data.angularVelocity = value;\n\n    }\n\n});\n\n/**\n* Damping is specified as a value between 0 and 1, which is the proportion of velocity lost per second.\n* @name Phaser.Physics.P2.Body#damping\n* @property {number} damping - The linear damping acting on the body in the velocity direction.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"damping\", {\n\n    get: function () {\n\n        return this.data.damping;\n\n    },\n\n    set: function (value) {\n\n        this.data.damping = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#fixedRotation\n* @property {boolean} fixedRotation -\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"fixedRotation\", {\n\n    get: function () {\n\n        return this.data.fixedRotation;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this.data.fixedRotation)\n        {\n            this.data.fixedRotation = value;\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#inertia\n* @property {number} inertia - The inertia of the body around the Z axis..\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"inertia\", {\n\n    get: function () {\n\n        return this.data.inertia;\n\n    },\n\n    set: function (value) {\n\n        this.data.inertia = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#mass\n* @property {number} mass -\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"mass\", {\n\n    get: function () {\n\n        return this.data.mass;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this.data.mass)\n        {\n            this.data.mass = value;\n            this.data.updateMassProperties();\n        }\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#motionState\n* @property {number} motionState - The type of motion this body has. Should be one of: Body.STATIC (the body does not move), Body.DYNAMIC (body can move and respond to collisions) and Body.KINEMATIC (only moves according to its .velocity).\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"motionState\", {\n\n    get: function () {\n\n        return this.data.motionState;\n\n    },\n\n    set: function (value) {\n\n        if (value !== this.data.motionState)\n        {\n            this.data.motionState = value;\n        }\n\n    }\n\n});\n\n/**\n* The angle of the Body in radians.\n* If you wish to work in degrees instead of radians use the Body.angle property instead. Working in radians is faster as it doesn't have to convert values.\n*\n* @name Phaser.Physics.P2.Body#rotation\n* @property {number} rotation - The angle of this Body in radians.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"rotation\", {\n\n    get: function() {\n\n        return this.data.angle;\n\n    },\n\n    set: function(value) {\n\n        this.data.angle = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#sleepSpeedLimit\n* @property {number} sleepSpeedLimit - .\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"sleepSpeedLimit\", {\n\n    get: function () {\n\n        return this.data.sleepSpeedLimit;\n\n    },\n\n    set: function (value) {\n\n        this.data.sleepSpeedLimit = value;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#x\n* @property {number} x - The x coordinate of this Body.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"x\", {\n\n    get: function () {\n\n        return this.world.mpxi(this.data.position[0]);\n\n    },\n\n    set: function (value) {\n\n        this.data.position[0] = this.world.pxmi(value);\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#y\n* @property {number} y - The y coordinate of this Body.\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"y\", {\n\n    get: function () {\n\n        return this.world.mpxi(this.data.position[1]);\n\n    },\n\n    set: function (value) {\n\n        this.data.position[1] = this.world.pxmi(value);\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#id\n* @property {number} id - The Body ID. Each Body that has been added to the World has a unique ID.\n* @readonly\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"id\", {\n\n    get: function () {\n\n        return this.data.id;\n\n    }\n\n});\n\n/**\n* @name Phaser.Physics.P2.Body#debug\n* @property {boolean} debug - Enable or disable debug drawing of this body\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"debug\", {\n\n    get: function () {\n\n        return (!this.debugBody);\n\n    },\n\n    set: function (value) {\n\n        if (value && !this.debugBody)\n        {\n            //  This will be added to the global space\n            this.debugBody = new Phaser.Physics.P2.BodyDebug(this.game, this.data);\n        }\n        else if (!value && this.debugBody)\n        {\n            this.debugBody.destroy();\n            this.debugBody = null;\n        }\n\n    }\n\n});\n\n/**\n* A Body can be set to collide against the World bounds automatically if this is set to true. Otherwise it will leave the World.\n* Note that this only applies if your World has bounds! The response to the collision should be managed via CollisionMaterials.\n* @name Phaser.Physics.P2.Body#collideWorldBounds\n* @property {boolean} collideWorldBounds - Should the Body collide with the World bounds?\n*/\nObject.defineProperty(Phaser.Physics.P2.Body.prototype, \"collideWorldBounds\", {\n\n    get: function () {\n\n        return this._collideWorldBounds;\n\n    },\n\n    set: function (value) {\n\n        if (value && !this._collideWorldBounds)\n        {\n            this._collideWorldBounds = true;\n            this.updateCollisionMask();\n        }\n        else if (!value && this._collideWorldBounds)\n        {\n            this._collideWorldBounds = false;\n            this.updateCollisionMask();\n        }\n\n    }\n\n});\n\n/**\n* @author       George https://github.com/georgiee\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Draws a P2 Body to a Graphics instance for visual debugging.\n* Needless to say, for every body you enable debug drawing on, you are adding processor and graphical overhead.\n* So use sparingly and rarely (if ever) in production code.\n*\n* @class Phaser.Physics.P2.BodyDebug\n* @classdesc Physics Body Debug Constructor\n* @constructor\n* @extends Phaser.Group\n* @param {Phaser.Game} game - Game reference to the currently running game.\n* @param {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.\n* @param {object} settings - Settings object.\n*/\nPhaser.Physics.P2.BodyDebug = function(game, body, settings) {\n\n    Phaser.Group.call(this, game);\n\n    /**\n    * @property {object} defaultSettings - Default debug settings.\n    * @private\n    */\n    var defaultSettings = {\n        pixelsPerLengthUnit: 20,\n        debugPolygons: false,\n        lineWidth: 1,\n        alpha: 0.5\n    };\n\n    this.settings = Phaser.Utils.extend(defaultSettings, settings);\n\n    /**\n    * @property {number} ppu - Pixels per Length Unit.\n    */\n    this.ppu = this.settings.pixelsPerLengthUnit;\n    this.ppu = -1 * this.ppu;\n\n    /**\n    * @property {Phaser.Physics.P2.Body} body - The P2 Body to display debug data for.\n    */\n    this.body = body;\n\n    /**\n    * @property {Phaser.Graphics} canvas - The canvas to render the debug info to.\n    */\n    this.canvas = new Phaser.Graphics(game);\n\n    this.canvas.alpha = this.settings.alpha;\n\n    this.add(this.canvas);\n\n    this.draw();\n\n};\n\nPhaser.Physics.P2.BodyDebug.prototype = Object.create(Phaser.Group.prototype);\nPhaser.Physics.P2.BodyDebug.prototype.constructor = Phaser.Physics.P2.BodyDebug;\n\nPhaser.Utils.extend(Phaser.Physics.P2.BodyDebug.prototype, {\n\n    /**\n    * Core update.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#update\n    */\n    update: function() {\n\n        this.updateSpriteTransform();\n\n    },\n\n    /**\n    * Core update.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#updateSpriteTransform\n    */\n    updateSpriteTransform: function() {\n\n        this.position.x = this.body.position[0] * this.ppu;\n        this.position.y = this.body.position[1] * this.ppu;\n\n        return this.rotation = this.body.angle;\n\n    },\n\n    /**\n    * Draws the P2 shapes to the Graphics object.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#draw\n    */\n    draw: function() {\n\n        var angle, child, color, i, j, lineColor, lw, obj, offset, sprite, v, verts, vrot, _j, _ref1;\n        obj = this.body;\n        sprite = this.canvas;\n        sprite.clear();\n        color = parseInt(this.randomPastelHex(), 16);\n        lineColor = 0xff0000;\n        lw = this.lineWidth;\n\n        if (obj instanceof p2.Body && obj.shapes.length)\n        {\n            var l = obj.shapes.length;\n\n            i = 0;\n\n            while (i !== l)\n            {\n                child = obj.shapes[i];\n                offset = obj.shapeOffsets[i];\n                angle = obj.shapeAngles[i];\n                offset = offset || 0;\n                angle = angle || 0;\n\n                if (child instanceof p2.Circle)\n                {\n                    this.drawCircle(sprite, offset[0] * this.ppu, offset[1] * this.ppu, angle, child.radius * this.ppu, color, lw);\n                }\n                else if (child instanceof p2.Convex)\n                {\n                    verts = [];\n                    vrot = p2.vec2.create();\n\n                    for (j = _j = 0, _ref1 = child.vertices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j)\n                    {\n                        v = child.vertices[j];\n                        p2.vec2.rotate(vrot, v, angle);\n                        verts.push([(vrot[0] + offset[0]) * this.ppu, -(vrot[1] + offset[1]) * this.ppu]);\n                    }\n\n                    this.drawConvex(sprite, verts, child.triangles, lineColor, color, lw, this.settings.debugPolygons, [offset[0] * this.ppu, -offset[1] * this.ppu]);\n                }\n                else if (child instanceof p2.Plane)\n                {\n                    this.drawPlane(sprite, offset[0] * this.ppu, -offset[1] * this.ppu, color, lineColor, lw * 5, lw * 10, lw * 10, this.ppu * 100, angle);\n                }\n                else if (child instanceof p2.Line)\n                {\n                    this.drawLine(sprite, child.length * this.ppu, lineColor, lw);\n                }\n                else if (child instanceof p2.Rectangle)\n                {\n                    this.drawRectangle(sprite, offset[0] * this.ppu, -offset[1] * this.ppu, angle, child.width * this.ppu, child.height * this.ppu, lineColor, color, lw);\n                }\n\n                i++;\n            }\n        }\n\n    },\n\n    /**\n    * Draws the P2 shapes to the Graphics object.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#draw\n    */\n    drawRectangle: function(g, x, y, angle, w, h, color, fillColor, lineWidth) {\n\n        if (typeof lineWidth === 'undefined') { lineWidth = 1; }\n        if (typeof color === 'undefined') { color = 0x000000; }\n\n        g.lineStyle(lineWidth, color, 1);\n        g.beginFill(fillColor);\n        g.drawRect(x - w / 2, y - h / 2, w, h);\n\n    },\n\n    /**\n    * Draws a P2 Circle shape.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#drawCircle\n    */\n    drawCircle: function(g, x, y, angle, radius, color, lineWidth) {\n\n        if (typeof lineWidth === 'undefined') { lineWidth = 1; }\n        if (typeof color === 'undefined') { color = 0xffffff; }\n        g.lineStyle(lineWidth, 0x000000, 1);\n        g.beginFill(color, 1.0);\n        g.drawCircle(x, y, -radius);\n        g.endFill();\n        g.moveTo(x, y);\n        g.lineTo(x + radius * Math.cos(-angle), y + radius * Math.sin(-angle));\n\n    },\n\n    /**\n    * Draws a P2 Line shape.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#drawCircle\n    */\n    drawLine: function(g, len, color, lineWidth) {\n\n        if (typeof lineWidth === 'undefined') { lineWidth = 1; }\n        if (typeof color === 'undefined') { color = 0x000000; }\n\n        g.lineStyle(lineWidth * 5, color, 1);\n        g.moveTo(-len / 2, 0);\n        g.lineTo(len / 2, 0);\n\n    },\n\n    /**\n    * Draws a P2 Convex shape.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#drawConvex\n    */\n    drawConvex: function(g, verts, triangles, color, fillColor, lineWidth, debug, offset) {\n\n        var colors, i, v, v0, v1, x, x0, x1, y, y0, y1;\n\n        if (typeof lineWidth === 'undefined') { lineWidth = 1; }\n        if (typeof color === 'undefined') { color = 0x000000; }\n\n        if (!debug)\n        {\n            g.lineStyle(lineWidth, color, 1);\n            g.beginFill(fillColor);\n            i = 0;\n\n            while (i !== verts.length)\n            {\n                v = verts[i];\n                x = v[0];\n                y = v[1];\n\n                if (i === 0)\n                {\n                    g.moveTo(x, -y);\n                }\n                else\n                {\n                    g.lineTo(x, -y);\n                }\n\n                i++;\n            }\n\n            g.endFill();\n\n            if (verts.length > 2)\n            {\n                g.moveTo(verts[verts.length - 1][0], -verts[verts.length - 1][1]);\n                return g.lineTo(verts[0][0], -verts[0][1]);\n            }\n        }\n        else\n        {\n            colors = [0xff0000, 0x00ff00, 0x0000ff];\n            i = 0;\n\n            while (i !== verts.length + 1)\n            {\n                v0 = verts[i % verts.length];\n                v1 = verts[(i + 1) % verts.length];\n                x0 = v0[0];\n                y0 = v0[1];\n                x1 = v1[0];\n                y1 = v1[1];\n                g.lineStyle(lineWidth, colors[i % colors.length], 1);\n                g.moveTo(x0, -y0);\n                g.lineTo(x1, -y1);\n                g.drawCircle(x0, -y0, lineWidth * 2);\n                i++;\n            }\n\n            g.lineStyle(lineWidth, 0x000000, 1);\n            return g.drawCircle(offset[0], offset[1], lineWidth * 2);\n        }\n\n    },\n\n    /**\n    * Draws a P2 Path.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#drawPath\n    */\n    drawPath: function(g, path, color, fillColor, lineWidth) {\n\n        var area, i, lastx, lasty, p1x, p1y, p2x, p2y, p3x, p3y, v, x, y;\n        if (typeof lineWidth === 'undefined') { lineWidth = 1; }\n        if (typeof color === 'undefined') { color = 0x000000; }\n\n        g.lineStyle(lineWidth, color, 1);\n\n        if (typeof fillColor === \"number\")\n        {\n            g.beginFill(fillColor);\n        }\n\n        lastx = null;\n        lasty = null;\n        i = 0;\n\n        while (i < path.length)\n        {\n            v = path[i];\n            x = v[0];\n            y = v[1];\n\n            if (x !== lastx || y !== lasty)\n            {\n                if (i === 0)\n                {\n                    g.moveTo(x, y);\n                }\n                else\n                {\n                    p1x = lastx;\n                    p1y = lasty;\n                    p2x = x;\n                    p2y = y;\n                    p3x = path[(i + 1) % path.length][0];\n                    p3y = path[(i + 1) % path.length][1];\n                    area = ((p2x - p1x) * (p3y - p1y)) - ((p3x - p1x) * (p2y - p1y));\n\n                    if (area !== 0)\n                    {\n                        g.lineTo(x, y);\n                    }\n                }\n                lastx = x;\n                lasty = y;\n            }\n\n            i++;\n\n        }\n\n        if (typeof fillColor === \"number\")\n        {\n            g.endFill();\n        }\n\n        if (path.length > 2 && typeof fillColor === \"number\")\n        {\n            g.moveTo(path[path.length - 1][0], path[path.length - 1][1]);\n            g.lineTo(path[0][0], path[0][1]);\n        }\n\n    },\n\n    /**\n    * Draws a P2 Plane shape.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#drawPlane\n    */\n    drawPlane: function(g, x0, x1, color, lineColor, lineWidth, diagMargin, diagSize, maxLength, angle) {\n\n        var max, xd, yd;\n        if (typeof lineWidth === 'undefined') { lineWidth = 1; }\n        if (typeof color === 'undefined') { color = 0xffffff; }\n\n        g.lineStyle(lineWidth, lineColor, 11);\n        g.beginFill(color);\n        max = maxLength;\n\n        g.moveTo(x0, -x1);\n        xd = x0 + Math.cos(angle) * this.game.width;\n        yd = x1 + Math.sin(angle) * this.game.height;\n        g.lineTo(xd, -yd);\n\n        g.moveTo(x0, -x1);\n        xd = x0 + Math.cos(angle) * -this.game.width;\n        yd = x1 + Math.sin(angle) * -this.game.height;\n        g.lineTo(xd, -yd);\n\n    },\n\n    /**\n    * Picks a random pastel color.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#randomPastelHex\n    */\n    randomPastelHex: function() {\n\n        var blue, green, mix, red;\n        mix = [255, 255, 255];\n\n        red = Math.floor(Math.random() * 256);\n        green = Math.floor(Math.random() * 256);\n        blue = Math.floor(Math.random() * 256);\n\n        red = Math.floor((red + 3 * mix[0]) / 4);\n        green = Math.floor((green + 3 * mix[1]) / 4);\n        blue = Math.floor((blue + 3 * mix[2]) / 4);\n\n        return this.rgbToHex(red, green, blue);\n\n    },\n\n    /**\n    * Converts from RGB to Hex.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#rgbToHex\n    */\n    rgbToHex: function(r, g, b) {\n        return this.componentToHex(r) + this.componentToHex(g) + this.componentToHex(b);\n    },\n\n    /**\n    * Component to hex conversion.\n    *\n    * @method Phaser.Physics.P2.BodyDebug#componentToHex\n    */\n    componentToHex: function(c) {\n\n        var hex;\n        hex = c.toString(16);\n\n        if (hex.len === 2)\n        {\n            return hex;\n        }\n        else\n        {\n            return hex + '0';\n        }\n\n    }\n\n});\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Creates a spring, connecting two bodies. A spring can have a resting length, a stiffness and damping.\n*\n* @class Phaser.Physics.P2.Spring\n* @classdesc Physics Spring Constructor\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {p2.Body} bodyA - First connected body.\n* @param {p2.Body} bodyB - Second connected body.\n* @param {number} [restLength=1] - Rest length of the spring. A number > 0.\n* @param {number} [stiffness=100] - Stiffness of the spring. A number >= 0.\n* @param {number} [damping=1] - Damping of the spring. A number >= 0.\n* @param {Array} [worldA] - Where to hook the spring to body A in world coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {Array} [worldB] - Where to hook the spring to body B in world coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {Array} [localA] - Where to hook the spring to body A in local body coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {Array} [localB] - Where to hook the spring to body B in local body coordinates. This value is an array with 2 elements matching x and y, i.e: [32, 32].\n*/\nPhaser.Physics.P2.Spring = function (world, bodyA, bodyB, restLength, stiffness, damping, worldA, worldB, localA, localB) {\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = world.game;\n\n    /**\n    * @property {Phaser.Physics.P2} world - Local reference to P2 World.\n    */\n    this.world = world;\n\n    if (typeof restLength === 'undefined') { restLength = 1; }\n    if (typeof stiffness === 'undefined') { stiffness = 100; }\n    if (typeof damping === 'undefined') { damping = 1; }\n\n    restLength = world.pxm(restLength);\n\n    var options = {\n        restLength: restLength,\n        stiffness: stiffness,\n        damping: damping\n    };\n\n    if (typeof worldA !== 'undefined' && worldA !== null)\n    {\n        options.worldAnchorA = [ world.pxm(worldA[0]), world.pxm(worldA[1]) ];\n    }\n\n    if (typeof worldB !== 'undefined' && worldB !== null)\n    {\n        options.worldAnchorB = [ world.pxm(worldB[0]), world.pxm(worldB[1]) ];\n    }\n\n    if (typeof localA !== 'undefined' && localA !== null)\n    {\n        options.localAnchorA = [ world.pxm(localA[0]), world.pxm(localA[1]) ];\n    }\n\n    if (typeof localB !== 'undefined' && localB !== null)\n    {\n        options.localAnchorB = [ world.pxm(localB[0]), world.pxm(localB[1]) ];\n    }\n\n    p2.Spring.call(this, bodyA, bodyB, options);\n\n};\n\nPhaser.Physics.P2.Spring.prototype = Object.create(p2.Spring.prototype);\nPhaser.Physics.P2.Spring.prototype.constructor = Phaser.Physics.P2.Spring;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* \\o/ ~ \"Because I'm a Material girl\"\n*\n* @class Phaser.Physics.P2.Material\n* @classdesc Physics Material Constructor\n* @constructor\n*/\nPhaser.Physics.P2.Material = function (name) {\n\n    /**\n    * @property {string} name - The user defined name given to this Material.\n    * @default\n    */\n    this.name = name;\n\n    p2.Material.call(this);\n\n};\n\nPhaser.Physics.P2.Material.prototype = Object.create(p2.Material.prototype);\nPhaser.Physics.P2.Material.prototype.constructor = Phaser.Physics.P2.Material;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Defines a physics material\n*\n* @class Phaser.Physics.P2.ContactMaterial\n* @classdesc Physics ContactMaterial Constructor\n* @constructor\n* @param {Phaser.Physics.P2.Material} materialA\n* @param {Phaser.Physics.P2.Material} materialB\n* @param {object} [options]\n*/\nPhaser.Physics.P2.ContactMaterial = function (materialA, materialB, options) {\n\n\t/**\n\t* @property {number} id - The contact material identifier.\n\t*/\n\n\t/**\n\t* @property {Phaser.Physics.P2.Material} materialA - First material participating in the contact material.\n\t*/\n\n\t/**\n\t* @property {Phaser.Physics.P2.Material} materialB - First second participating in the contact material.\n\t*/\n\n\t/**\n\t* @property {number} [friction=0.3] - Friction to use in the contact of these two materials.\n\t*/\n\n\t/**\n\t* @property {number} [restitution=0.0] - Restitution to use in the contact of these two materials.\n\t*/\n\n\t/**\n\t* @property {number} [stiffness=1e7] - Stiffness of the resulting ContactEquation that this ContactMaterial generate.\n\t*/\n\n\t/**\n\t* @property {number} [relaxation=3] - Relaxation of the resulting ContactEquation that this ContactMaterial generate.\n\t*/\n\n\t/**\n\t* @property {number} [frictionStiffness=1e7] - Stiffness of the resulting FrictionEquation that this ContactMaterial generate.\n\t*/\n\n\t/**\n\t* @property {number} [frictionRelaxation=3] - Relaxation of the resulting FrictionEquation that this ContactMaterial generate.\n\t*/\n\n\t/**\n\t* @property {number} [surfaceVelocity=0] - Will add surface velocity to this material. If bodyA rests on top if bodyB, and the surface velocity is positive, bodyA will slide to the right.\n\t*/\n\n    p2.ContactMaterial.call(this, materialA, materialB, options);\n\n};\n\nPhaser.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype);\nPhaser.Physics.P2.ContactMaterial.prototype.constructor = Phaser.Physics.P2.ContactMaterial;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Collision Group\n*\n* @class Phaser.Physics.P2.CollisionGroup\n* @classdesc Physics Collision Group Constructor\n* @constructor\n*/\nPhaser.Physics.P2.CollisionGroup = function (bitmask) {\n\n    /**\n    * @property {number} mask - The CollisionGroup bitmask.\n    */\n    this.mask = bitmask;\n\n};\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* A constraint that tries to keep the distance between two bodies constant.\n*\n* @class Phaser.Physics.P2.DistanceConstraint\n* @classdesc Physics DistanceConstraint Constructor\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {p2.Body} bodyA - First connected body.\n* @param {p2.Body} bodyB - Second connected body.\n* @param {number} distance - The distance to keep between the bodies.\n* @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.\n*/\nPhaser.Physics.P2.DistanceConstraint = function (world, bodyA, bodyB, distance, maxForce) {\n\n    if (typeof distance === 'undefined') { distance = 100; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = world.game;\n\n    /**\n    * @property {Phaser.Physics.P2} world - Local reference to P2 World.\n    */\n    this.world = world;\n\n    distance = world.pxm(distance);\n\n    p2.DistanceConstraint.call(this, bodyA, bodyB, distance, maxForce);\n\n};\n\nPhaser.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype);\nPhaser.Physics.P2.DistanceConstraint.prototype.constructor = Phaser.Physics.P2.DistanceConstraint;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n*\n* @class Phaser.Physics.P2.GearConstraint\n* @classdesc Physics GearConstraint Constructor\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {p2.Body} bodyA - First connected body.\n* @param {p2.Body} bodyB - Second connected body.\n* @param {number} [angle=0] - The relative angle\n* @param {number} [ratio=1] - The gear ratio.\n*/\nPhaser.Physics.P2.GearConstraint = function (world, bodyA, bodyB, angle, ratio) {\n\n    if (typeof angle === 'undefined') { angle = 0; }\n    if (typeof ratio === 'undefined') { ratio = 1; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = world.game;\n\n    /**\n    * @property {Phaser.Physics.P2} world - Local reference to P2 World.\n    */\n    this.world = world;\n\n    var options = { angle: angle, ratio: ratio };\n\n    p2.GearConstraint.call(this, bodyA, bodyB, options);\n\n};\n\nPhaser.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype);\nPhaser.Physics.P2.GearConstraint.prototype.constructor = Phaser.Physics.P2.GearConstraint;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Locks the relative position between two bodies.\n*\n* @class Phaser.Physics.P2.LockConstraint\n* @classdesc Physics LockConstraint Constructor\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {p2.Body} bodyA - First connected body.\n* @param {p2.Body} bodyB - Second connected body.\n* @param {Array} [offset] - The offset of bodyB in bodyA's frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {number} [angle=0] - The angle of bodyB in bodyA's frame.\n* @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.\n*/\nPhaser.Physics.P2.LockConstraint = function (world, bodyA, bodyB, offset, angle, maxForce) {\n\n    if (typeof offset === 'undefined') { offset = [0, 0]; }\n    if (typeof angle === 'undefined') { angle = 0; }\n    if (typeof maxForce === 'undefined') { maxForce = Number.MAX_VALUE; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = world.game;\n\n    /**\n    * @property {Phaser.Physics.P2} world - Local reference to P2 World.\n    */\n    this.world = world;\n\n    offset = [ world.pxm(offset[0]), world.pxm(offset[1]) ];\n\n    var options = { localOffsetB: offset, localAngleB: angle, maxForce: maxForce };\n\n    p2.LockConstraint.call(this, bodyA, bodyB, options);\n\n};\n\nPhaser.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype);\nPhaser.Physics.P2.LockConstraint.prototype.constructor = Phaser.Physics.P2.LockConstraint;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n*\n* @class Phaser.Physics.P2.PrismaticConstraint\n* @classdesc Physics PrismaticConstraint Constructor\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {p2.Body} bodyA - First connected body.\n* @param {p2.Body} bodyB - Second connected body.\n* @param {boolean} [lockRotation=true] - If set to false, bodyB will be free to rotate around its anchor point.\n* @param {Array} [anchorA] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {Array} [anchorB] - Body A's anchor point, defined in its own local frame. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {Array} [axis] - An axis, defined in body A frame, that body B's anchor point may slide along. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {number} [maxForce] - The maximum force that should be applied to constrain the bodies.\n*/\nPhaser.Physics.P2.PrismaticConstraint = function (world, bodyA, bodyB, lockRotation, anchorA, anchorB, axis, maxForce) {\n\n    if (typeof lockRotation === 'undefined') { lockRotation = true; }\n    if (typeof anchorA === 'undefined') { anchorA = [0, 0]; }\n    if (typeof anchorB === 'undefined') { anchorB = [0, 0]; }\n    if (typeof axis === 'undefined') { axis = [0, 0]; }\n    if (typeof maxForce === 'undefined') { maxForce = Number.MAX_VALUE; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = world.game;\n\n    /**\n    * @property {Phaser.Physics.P2} world - Local reference to P2 World.\n    */\n    this.world = world;\n\n    anchorA = [ world.pxmi(anchorA[0]), world.pxmi(anchorA[1]) ];\n    anchorB = [ world.pxmi(anchorB[0]), world.pxmi(anchorB[1]) ];\n\n    var options = { localAnchorA: anchorA, localAnchorB: anchorB, localAxisA: axis, maxForce: maxForce, disableRotationalLock: !lockRotation };\n\n    p2.PrismaticConstraint.call(this, bodyA, bodyB, options);\n\n};\n\nPhaser.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype);\nPhaser.Physics.P2.PrismaticConstraint.prototype.constructor = Phaser.Physics.P2.PrismaticConstraint;\n\n/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2014 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* Connects two bodies at given offset points, letting them rotate relative to each other around this point.\n* The pivot points are given in world (pixel) coordinates.\n*\n* @class Phaser.Physics.P2.RevoluteConstraint\n* @classdesc Physics RevoluteConstraint Constructor\n* @constructor\n* @param {Phaser.Physics.P2} world - A reference to the P2 World.\n* @param {p2.Body} bodyA - First connected body.\n* @param {Float32Array} pivotA - The point relative to the center of mass of bodyA which bodyA is constrained to. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {p2.Body} bodyB - Second connected body.\n* @param {Float32Array} pivotB - The point relative to the center of mass of bodyB which bodyB is constrained to. The value is an array with 2 elements matching x and y, i.e: [32, 32].\n* @param {number} [maxForce=0] - The maximum force that should be applied to constrain the bodies.\n*/\nPhaser.Physics.P2.RevoluteConstraint = function (world, bodyA, pivotA, bodyB, pivotB, maxForce) {\n\n    if (typeof maxForce === 'undefined') { maxForce = Number.MAX_VALUE; }\n\n    /**\n    * @property {Phaser.Game} game - Local reference to game.\n    */\n    this.game = world.game;\n\n    /**\n    * @property {Phaser.Physics.P2} world - Local reference to P2 World.\n    */\n    this.world = world;\n\n    pivotA = [ world.pxmi(pivotA[0]), world.pxmi(pivotA[1]) ];\n    pivotB = [ world.pxmi(pivotB[0]), world.pxmi(pivotB[1]) ];\n\n    p2.RevoluteConstraint.call(this, bodyA, pivotA, bodyB, pivotB, {maxForce: maxForce});\n\n};\n\nPhaser.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype);\nPhaser.Physics.P2.RevoluteConstraint.prototype.constructor = Phaser.Physics.P2.RevoluteConstraint;\n"]}